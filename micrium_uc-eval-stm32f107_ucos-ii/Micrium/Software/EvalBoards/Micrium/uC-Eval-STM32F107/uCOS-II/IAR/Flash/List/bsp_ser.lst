###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:19 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp_ser.c                                       #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp_ser.c" -D USE_STDPERIPH_DRIVER -lCN         #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\" -o                         #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\bsp_ser.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\bsp_ser.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp_ser.c
      1          /*
      2          *********************************************************************************************************
      3          *
      4          *                                    MICRIUM BOARD SUPPORT PACKAGE
      5          *
      6          *                          (c) Copyright 2003-2010; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               This BSP is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                    MICRIUM BOARD SUPPORT PACKAGE
     26          *                                       SERIAL (UART) INTERFACE
     27          *
     28          * Filename      : bsp_ser.c
     29          * Version       : V1.00
     30          * Programmer(s) : EHS
     31          *                 SR
     32          *                 AA
     33          *********************************************************************************************************
     34          */
     35          
     36          
     37          /*
     38          *********************************************************************************************************
     39          *                                             INCLUDE FILES
     40          *********************************************************************************************************
     41          */
     42          
     43          #define  BSP_SER_MODULE
     44          #include <bsp.h>
     45          
     46          
     47          /*
     48          *********************************************************************************************************
     49          *                                            LOCAL DEFINES
     50          *********************************************************************************************************
     51          */
     52          
     53          
     54          /*
     55          *********************************************************************************************************
     56          *                                           LOCAL CONSTANTS
     57          *********************************************************************************************************
     58          */
     59          
     60          
     61          /*
     62          *********************************************************************************************************
     63          *                                          LOCAL DATA TYPES
     64          *********************************************************************************************************
     65          */
     66          
     67          
     68          /*
     69          *********************************************************************************************************
     70          *                                            LOCAL TABLES
     71          *********************************************************************************************************
     72          */
     73          
     74          
     75          /*
     76          *********************************************************************************************************
     77          *                                       LOCAL GLOBAL VARIABLES
     78          *********************************************************************************************************
     79          */
     80          

   \                                 In section .bss, align 4
     81          static  BSP_OS_SEM   BSP_SerTxWait;
   \                     BSP_SerTxWait:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     82          static  BSP_OS_SEM   BSP_SerRxWait;
   \                     BSP_SerRxWait:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     83          static  BSP_OS_SEM   BSP_SerLock;
   \                     BSP_SerLock:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     84          static  CPU_INT08U   BSP_SerRxData;
   \                     BSP_SerRxData:
   \   00000000                      DS8 1
     85          
     86          #if (BSP_CFG_SER_CMD_HISTORY_LEN > 0u)
     87          static  CPU_CHAR     BSP_SerCmdHistory[BSP_CFG_SER_CMD_HISTORY_LEN];
     88          #endif
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                      LOCAL FUNCTION PROTOTYPES
     93          *********************************************************************************************************
     94          */
     95          
     96          static  void        BSP_Ser_WrByteUnlocked  (CPU_INT08U  c);
     97          static  CPU_INT08U  BSP_Ser_RdByteUnlocked  (void);
     98          static  void        BSP_Ser_ISR_Handler     (void);
     99          
    100          
    101          
    102          /*
    103          *********************************************************************************************************
    104          *                                     LOCAL CONFIGURATION ERRORS
    105          *********************************************************************************************************
    106          */
    107          
    108          
    109          /*
    110          *********************************************************************************************************
    111          *********************************************************************************************************
    112          **                                         GLOBAL FUNCTIONS
    113          *********************************************************************************************************
    114          *********************************************************************************************************
    115          */
    116          
    117          
    118          /*
    119          *********************************************************************************************************
    120          *                                          BSP_Ser_Init()
    121          *
    122          * Description : Initialize a serial port for communication.
    123          *
    124          * Argument(s) : baud_rate           The desire RS232 baud rate.
    125          *
    126          * Return(s)   : none.
    127          *
    128          * Caller(s)   : Application.
    129          *
    130          * Note(s)     : none.
    131          *********************************************************************************************************
    132          */
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void  BSP_Ser_Init (CPU_INT32U  baud_rate)
    135          {
   \                     BSP_Ser_Init:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    136              FlagStatus              tc_status;
    137              GPIO_InitTypeDef        gpio_init;
    138              USART_InitTypeDef       usart_init;
    139              USART_ClockInitTypeDef  usart_clk_init;
    140          
    141          
    142                                                                          /* ------------------ INIT OS OBJECTS ----------------- */
    143              BSP_OS_SemCreate(&BSP_SerTxWait,   0, "Serial Tx Wait");
   \   00000006   0x....             LDR.N    R2,??DataTable7
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x.... 0x....      BL       BSP_OS_SemCreate
    144              BSP_OS_SemCreate(&BSP_SerRxWait,   0, "Serial Rx Wait");
   \   00000010   0x....             LDR.N    R2,??DataTable7_2
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x....             LDR.N    R0,??DataTable7_3
   \   00000016   0x.... 0x....      BL       BSP_OS_SemCreate
    145              BSP_OS_SemCreate(&BSP_SerLock,     1, "Serial Lock");
   \   0000001A   0x....             LDR.N    R2,??DataTable7_4
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x....             LDR.N    R0,??DataTable7_5
   \   00000020   0x.... 0x....      BL       BSP_OS_SemCreate
    146          
    147          #if (BSP_CFG_SER_CMD_HISTORY_LEN > 0u)
    148              BSP_SerCmdHistory[0] = (CPU_CHAR)'\0';
    149          #endif
    150          
    151                                                                          /* ----------------- INIT USART STRUCT ---------------- */
    152              usart_init.USART_BaudRate            = baud_rate;
   \   00000024   0x9403             STR      R4,[SP, #+12]
    153              usart_init.USART_WordLength          = USART_WordLength_8b;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    154              usart_init.USART_StopBits            = USART_StopBits_1;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    155              usart_init.USART_Parity              = USART_Parity_No ;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    156              usart_init.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    157              usart_init.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
   \   0000003E   0x200C             MOVS     R0,#+12
   \   00000040   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    158          
    159              usart_clk_init.USART_Clock           = USART_Clock_Disable;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    160              usart_clk_init.USART_CPOL            = USART_CPOL_Low;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    161              usart_clk_init.USART_CPHA            = USART_CPHA_2Edge;
   \   00000050   0xF44F 0x7000      MOV      R0,#+512
   \   00000054   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    162              usart_clk_init.USART_LastBit         = USART_LastBit_Disable;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    163          
    164          
    165              BSP_PeriphEn(BSP_PERIPH_ID_USART2);
   \   0000005E   0x2051             MOVS     R0,#+81
   \   00000060   0x.... 0x....      BL       BSP_PeriphEn
    166              BSP_PeriphEn(BSP_PERIPH_ID_IOPD);
   \   00000064   0x2025             MOVS     R0,#+37
   \   00000066   0x.... 0x....      BL       BSP_PeriphEn
    167              BSP_PeriphEn(BSP_PERIPH_ID_AFIO);
   \   0000006A   0x2020             MOVS     R0,#+32
   \   0000006C   0x.... 0x....      BL       BSP_PeriphEn
    168              GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0x.... 0x....      BL       GPIO_PinRemapConfig
    169                                                                          /* ----------------- SETUP USART2 GPIO ---------------- */
    170                                                                          /* Configure GPIOD.5 as push-pull.                      */
    171              gpio_init.GPIO_Pin   = GPIO_Pin_5;
   \   00000078   0x2020             MOVS     R0,#+32
   \   0000007A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    172              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0xF88D 0x0002      STRB     R0,[SP, #+2]
    173              gpio_init.GPIO_Mode  = GPIO_Mode_AF_PP;
   \   00000084   0x2018             MOVS     R0,#+24
   \   00000086   0xF88D 0x0003      STRB     R0,[SP, #+3]
    174              GPIO_Init(GPIOD, &gpio_init);
   \   0000008A   0xA900             ADD      R1,SP,#+0
   \   0000008C   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40011400
   \   0000008E   0x.... 0x....      BL       GPIO_Init
    175          
    176                                                                          /* Configure GPIOD.6 as input floating.                 */
    177              gpio_init.GPIO_Pin   = GPIO_Pin_6;
   \   00000092   0x2040             MOVS     R0,#+64
   \   00000094   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    178              gpio_init.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    179              GPIO_Init(GPIOD, &gpio_init);
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0x....             LDR.N    R0,??DataTable7_6  ;; 0x40011400
   \   000000A2   0x.... 0x....      BL       GPIO_Init
    180          
    181                                                                          /* ------------------ SETUP USART2 -------------------- */
    182              USART_Init(USART2, &usart_init);
   \   000000A6   0xA903             ADD      R1,SP,#+12
   \   000000A8   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000AA   0x.... 0x....      BL       USART_Init
    183              USART_ClockInit(USART2, &usart_clk_init);
   \   000000AE   0xA901             ADD      R1,SP,#+4
   \   000000B0   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000B2   0x.... 0x....      BL       USART_ClockInit
    184              USART_Cmd(USART2, ENABLE);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000BA   0x.... 0x....      BL       USART_Cmd
    185              
    186              USART_ITConfig(USART2, USART_IT_TC, DISABLE);
   \   000000BE   0x2200             MOVS     R2,#+0
   \   000000C0   0xF240 0x6126      MOVW     R1,#+1574
   \   000000C4   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000C6   0x.... 0x....      BL       USART_ITConfig
    187              USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0xF240 0x7127      MOVW     R1,#+1831
   \   000000D0   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000D2   0x.... 0x....      BL       USART_ITConfig
    188              tc_status  = USART_GetFlagStatus(USART2, USART_FLAG_TC);
   \   000000D6   0x2140             MOVS     R1,#+64
   \   000000D8   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000DA   0x.... 0x....      BL       USART_GetFlagStatus
   \   000000DE   0x0005             MOVS     R5,R0
    189              
    190              while (tc_status == SET) {
   \                     ??BSP_Ser_Init_0:
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0x2D01             CMP      R5,#+1
   \   000000E4   0xD112             BNE.N    ??BSP_Ser_Init_1
    191                  USART_ClearITPendingBit(USART2, USART_IT_TC);
   \   000000E6   0xF240 0x6126      MOVW     R1,#+1574
   \   000000EA   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000EC   0x.... 0x....      BL       USART_ClearITPendingBit
    192                  USART_ClearFlag(USART2, USART_IT_TC);
   \   000000F0   0xF240 0x6126      MOVW     R1,#+1574
   \   000000F4   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   000000F6   0x.... 0x....      BL       USART_ClearFlag
    193                  BSP_OS_TimeDlyMs(10);
   \   000000FA   0x200A             MOVS     R0,#+10
   \   000000FC   0x.... 0x....      BL       BSP_OS_TimeDlyMs
    194                  tc_status = USART_GetFlagStatus(USART2, USART_FLAG_TC);        
   \   00000100   0x2140             MOVS     R1,#+64
   \   00000102   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000104   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000108   0x0005             MOVS     R5,R0
   \   0000010A   0xE7E9             B.N      ??BSP_Ser_Init_0
    195              }
    196                     
    197              BSP_IntVectSet(BSP_INT_ID_USART2, BSP_Ser_ISR_Handler);
   \                     ??BSP_Ser_Init_1:
   \   0000010C   0x.... 0x....      ADR.W    R1,BSP_Ser_ISR_Handler
   \   00000110   0x2026             MOVS     R0,#+38
   \   00000112   0x.... 0x....      BL       BSP_IntVectSet
    198              BSP_IntEn(BSP_INT_ID_USART2);
   \   00000116   0x2026             MOVS     R0,#+38
   \   00000118   0x.... 0x....      BL       BSP_IntEn
    199          }
   \   0000011C   0xB007             ADD      SP,SP,#+28
   \   0000011E   0xBD30             POP      {R4,R5,PC}       ;; return
    200          
    201          
    202          /*
    203          *********************************************************************************************************
    204          *                                         BSP_Ser_ISR_Handler()
    205          *
    206          * Description : Serial ISR.
    207          *
    208          * Argument(s) : none.
    209          *
    210          * Return(s)   : none.
    211          *
    212          * Caller(s)   : This is an ISR.
    213          *
    214          * Note(s)     : none.
    215          *********************************************************************************************************
    216          */
    217          

   \                                 In section .text, align 4, keep-with-next
    218          void  BSP_Ser_ISR_Handler (void)
    219          {
   \                     BSP_Ser_ISR_Handler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    220              FlagStatus tc_status;
    221              FlagStatus rxne_status;
    222          
    223          
    224              rxne_status = USART_GetFlagStatus(USART2, USART_FLAG_RXNE);
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000006   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000000A   0x0005             MOVS     R5,R0
    225              if (rxne_status == SET) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD10C             BNE.N    ??BSP_Ser_ISR_Handler_0
    226                  BSP_SerRxData = USART_ReceiveData(USART2) & 0xFF;       /* Read one byte from the receive data register.      */
   \   00000012   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000014   0x.... 0x....      BL       USART_ReceiveData
   \   00000018   0x....             LDR.N    R1,??DataTable7_8
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    227                  USART_ClearITPendingBit(USART2, USART_IT_RXNE);         /* Clear the USART2 receive interrupt.                */
   \   0000001C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000020   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000022   0x.... 0x....      BL       USART_ClearITPendingBit
    228                  BSP_OS_SemPost(&BSP_SerRxWait);                         /* Post to the sempahore                              */
   \   00000026   0x....             LDR.N    R0,??DataTable7_3
   \   00000028   0x.... 0x....      BL       BSP_OS_SemPost
    229              }
    230          
    231              tc_status = USART_GetFlagStatus(USART2, USART_FLAG_TC);
   \                     ??BSP_Ser_ISR_Handler_0:
   \   0000002C   0x2140             MOVS     R1,#+64
   \   0000002E   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000030   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000034   0x0004             MOVS     R4,R0
    232              if (tc_status == SET) {
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C01             CMP      R4,#+1
   \   0000003A   0xD10D             BNE.N    ??BSP_Ser_ISR_Handler_1
    233                  USART_ITConfig(USART2, USART_IT_TC, DISABLE);
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF240 0x6126      MOVW     R1,#+1574
   \   00000042   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    234                  USART_ClearITPendingBit(USART2, USART_IT_TC);           /* Clear the USART2 receive interrupt.                */
   \   00000048   0xF240 0x6126      MOVW     R1,#+1574
   \   0000004C   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   0000004E   0x.... 0x....      BL       USART_ClearITPendingBit
    235                  BSP_OS_SemPost(&BSP_SerTxWait);                         /* Post to the semaphore                              */
   \   00000052   0x....             LDR.N    R0,??DataTable7_1
   \   00000054   0x.... 0x....      BL       BSP_OS_SemPost
    236              }
    237          }
   \                     ??BSP_Ser_ISR_Handler_1:
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    238          
    239          
    240          /*
    241          *********************************************************************************************************
    242          *                                           BSP_Ser_Printf()
    243          *
    244          * Description : Print formatted data to the output serial port.
    245          *
    246          * Argument(s) : format      String that contains the text to be written.
    247          *
    248          * Return(s)   : none.
    249          *
    250          * Caller(s)   : Application.
    251          *
    252          * Note(s)     : (1) This function output a maximum of BSP_SER_PRINTF_STR_BUF_SIZE number of bytes to the
    253          *                   serial port.  The calling function hence has to make sure the formatted string will
    254          *                   be able fit into this string buffer or hence the output string will be truncated.
    255          *********************************************************************************************************
    256          */
    257          

   \                                 In section .text, align 2, keep-with-next
    258          void  BSP_Ser_Printf (CPU_CHAR  *format, ...)
    259          {
   \                     BSP_Ser_Printf:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB570             PUSH     {R4-R6,LR}
   \   00000004   0xB095             SUB      SP,SP,#+84
   \   00000006   0x0004             MOVS     R4,R0
    260              CPU_CHAR  buf_str[BSP_SER_PRINTF_STR_BUF_SIZE + 1u];
    261              va_list   v_args;
    262          
    263          
    264              va_start(v_args, format);
   \   00000008   0xA819             ADD      R0,SP,#+100
   \   0000000A   0x0005             MOVS     R5,R0
    265             (void)vsnprintf((char       *)&buf_str[0],
    266                             (size_t      ) sizeof(buf_str),
    267                             (char const *) format,
    268                                            v_args);
   \   0000000C   0x002B             MOVS     R3,R5
   \   0000000E   0x0022             MOVS     R2,R4
   \   00000010   0x2151             MOVS     R1,#+81
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       vsnprintf
   \   00000018   0x0006             MOVS     R6,R0
    269              va_end(v_args);
    270          
    271              BSP_Ser_WrStr(buf_str);
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       BSP_Ser_WrStr
    272          }
   \   00000020   0xB015             ADD      SP,SP,#+84
   \   00000022   0xBC70             POP      {R4-R6}
   \   00000024   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    273          
    274          
    275          /*
    276          *********************************************************************************************************
    277          *                                                BSP_Ser_RdByte()
    278          *
    279          * Description : Receive a single byte.
    280          *
    281          * Argument(s) : none.
    282          *
    283          * Return(s)   : The received byte.
    284          *
    285          * Caller(s)   : Application.
    286          *
    287          * Note(s)     : (1) This functions blocks until a data is received.
    288          *
    289          *               (2) It can not be called from an ISR.
    290          *********************************************************************************************************
    291          */
    292          

   \                                 In section .text, align 2, keep-with-next
    293          CPU_INT08U  BSP_Ser_RdByte (void)
    294          {
   \                     BSP_Ser_RdByte:
   \   00000000   0xB510             PUSH     {R4,LR}
    295              CPU_INT08U  rx_byte;
    296          
    297          
    298              BSP_OS_SemWait(&BSP_SerLock, 0);                            /* Obtain access to the serial interface.             */
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable7_5
   \   00000006   0x.... 0x....      BL       BSP_OS_SemWait
    299          
    300              rx_byte = BSP_Ser_RdByteUnlocked();
   \   0000000A   0x.... 0x....      BL       BSP_Ser_RdByteUnlocked
   \   0000000E   0x0004             MOVS     R4,R0
    301          
    302              BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface.            */
   \   00000010   0x....             LDR.N    R0,??DataTable7_5
   \   00000012   0x.... 0x....      BL       BSP_OS_SemPost
    303          
    304              return (rx_byte);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    305          }
    306          
    307          
    308          /*
    309          *********************************************************************************************************
    310          *                                       BSP_Ser_RdByteUnlocked()
    311          *
    312          * Description : Receive a single byte.
    313          *
    314          * Argument(s) : none.
    315          *
    316          * Return(s)   : The received byte.
    317          *
    318          * Caller(s)   : BSP_Ser_RdByte()
    319          *               BSP_Ser_RdStr()
    320          *
    321          * Note(s)     : none.
    322          *********************************************************************************************************
    323          */
    324          

   \                                 In section .text, align 2, keep-with-next
    325          CPU_INT08U  BSP_Ser_RdByteUnlocked (void)
    326          {
   \                     BSP_Ser_RdByteUnlocked:
   \   00000000   0xB510             PUSH     {R4,LR}
    327          
    328              CPU_INT08U   rx_byte;
    329          
    330          
    331              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);              /* Enable the Receive not empty interrupt             */
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xF240 0x5125      MOVW     R1,#+1317
   \   00000008   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   0000000A   0x.... 0x....      BL       USART_ITConfig
    332          
    333              BSP_OS_SemWait(&BSP_SerRxWait, 0);                          /* Wait until data is received                        */
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR.N    R0,??DataTable7_3
   \   00000012   0x.... 0x....      BL       BSP_OS_SemWait
    334          
    335              USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);             /* Disable the Receive not empty interrupt            */
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xF240 0x5125      MOVW     R1,#+1317
   \   0000001C   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   0000001E   0x.... 0x....      BL       USART_ITConfig
    336          
    337              rx_byte = BSP_SerRxData;                                    /* Read the data from the temporary register          */
   \   00000022   0x....             LDR.N    R0,??DataTable7_8
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x0004             MOVS     R4,R0
    338          
    339              return (rx_byte);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    340          }
    341          
    342          /*
    343          *********************************************************************************************************
    344          *                                                BSP_Ser_RdStr()
    345          *
    346          * Description : This function reads a string from a UART.
    347          *
    348          * Argument(s) : p_str       A pointer to a buffer at which the string can be stored.
    349          *
    350          *               len         The size of the string that will be read.
    351          *
    352          * Return(s)   : none.
    353          *
    354          * Caller(s)   : Application
    355          *
    356          * Note(s)     : none.
    357          *********************************************************************************************************
    358          */
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void  BSP_Ser_RdStr (CPU_CHAR    *p_str,
    361                               CPU_INT16U   len)
    362          {
   \                     BSP_Ser_RdStr:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    363              CPU_CHAR     *p_char;
    364              CPU_BOOLEAN   rxd_history_char0;
    365              CPU_CHAR      rx_data;
    366              CPU_BOOLEAN   err;
    367          
    368          
    369              rxd_history_char0 = DEF_NO;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0007             MOVS     R7,R0
    370              p_str[0]          = (CPU_CHAR)'\0';
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    371              p_char            = p_str;
   \   00000010   0x0026             MOVS     R6,R4
    372          
    373              err = BSP_OS_SemWait(&BSP_SerLock, 0);                      /* Obtain access to the serial interface                */
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x....             LDR.N    R0,??DataTable7_5
   \   00000016   0x.... 0x....      BL       BSP_OS_SemWait
   \   0000001A   0x4681             MOV      R9,R0
    374          
    375              if (err != DEF_OK ) {
   \   0000001C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000020   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000024   0xD149             BNE.N    ??BSP_Ser_RdStr_0
    376                  return;
    377              }
    378          
    379              while (DEF_TRUE)
    380              {
    381                  rx_data = BSP_Ser_RdByteUnlocked();
   \                     ??BSP_Ser_RdStr_1:
   \   00000026   0x.... 0x....      BL       BSP_Ser_RdByteUnlocked
   \   0000002A   0x4680             MOV      R8,R0
    382          
    383                  if ((rx_data == ASCII_CHAR_CARRIAGE_RETURN) ||          /* Is it '\r' or '\n' character  ?                      */
    384                      (rx_data == ASCII_CHAR_LINE_FEED      )) {
   \   0000002C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000030   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000034   0xD004             BEQ.N    ??BSP_Ser_RdStr_2
   \   00000036   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003A   0xF1B8 0x0F0A      CMP      R8,#+10
   \   0000003E   0xD10B             BNE.N    ??BSP_Ser_RdStr_3
    385          
    386                      BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_LINE_FEED);
   \                     ??BSP_Ser_RdStr_2:
   \   00000040   0x200A             MOVS     R0,#+10
   \   00000042   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
    387                      BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_CARRIAGE_RETURN);
   \   00000046   0x200D             MOVS     R0,#+13
   \   00000048   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
    388                     *p_char = (CPU_CHAR)'\0';                            /* set the null character at the end of the string      */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7030             STRB     R0,[R6, #+0]
    389          #if (BSP_CFG_SER_CMD_HISTORY_LEN > 0u)
    390                      Str_Copy(BSP_SerCmdHistory, p_str);
    391          #endif
    392                      break;                                              /* exit the loop                                        */
    393                  }
    394          
    395                  if (rx_data == ASCII_CHAR_BACKSPACE) {                  /* Is backspace character                               */
    396                      if (p_char > p_str) {
    397                          BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_BACKSPACE);
    398                          p_char--;                                       /* Decrement the index                                  */
    399                      }
    400                  }
    401          
    402                  if ((ASCII_IsPrint(rx_data)      ) &&
    403                      (rxd_history_char0 == DEF_NO)) {                    /* Is it a printable character ... ?                    */
    404                      BSP_Ser_WrByteUnlocked((CPU_INT08U)rx_data);        /* Echo-back                                            */
    405                     *p_char = rx_data;                                   /* Save the received character in the buffer            */
    406                      p_char++;                                           /* Increment the buffer index                           */
    407                      if (p_char >= &p_str[len]) {
    408                          p_char  = &p_str[len];
    409                      }
    410          
    411                  } else if ((rx_data           == ASCII_CHAR_ESCAPE) &&
    412                             (rxd_history_char0 == DEF_NO           )) {
    413                      rxd_history_char0 = DEF_YES;
    414          
    415          #if (BSP_CFG_SER_CMD_HISTORY_LEN > 0u)
    416                  } else if ((rx_data           == ASCII_CHAR_LEFT_SQUARE_BRACKET) &&
    417                             (rxd_history_char0 == DEF_YES                       )) {
    418          
    419                      while (p_char != p_str) {
    420                          BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_BACKSPACE);
    421                          p_char--;                                       /* Decrement the index                                  */
    422                      }
    423          
    424                      Str_Copy(p_str, BSP_SerCmdHistory);
    425          
    426                      while (*p_char != '\0') {
    427                          BSP_Ser_WrByteUnlocked(*p_char++);
    428                      }
    429          #endif
    430                  } else {
    431                      rxd_history_char0 = DEF_NO;
    432                  }
    433              }
    434          
    435              BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface               */
   \   00000050   0x....             LDR.N    R0,??DataTable7_5
   \   00000052   0x.... 0x....      BL       BSP_OS_SemPost
    436          }
   \   00000056   0xE030             B.N      ??BSP_Ser_RdStr_0
   \                     ??BSP_Ser_RdStr_3:
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000060   0xD105             BNE.N    ??BSP_Ser_RdStr_4
   \   00000062   0x42B4             CMP      R4,R6
   \   00000064   0xD203             BCS.N    ??BSP_Ser_RdStr_4
   \   00000066   0x2008             MOVS     R0,#+8
   \   00000068   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
   \   0000006C   0x1E76             SUBS     R6,R6,#+1
   \                     ??BSP_Ser_RdStr_4:
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       ASCII_IsPrint
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD011             BEQ.N    ??BSP_Ser_RdStr_5
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD10E             BNE.N    ??BSP_Ser_RdStr_5
   \   00000080   0x4640             MOV      R0,R8
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
   \   00000088   0xF886 0x8000      STRB     R8,[R6, #+0]
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \   0000008E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000090   0x1928             ADDS     R0,R5,R4
   \   00000092   0x4286             CMP      R6,R0
   \   00000094   0xD3C7             BCC.N    ??BSP_Ser_RdStr_1
   \   00000096   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000098   0x1928             ADDS     R0,R5,R4
   \   0000009A   0x0006             MOVS     R6,R0
   \   0000009C   0xE7C3             B.N      ??BSP_Ser_RdStr_1
   \                     ??BSP_Ser_RdStr_5:
   \   0000009E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A2   0xF1B8 0x0F1B      CMP      R8,#+27
   \   000000A6   0xD105             BNE.N    ??BSP_Ser_RdStr_6
   \   000000A8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AA   0x2F00             CMP      R7,#+0
   \   000000AC   0xD102             BNE.N    ??BSP_Ser_RdStr_6
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x0007             MOVS     R7,R0
   \   000000B2   0xE7B8             B.N      ??BSP_Ser_RdStr_1
   \                     ??BSP_Ser_RdStr_6:
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0007             MOVS     R7,R0
   \   000000B8   0xE7B5             B.N      ??BSP_Ser_RdStr_1
   \                     ??BSP_Ser_RdStr_0:
   \   000000BA   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    437          
    438          
    439          /*
    440          *********************************************************************************************************
    441          *                                          BSP_Ser_WrByteUnlocked()
    442          *
    443          * Description : Writes a single byte to a serial port.
    444          *
    445          * Argument(s) : c           The character to output.
    446          *
    447          * Return(s)   : none.
    448          *
    449          * Caller(s)   : BSP_Ser_WrByte()
    450          *               BSP_Ser_WrByteUnlocked()
    451          *
    452          * Note(s)     : (1) This function blocks until room is available in the UART for the byte to be sent.
    453          *********************************************************************************************************
    454          */
    455          

   \                                 In section .text, align 2, keep-with-next
    456          void  BSP_Ser_WrByteUnlocked (CPU_INT08U c)
    457          {
   \                     BSP_Ser_WrByteUnlocked:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    458              USART_ITConfig(USART2, USART_IT_TC, ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF240 0x6126      MOVW     R1,#+1574
   \   0000000A   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   0000000C   0x.... 0x....      BL       USART_ITConfig
    459              USART_SendData(USART2, c);
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   00000018   0x.... 0x....      BL       USART_SendData
    460              BSP_OS_SemWait(&BSP_SerTxWait, 0);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x....             LDR.N    R0,??DataTable7_1
   \   00000020   0x.... 0x....      BL       BSP_OS_SemWait
    461              USART_ITConfig(USART2, USART_IT_TC, DISABLE);
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0xF240 0x6126      MOVW     R1,#+1574
   \   0000002A   0x....             LDR.N    R0,??DataTable7_7  ;; 0x40004400
   \   0000002C   0x.... 0x....      BL       USART_ITConfig
    462          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    463          
    464          
    465          /*
    466          *********************************************************************************************************
    467          *                                                BSP_Ser_WrByte()
    468          *
    469          * Description : Writes a single byte to a serial port.
    470          *
    471          * Argument(s) : tx_byte     The character to output.
    472          *
    473          * Return(s)   : none.
    474          *
    475          * Caller(s)   : Application.
    476          *
    477          * Note(s)     : none.
    478          *********************************************************************************************************
    479          */
    480          

   \                                 In section .text, align 2, keep-with-next
    481          void  BSP_Ser_WrByte(CPU_INT08U  c)
    482          {
   \                     BSP_Ser_WrByte:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    483              BSP_OS_SemWait(&BSP_SerLock, 0);                            /* Obtain access to the serial interface              */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable7_5
   \   00000008   0x.... 0x....      BL       BSP_OS_SemWait
    484          
    485              BSP_Ser_WrByteUnlocked(c);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
    486          
    487              BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface             */
   \   00000014   0x....             LDR.N    R0,??DataTable7_5
   \   00000016   0x.... 0x....      BL       BSP_OS_SemPost
    488          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    489          
    490          
    491          /*
    492          *********************************************************************************************************
    493          *                                                BSP_Ser_WrStr()
    494          *
    495          * Description : Transmits a string.
    496          *
    497          * Argument(s) : p_str       Pointer to the string that will be transmitted.
    498          *
    499          * Caller(s)   : Application.
    500          *
    501          * Return(s)   : none.
    502          *
    503          * Note(s)     : none.
    504          *********************************************************************************************************
    505          */
    506          

   \                                 In section .text, align 2, keep-with-next
    507          void  BSP_Ser_WrStr (CPU_CHAR  *p_str)
    508          {
   \                     BSP_Ser_WrStr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    509              CPU_BOOLEAN  err;
    510          
    511          
    512              if (p_str == (CPU_CHAR *)0) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD01D             BEQ.N    ??BSP_Ser_WrStr_0
    513                  return;
    514              }
    515          
    516          
    517              err = BSP_OS_SemWait(&BSP_SerLock, 0);                      /* Obtain access to the serial interface              */
   \                     ??BSP_Ser_WrStr_1:
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable7_5
   \   0000000C   0x.... 0x....      BL       BSP_OS_SemWait
   \   00000010   0x0005             MOVS     R5,R0
    518              if (err != DEF_OK ) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D01             CMP      R5,#+1
   \   00000016   0xD115             BNE.N    ??BSP_Ser_WrStr_0
    519                  return;
    520              }
    521          
    522              while ((*p_str) != (CPU_CHAR )0) {
   \                     ??BSP_Ser_WrStr_2:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00F             BEQ.N    ??BSP_Ser_WrStr_3
    523                  if (*p_str == ASCII_CHAR_LINE_FEED) {
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x280A             CMP      R0,#+10
   \   00000022   0xD107             BNE.N    ??BSP_Ser_WrStr_4
    524                      BSP_Ser_WrByteUnlocked(ASCII_CHAR_CARRIAGE_RETURN);
   \   00000024   0x200D             MOVS     R0,#+13
   \   00000026   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
    525                      BSP_Ser_WrByteUnlocked(ASCII_CHAR_LINE_FEED);
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
    526                      p_str++;
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0xE7F1             B.N      ??BSP_Ser_WrStr_2
    527                  } else {
    528                      BSP_Ser_WrByteUnlocked(*p_str++);
   \                     ??BSP_Ser_WrStr_4:
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       BSP_Ser_WrByteUnlocked
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \   0000003C   0xE7EC             B.N      ??BSP_Ser_WrStr_2
    529                  }
    530              }
    531          
    532              BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface             */
   \                     ??BSP_Ser_WrStr_3:
   \   0000003E   0x....             LDR.N    R0,??DataTable7_5
   \   00000040   0x.... 0x....      BL       BSP_OS_SemPost
    533          }
   \                     ??BSP_Ser_WrStr_0:
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     `?<Constant "Serial Tx Wait">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     BSP_SerTxWait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     `?<Constant "Serial Rx Wait">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     BSP_SerRxWait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     `?<Constant "Serial Lock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     BSP_SerLock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     BSP_SerRxData

   \                                 In section .rodata, align 4
   \                     `?<Constant "Serial Tx Wait">`:
   \   00000000   0x53 0x65          DC8 "Serial Tx Wait"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x54    
   \              0x78 0x20    
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Serial Rx Wait">`:
   \   00000000   0x53 0x65          DC8 "Serial Rx Wait"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x52    
   \              0x78 0x20    
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Serial Lock">`:
   \   00000000   0x53 0x65          DC8 "Serial Lock"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x4C    
   \              0x6F 0x63    
   \              0x6B 0x00    
    534          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BSP_Ser_ISR_Handler
        16   -> BSP_OS_SemPost
        16   -> USART_ClearITPendingBit
        16   -> USART_GetFlagStatus
        16   -> USART_ITConfig
        16   -> USART_ReceiveData
      40   BSP_Ser_Init
        40   -> BSP_IntEn
        40   -> BSP_IntVectSet
        40   -> BSP_OS_SemCreate
        40   -> BSP_OS_TimeDlyMs
        40   -> BSP_PeriphEn
        40   -> GPIO_Init
        40   -> GPIO_PinRemapConfig
        40   -> USART_ClearFlag
        40   -> USART_ClearITPendingBit
        40   -> USART_ClockInit
        40   -> USART_Cmd
        40   -> USART_GetFlagStatus
        40   -> USART_ITConfig
        40   -> USART_Init
     112   BSP_Ser_Printf
       112   -> BSP_Ser_WrStr
       112   -> vsnprintf
       8   BSP_Ser_RdByte
         8   -> BSP_OS_SemPost
         8   -> BSP_OS_SemWait
         8   -> BSP_Ser_RdByteUnlocked
       8   BSP_Ser_RdByteUnlocked
         8   -> BSP_OS_SemWait
         8   -> USART_ITConfig
      32   BSP_Ser_RdStr
        32   -> ASCII_IsPrint
        32   -> BSP_OS_SemPost
        32   -> BSP_OS_SemWait
        32   -> BSP_Ser_RdByteUnlocked
        32   -> BSP_Ser_WrByteUnlocked
       8   BSP_Ser_WrByte
         8   -> BSP_OS_SemPost
         8   -> BSP_OS_SemWait
         8   -> BSP_Ser_WrByteUnlocked
       8   BSP_Ser_WrByteUnlocked
         8   -> BSP_OS_SemWait
         8   -> USART_ITConfig
         8   -> USART_SendData
      16   BSP_Ser_WrStr
        16   -> BSP_OS_SemPost
        16   -> BSP_OS_SemWait
        16   -> BSP_Ser_WrByteUnlocked


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "Serial Lock">
      16  ?<Constant "Serial Rx Wait">
      16  ?<Constant "Serial Tx Wait">
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  BSP_SerLock
       1  BSP_SerRxData
       4  BSP_SerRxWait
       4  BSP_SerTxWait
      90  BSP_Ser_ISR_Handler
     288  BSP_Ser_Init
      40  BSP_Ser_Printf
      28  BSP_Ser_RdByte
      46  BSP_Ser_RdByteUnlocked
     190  BSP_Ser_RdStr
      28  BSP_Ser_WrByte
      50  BSP_Ser_WrByteUnlocked
      70  BSP_Ser_WrStr

 
  13 bytes in section .bss
  44 bytes in section .rodata
 866 bytes in section .text
 
 866 bytes of CODE  memory
  44 bytes of CONST memory
  13 bytes of DATA  memory

Errors: none
Warnings: none

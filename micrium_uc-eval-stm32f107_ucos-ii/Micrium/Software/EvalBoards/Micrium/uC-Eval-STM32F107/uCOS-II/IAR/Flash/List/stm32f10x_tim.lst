###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:25 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_tim.c                    #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_tim.c" -D                #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_tim.lst            #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_tim.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the TIM firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_tim.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ---------------------- TIM registers bit mask ------------------------ */
     23          #define CR1_CEN_Set                 ((u16)0x0001)
     24          #define CR1_CEN_Reset               ((u16)0x03FE)
     25          #define CR1_UDIS_Set                ((u16)0x0002)
     26          #define CR1_UDIS_Reset              ((u16)0x03FD)
     27          #define CR1_URS_Set                 ((u16)0x0004)
     28          #define CR1_URS_Reset               ((u16)0x03FB)
     29          #define CR1_OPM_Reset               ((u16)0x03F7)
     30          #define CR1_CounterMode_Mask        ((u16)0x038F)
     31          #define CR1_ARPE_Set                ((u16)0x0080)
     32          #define CR1_ARPE_Reset              ((u16)0x037F)
     33          #define CR1_CKD_Mask                ((u16)0x00FF)
     34          
     35          #define CR2_CCPC_Set                ((u16)0x0001)
     36          #define CR2_CCPC_Reset              ((u16)0xFFFE)
     37          #define CR2_CCUS_Set                ((u16)0x0004)
     38          #define CR2_CCUS_Reset              ((u16)0xFFFB)
     39          #define CR2_CCDS_Set                ((u16)0x0008)
     40          #define CR2_CCDS_Reset              ((u16)0xFFF7)
     41          #define CR2_MMS_Mask                ((u16)0xFF8F)
     42          #define CR2_TI1S_Set                ((u16)0x0080)
     43          #define CR2_TI1S_Reset              ((u16)0xFF7F)
     44          #define CR2_OIS1_Reset              ((u16)0x7EFF)
     45          #define CR2_OIS1N_Reset             ((u16)0x7DFF)
     46          #define CR2_OIS2_Reset              ((u16)0x7BFF)
     47          #define CR2_OIS2N_Reset             ((u16)0x77FF)
     48          #define CR2_OIS3_Reset              ((u16)0x6FFF)
     49          #define CR2_OIS3N_Reset             ((u16)0x5FFF)
     50          #define CR2_OIS4_Reset              ((u16)0x3FFF)
     51          
     52          #define SMCR_SMS_Mask               ((u16)0xFFF8)
     53          #define SMCR_ETR_Mask               ((u16)0x00FF)
     54          #define SMCR_TS_Mask                ((u16)0xFF8F)
     55          #define SMCR_MSM_Reset              ((u16)0xFF7F)
     56          #define SMCR_ECE_Set                ((u16)0x4000)
     57          
     58          #define CCMR_CC13S_Mask             ((u16)0xFFFC)
     59          #define CCMR_CC24S_Mask             ((u16)0xFCFF)
     60          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     61          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     62          #define CCMR_OC13FE_Reset           ((u16)0xFFFB)
     63          #define CCMR_OC24FE_Reset           ((u16)0xFBFF)
     64          #define CCMR_OC13PE_Reset           ((u16)0xFFF7)
     65          #define CCMR_OC24PE_Reset           ((u16)0xF7FF)
     66          #define CCMR_OC13M_Mask             ((u16)0xFF8F)
     67          #define CCMR_OC24M_Mask             ((u16)0x8FFF) 
     68          
     69          #define CCMR_OC13CE_Reset           ((u16)0xFF7F)
     70          #define CCMR_OC24CE_Reset           ((u16)0x7FFF)
     71          
     72          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     73          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     74          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     75          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     76          
     77          #define CCMR_Offset                 ((u16)0x0018)
     78          #define CCER_CCE_Set                ((u16)0x0001)
     79          #define	CCER_CCNE_Set               ((u16)0x0004)
     80          
     81          #define CCER_CC1P_Reset             ((u16)0xFFFD)
     82          #define CCER_CC2P_Reset             ((u16)0xFFDF)
     83          #define CCER_CC3P_Reset             ((u16)0xFDFF)
     84          #define CCER_CC4P_Reset             ((u16)0xDFFF)
     85          
     86          #define CCER_CC1NP_Reset            ((u16)0xFFF7)
     87          #define CCER_CC2NP_Reset            ((u16)0xFF7F)
     88          #define CCER_CC3NP_Reset            ((u16)0xF7FF)
     89          
     90          #define CCER_CC1E_Set               ((u16)0x0001)
     91          #define CCER_CC1E_Reset             ((u16)0xFFFE)
     92          
     93          #define CCER_CC1NE_Reset            ((u16)0xFFFB)
     94          
     95          #define CCER_CC2E_Set               ((u16)0x0010)
     96          #define CCER_CC2E_Reset             ((u16)0xFFEF)
     97          
     98          #define CCER_CC2NE_Reset            ((u16)0xFFBF)
     99          
    100          #define CCER_CC3E_Set               ((u16)0x0100)
    101          #define CCER_CC3E_Reset             ((u16)0xFEFF)
    102          
    103          #define CCER_CC3NE_Reset            ((u16)0xFBFF)
    104          
    105          #define CCER_CC4E_Set               ((u16)0x1000)
    106          #define CCER_CC4E_Reset             ((u16)0xEFFF)
    107          
    108          #define BDTR_MOE_Set                ((u16)0x8000)
    109          #define BDTR_MOE_Reset              ((u16)0x7FFF)
    110          
    111          /* Private macro -------------------------------------------------------------*/
    112          /* Private variables ---------------------------------------------------------*/
    113          /* Private function prototypes -----------------------------------------------*/
    114          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    115                                 u16 TIM_ICFilter);
    116          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    117                                 u16 TIM_ICFilter);
    118          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    119                                 u16 TIM_ICFilter);
    120          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    121                                 u16 TIM_ICFilter);
    122          /* Private macro -------------------------------------------------------------*/
    123          /* Private variables ---------------------------------------------------------*/
    124          /* Private function prototypes -----------------------------------------------*/
    125          /* Private functions ---------------------------------------------------------*/
    126          /*******************************************************************************
    127          * Function Name  : TIM_DeInit
    128          * Description    : Deinitializes the TIMx peripheral registers to their default
    129          *                  reset values.
    130          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    131          * Output         : None
    132          * Return         : None
    133          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          void TIM_DeInit(TIM_TypeDef* TIMx)
    135          {
   \                     TIM_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    136            /* Check the parameters */
    137            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    138           
    139            switch (*(u32*)&TIMx)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000000A   0xD020             BEQ.N    ??TIM_DeInit_0
   \   0000000C   0x....             LDR.N    R1,??DataTable5  ;; 0x40000400
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD026             BEQ.N    ??TIM_DeInit_1
   \   00000012   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40000800
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD02C             BEQ.N    ??TIM_DeInit_2
   \   00000018   0x....             LDR.N    R1,??DataTable5_2  ;; 0x40000c00
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD032             BEQ.N    ??TIM_DeInit_3
   \   0000001E   0x....             LDR.N    R1,??DataTable5_3  ;; 0x40001000
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD038             BEQ.N    ??TIM_DeInit_4
   \   00000024   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40001400
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD03E             BEQ.N    ??TIM_DeInit_5
   \   0000002A   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40012c00
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD003             BEQ.N    ??TIM_DeInit_6
   \   00000030   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40013400
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD041             BEQ.N    ??TIM_DeInit_7
   \   00000036   0xE04B             B.N      ??TIM_DeInit_8
    140            {
    141              case TIM1_BASE:
    142                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
   \                     ??TIM_DeInit_6:
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    143                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF44F 0x6000      MOV      R0,#+2048
   \   00000048   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    144                break; 
   \   0000004C   0xE040             B.N      ??TIM_DeInit_9
    145                
    146              case TIM2_BASE:
    147                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \                     ??TIM_DeInit_0:
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    148                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    149                break;
   \   0000005E   0xE037             B.N      ??TIM_DeInit_9
    150           
    151              case TIM3_BASE:
    152                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \                     ??TIM_DeInit_1:
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    153                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    154                break;
   \   00000070   0xE02E             B.N      ??TIM_DeInit_9
    155           
    156              case TIM4_BASE:
    157                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \                     ??TIM_DeInit_2:
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    158                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    159                break;
   \   00000082   0xE025             B.N      ??TIM_DeInit_9
    160                
    161              case TIM5_BASE:
    162                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
   \                     ??TIM_DeInit_3:
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x2008             MOVS     R0,#+8
   \   00000088   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    163                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2008             MOVS     R0,#+8
   \   00000090   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    164                break;
   \   00000094   0xE01C             B.N      ??TIM_DeInit_9
    165                
    166              case TIM6_BASE:
    167                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \                     ??TIM_DeInit_4:
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x2010             MOVS     R0,#+16
   \   0000009A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    168                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x2010             MOVS     R0,#+16
   \   000000A2   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    169                break;
   \   000000A6   0xE013             B.N      ??TIM_DeInit_9
    170                
    171              case TIM7_BASE:
    172                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \                     ??TIM_DeInit_5:
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x2020             MOVS     R0,#+32
   \   000000AC   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    173                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x2020             MOVS     R0,#+32
   \   000000B4   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    174                break;
   \   000000B8   0xE00A             B.N      ??TIM_DeInit_9
    175                
    176              case TIM8_BASE:
    177                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
   \                     ??TIM_DeInit_7:
   \   000000BA   0x2101             MOVS     R1,#+1
   \   000000BC   0xF44F 0x5000      MOV      R0,#+8192
   \   000000C0   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    178                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0xF44F 0x5000      MOV      R0,#+8192
   \   000000CA   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    179                break; 
   \   000000CE   0xE7FF             B.N      ??TIM_DeInit_9
    180                
    181              default:
    182                break;
    183            }
    184          }
   \                     ??TIM_DeInit_8:
   \                     ??TIM_DeInit_9:
   \   000000D0   0xBD10             POP      {R4,PC}          ;; return
    185          
    186          /*******************************************************************************
    187          * Function Name  : TIM_TimeBaseInit
    188          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    189          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    190          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    191          *                    peripheral.
    192          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    193          *                   structure that contains the configuration information for
    194          *                   the specified TIM peripheral.
    195          * Output         : None
    196          * Return         : None
    197          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    199          {
   \                     TIM_TimeBaseInit:
   \   00000000   0xB410             PUSH     {R4}
    200            /* Check the parameters */
    201            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    202            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    203            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    204          
    205            /* Select the Counter Mode and set the clock division */
    206            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
   \   00000002   0x8802             LDRH     R2,[R0, #+0]
   \   00000004   0xF012 0x028F      ANDS     R2,R2,#0x8F
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    207            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    208                          TIM_TimeBaseInitStruct->TIM_CounterMode;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x88CB             LDRH     R3,[R1, #+6]
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x8002             STRH     R2,[R0, #+0]
    209            /* Set the Autoreload value */
    210            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   00000016   0x888A             LDRH     R2,[R1, #+4]
   \   00000018   0x8582             STRH     R2,[R0, #+44]
    211          
    212            /* Set the Prescaler value */
    213            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   0000001A   0x880A             LDRH     R2,[R1, #+0]
   \   0000001C   0x8502             STRH     R2,[R0, #+40]
    214             
    215            if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
   \   0000001E   0x....             LDR.N    R2,??DataTable5_5  ;; 0x40012c00
   \   00000020   0x4290             CMP      R0,R2
   \   00000022   0xD002             BEQ.N    ??TIM_TimeBaseInit_0
   \   00000024   0x....             LDR.N    R2,??DataTable5_6  ;; 0x40013400
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD101             BNE.N    ??TIM_TimeBaseInit_1
    216            {
    217              /* Set the Repetition Counter value */
    218              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
   \                     ??TIM_TimeBaseInit_0:
   \   0000002A   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000002C   0x8602             STRH     R2,[R0, #+48]
    219            } 
    220            /* Generate an update event to reload the Prescaler value immediatly */
    221            TIMx->EGR = TIM_PSCReloadMode_Immediate;       
   \                     ??TIM_TimeBaseInit_1:
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x8282             STRH     R2,[R0, #+20]
    222          }
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
    223          
    224          /*******************************************************************************
    225          * Function Name  : TIM_OC1Init
    226          * Description    : Initializes the TIMx Channel1 according to the specified
    227          *                  parameters in the TIM_OCInitStruct.
    228          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    229          *                    peripheral.
    230          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    231          *                    that contains the configuration information for the specified
    232          *                    TIM peripheral.
    233          * Output         : None
    234          * Return         : None
    235          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    236          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    237          {
   \                     TIM_OC1Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    238            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2200             MOVS     R2,#+0
    239             
    240            /* Check the parameters */
    241            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    242            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    243            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    244            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    245          
    246            /* Disable the Channel 1: Reset the CC1E Bit */
    247            TIMx->CCER &= CCER_CC1E_Reset;
   \   00000008   0x8C05             LDRH     R5,[R0, #+32]
   \   0000000A   0xF64F 0x76FE      MOVW     R6,#+65534
   \   0000000E   0x4035             ANDS     R5,R6,R5
   \   00000010   0x8405             STRH     R5,[R0, #+32]
    248            
    249            /* Get the TIMx CCER register value */
    250            tmpccer = TIMx->CCER;
   \   00000012   0x8C05             LDRH     R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
    251          
    252            /* Get the TIMx CR2 register value */
    253            tmpcr2 =  TIMx->CR2;
   \   00000016   0x8885             LDRH     R5,[R0, #+4]
   \   00000018   0x002A             MOVS     R2,R5
    254            
    255            /* Get the TIMx CCMR1 register value */
    256            tmpccmrx = TIMx->CCMR1;
   \   0000001A   0x8B05             LDRH     R5,[R0, #+24]
   \   0000001C   0x002B             MOVS     R3,R5
    257              
    258            /* Reset the Output Compare Mode Bits */
    259            tmpccmrx &= CCMR_OC13M_Mask;
   \   0000001E   0xF64F 0x758F      MOVW     R5,#+65423
   \   00000022   0x402B             ANDS     R3,R5,R3
    260            
    261            /* Select the Output Compare Mode */
    262            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000024   0x880D             LDRH     R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
    263            
    264            /* Reset the Output Polarity level */
    265            tmpccer &= CCER_CC1P_Reset;
   \   00000028   0xF64F 0x75FD      MOVW     R5,#+65533
   \   0000002C   0x402C             ANDS     R4,R5,R4
    266          
    267            /* Set the Output Compare Polarity */
    268            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
   \   0000002E   0x890D             LDRH     R5,[R1, #+8]
   \   00000030   0x432C             ORRS     R4,R5,R4
    269            
    270            /* Set the Output State */
    271            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   00000032   0x884D             LDRH     R5,[R1, #+2]
   \   00000034   0x432C             ORRS     R4,R5,R4
    272            
    273            /* Set the Capture Compare Register value */
    274            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
   \   00000036   0x88CD             LDRH     R5,[R1, #+6]
   \   00000038   0x8685             STRH     R5,[R0, #+52]
    275            
    276            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   0000003A   0x....             LDR.N    R5,??DataTable5_5  ;; 0x40012c00
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD002             BEQ.N    ??TIM_OC1Init_0
   \   00000040   0x....             LDR.N    R5,??DataTable5_6  ;; 0x40013400
   \   00000042   0x42A8             CMP      R0,R5
   \   00000044   0xD113             BNE.N    ??TIM_OC1Init_1
    277            {
    278              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    279              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    280              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    281              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    282              
    283              /* Reset the Output N Polarity level */
    284              tmpccer &= CCER_CC1NP_Reset;
   \                     ??TIM_OC1Init_0:
   \   00000046   0xF64F 0x75F7      MOVW     R5,#+65527
   \   0000004A   0x402C             ANDS     R4,R5,R4
    285          
    286              /* Set the Output N Polarity */
    287              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
   \   0000004C   0x894D             LDRH     R5,[R1, #+10]
   \   0000004E   0x432C             ORRS     R4,R5,R4
    288          
    289              /* Reset the Output N State */
    290              tmpccer &= CCER_CC1NE_Reset;
   \   00000050   0xF64F 0x75FB      MOVW     R5,#+65531
   \   00000054   0x402C             ANDS     R4,R5,R4
    291              
    292              /* Set the Output N State */
    293              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
   \   00000056   0x888D             LDRH     R5,[R1, #+4]
   \   00000058   0x432C             ORRS     R4,R5,R4
    294          
    295              /* Reset the Ouput Compare and Output Compare N IDLE State */
    296              tmpcr2 &= CR2_OIS1_Reset;
   \   0000005A   0xF647 0x65FF      MOVW     R5,#+32511
   \   0000005E   0x402A             ANDS     R2,R5,R2
    297              tmpcr2 &= CR2_OIS1N_Reset;
   \   00000060   0xF647 0x55FF      MOVW     R5,#+32255
   \   00000064   0x402A             ANDS     R2,R5,R2
    298          
    299              /* Set the Output Idle state */
    300              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
   \   00000066   0x898D             LDRH     R5,[R1, #+12]
   \   00000068   0x432A             ORRS     R2,R5,R2
    301          
    302              /* Set the Output N Idle state */
    303              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
   \   0000006A   0x89CD             LDRH     R5,[R1, #+14]
   \   0000006C   0x432A             ORRS     R2,R5,R2
    304            }
    305            /* Write to TIMx CR2 */
    306            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1Init_1:
   \   0000006E   0x8082             STRH     R2,[R0, #+4]
    307            
    308            /* Write to TIMx CCMR1 */
    309            TIMx->CCMR1 = tmpccmrx;
   \   00000070   0x8303             STRH     R3,[R0, #+24]
    310            
    311            /* Write to TIMx CCER */
    312            TIMx->CCER = tmpccer;
   \   00000072   0x8404             STRH     R4,[R0, #+32]
    313          }
   \   00000074   0xBC70             POP      {R4-R6}
   \   00000076   0x4770             BX       LR               ;; return
    314          
    315          /*******************************************************************************
    316          * Function Name  : TIM_OC2Init
    317          * Description    : Initializes the TIMx Channel2 according to the specified
    318          *                  parameters in the TIM_OCInitStruct.
    319          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    320          *                    peripheral.
    321          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    322          *                    that contains the configuration information for the specified
    323          *                    TIM peripheral.
    324          * Output         : None
    325          * Return         : None
    326          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    327          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    328          {
   \                     TIM_OC2Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    329            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2200             MOVS     R2,#+0
    330             
    331            /* Check the parameters */
    332            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    333            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    334            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    335            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    336          
    337            /* Disable the Channel 2: Reset the CC2E Bit */
    338            TIMx->CCER &= CCER_CC2E_Reset;
   \   00000008   0x8C05             LDRH     R5,[R0, #+32]
   \   0000000A   0xF64F 0x76EF      MOVW     R6,#+65519
   \   0000000E   0x4035             ANDS     R5,R6,R5
   \   00000010   0x8405             STRH     R5,[R0, #+32]
    339            
    340            /* Get the TIMx CCER register value */  
    341            tmpccer = TIMx->CCER;
   \   00000012   0x8C05             LDRH     R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
    342          
    343            /* Get the TIMx CR2 register value */
    344            tmpcr2 =  TIMx->CR2;
   \   00000016   0x8885             LDRH     R5,[R0, #+4]
   \   00000018   0x002A             MOVS     R2,R5
    345            
    346            /* Get the TIMx CCMR1 register value */
    347            tmpccmrx = TIMx->CCMR1;
   \   0000001A   0x8B05             LDRH     R5,[R0, #+24]
   \   0000001C   0x002B             MOVS     R3,R5
    348              
    349            /* Reset the Output Compare Mode Bits */
    350            tmpccmrx &= CCMR_OC24M_Mask;
   \   0000001E   0xF648 0x75FF      MOVW     R5,#+36863
   \   00000022   0x402B             ANDS     R3,R5,R3
    351            
    352            /* Select the Output Compare Mode */
    353            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000024   0x880D             LDRH     R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
    354            
    355            /* Reset the Output Polarity level */
    356            tmpccer &= CCER_CC2P_Reset;
   \   0000002A   0xF64F 0x75DF      MOVW     R5,#+65503
   \   0000002E   0x402C             ANDS     R4,R5,R4
    357          
    358            /* Set the Output Compare Polarity */
    359            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
   \   00000030   0x890D             LDRH     R5,[R1, #+8]
   \   00000032   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
    360            
    361            /* Set the Output State */
    362            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
   \   00000036   0x884D             LDRH     R5,[R1, #+2]
   \   00000038   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
    363            
    364            /* Set the Capture Compare Register value */
    365            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   0000003C   0x88CD             LDRH     R5,[R1, #+6]
   \   0000003E   0x8705             STRH     R5,[R0, #+56]
    366            
    367            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000040   0x....             LDR.N    R5,??DataTable5_5  ;; 0x40012c00
   \   00000042   0x42A8             CMP      R0,R5
   \   00000044   0xD002             BEQ.N    ??TIM_OC2Init_0
   \   00000046   0x....             LDR.N    R5,??DataTable5_6  ;; 0x40013400
   \   00000048   0x42A8             CMP      R0,R5
   \   0000004A   0xD117             BNE.N    ??TIM_OC2Init_1
    368            {
    369              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    370              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    371              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    372              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    373              
    374              /* Reset the Output N Polarity level */
    375              tmpccer &= CCER_CC2NP_Reset;
   \                     ??TIM_OC2Init_0:
   \   0000004C   0xF64F 0x757F      MOVW     R5,#+65407
   \   00000050   0x402C             ANDS     R4,R5,R4
    376          
    377              /* Set the Output N Polarity */
    378              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
   \   00000052   0x894D             LDRH     R5,[R1, #+10]
   \   00000054   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
    379          
    380              /* Reset the Output N State */
    381              tmpccer &= CCER_CC2NE_Reset;
   \   00000058   0xF64F 0x75BF      MOVW     R5,#+65471
   \   0000005C   0x402C             ANDS     R4,R5,R4
    382              
    383              /* Set the Output N State */
    384              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
   \   0000005E   0x888D             LDRH     R5,[R1, #+4]
   \   00000060   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
    385          
    386              /* Reset the Ouput Compare and Output Compare N IDLE State */
    387              tmpcr2 &= CR2_OIS2_Reset;
   \   00000064   0xF647 0x35FF      MOVW     R5,#+31743
   \   00000068   0x402A             ANDS     R2,R5,R2
    388              tmpcr2 &= CR2_OIS2N_Reset;
   \   0000006A   0xF247 0x75FF      MOVW     R5,#+30719
   \   0000006E   0x402A             ANDS     R2,R5,R2
    389          
    390              /* Set the Output Idle state */
    391              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
   \   00000070   0x898D             LDRH     R5,[R1, #+12]
   \   00000072   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
    392          
    393              /* Set the Output N Idle state */
    394              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
   \   00000076   0x89CD             LDRH     R5,[R1, #+14]
   \   00000078   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
    395            }
    396          
    397            /* Write to TIMx CR2 */
    398            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2Init_1:
   \   0000007C   0x8082             STRH     R2,[R0, #+4]
    399            
    400            /* Write to TIMx CCMR1 */
    401            TIMx->CCMR1 = tmpccmrx;
   \   0000007E   0x8303             STRH     R3,[R0, #+24]
    402            
    403            /* Write to TIMx CCER */
    404            TIMx->CCER = tmpccer;
   \   00000080   0x8404             STRH     R4,[R0, #+32]
    405          }
   \   00000082   0xBC70             POP      {R4-R6}
   \   00000084   0x4770             BX       LR               ;; return
    406          
    407          /*******************************************************************************
    408          * Function Name  : TIM_OC3Init
    409          * Description    : Initializes the TIMx Channel3 according to the specified
    410          *                  parameters in the TIM_OCInitStruct.
    411          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    412          *                    peripheral.
    413          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    414          *                    that contains the configuration information for the specified
    415          *                    TIM peripheral.
    416          * Output         : None
    417          * Return         : None
    418          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    419          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    420          {
   \                     TIM_OC3Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    421            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2200             MOVS     R2,#+0
    422             
    423            /* Check the parameters */
    424            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    425            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    426            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    427            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    428          
    429            /* Disable the Channel 2: Reset the CC2E Bit */
    430            TIMx->CCER &= CCER_CC3E_Reset;
   \   00000008   0x8C05             LDRH     R5,[R0, #+32]
   \   0000000A   0xF64F 0x66FF      MOVW     R6,#+65279
   \   0000000E   0x4035             ANDS     R5,R6,R5
   \   00000010   0x8405             STRH     R5,[R0, #+32]
    431            
    432            /* Get the TIMx CCER register value */
    433            tmpccer = TIMx->CCER;
   \   00000012   0x8C05             LDRH     R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
    434          
    435            /* Get the TIMx CR2 register value */
    436            tmpcr2 =  TIMx->CR2;
   \   00000016   0x8885             LDRH     R5,[R0, #+4]
   \   00000018   0x002A             MOVS     R2,R5
    437            
    438            /* Get the TIMx CCMR2 register value */
    439            tmpccmrx = TIMx->CCMR2;
   \   0000001A   0x8B85             LDRH     R5,[R0, #+28]
   \   0000001C   0x002B             MOVS     R3,R5
    440              
    441            /* Reset the Output Compare Mode Bits */
    442            tmpccmrx &= CCMR_OC13M_Mask;
   \   0000001E   0xF64F 0x758F      MOVW     R5,#+65423
   \   00000022   0x402B             ANDS     R3,R5,R3
    443            
    444            /* Select the Output Compare Mode */
    445            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000024   0x880D             LDRH     R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
    446            
    447            /* Reset the Output Polarity level */
    448            tmpccer &= CCER_CC3P_Reset;
   \   00000028   0xF64F 0x55FF      MOVW     R5,#+65023
   \   0000002C   0x402C             ANDS     R4,R5,R4
    449          
    450            /* Set the Output Compare Polarity */
    451            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
   \   0000002E   0x890D             LDRH     R5,[R1, #+8]
   \   00000030   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
    452            
    453            /* Set the Output State */
    454            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   00000034   0x884D             LDRH     R5,[R1, #+2]
   \   00000036   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
    455            
    456            /* Set the Capture Compare Register value */
    457            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   0000003A   0x88CD             LDRH     R5,[R1, #+6]
   \   0000003C   0x8785             STRH     R5,[R0, #+60]
    458            
    459            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   0000003E   0x....             LDR.N    R5,??DataTable5_5  ;; 0x40012c00
   \   00000040   0x42A8             CMP      R0,R5
   \   00000042   0xD002             BEQ.N    ??TIM_OC3Init_0
   \   00000044   0x....             LDR.N    R5,??DataTable5_6  ;; 0x40013400
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD117             BNE.N    ??TIM_OC3Init_1
    460            {
    461              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    462              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    463              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    464              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    465              
    466              /* Reset the Output N Polarity level */
    467              tmpccer &= CCER_CC3NP_Reset;
   \                     ??TIM_OC3Init_0:
   \   0000004A   0xF24F 0x75FF      MOVW     R5,#+63487
   \   0000004E   0x402C             ANDS     R4,R5,R4
    468          
    469              /* Set the Output N Polarity */
    470              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
   \   00000050   0x894D             LDRH     R5,[R1, #+10]
   \   00000052   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
    471          
    472              /* Reset the Output N State */
    473              tmpccer &= CCER_CC3NE_Reset;
   \   00000056   0xF64F 0x35FF      MOVW     R5,#+64511
   \   0000005A   0x402C             ANDS     R4,R5,R4
    474              
    475              /* Set the Output N State */
    476              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
   \   0000005C   0x888D             LDRH     R5,[R1, #+4]
   \   0000005E   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
    477          
    478              /* Reset the Ouput Compare and Output Compare N IDLE State */
    479              tmpcr2 &= CR2_OIS3_Reset;
   \   00000062   0xF646 0x75FF      MOVW     R5,#+28671
   \   00000066   0x402A             ANDS     R2,R5,R2
    480              tmpcr2 &= CR2_OIS3N_Reset;
   \   00000068   0xF645 0x75FF      MOVW     R5,#+24575
   \   0000006C   0x402A             ANDS     R2,R5,R2
    481          
    482              /* Set the Output Idle state */
    483              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
   \   0000006E   0x898D             LDRH     R5,[R1, #+12]
   \   00000070   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
    484          
    485              /* Set the Output N Idle state */
    486              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
   \   00000074   0x89CD             LDRH     R5,[R1, #+14]
   \   00000076   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
    487            }
    488          
    489            /* Write to TIMx CR2 */
    490            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3Init_1:
   \   0000007A   0x8082             STRH     R2,[R0, #+4]
    491            
    492            /* Write to TIMx CCMR2 */
    493            TIMx->CCMR2 = tmpccmrx;
   \   0000007C   0x8383             STRH     R3,[R0, #+28]
    494            
    495            /* Write to TIMx CCER */
    496            TIMx->CCER = tmpccer;
   \   0000007E   0x8404             STRH     R4,[R0, #+32]
    497          }
   \   00000080   0xBC70             POP      {R4-R6}
   \   00000082   0x4770             BX       LR               ;; return
    498          
    499          /*******************************************************************************
    500          * Function Name  : TIM_OC4Init
    501          * Description    : Initializes the TIMx Channel4 according to the specified
    502          *                  parameters in the TIM_OCInitStruct.
    503          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    504          *                    peripheral.
    505          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    506          *                    that contains the configuration information for the specified
    507          *                    TIM peripheral.
    508          * Output         : None
    509          * Return         : None
    510          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    511          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    512          {
   \                     TIM_OC4Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    513            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2200             MOVS     R2,#+0
    514             
    515            /* Check the parameters */
    516            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    517            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    518            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    519            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    520          
    521            /* Disable the Channel 2: Reset the CC4E Bit */
    522            TIMx->CCER &= CCER_CC4E_Reset;
   \   00000008   0x8C05             LDRH     R5,[R0, #+32]
   \   0000000A   0xF64E 0x76FF      MOVW     R6,#+61439
   \   0000000E   0x4035             ANDS     R5,R6,R5
   \   00000010   0x8405             STRH     R5,[R0, #+32]
    523            
    524            /* Get the TIMx CCER register value */
    525            tmpccer = TIMx->CCER;
   \   00000012   0x8C05             LDRH     R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
    526          
    527            /* Get the TIMx CR2 register value */
    528            tmpcr2 =  TIMx->CR2;
   \   00000016   0x8885             LDRH     R5,[R0, #+4]
   \   00000018   0x002A             MOVS     R2,R5
    529            
    530            /* Get the TIMx CCMR2 register value */
    531            tmpccmrx = TIMx->CCMR2;
   \   0000001A   0x8B85             LDRH     R5,[R0, #+28]
   \   0000001C   0x002B             MOVS     R3,R5
    532              
    533            /* Reset the Output Compare Mode Bits */
    534            tmpccmrx &= CCMR_OC24M_Mask;
   \   0000001E   0xF648 0x75FF      MOVW     R5,#+36863
   \   00000022   0x402B             ANDS     R3,R5,R3
    535            
    536            /* Select the Output Compare Mode */
    537            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000024   0x880D             LDRH     R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
    538            
    539            /* Reset the Output Polarity level */
    540            tmpccer &= CCER_CC4P_Reset;
   \   0000002A   0xF64D 0x75FF      MOVW     R5,#+57343
   \   0000002E   0x402C             ANDS     R4,R5,R4
    541          
    542            /* Set the Output Compare Polarity */
    543            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
   \   00000030   0x890D             LDRH     R5,[R1, #+8]
   \   00000032   0xEA54 0x3405      ORRS     R4,R4,R5, LSL #+12
    544            
    545            /* Set the Output State */
    546            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
   \   00000036   0x884D             LDRH     R5,[R1, #+2]
   \   00000038   0xEA54 0x3405      ORRS     R4,R4,R5, LSL #+12
    547            
    548            /* Set the Capture Compare Register value */
    549            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   0000003C   0x88CD             LDRH     R5,[R1, #+6]
   \   0000003E   0xF8A0 0x5040      STRH     R5,[R0, #+64]
    550            
    551            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000042   0x....             LDR.N    R5,??DataTable5_5  ;; 0x40012c00
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD002             BEQ.N    ??TIM_OC4Init_0
   \   00000048   0x....             LDR.N    R5,??DataTable5_6  ;; 0x40013400
   \   0000004A   0x42A8             CMP      R0,R5
   \   0000004C   0xD104             BNE.N    ??TIM_OC4Init_1
    552            {
    553              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    554          
    555              /* Reset the Ouput Compare IDLE State */
    556              tmpcr2 &= CR2_OIS4_Reset;
   \                     ??TIM_OC4Init_0:
   \   0000004E   0x0492             LSLS     R2,R2,#+18       ;; ZeroExtS R2,R2,#+18,#+18
   \   00000050   0x0C92             LSRS     R2,R2,#+18
    557          
    558              /* Set the Output Idle state */
    559              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
   \   00000052   0x898D             LDRH     R5,[R1, #+12]
   \   00000054   0xEA52 0x1285      ORRS     R2,R2,R5, LSL #+6
    560            }
    561          
    562            /* Write to TIMx CR2 */
    563            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4Init_1:
   \   00000058   0x8082             STRH     R2,[R0, #+4]
    564            
    565            /* Write to TIMx CCMR2 */  
    566            TIMx->CCMR2 = tmpccmrx;
   \   0000005A   0x8383             STRH     R3,[R0, #+28]
    567            
    568            /* Write to TIMx CCER */
    569            TIMx->CCER = tmpccer;
   \   0000005C   0x8404             STRH     R4,[R0, #+32]
    570          }
   \   0000005E   0xBC70             POP      {R4-R6}
   \   00000060   0x4770             BX       LR               ;; return
    571          
    572          /*******************************************************************************
    573          * Function Name  : TIM_ICInit
    574          * Description    : Initializes the TIM peripheral according to the specified
    575          *                  parameters in the TIM_ICInitStruct.
    576          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    577          *                    peripheral.
    578          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    579          *                    that contains the configuration information for the specified
    580          *                    TIM peripheral.
    581          * Output         : None
    582          * Return         : None
    583          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    584          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    585          {
   \                     TIM_ICInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    586            /* Check the parameters */
    587            assert_param(IS_TIM_123458_PERIPH(TIMx));
    588            assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    589            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    590            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    591            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    592            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    593            
    594            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000006   0x8828             LDRH     R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10A             BNE.N    ??TIM_ICInit_0
    595            {
    596              /* TI1 Configuration */
    597              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    598                         TIM_ICInitStruct->TIM_ICSelection,
    599                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000000C   0x892B             LDRH     R3,[R5, #+8]
   \   0000000E   0x88AA             LDRH     R2,[R5, #+4]
   \   00000010   0x8869             LDRH     R1,[R5, #+2]
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       TI1_Config
    600          
    601              /* Set the Input Capture Prescaler value */
    602              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000018   0x88E9             LDRH     R1,[R5, #+6]
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       TIM_SetIC1Prescaler
   \   00000020   0xE025             B.N      ??TIM_ICInit_1
    603            }
    604            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0:
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD10A             BNE.N    ??TIM_ICInit_2
    605            {
    606              /* TI2 Configuration */
    607              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    608                         TIM_ICInitStruct->TIM_ICSelection,
    609                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   0x892B             LDRH     R3,[R5, #+8]
   \   0000002A   0x88AA             LDRH     R2,[R5, #+4]
   \   0000002C   0x8869             LDRH     R1,[R5, #+2]
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       TI2_Config
    610          
    611              /* Set the Input Capture Prescaler value */
    612              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000034   0x88E9             LDRH     R1,[R5, #+6]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \   0000003C   0xE017             B.N      ??TIM_ICInit_1
    613            }
    614            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_2:
   \   0000003E   0x8828             LDRH     R0,[R5, #+0]
   \   00000040   0x2808             CMP      R0,#+8
   \   00000042   0xD10A             BNE.N    ??TIM_ICInit_3
    615            {
    616              /* TI3 Configuration */
    617              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    618                         TIM_ICInitStruct->TIM_ICSelection,
    619                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000044   0x892B             LDRH     R3,[R5, #+8]
   \   00000046   0x88AA             LDRH     R2,[R5, #+4]
   \   00000048   0x8869             LDRH     R1,[R5, #+2]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       TI3_Config
    620          
    621              /* Set the Input Capture Prescaler value */
    622              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000050   0x88E9             LDRH     R1,[R5, #+6]
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       TIM_SetIC3Prescaler
   \   00000058   0xE009             B.N      ??TIM_ICInit_1
    623            }
    624            else
    625            {
    626              /* TI4 Configuration */
    627              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    628                         TIM_ICInitStruct->TIM_ICSelection,
    629                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_3:
   \   0000005A   0x892B             LDRH     R3,[R5, #+8]
   \   0000005C   0x88AA             LDRH     R2,[R5, #+4]
   \   0000005E   0x8869             LDRH     R1,[R5, #+2]
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       TI4_Config
    630          
    631              /* Set the Input Capture Prescaler value */
    632              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000066   0x88E9             LDRH     R1,[R5, #+6]
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       TIM_SetIC4Prescaler
    633            }
    634          }
   \                     ??TIM_ICInit_1:
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    635          
    636          /*******************************************************************************
    637          * Function Name  : TIM_PWMIConfig
    638          * Description    : Configures the TIM peripheral according to the specified
    639          *                  parameters in the TIM_ICInitStruct to measure an external PWM
    640          *                  signal.
    641          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    642          *                    peripheral.
    643          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    644          *                    that contains the configuration information for the specified
    645          *                    TIM peripheral.
    646          * Output         : None
    647          * Return         : None
    648          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    649          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    650          {
   \                     TIM_PWMIConfig:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    651            u16 icoppositepolarity = TIM_ICPolarity_Rising;
   \   00000006   0x2600             MOVS     R6,#+0
    652            u16 icoppositeselection = TIM_ICSelection_DirectTI;
   \   00000008   0x2701             MOVS     R7,#+1
    653          
    654            /* Check the parameters */
    655            assert_param(IS_TIM_123458_PERIPH(TIMx));
    656          
    657            /* Select the Opposite Input Polarity */
    658            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \   0000000A   0x8868             LDRH     R0,[R5, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??TIM_PWMIConfig_0
    659            {
    660              icoppositepolarity = TIM_ICPolarity_Falling;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x0006             MOVS     R6,R0
   \   00000014   0xE001             B.N      ??TIM_PWMIConfig_1
    661            }
    662            else
    663            {
    664              icoppositepolarity = TIM_ICPolarity_Rising;
   \                     ??TIM_PWMIConfig_0:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0006             MOVS     R6,R0
    665            }
    666          
    667            /* Select the Opposite Input */
    668            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_1:
   \   0000001A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD102             BNE.N    ??TIM_PWMIConfig_2
    669            {
    670              icoppositeselection = TIM_ICSelection_IndirectTI;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x0007             MOVS     R7,R0
   \   00000024   0xE001             B.N      ??TIM_PWMIConfig_3
    671            }
    672            else
    673            {
    674              icoppositeselection = TIM_ICSelection_DirectTI;
   \                     ??TIM_PWMIConfig_2:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0007             MOVS     R7,R0
    675            }
    676          
    677            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_PWMIConfig_3:
   \   0000002A   0x8828             LDRH     R0,[R5, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD116             BNE.N    ??TIM_PWMIConfig_4
    678            {
    679              /* TI1 Configuration */
    680              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    681                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000030   0x892B             LDRH     R3,[R5, #+8]
   \   00000032   0x88AA             LDRH     R2,[R5, #+4]
   \   00000034   0x8869             LDRH     R1,[R5, #+2]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       TI1_Config
    682          
    683              /* Set the Input Capture Prescaler value */
    684              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000003C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       TIM_SetIC1Prescaler
    685          
    686              /* TI2 Configuration */
    687              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   00000044   0x892B             LDRH     R3,[R5, #+8]
   \   00000046   0x003A             MOVS     R2,R7
   \   00000048   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       TI2_Config
    688          
    689              /* Set the Input Capture Prescaler value */
    690              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000054   0x88E9             LDRH     R1,[R5, #+6]
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \   0000005C   0xE015             B.N      ??TIM_PWMIConfig_5
    691            }
    692            else
    693            { 
    694              /* TI2 Configuration */
    695              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    696                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_4:
   \   0000005E   0x892B             LDRH     R3,[R5, #+8]
   \   00000060   0x88AA             LDRH     R2,[R5, #+4]
   \   00000062   0x8869             LDRH     R1,[R5, #+2]
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       TI2_Config
    697          
    698              /* Set the Input Capture Prescaler value */
    699              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000006A   0x88E9             LDRH     R1,[R5, #+6]
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       TIM_SetIC2Prescaler
    700          
    701              /* TI1 Configuration */
    702              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   00000072   0x892B             LDRH     R3,[R5, #+8]
   \   00000074   0x003A             MOVS     R2,R7
   \   00000076   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       TI1_Config
    703          
    704              /* Set the Input Capture Prescaler value */
    705              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000082   0x88E9             LDRH     R1,[R5, #+6]
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       TIM_SetIC1Prescaler
    706            }
    707          }
   \                     ??TIM_PWMIConfig_5:
   \   0000008A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    708          
    709          /*******************************************************************************
    710          * Function Name  : TIM_BDTRConfig
    711          * Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
    712          *                  the OSSR State and the AOE(automatic output enable).
    713          * Input          :- TIMx: where x can be  1 or 8 to select the TIM 
    714          *                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
    715          *                    structure that contains the BDTR Register configuration
    716          *                    information for the TIM peripheral.
    717          * Output         : None
    718          * Return         : None
    719          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    720          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    721          {
    722            /* Check the parameters */
    723            assert_param(IS_TIM_18_PERIPH(TIMx));
    724            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    725            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    726            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    727            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    728            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    729            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    730          
    731            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    732               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    733          
    734            TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    735                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    736                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    737                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   \                     TIM_BDTRConfig:
   \   00000000   0x880A             LDRH     R2,[R1, #+0]
   \   00000002   0x884B             LDRH     R3,[R1, #+2]
   \   00000004   0x431A             ORRS     R2,R3,R2
   \   00000006   0x888B             LDRH     R3,[R1, #+4]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x88CB             LDRH     R3,[R1, #+6]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x890B             LDRH     R3,[R1, #+8]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x894B             LDRH     R3,[R1, #+10]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x898B             LDRH     R3,[R1, #+12]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0xF8A0 0x2044      STRH     R2,[R0, #+68]
    738          
    739          }
   \   0000001E   0x4770             BX       LR               ;; return
    740          
    741          /*******************************************************************************
    742          * Function Name  : TIM_TimeBaseStructInit
    743          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    744          * Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    745          *                    structure which will be initialized.
    746          * Output         : None
    747          * Return         : None
    748          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    749          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    750          {
    751            /* Set the default configuration */
    752            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit:
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8081             STRH     R1,[R0, #+4]
    753            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8001             STRH     R1,[R0, #+0]
    754            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    755            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8041             STRH     R1,[R0, #+2]
    756            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7201             STRB     R1,[R0, #+8]
    757          }
   \   00000016   0x4770             BX       LR               ;; return
    758          
    759          /*******************************************************************************
    760          * Function Name  : TIM_OCStructInit
    761          * Description    : Fills each TIM_OCInitStruct member with its default value.
    762          * Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
    763          *                    which will be initialized.
    764          * Output         : None
    765          * Return         : None
    766          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    767          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    768          {
    769            /* Set the default configuration */
    770            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    771            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    772            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    773            TIM_OCInitStruct->TIM_Pulse = 0x0000;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    774            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    775            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    776            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    777            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x81C1             STRH     R1,[R0, #+14]
    778          }
   \   00000020   0x4770             BX       LR               ;; return
    779          
    780          /*******************************************************************************
    781          * Function Name  : TIM_ICStructInit
    782          * Description    : Fills each TIM_ICInitStruct member with its default value.
    783          * Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
    784          *                    which will be initialized.
    785          * Output         : None
    786          * Return         : None
    787          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    788          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    789          {
    790            /* Set the default configuration */
    791            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    792            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    793            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    794            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    795            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    796          }
   \   00000014   0x4770             BX       LR               ;; return
    797          
    798          /*******************************************************************************
    799          * Function Name  : TIM_BDTRStructInit
    800          * Description    : Fills each TIM_BDTRInitStruct member with its default value.
    801          * Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
    802          *                    structure which will be initialized.
    803          * Output         : None
    804          * Return         : None
    805          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    806          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    807          {
    808            /* Set the default configuration */
    809            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   \                     TIM_BDTRStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    810            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    811            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    812            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    813            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    814            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    815            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    816          }
   \   0000001C   0x4770             BX       LR               ;; return
    817          
    818          /*******************************************************************************
    819          * Function Name  : TIM_Cmd
    820          * Description    : Enables or disables the specified TIM peripheral.
    821          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    822          *                  - NewState: new state of the TIMx peripheral.
    823          *                    This parameter can be: ENABLE or DISABLE.
    824          * Output         : None
    825          * Return         : None
    826          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    827          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    828          {
    829            /* Check the parameters */
    830            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    831            assert_param(IS_FUNCTIONAL_STATE(NewState));
    832            
    833            if (NewState != DISABLE)
   \                     TIM_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_Cmd_0
    834            {
    835              /* Enable the TIM Counter */
    836              TIMx->CR1 |= CR1_CEN_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??TIM_Cmd_1
    837            }
    838            else
    839            {
    840              /* Disable the TIM Counter */
    841              TIMx->CR1 &= CR1_CEN_Reset;
   \                     ??TIM_Cmd_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF240 0x33FE      MOVW     R3,#+1022
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
    842            }
    843          }
   \                     ??TIM_Cmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    844          
    845          /*******************************************************************************
    846          * Function Name  : TIM_CtrlPWMOutputs
    847          * Description    : Enables or disables the TIM peripheral Main Outputs.
    848          * Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
    849          *                 - NewState: new state of the TIM peripheral Main Outputs.
    850          *                    This parameter can be: ENABLE or DISABLE.
    851          * Output         : None
    852          * Return         : None
    853          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    854          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    855          {
    856            /* Check the parameters */
    857            assert_param(IS_TIM_18_PERIPH(TIMx));
    858            assert_param(IS_FUNCTIONAL_STATE(NewState));
    859          
    860            if (NewState != DISABLE)
   \                     TIM_CtrlPWMOutputs:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD006             BEQ.N    ??TIM_CtrlPWMOutputs_0
    861            {
    862              /* Enable the TIM Main Output */
    863              TIMx->BDTR |= BDTR_MOE_Set;
   \   00000006   0xF8B0 0x2044      LDRH     R2,[R0, #+68]
   \   0000000A   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \   0000000E   0xF8A0 0x2044      STRH     R2,[R0, #+68]
   \   00000012   0xE005             B.N      ??TIM_CtrlPWMOutputs_1
    864            }
    865            else
    866            {
    867              /* Disable the TIM Main Output */
    868              TIMx->BDTR &= BDTR_MOE_Reset;
   \                     ??TIM_CtrlPWMOutputs_0:
   \   00000014   0xF8B0 0x2044      LDRH     R2,[R0, #+68]
   \   00000018   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   0000001A   0x0C52             LSRS     R2,R2,#+17
   \   0000001C   0xF8A0 0x2044      STRH     R2,[R0, #+68]
    869            }  
    870          }
   \                     ??TIM_CtrlPWMOutputs_1:
   \   00000020   0x4770             BX       LR               ;; return
    871          
    872          /*******************************************************************************
    873          * Function Name  : TIM_ITConfig
    874          * Description    : Enables or disables the specified TIM interrupts.
    875          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    876          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    877          *                    or disabled.
    878          *                    This parameter can be any combination of the following values:
    879          *                       - TIM_IT_Update: TIM update Interrupt source
    880          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    881          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    882          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    883          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    884          *                       - TIM_IT_COM: TIM Commutation Interrupt source
    885          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
    886          *                       - TIM_IT_Break: TIM Break Interrupt source
    887          *                  - NewState: new state of the TIM interrupts.
    888          *                    This parameter can be: ENABLE or DISABLE.
    889          * Output         : None
    890          * Return         : None
    891          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    892          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
    893          {  
    894            /* Check the parameters */
    895            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    896            assert_param(IS_TIM_IT(TIM_IT));
    897            assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
    898            assert_param(IS_FUNCTIONAL_STATE(NewState));
    899            
    900            if (NewState != DISABLE)
   \                     TIM_ITConfig:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??TIM_ITConfig_0
    901            {
    902              /* Enable the Interrupt sources */
    903              TIMx->DIER |= TIM_IT;
   \   00000006   0x8983             LDRH     R3,[R0, #+12]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x8183             STRH     R3,[R0, #+12]
   \   0000000C   0xE002             B.N      ??TIM_ITConfig_1
    904            }
    905            else
    906            {
    907              /* Disable the Interrupt sources */
    908              TIMx->DIER &= (u16)~TIM_IT;
   \                     ??TIM_ITConfig_0:
   \   0000000E   0x8983             LDRH     R3,[R0, #+12]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x8183             STRH     R3,[R0, #+12]
    909            }
    910          }
   \                     ??TIM_ITConfig_1:
   \   00000014   0x4770             BX       LR               ;; return
    911          
    912          /*******************************************************************************
    913          * Function Name  : TIM_GenerateEvent
    914          * Description    : Configures the TIMx event to be generate by software.
    915          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    916          *                  - TIM_EventSource: specifies the event source.
    917          *                    This parameter can be one or more of the following values:	   
    918          *                       - TIM_EventSource_Update: Timer update Event source
    919          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    920          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    921          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    922          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    923          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
    924          * Output         : None
    925          * Return         : None
    926          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    927          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
    928          { 
    929            /* Check the parameters */
    930            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    931            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    932            assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
    933          
    934            /* Set the event sources */
    935            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent:
   \   00000000   0x8281             STRH     R1,[R0, #+20]
    936          }
   \   00000002   0x4770             BX       LR               ;; return
    937          
    938          /*******************************************************************************
    939          * Function Name  : TIM_DMAConfig
    940          * Description    : Configures the TIMxs DMA interface.
    941          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    942          *                    peripheral.
    943          *                  - TIM_DMABase: DMA Base address.
    944          *                    This parameter can be one of the following values:
    945          *                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    946          *                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    947          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    948          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    949          *                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    950          *                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    951          *                         TIM_DMABase_DCR.
    952          *                   - TIM_DMABurstLength: DMA Burst length.
    953          *                     This parameter can be one value between:
    954          *                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    955          * Output         : None
    956          * Return         : None
    957          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    958          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    959          {
    960            /* Check the parameters */
    961            assert_param(IS_TIM_123458_PERIPH(TIMx));
    962            assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    963            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    964          
    965            /* Set the DMA Base and the DMA Burst Length */
    966            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     TIM_DMAConfig:
   \   00000000   0xEA52 0x0301      ORRS     R3,R2,R1
   \   00000004   0xF8A0 0x3048      STRH     R3,[R0, #+72]
    967          }
   \   00000008   0x4770             BX       LR               ;; return
    968          
    969          /*******************************************************************************
    970          * Function Name  : TIM_DMACmd
    971          * Description    : Enables or disables the TIMxs DMA Requests.
    972          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
    973          *                  - TIM_DMASources: specifies the DMA Request sources.
    974          *                    This parameter can be any combination of the following values:
    975          *                       - TIM_DMA_Update: TIM update Interrupt source
    976          *                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    977          *                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    978          *                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    979          *                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    980          *                       - TIM_DMA_COM: TIM Commutation DMA source
    981          *                       - TIM_DMA_Trigger: TIM Trigger DMA source
    982          *                  - NewState: new state of the DMA Request sources.
    983          *                    This parameter can be: ENABLE or DISABLE.
    984          * Output         : None
    985          * Return         : None
    986          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    987          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
    988          { 
    989            /* Check the parameters */
    990            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    991            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    992            assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
    993            assert_param(IS_FUNCTIONAL_STATE(NewState));
    994            
    995            if (NewState != DISABLE)
   \                     TIM_DMACmd:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??TIM_DMACmd_0
    996            {
    997              /* Enable the DMA sources */
    998              TIMx->DIER |= TIM_DMASource; 
   \   00000006   0x8983             LDRH     R3,[R0, #+12]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x8183             STRH     R3,[R0, #+12]
   \   0000000C   0xE002             B.N      ??TIM_DMACmd_1
    999            }
   1000            else
   1001            {
   1002              /* Disable the DMA sources */
   1003              TIMx->DIER &= (u16)~TIM_DMASource;
   \                     ??TIM_DMACmd_0:
   \   0000000E   0x8983             LDRH     R3,[R0, #+12]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x8183             STRH     R3,[R0, #+12]
   1004            }
   1005          }
   \                     ??TIM_DMACmd_1:
   \   00000014   0x4770             BX       LR               ;; return
   1006          
   1007          /*******************************************************************************
   1008          * Function Name  : TIM_InternalClockConfig
   1009          * Description    : Configures the TIMx interrnal Clock
   1010          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1011          *                    peripheral.
   1012          * Output         : None
   1013          * Return         : None
   1014          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1015          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   1016          {
   1017            /* Check the parameters */
   1018            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1019          
   1020            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1021            TIMx->SMCR &=  SMCR_SMS_Mask;
   \                     TIM_InternalClockConfig:
   \   00000000   0x8901             LDRH     R1,[R0, #+8]
   \   00000002   0xF64F 0x72F8      MOVW     R2,#+65528
   \   00000006   0x4011             ANDS     R1,R2,R1
   \   00000008   0x8101             STRH     R1,[R0, #+8]
   1022          }
   \   0000000A   0x4770             BX       LR               ;; return
   1023          /*******************************************************************************
   1024          * Function Name  : TIM_ITRxExternalClockConfig
   1025          * Description    : Configures the TIMx Internal Trigger as External Clock
   1026          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1027          *                    peripheral.
   1028          *                  - TIM_ITRSource: Trigger source.
   1029          *                    This parameter can be one of the following values:
   1030          *                       - TIM_TS_ITR0: Internal Trigger 0
   1031          *                       - TIM_TS_ITR1: Internal Trigger 1
   1032          *                       - TIM_TS_ITR2: Internal Trigger 2
   1033          *                       - TIM_TS_ITR3: Internal Trigger 3
   1034          * Output         : None
   1035          * Return         : None
   1036          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1037          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1038          {
   \                     TIM_ITRxExternalClockConfig:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1039            /* Check the parameters */
   1040            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1041            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1042          
   1043            /* Select the Internal Trigger */
   1044            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       TIM_SelectInputTrigger
   1045          
   1046            /* Select the External clock mode1 */
   1047            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000010   0x8920             LDRH     R0,[R4, #+8]
   \   00000012   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   00000016   0x8120             STRH     R0,[R4, #+8]
   1048          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1049          /*******************************************************************************
   1050          * Function Name  : TIM_TIxExternalClockConfig
   1051          * Description    : Configures the TIMx Trigger as External Clock
   1052          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1053          *                    peripheral.
   1054          *                  - TIM_TIxExternalCLKSource: Trigger source.
   1055          *                    This parameter can be one of the following values:
   1056          *                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1057          *                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1058          *                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1059          *                  - TIM_ICPolarity: specifies the TIx Polarity.
   1060          *                    This parameter can be:
   1061          *                       - TIM_ICPolarity_Rising
   1062          *                       - TIM_ICPolarity_Falling
   1063          *                   - ICFilter : specifies the filter value.
   1064          *                     This parameter must be a value between 0x0 and 0xF.
   1065          * Output         : None
   1066          * Return         : None
   1067          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1068          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
   1069                                          u16 TIM_ICPolarity, u16 ICFilter)
   1070          {
   \                     TIM_TIxExternalClockConfig:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1071            /* Check the parameters */
   1072            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1073            assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
   1074            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1075            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1076          
   1077            /* Configure the Timer Input Clock Source */
   1078            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \   0000000A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000C   0x2D60             CMP      R5,#+96
   \   0000000E   0xD108             BNE.N    ??TIM_TIxExternalClockConfig_0
   1079            {
   1080              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   00000010   0x003B             MOVS     R3,R7
   \   00000012   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       TI2_Config
   \   00000020   0xE007             B.N      ??TIM_TIxExternalClockConfig_1
   1081            }
   1082            else
   1083            {
   1084              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0:
   \   00000022   0x003B             MOVS     R3,R7
   \   00000024   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x0031             MOVS     R1,R6
   \   0000002A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       TI1_Config
   1085            }
   1086          
   1087            /* Select the Trigger source */
   1088            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_1:
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       TIM_SelectInputTrigger
   1089          
   1090            /* Select the External clock mode1 */
   1091            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000003C   0x8920             LDRH     R0,[R4, #+8]
   \   0000003E   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   00000042   0x8120             STRH     R0,[R4, #+8]
   1092          }
   \   00000044   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1093          
   1094          /*******************************************************************************
   1095          * Function Name  : TIM_ETRClockMode1Config
   1096          * Description    : Configures the External clock Mode1
   1097          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1098          *                    peripheral.
   1099          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1100          *                    It can be one of the following values:
   1101          *                       - TIM_ExtTRGPSC_OFF
   1102          *                       - TIM_ExtTRGPSC_DIV2
   1103          *                       - TIM_ExtTRGPSC_DIV4
   1104          *                       - TIM_ExtTRGPSC_DIV8.
   1105          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1106          *                    It can be one of the following values:
   1107          *                       - TIM_ExtTRGPolarity_Inverted
   1108          *                       - TIM_ExtTRGPolarity_NonInverted
   1109          *                  - ExtTRGFilter: External Trigger Filter.
   1110          *                    This parameter must be a value between 0x00 and 0x0F
   1111          * Output         : None
   1112          * Return         : None
   1113          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1114          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1115                                       u16 ExtTRGFilter)
   1116          {
   \                     TIM_ETRClockMode1Config:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1117            u16 tmpsmcr = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1118          
   1119            /* Check the parameters */
   1120            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1121            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1122            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1123            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1124          
   1125            /* Configure the ETR Clock source */
   1126            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000010   0x003B             MOVS     R3,R7
   \   00000012   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_ETRConfig
   1127            
   1128            /* Get the TIMx SMCR register value */
   1129            tmpsmcr = TIMx->SMCR;
   \   00000022   0x8920             LDRH     R0,[R4, #+8]
   \   00000024   0x4680             MOV      R8,R0
   1130          
   1131            /* Reset the SMS Bits */
   1132            tmpsmcr &= SMCR_SMS_Mask;
   \   00000026   0xF64F 0x70F8      MOVW     R0,#+65528
   \   0000002A   0xEA10 0x0808      ANDS     R8,R0,R8
   1133            /* Select the External clock mode1 */
   1134            tmpsmcr |= TIM_SlaveMode_External1;
   \   0000002E   0xF058 0x0807      ORRS     R8,R8,#0x7
   1135          
   1136            /* Select the Trigger selection : ETRF */
   1137            tmpsmcr &= SMCR_TS_Mask;
   \   00000032   0xF64F 0x708F      MOVW     R0,#+65423
   \   00000036   0xEA10 0x0808      ANDS     R8,R0,R8
   1138            tmpsmcr |= TIM_TS_ETRF;
   \   0000003A   0xF058 0x0870      ORRS     R8,R8,#0x70
   1139          
   1140            /* Write to TIMx SMCR */
   1141            TIMx->SMCR = tmpsmcr;
   \   0000003E   0xF8A4 0x8008      STRH     R8,[R4, #+8]
   1142          }
   \   00000042   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1143          
   1144          /*******************************************************************************
   1145          * Function Name  : TIM_ETRClockMode2Config
   1146          * Description    : Configures the External clock Mode2
   1147          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1148          *                    peripheral.
   1149          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1150          *                    It can be one of the following values:
   1151          *                       - TIM_ExtTRGPSC_OFF
   1152          *                       - TIM_ExtTRGPSC_DIV2
   1153          *                       - TIM_ExtTRGPSC_DIV4
   1154          *                       - TIM_ExtTRGPSC_DIV8
   1155          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1156          *                    It can be one of the following values:
   1157          *                       - TIM_ExtTRGPolarity_Inverted
   1158          *                       - TIM_ExtTRGPolarity_NonInverted
   1159          *                  - ExtTRGFilter: External Trigger Filter.
   1160          *                    This parameter must be a value between 0x00 and 0x0F
   1161          * Output         : None
   1162          * Return         : None
   1163          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1164          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
   1165                                       u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
   1166          {
   \                     TIM_ETRClockMode2Config:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1167            /* Check the parameters */
   1168            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1169            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1170            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1171            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1172          
   1173            /* Configure the ETR Clock source */
   1174            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       TIM_ETRConfig
   1175          
   1176            /* Enable the External clock mode2 */
   1177            TIMx->SMCR |= SMCR_ECE_Set;
   \   0000001C   0x8920             LDRH     R0,[R4, #+8]
   \   0000001E   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000022   0x8120             STRH     R0,[R4, #+8]
   1178          }
   \   00000024   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1179          
   1180          /*******************************************************************************
   1181          * Function Name  : TIM_ETRConfig
   1182          * Description    : Configures the TIMx External Trigger (ETR).
   1183          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1184          *                    peripheral.
   1185          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1186          *                    This parameter can be one of the following values:
   1187          *                       - TIM_ExtTRGPSC_OFF
   1188          *                       - TIM_ExtTRGPSC_DIV2
   1189          *                       - TIM_ExtTRGPSC_DIV4
   1190          *                       - TIM_ExtTRGPSC_DIV8
   1191          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1192          *                    This parameter can be one of the following values:
   1193          *                       - TIM_ExtTRGPolarity_Inverted
   1194          *                       - TIM_ExtTRGPolarity_NonInverted
   1195          *                  - ExtTRGFilter: External Trigger Filter.
   1196          *                    This parameter must be a value between 0x00 and 0x0F.
   1197          * Output         : None
   1198          * Return         : None
   1199          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1200          void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1201                             u16 ExtTRGFilter)
   1202          {
   \                     TIM_ETRConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   1203            u16 tmpsmcr = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   1204          
   1205            /* Check the parameters */
   1206            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1207            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1208            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1209            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1210          
   1211            tmpsmcr = TIMx->SMCR;
   \   00000004   0x8905             LDRH     R5,[R0, #+8]
   \   00000006   0x002C             MOVS     R4,R5
   1212          
   1213            /* Reset the ETR Bits */
   1214            tmpsmcr &= SMCR_ETR_Mask;
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   1215          
   1216            /* Set the Prescaler, the Filter value and the Polarity */
   1217            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
   \   0000000A   0xEA52 0x0501      ORRS     R5,R2,R1
   \   0000000E   0xEA55 0x2503      ORRS     R5,R5,R3, LSL #+8
   \   00000012   0x432C             ORRS     R4,R5,R4
   1218          
   1219            /* Write to TIMx SMCR */
   1220            TIMx->SMCR = tmpsmcr;
   \   00000014   0x8104             STRH     R4,[R0, #+8]
   1221          }
   \   00000016   0xBC30             POP      {R4,R5}
   \   00000018   0x4770             BX       LR               ;; return
   1222          
   1223          /*******************************************************************************
   1224          * Function Name  : TIM_PrescalerConfig
   1225          * Description    : Configures the TIMx Prescaler.
   1226          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
   1227          *                  - Prescaler: specifies the Prescaler Register value
   1228          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1229          *                    This parameter can be one of the following values:
   1230          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
   1231          *                         the update event.
   1232          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
   1233          *                         immediatly.
   1234          * Output         : None
   1235          * Return         : None
   1236          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1237          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
   1238          {
   1239            /* Check the parameters */
   1240            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1241            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1242          
   1243            /* Set the Prescaler value */
   1244            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig:
   \   00000000   0x8501             STRH     R1,[R0, #+40]
   1245          
   1246            /* Set or reset the UG Bit */
   1247            TIMx->EGR = TIM_PSCReloadMode;
   \   00000002   0x8282             STRH     R2,[R0, #+20]
   1248          }
   \   00000004   0x4770             BX       LR               ;; return
   1249          
   1250          /*******************************************************************************
   1251          * Function Name  : TIM_CounterModeConfig
   1252          * Description    : Specifies the TIMx Counter Mode to be used.
   1253          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1254          *                    peripheral.
   1255          *                  - TIM_CounterMode: specifies the Counter Mode to be used
   1256          *                    This parameter can be one of the following values:
   1257          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
   1258          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
   1259          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1260          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1261          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1262          * Output         : None
   1263          * Return         : None
   1264          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1265          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
   1266          {
   1267            u16 tmpcr1 = 0;
   \                     TIM_CounterModeConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1268          
   1269            /* Check the parameters */
   1270            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1271            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1272          
   1273            tmpcr1 = TIMx->CR1;
   \   00000002   0x8803             LDRH     R3,[R0, #+0]
   \   00000004   0x001A             MOVS     R2,R3
   1274          
   1275            /* Reset the CMS and DIR Bits */
   1276            tmpcr1 &= CR1_CounterMode_Mask;
   \   00000006   0xF240 0x338F      MOVW     R3,#+911
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1277          
   1278            /* Set the Counter Mode */
   1279            tmpcr1 |= TIM_CounterMode;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1280          
   1281            /* Write to TIMx CR1 register */
   1282            TIMx->CR1 = tmpcr1;
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
   1283          }
   \   00000010   0x4770             BX       LR               ;; return
   1284          
   1285          /*******************************************************************************
   1286          * Function Name  : TIM_SelectInputTrigger
   1287          * Description    : Selects the Input Trigger source
   1288          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1289          *                    peripheral.
   1290          *                  - TIM_InputTriggerSource: The Input Trigger source.
   1291          *                    This parameter can be one of the following values:
   1292          *                       - TIM_TS_ITR0: Internal Trigger 0
   1293          *                       - TIM_TS_ITR1: Internal Trigger 1
   1294          *                       - TIM_TS_ITR2: Internal Trigger 2
   1295          *                       - TIM_TS_ITR3: Internal Trigger 3
   1296          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
   1297          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
   1298          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
   1299          *                       - TIM_TS_ETRF: External Trigger input
   1300          * Output         : None
   1301          * Return         : None
   1302          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1303          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1304          {
   1305            u16 tmpsmcr = 0;
   \                     TIM_SelectInputTrigger:
   \   00000000   0x2200             MOVS     R2,#+0
   1306          
   1307            /* Check the parameters */
   1308            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1309            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1310          
   1311            /* Get the TIMx SMCR register value */
   1312            tmpsmcr = TIMx->SMCR;
   \   00000002   0x8903             LDRH     R3,[R0, #+8]
   \   00000004   0x001A             MOVS     R2,R3
   1313          
   1314            /* Reset the TS Bits */
   1315            tmpsmcr &= SMCR_TS_Mask;
   \   00000006   0xF64F 0x738F      MOVW     R3,#+65423
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1316          
   1317            /* Set the Input Trigger source */
   1318            tmpsmcr |= TIM_InputTriggerSource;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1319          
   1320            /* Write to TIMx SMCR */
   1321            TIMx->SMCR = tmpsmcr;
   \   0000000E   0x8102             STRH     R2,[R0, #+8]
   1322          }
   \   00000010   0x4770             BX       LR               ;; return
   1323          
   1324          /*******************************************************************************
   1325          * Function Name  : TIM_EncoderInterfaceConfig
   1326          * Description    : Configures the TIMx Encoder Interface.
   1327          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1328          *                    peripheral.
   1329          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1330          *                    This parameter can be one of the following values:
   1331          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1332          *                         depending on TI2FP2 level.
   1333          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1334          *                         depending on TI1FP1 level.
   1335          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1336          *                         TI2FP2 edges depending on the level of the other input.
   1337          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1338          *                    This parmeter can be one of the following values:
   1339          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1340          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1341          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1342          *                    This parmeter can be one of the following values:
   1343          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1344          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1345          * Output         : None
   1346          * Return         : None
   1347          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1348          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1349                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1350          {
   \                     TIM_EncoderInterfaceConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1351            u16 tmpsmcr = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   1352            u16 tmpccmr1 = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1353            u16 tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1354              
   1355            /* Check the parameters */
   1356            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1357            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1358            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1359            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1360          
   1361            /* Get the TIMx SMCR register value */
   1362            tmpsmcr = TIMx->SMCR;
   \   00000008   0x8907             LDRH     R7,[R0, #+8]
   \   0000000A   0x003C             MOVS     R4,R7
   1363          
   1364            /* Get the TIMx CCMR1 register value */
   1365            tmpccmr1 = TIMx->CCMR1;
   \   0000000C   0x8B07             LDRH     R7,[R0, #+24]
   \   0000000E   0x003D             MOVS     R5,R7
   1366          
   1367            /* Get the TIMx CCER register value */
   1368            tmpccer = TIMx->CCER;
   \   00000010   0x8C07             LDRH     R7,[R0, #+32]
   \   00000012   0x003E             MOVS     R6,R7
   1369          
   1370            /* Set the encoder Mode */
   1371            tmpsmcr &= SMCR_SMS_Mask;
   \   00000014   0xF64F 0x77F8      MOVW     R7,#+65528
   \   00000018   0x403C             ANDS     R4,R7,R4
   1372            tmpsmcr |= TIM_EncoderMode;
   \   0000001A   0x430C             ORRS     R4,R1,R4
   1373          
   1374            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1375            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   \   0000001C   0xF64F 0x47FC      MOVW     R7,#+64764
   \   00000020   0x403D             ANDS     R5,R7,R5
   1376            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   \   00000022   0xF240 0x1701      MOVW     R7,#+257
   \   00000026   0x433D             ORRS     R5,R7,R5
   1377          
   1378            /* Set the TI1 and the TI2 Polarities */
   1379            tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
   \   00000028   0xF64F 0x77DD      MOVW     R7,#+65501
   \   0000002C   0x403E             ANDS     R6,R7,R6
   1380            tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
   \   0000002E   0xEA52 0x1703      ORRS     R7,R2,R3, LSL #+4
   \   00000032   0x433E             ORRS     R6,R7,R6
   1381          
   1382            /* Write to TIMx SMCR */
   1383            TIMx->SMCR = tmpsmcr;
   \   00000034   0x8104             STRH     R4,[R0, #+8]
   1384          
   1385            /* Write to TIMx CCMR1 */
   1386            TIMx->CCMR1 = tmpccmr1;
   \   00000036   0x8305             STRH     R5,[R0, #+24]
   1387          
   1388            /* Write to TIMx CCER */
   1389            TIMx->CCER = tmpccer;
   \   00000038   0x8406             STRH     R6,[R0, #+32]
   1390          }
   \   0000003A   0xBCF0             POP      {R4-R7}
   \   0000003C   0x4770             BX       LR               ;; return
   1391          
   1392          /*******************************************************************************
   1393          * Function Name  : TIM_ForcedOC1Config
   1394          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
   1395          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1396          *                    peripheral.
   1397          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1398          *                    the output waveform.
   1399          *                    This parameter can be one of the following values:
   1400          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
   1401          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1402          *                         OC1REF.
   1403          * Output         : None
   1404          * Return         : None
   1405          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1406          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1407          {
   1408            u16 tmpccmr1 = 0;
   \                     TIM_ForcedOC1Config:
   \   00000000   0x2200             MOVS     R2,#+0
   1409          
   1410            /* Check the parameters */
   1411            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1412            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1413          
   1414            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1415          
   1416            /* Reset the OC1M Bits */
   1417            tmpccmr1 &= CCMR_OC13M_Mask;
   \   00000006   0xF64F 0x738F      MOVW     R3,#+65423
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1418          
   1419            /* Configure The Forced output Mode */
   1420            tmpccmr1 |= TIM_ForcedAction;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1421          
   1422            /* Write to TIMx CCMR1 register */
   1423            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   1424          }
   \   00000010   0x4770             BX       LR               ;; return
   1425          
   1426          /*******************************************************************************
   1427          * Function Name  : TIM_ForcedOC2Config
   1428          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
   1429          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1430          *                    peripheral.
   1431          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1432          *                    the output waveform.
   1433          *                    This parameter can be one of the following values:
   1434          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
   1435          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1436          *                         OC2REF.
   1437          * Output         : None
   1438          * Return         : None
   1439          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1440          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1441          {
   1442            u16 tmpccmr1 = 0;
   \                     TIM_ForcedOC2Config:
   \   00000000   0x2200             MOVS     R2,#+0
   1443          
   1444            /* Check the parameters */
   1445            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1446            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1447          
   1448            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1449          
   1450            /* Reset the OC2M Bits */
   1451            tmpccmr1 &= CCMR_OC24M_Mask;
   \   00000006   0xF648 0x73FF      MOVW     R3,#+36863
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1452          
   1453            /* Configure The Forced output Mode */
   1454            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1455          
   1456            /* Write to TIMx CCMR1 register */
   1457            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0x8302             STRH     R2,[R0, #+24]
   1458          }
   \   00000012   0x4770             BX       LR               ;; return
   1459          
   1460          /*******************************************************************************
   1461          * Function Name  : TIM_ForcedOC3Config
   1462          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
   1463          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1464          *                    peripheral.
   1465          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1466          *                    the output waveform.
   1467          *                    This parameter can be one of the following values:
   1468          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
   1469          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1470          *                         OC3REF.
   1471          * Output         : None
   1472          * Return         : None
   1473          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1474          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1475          {
   1476            u16 tmpccmr2 = 0;
   \                     TIM_ForcedOC3Config:
   \   00000000   0x2200             MOVS     R2,#+0
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1480            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1481          
   1482            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1483          
   1484            /* Reset the OC1M Bits */
   1485            tmpccmr2 &= CCMR_OC13M_Mask;
   \   00000006   0xF64F 0x738F      MOVW     R3,#+65423
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1486          
   1487            /* Configure The Forced output Mode */
   1488            tmpccmr2 |= TIM_ForcedAction;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1489          
   1490            /* Write to TIMx CCMR2 register */
   1491            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   1492          }
   \   00000010   0x4770             BX       LR               ;; return
   1493          
   1494          /*******************************************************************************
   1495          * Function Name  : TIM_ForcedOC4Config
   1496          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
   1497          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1498          *                    peripheral.
   1499          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1500          *                    the output waveform.
   1501          *                    This parameter can be one of the following values:
   1502          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
   1503          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1504          *                         OC4REF.
   1505          * Output         : None
   1506          * Return         : None
   1507          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1508          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1509          {
   1510            u16 tmpccmr2 = 0;
   \                     TIM_ForcedOC4Config:
   \   00000000   0x2200             MOVS     R2,#+0
   1511          
   1512            /* Check the parameters */
   1513            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1514            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1515            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1516          
   1517            /* Reset the OC2M Bits */
   1518            tmpccmr2 &= CCMR_OC24M_Mask;
   \   00000006   0xF648 0x73FF      MOVW     R3,#+36863
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1519          
   1520            /* Configure The Forced output Mode */
   1521            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1522          
   1523            /* Write to TIMx CCMR2 register */
   1524            TIMx->CCMR2 = tmpccmr2;
   \   00000010   0x8382             STRH     R2,[R0, #+28]
   1525          }
   \   00000012   0x4770             BX       LR               ;; return
   1526          
   1527          /*******************************************************************************
   1528          * Function Name  : TIM_ARRPreloadConfig
   1529          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
   1530          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1531          *                    peripheral.
   1532          *                  - NewState: new state of the TIMx peripheral Preload register
   1533          *                    This parameter can be: ENABLE or DISABLE.
   1534          * Output         : None
   1535          * Return         : None
   1536          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1537          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1538          {
   1539            /* Check the parameters */
   1540            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1541            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1542          
   1543            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_ARRPreloadConfig_0
   1544            {
   1545              /* Set the ARR Preload Bit */
   1546              TIMx->CR1 |= CR1_ARPE_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??TIM_ARRPreloadConfig_1
   1547            }
   1548            else
   1549            {
   1550              /* Reset the ARR Preload Bit */
   1551              TIMx->CR1 &= CR1_ARPE_Reset;
   \                     ??TIM_ARRPreloadConfig_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF240 0x337F      MOVW     R3,#+895
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
   1552            }
   1553          }
   \                     ??TIM_ARRPreloadConfig_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1554          
   1555          /*******************************************************************************
   1556          * Function Name  : TIM_SelectCOM
   1557          * Description    : Selects the TIM peripheral Commutation event.
   1558          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1559          *                 - NewState: new state of the Commutation event.
   1560          *                    This parameter can be: ENABLE or DISABLE.
   1561          * Output         : None
   1562          * Return         : None
   1563          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1564          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1565          {
   1566            /* Check the parameters */
   1567            assert_param(IS_TIM_18_PERIPH(TIMx));
   1568            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1569          
   1570            if (NewState != DISABLE)
   \                     TIM_SelectCOM:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_SelectCOM_0
   1571            {
   1572              /* Set the COM Bit */
   1573              TIMx->CR2 |= CR2_CCUS_Set;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   \   0000000E   0xE004             B.N      ??TIM_SelectCOM_1
   1574            }
   1575            else
   1576            {
   1577              /* Reset the COM Bit */
   1578              TIMx->CR2 &= CR2_CCUS_Reset;
   \                     ??TIM_SelectCOM_0:
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xF64F 0x73FB      MOVW     R3,#+65531
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8082             STRH     R2,[R0, #+4]
   1579            }
   1580          }
   \                     ??TIM_SelectCOM_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1581          
   1582          /*******************************************************************************
   1583          * Function Name  : TIM_SelectCCDMA
   1584          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
   1585          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1586          *                    peripheral.
   1587          *                  - NewState: new state of the Capture Compare DMA source
   1588          *                    This parameter can be: ENABLE or DISABLE.
   1589          * Output         : None
   1590          * Return         : None
   1591          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1592          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1593          {
   1594            /* Check the parameters */
   1595            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1596            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1597          
   1598            if (NewState != DISABLE)
   \                     TIM_SelectCCDMA:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_SelectCCDMA_0
   1599            {
   1600              /* Set the CCDS Bit */
   1601              TIMx->CR2 |= CR2_CCDS_Set;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   \   0000000E   0xE004             B.N      ??TIM_SelectCCDMA_1
   1602            }
   1603            else
   1604            {
   1605              /* Reset the CCDS Bit */
   1606              TIMx->CR2 &= CR2_CCDS_Reset;
   \                     ??TIM_SelectCCDMA_0:
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8082             STRH     R2,[R0, #+4]
   1607            }
   1608          }
   \                     ??TIM_SelectCCDMA_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1609          
   1610          /*******************************************************************************
   1611          * Function Name  : TIM_CCPreloadControl
   1612          * Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
   1613          *                  Control bit.
   1614          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1615          *                 - NewState: new state of the Capture Compare Preload Control bit
   1616          *                    This parameter can be: ENABLE or DISABLE.
   1617          * Output         : None
   1618          * Return         : None
   1619          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1620          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1621          { 
   1622            /* Check the parameters */
   1623            assert_param(IS_TIM_18_PERIPH(TIMx));
   1624            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1625          
   1626            if (NewState != DISABLE)
   \                     TIM_CCPreloadControl:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_CCPreloadControl_0
   1627            {
   1628              /* Set the CCPC Bit */
   1629              TIMx->CR2 |= CR2_CCPC_Set;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   \   0000000E   0xE004             B.N      ??TIM_CCPreloadControl_1
   1630            }
   1631            else
   1632            {
   1633              /* Reset the CCPC Bit */
   1634              TIMx->CR2 &= CR2_CCPC_Reset;
   \                     ??TIM_CCPreloadControl_0:
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xF64F 0x73FE      MOVW     R3,#+65534
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8082             STRH     R2,[R0, #+4]
   1635            }
   1636          }
   \                     ??TIM_CCPreloadControl_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1637          
   1638          /*******************************************************************************
   1639          * Function Name  : TIM_OC1PreloadConfig
   1640          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
   1641          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1642          *                    peripheral.
   1643          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1644          *                    register
   1645          *                    This parameter can be one of the following values:
   1646          *                       - TIM_OCPreload_Enable
   1647          *                       - TIM_OCPreload_Disable
   1648          * Output         : None
   1649          * Return         : None
   1650          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1651          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1652          {
   1653            u16 tmpccmr1 = 0;
   \                     TIM_OC1PreloadConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1654          
   1655            /* Check the parameters */
   1656            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1657            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1658          
   1659            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1660          
   1661            /* Reset the OC1PE Bit */
   1662            tmpccmr1 &= CCMR_OC13PE_Reset;
   \   00000006   0xF64F 0x73F7      MOVW     R3,#+65527
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1663          
   1664            /* Enable or Disable the Output Compare Preload feature */
   1665            tmpccmr1 |= TIM_OCPreload;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1666          
   1667            /* Write to TIMx CCMR1 register */
   1668            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   1669          }
   \   00000010   0x4770             BX       LR               ;; return
   1670          
   1671          /*******************************************************************************
   1672          * Function Name  : TIM_OC2PreloadConfig
   1673          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1674          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1675          *                    peripheral.
   1676          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1677          *                    register
   1678          *                    This parameter can be one of the following values:
   1679          *                       - TIM_OCPreload_Enable
   1680          *                       - TIM_OCPreload_Disable
   1681          * Output         : None
   1682          * Return         : None
   1683          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1684          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1685          {
   1686            u16 tmpccmr1 = 0;
   \                     TIM_OC2PreloadConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1687          
   1688            /* Check the parameters */
   1689            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1690            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1691          
   1692            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1693          
   1694            /* Reset the OC2PE Bit */
   1695            tmpccmr1 &= CCMR_OC24PE_Reset;
   \   00000006   0xF24F 0x73FF      MOVW     R3,#+63487
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1696          
   1697            /* Enable or Disable the Output Compare Preload feature */
   1698            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1699          
   1700            /* Write to TIMx CCMR1 register */
   1701            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0x8302             STRH     R2,[R0, #+24]
   1702          }
   \   00000012   0x4770             BX       LR               ;; return
   1703          
   1704          /*******************************************************************************
   1705          * Function Name  : TIM_OC3PreloadConfig
   1706          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1707          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1708          *                    peripheral.
   1709          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1710          *                    register
   1711          *                    This parameter can be one of the following values:
   1712          *                       - TIM_OCPreload_Enable
   1713          *                       - TIM_OCPreload_Disable
   1714          * Output         : None
   1715          * Return         : None
   1716          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1717          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1718          {
   1719            u16 tmpccmr2 = 0;
   \                     TIM_OC3PreloadConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1720          
   1721            /* Check the parameters */
   1722            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1723            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1724          
   1725            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1726          
   1727            /* Reset the OC3PE Bit */
   1728            tmpccmr2 &= CCMR_OC13PE_Reset;
   \   00000006   0xF64F 0x73F7      MOVW     R3,#+65527
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1729          
   1730            /* Enable or Disable the Output Compare Preload feature */
   1731            tmpccmr2 |= TIM_OCPreload;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1732          
   1733            /* Write to TIMx CCMR2 register */
   1734            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   1735          }
   \   00000010   0x4770             BX       LR               ;; return
   1736          
   1737          /*******************************************************************************
   1738          * Function Name  : TIM_OC4PreloadConfig
   1739          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1740          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1741          *                    peripheral.
   1742          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1743          *                    register
   1744          *                    This parameter can be one of the following values:
   1745          *                       - TIM_OCPreload_Enable
   1746          *                       - TIM_OCPreload_Disable
   1747          * Output         : None
   1748          * Return         : None
   1749          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1750          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1751          {
   1752            u16 tmpccmr2 = 0;
   \                     TIM_OC4PreloadConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1753          
   1754            /* Check the parameters */
   1755            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1756            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1757          
   1758            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1759          
   1760            /* Reset the OC4PE Bit */
   1761            tmpccmr2 &= CCMR_OC24PE_Reset;
   \   00000006   0xF24F 0x73FF      MOVW     R3,#+63487
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1762          
   1763            /* Enable or Disable the Output Compare Preload feature */
   1764            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1765          
   1766            /* Write to TIMx CCMR2 register */
   1767            TIMx->CCMR2 = tmpccmr2;
   \   00000010   0x8382             STRH     R2,[R0, #+28]
   1768          }
   \   00000012   0x4770             BX       LR               ;; return
   1769          
   1770          /*******************************************************************************
   1771          * Function Name  : TIM_OC1FastConfig
   1772          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1773          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1774          *                    peripheral.
   1775          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1776          *                    This parameter can be one of the following values:
   1777          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1778          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1779          * Output         : None
   1780          * Return         : None
   1781          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1782          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1783          {
   1784            u16 tmpccmr1 = 0;
   \                     TIM_OC1FastConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1785          
   1786            /* Check the parameters */
   1787            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1788            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1789          
   1790            /* Get the TIMx CCMR1 register value */
   1791            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1792          
   1793            /* Reset the OC1FE Bit */
   1794            tmpccmr1 &= CCMR_OC13FE_Reset;
   \   00000006   0xF64F 0x73FB      MOVW     R3,#+65531
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1795          
   1796            /* Enable or Disable the Output Compare Fast Bit */
   1797            tmpccmr1 |= TIM_OCFast;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1798          
   1799            /* Write to TIMx CCMR1 */
   1800            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   1801          }
   \   00000010   0x4770             BX       LR               ;; return
   1802          
   1803          /*******************************************************************************
   1804          * Function Name  : TIM_OC2FastConfig
   1805          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1806          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1807          *                    peripheral.
   1808          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1809          *                    This parameter can be one of the following values:
   1810          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1811          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1812          * Output         : None
   1813          * Return         : None
   1814          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1815          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1816          {
   1817            u16 tmpccmr1 = 0;
   \                     TIM_OC2FastConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1818          
   1819            /* Check the parameters */
   1820            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1821            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1822          
   1823            /* Get the TIMx CCMR1 register value */
   1824            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1825          
   1826            /* Reset the OC2FE Bit */
   1827            tmpccmr1 &= CCMR_OC24FE_Reset;
   \   00000006   0xF64F 0x33FF      MOVW     R3,#+64511
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1828          
   1829            /* Enable or Disable the Output Compare Fast Bit */
   1830            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1831          
   1832            /* Write to TIMx CCMR1 */
   1833            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0x8302             STRH     R2,[R0, #+24]
   1834          }
   \   00000012   0x4770             BX       LR               ;; return
   1835          
   1836          /*******************************************************************************
   1837          * Function Name  : TIM_OC3FastConfig
   1838          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1839          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1840          *                    peripheral.
   1841          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1842          *                    This parameter can be one of the following values:
   1843          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1844          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1845          * Output         : None
   1846          * Return         : None
   1847          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1848          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1849          {
   1850            u16 tmpccmr2 = 0;
   \                     TIM_OC3FastConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1851          
   1852            /* Check the parameters */
   1853            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1854            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1855          
   1856            /* Get the TIMx CCMR2 register value */
   1857            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1858          
   1859            /* Reset the OC3FE Bit */
   1860            tmpccmr2 &= CCMR_OC13FE_Reset;
   \   00000006   0xF64F 0x73FB      MOVW     R3,#+65531
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1861          
   1862            /* Enable or Disable the Output Compare Fast Bit */
   1863            tmpccmr2 |= TIM_OCFast;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1864          
   1865            /* Write to TIMx CCMR2 */
   1866            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   1867          }
   \   00000010   0x4770             BX       LR               ;; return
   1868          
   1869          /*******************************************************************************
   1870          * Function Name  : TIM_OC4FastConfig
   1871          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1872          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1873          *                    peripheral.
   1874          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1875          *                    This parameter can be one of the following values:
   1876          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1877          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1878          * Output         : None
   1879          * Return         : None
   1880          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1881          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1882          {
   1883            u16 tmpccmr2 = 0;
   \                     TIM_OC4FastConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1884          
   1885            /* Check the parameters */
   1886            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1887            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1888          
   1889            /* Get the TIMx CCMR2 register value */
   1890            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1891          
   1892            /* Reset the OC4FE Bit */
   1893            tmpccmr2 &= CCMR_OC24FE_Reset;
   \   00000006   0xF64F 0x33FF      MOVW     R3,#+64511
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1894          
   1895            /* Enable or Disable the Output Compare Fast Bit */
   1896            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1897          
   1898            /* Write to TIMx CCMR2 */
   1899            TIMx->CCMR2 = tmpccmr2;
   \   00000010   0x8382             STRH     R2,[R0, #+28]
   1900          }
   \   00000012   0x4770             BX       LR               ;; return
   1901          
   1902          /*******************************************************************************
   1903          * Function Name  : TIM_ClearOC1Ref
   1904          * Description    : Clears or safeguards the OCREF1 signal on an external event
   1905          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1906          *                    peripheral.
   1907          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1908          *                    This parameter can be one of the following values:
   1909          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1910          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1911          * Output         : None
   1912          * Return         : None
   1913          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1914          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1915          {
   1916            u16 tmpccmr1 = 0;
   \                     TIM_ClearOC1Ref:
   \   00000000   0x2200             MOVS     R2,#+0
   1917          
   1918            /* Check the parameters */
   1919            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1920            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1921          
   1922            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1923          
   1924            /* Reset the OC1CE Bit */
   1925            tmpccmr1 &= CCMR_OC13CE_Reset;
   \   00000006   0xF64F 0x737F      MOVW     R3,#+65407
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1926          
   1927            /* Enable or Disable the Output Compare Clear Bit */
   1928            tmpccmr1 |= TIM_OCClear;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1929          
   1930            /* Write to TIMx CCMR1 register */
   1931            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   1932          }
   \   00000010   0x4770             BX       LR               ;; return
   1933          
   1934          /*******************************************************************************
   1935          * Function Name  : TIM_ClearOC2Ref
   1936          * Description    : Clears or safeguards the OCREF2 signal on an external event
   1937          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1938          *                    peripheral.
   1939          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1940          *                    This parameter can be one of the following values:
   1941          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1942          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1943          * Output         : None
   1944          * Return         : None
   1945          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1946          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1947          {
   1948            u16 tmpccmr1 = 0;
   \                     TIM_ClearOC2Ref:
   \   00000000   0x2200             MOVS     R2,#+0
   1949          
   1950            /* Check the parameters */
   1951            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1952            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1953          
   1954            tmpccmr1 = TIMx->CCMR1;
   \   00000002   0x8B03             LDRH     R3,[R0, #+24]
   \   00000004   0x001A             MOVS     R2,R3
   1955          
   1956            /* Reset the OC2CE Bit */
   1957            tmpccmr1 &= CCMR_OC24CE_Reset;
   \   00000006   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000008   0x0C52             LSRS     R2,R2,#+17
   1958          
   1959            /* Enable or Disable the Output Compare Clear Bit */
   1960            tmpccmr1 |= (u16)(TIM_OCClear << 8);
   \   0000000A   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   1961          
   1962            /* Write to TIMx CCMR1 register */
   1963            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   1964          }
   \   00000010   0x4770             BX       LR               ;; return
   1965          
   1966          /*******************************************************************************
   1967          * Function Name  : TIM_ClearOC3Ref
   1968          * Description    : Clears or safeguards the OCREF3 signal on an external event
   1969          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1970          *                    peripheral.
   1971          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1972          *                    This parameter can be one of the following values:
   1973          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1974          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1975          * Output         : None
   1976          * Return         : None
   1977          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1978          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1979          {
   1980            u16 tmpccmr2 = 0;
   \                     TIM_ClearOC3Ref:
   \   00000000   0x2200             MOVS     R2,#+0
   1981          
   1982            /* Check the parameters */
   1983            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1984            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1985          
   1986            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   1987          
   1988            /* Reset the OC3CE Bit */
   1989            tmpccmr2 &= CCMR_OC13CE_Reset;
   \   00000006   0xF64F 0x737F      MOVW     R3,#+65407
   \   0000000A   0x401A             ANDS     R2,R3,R2
   1990          
   1991            /* Enable or Disable the Output Compare Clear Bit */
   1992            tmpccmr2 |= TIM_OCClear;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1993          
   1994            /* Write to TIMx CCMR2 register */
   1995            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   1996          }
   \   00000010   0x4770             BX       LR               ;; return
   1997          
   1998          /*******************************************************************************
   1999          * Function Name  : TIM_ClearOC4Ref
   2000          * Description    : Clears or safeguards the OCREF4 signal on an external event
   2001          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   2002          *                    peripheral.
   2003          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   2004          *                    This parameter can be one of the following values:
   2005          *                       - TIM_OCClear_Enable: TIM Output clear enable
   2006          *                       - TIM_OCClear_Disable: TIM Output clear disable
   2007          * Output         : None
   2008          * Return         : None
   2009          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2010          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   2011          {
   2012            u16 tmpccmr2 = 0;
   \                     TIM_ClearOC4Ref:
   \   00000000   0x2200             MOVS     R2,#+0
   2013          
   2014            /* Check the parameters */
   2015            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2016            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   2017          
   2018            tmpccmr2 = TIMx->CCMR2;
   \   00000002   0x8B83             LDRH     R3,[R0, #+28]
   \   00000004   0x001A             MOVS     R2,R3
   2019          
   2020            /* Reset the OC4CE Bit */
   2021            tmpccmr2 &= CCMR_OC24CE_Reset;
   \   00000006   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000008   0x0C52             LSRS     R2,R2,#+17
   2022          
   2023            /* Enable or Disable the Output Compare Clear Bit */
   2024            tmpccmr2 |= (u16)(TIM_OCClear << 8);
   \   0000000A   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   2025          
   2026            /* Write to TIMx CCMR2 register */
   2027            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   2028          }
   \   00000010   0x4770             BX       LR               ;; return
   2029          
   2030          /*******************************************************************************
   2031          * Function Name  : TIM_OC1PolarityConfig
   2032          * Description    : Configures the TIMx channel 1 polarity.
   2033          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2034          *                    peripheral.
   2035          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   2036          *                    This parmeter can be one of the following values:
   2037          *                       - TIM_OCPolarity_High: Output Compare active high
   2038          *                       - TIM_OCPolarity_Low: Output Compare active low
   2039          * Output         : None
   2040          * Return         : None
   2041          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2042          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2043          {
   2044            u16 tmpccer = 0;
   \                     TIM_OC1PolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2045          
   2046            /* Check the parameters */
   2047            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2048            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2049          
   2050            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2051          
   2052            /* Set or Reset the CC1P Bit */
   2053            tmpccer &= CCER_CC1P_Reset;
   \   00000006   0xF64F 0x73FD      MOVW     R3,#+65533
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2054            tmpccer |= TIM_OCPolarity;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   2055          
   2056            /* Write to TIMx CCER register */
   2057            TIMx->CCER = tmpccer;
   \   0000000E   0x8402             STRH     R2,[R0, #+32]
   2058          }
   \   00000010   0x4770             BX       LR               ;; return
   2059          
   2060          /*******************************************************************************
   2061          * Function Name  : TIM_OC1NPolarityConfig
   2062          * Description    : Configures the TIMx Channel 1N polarity.
   2063          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2064          *                  - TIM_OCNPolarity: specifies the OC1N Polarity
   2065          *                    This parmeter can be one of the following values:
   2066          *                       - TIM_OCNPolarity_High: Output Compare active high
   2067          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2068          * Output         : None
   2069          * Return         : None
   2070          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2071          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2072          {
   2073            u16 tmpccer = 0;
   \                     TIM_OC1NPolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2074          
   2075            /* Check the parameters */
   2076            assert_param(IS_TIM_18_PERIPH(TIMx));
   2077            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2078             
   2079            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2080          
   2081            /* Set or Reset the CC1NP Bit */
   2082            tmpccer &= CCER_CC1NP_Reset;
   \   00000006   0xF64F 0x73F7      MOVW     R3,#+65527
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2083            tmpccer |= TIM_OCNPolarity;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   2084          
   2085            /* Write to TIMx CCER register */
   2086            TIMx->CCER = tmpccer;
   \   0000000E   0x8402             STRH     R2,[R0, #+32]
   2087          }
   \   00000010   0x4770             BX       LR               ;; return
   2088          
   2089          /*******************************************************************************
   2090          * Function Name  : TIM_OC2PolarityConfig
   2091          * Description    : Configures the TIMx channel 2 polarity.
   2092          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2093          *                    peripheral.
   2094          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   2095          *                    This parmeter can be one of the following values:
   2096          *                       - TIM_OCPolarity_High: Output Compare active high
   2097          *                       - TIM_OCPolarity_Low: Output Compare active low
   2098          * Output         : None
   2099          * Return         : None
   2100          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2101          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2102          {
   2103            u16 tmpccer = 0;
   \                     TIM_OC2PolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2104          
   2105            /* Check the parameters */
   2106            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2107            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2108          
   2109            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2110          
   2111            /* Set or Reset the CC2P Bit */
   2112            tmpccer &= CCER_CC2P_Reset;
   \   00000006   0xF64F 0x73DF      MOVW     R3,#+65503
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2113            tmpccer |= (u16)(TIM_OCPolarity << 4);
   \   0000000C   0xEA52 0x1201      ORRS     R2,R2,R1, LSL #+4
   2114          
   2115            /* Write to TIMx CCER register */
   2116            TIMx->CCER = tmpccer;
   \   00000010   0x8402             STRH     R2,[R0, #+32]
   2117          }
   \   00000012   0x4770             BX       LR               ;; return
   2118          
   2119          /*******************************************************************************
   2120          * Function Name  : TIM_OC2NPolarityConfig
   2121          * Description    : Configures the TIMx Channel 2N polarity.
   2122          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2123          *                  - TIM_OCNPolarity: specifies the OC2N Polarity
   2124          *                    This parmeter can be one of the following values:
   2125          *                       - TIM_OCNPolarity_High: Output Compare active high
   2126          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2127          * Output         : None
   2128          * Return         : None
   2129          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2130          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2131          {
   2132            u16 tmpccer = 0;
   \                     TIM_OC2NPolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2133          
   2134            /* Check the parameters */
   2135            assert_param(IS_TIM_18_PERIPH(TIMx));
   2136            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2137            
   2138            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2139          
   2140            /* Set or Reset the CC2NP Bit */
   2141            tmpccer &= CCER_CC2NP_Reset;
   \   00000006   0xF64F 0x737F      MOVW     R3,#+65407
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2142            tmpccer |= (u16)(TIM_OCNPolarity << 4);
   \   0000000C   0xEA52 0x1201      ORRS     R2,R2,R1, LSL #+4
   2143          
   2144            /* Write to TIMx CCER register */
   2145            TIMx->CCER = tmpccer;
   \   00000010   0x8402             STRH     R2,[R0, #+32]
   2146          }
   \   00000012   0x4770             BX       LR               ;; return
   2147          
   2148          /*******************************************************************************
   2149          * Function Name  : TIM_OC3PolarityConfig
   2150          * Description    : Configures the TIMx channel 3 polarity.
   2151          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2152          *                    peripheral.
   2153          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   2154          *                    This parmeter can be one of the following values:
   2155          *                       - TIM_OCPolarity_High: Output Compare active high
   2156          *                       - TIM_OCPolarity_Low: Output Compare active low
   2157          * Output         : None
   2158          * Return         : None
   2159          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2160          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2161          {
   2162            u16 tmpccer = 0;
   \                     TIM_OC3PolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2163          
   2164            /* Check the parameters */
   2165            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2166            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2167          
   2168            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2169          
   2170            /* Set or Reset the CC3P Bit */
   2171            tmpccer &= CCER_CC3P_Reset;
   \   00000006   0xF64F 0x53FF      MOVW     R3,#+65023
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2172            tmpccer |= (u16)(TIM_OCPolarity << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   2173          
   2174            /* Write to TIMx CCER register */
   2175            TIMx->CCER = tmpccer;
   \   00000010   0x8402             STRH     R2,[R0, #+32]
   2176          }
   \   00000012   0x4770             BX       LR               ;; return
   2177          
   2178          /*******************************************************************************
   2179          * Function Name  : TIM_OC3NPolarityConfig
   2180          * Description    : Configures the TIMx Channel 3N polarity.
   2181          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2182          *                  - TIM_OCNPolarity: specifies the OC3N Polarity
   2183          *                    This parmeter can be one of the following values:
   2184          *                       - TIM_OCNPolarity_High: Output Compare active high
   2185          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2186          * Output         : None
   2187          * Return         : None
   2188          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2189          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2190          {
   2191            u16 tmpccer = 0;
   \                     TIM_OC3NPolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2192           
   2193            /* Check the parameters */
   2194            assert_param(IS_TIM_18_PERIPH(TIMx));
   2195            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2196              
   2197            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2198          
   2199            /* Set or Reset the CC3NP Bit */
   2200            tmpccer &= CCER_CC3NP_Reset;
   \   00000006   0xF24F 0x73FF      MOVW     R3,#+63487
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2201            tmpccer |= (u16)(TIM_OCNPolarity << 8);
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   2202          
   2203            /* Write to TIMx CCER register */
   2204            TIMx->CCER = tmpccer;
   \   00000010   0x8402             STRH     R2,[R0, #+32]
   2205          }
   \   00000012   0x4770             BX       LR               ;; return
   2206          
   2207          /*******************************************************************************
   2208          * Function Name  : TIM_OC4PolarityConfig
   2209          * Description    : Configures the TIMx channel 4 polarity.
   2210          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2211          *                    peripheral.
   2212          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   2213          *                    This parmeter can be one of the following values:
   2214          *                       - TIM_OCPolarity_High: Output Compare active high
   2215          *                       - TIM_OCPolarity_Low: Output Compare active low
   2216          * Output         : None
   2217          * Return         : None
   2218          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2219          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2220          {
   2221            u16 tmpccer = 0;
   \                     TIM_OC4PolarityConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   2222          
   2223            /* Check the parameters */
   2224            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2225            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2226          
   2227            tmpccer = TIMx->CCER;
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x001A             MOVS     R2,R3
   2228          
   2229            /* Set or Reset the CC4P Bit */
   2230            tmpccer &= CCER_CC4P_Reset;
   \   00000006   0xF64D 0x73FF      MOVW     R3,#+57343
   \   0000000A   0x401A             ANDS     R2,R3,R2
   2231            tmpccer |= (u16)(TIM_OCPolarity << 12);
   \   0000000C   0xEA52 0x3201      ORRS     R2,R2,R1, LSL #+12
   2232          
   2233            /* Write to TIMx CCER register */
   2234            TIMx->CCER = tmpccer;
   \   00000010   0x8402             STRH     R2,[R0, #+32]
   2235          }
   \   00000012   0x4770             BX       LR               ;; return
   2236          
   2237          /*******************************************************************************
   2238          * Function Name  : TIM_CCxCmd
   2239          * Description    : Enables or disables the TIM Capture Compare Channel x.
   2240          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2241          *                    peripheral.
   2242          *                  - TIM_Channel: specifies the TIM Channel
   2243          *                    This parmeter can be one of the following values:
   2244          *                       - TIM_Channel_1: TIM Channel 1
   2245          *                       - TIM_Channel_2: TIM Channel 2
   2246          *                       - TIM_Channel_3: TIM Channel 3
   2247          *                       - TIM_Channel_4: TIM Channel 4
   2248          *                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
   2249          *                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   2250          * Output         : None
   2251          * Return         : None
   2252          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2253          void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
   2254          {
   \                     TIM_CCxCmd:
   \   00000000   0xB410             PUSH     {R4}
   2255            /* Check the parameters */
   2256            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2257            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2258            assert_param(IS_TIM_CCX(TIM_CCx));
   2259          
   2260            /* Reset the CCxE Bit */
   2261            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x8403             STRH     R3,[R0, #+32]
   2262          
   2263            /* Set or reset the CCxE Bit */ 
   2264            TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
   \   0000000C   0x8C03             LDRH     R3,[R0, #+32]
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000010   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x8403             STRH     R3,[R0, #+32]
   2265          }
   \   00000018   0xBC10             POP      {R4}
   \   0000001A   0x4770             BX       LR               ;; return
   2266          
   2267          /*******************************************************************************
   2268          * Function Name  : TIM_CCxNCmd
   2269          * Description    : Enables or disables the TIM Capture Compare Channel xN.
   2270          * Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2271          *                 - TIM_Channel: specifies the TIM Channel
   2272          *                    This parmeter can be one of the following values:
   2273          *                       - TIM_Channel_1: TIM Channel 1
   2274          *                       - TIM_Channel_2: TIM Channel 2
   2275          *                       - TIM_Channel_3: TIM Channel 3
   2276          *                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
   2277          *                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   2278          * Output         : None
   2279          * Return         : None
   2280          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2281          void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
   2282          {
   \                     TIM_CCxNCmd:
   \   00000000   0xB410             PUSH     {R4}
   2283            /* Check the parameters */
   2284            assert_param(IS_TIM_18_PERIPH(TIMx));
   2285            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   2286            assert_param(IS_TIM_CCXN(TIM_CCxN));
   2287          
   2288            /* Reset the CCxNE Bit */
   2289            TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x2404             MOVS     R4,#+4
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x8403             STRH     R3,[R0, #+32]
   2290          
   2291            /* Set or reset the CCxNE Bit */ 
   2292            TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
   \   0000000C   0x8C03             LDRH     R3,[R0, #+32]
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000010   0xFA12 0xF401      LSLS     R4,R2,R1
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x8403             STRH     R3,[R0, #+32]
   2293          }
   \   00000018   0xBC10             POP      {R4}
   \   0000001A   0x4770             BX       LR               ;; return
   2294          
   2295          /*******************************************************************************
   2296          * Function Name  : TIM_SelectOCxM
   2297          * Description    : Selects the TIM Ouput Compare Mode.
   2298          *                  This function disables the selected channel before changing 
   2299          *                  the Ouput Compare Mode. User has to enable this channel using
   2300          *                  TIM_CCxCmd and TIM_CCxNCmd functions.
   2301          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2302          *                    peripheral.
   2303          *                  - TIM_Channel: specifies the TIM Channel
   2304          *                    This parmeter can be one of the following values:
   2305          *                       - TIM_Channel_1: TIM Channel 1
   2306          *                       - TIM_Channel_2: TIM Channel 2
   2307          *                       - TIM_Channel_3: TIM Channel 3
   2308          *                       - TIM_Channel_4: TIM Channel 4
   2309          *                  - TIM_OCMode: specifies the TIM Output Compare Mode.
   2310          *                    This paramter can be one of the following values:
   2311          *                       - TIM_OCMode_Timing
   2312          *                       - TIM_OCMode_Active
   2313          *                       - TIM_OCMode_Toggle
   2314          *                       - TIM_OCMode_PWM1
   2315          *                       - TIM_OCMode_PWM2
   2316          *                       - TIM_ForcedAction_Active
   2317          *                       - TIM_ForcedAction_InActive
   2318          * Output         : None
   2319          * Return         : None
   2320          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2321          void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
   2322          {
   \                     TIM_SelectOCxM:
   \   00000000   0xB430             PUSH     {R4,R5}
   2323            /* Check the parameters */
   2324            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2325            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2326            assert_param(IS_TIM_OCM(TIM_OCMode));
   2327            
   2328            /* Disable the Channel: Reset the CCxE Bit */
   2329            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x8403             STRH     R3,[R0, #+32]
   2330          
   2331            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ.N    ??TIM_SelectOCxM_0
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0x2908             CMP      R1,#+8
   \   00000016   0xD115             BNE.N    ??TIM_SelectOCxM_1
   2332            {
   2333              /* Reset the OCxM bits in the CCMRx register */
   2334              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
   \                     ??TIM_SelectOCxM_0:
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0xEB10 0x0361      ADDS     R3,R0,R1, ASR #+1
   \   0000001E   0x699B             LDR      R3,[R3, #+24]
   \   00000020   0xF64F 0x748F      MOVW     R4,#+65423
   \   00000024   0x4023             ANDS     R3,R4,R3
   \   00000026   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000028   0xEB10 0x0461      ADDS     R4,R0,R1, ASR #+1
   \   0000002C   0x61A3             STR      R3,[R4, #+24]
   2335             
   2336              /* Configure the OCxM bits in the CCMRx register */
   2337              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) |= TIM_OCMode;
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0xEB10 0x0361      ADDS     R3,R0,R1, ASR #+1
   \   00000034   0x699B             LDR      R3,[R3, #+24]
   \   00000036   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000038   0x4313             ORRS     R3,R2,R3
   \   0000003A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003C   0xEB10 0x0461      ADDS     R4,R0,R1, ASR #+1
   \   00000040   0x61A3             STR      R3,[R4, #+24]
   \   00000042   0xE019             B.N      ??TIM_SelectOCxM_2
   2338          
   2339            }
   2340            else
   2341            {
   2342              /* Reset the OCxM bits in the CCMRx register */
   2343              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
   \                     ??TIM_SelectOCxM_1:
   \   00000044   0x1F0B             SUBS     R3,R1,#+4
   \   00000046   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000048   0xEB10 0x0363      ADDS     R3,R0,R3, ASR #+1
   \   0000004C   0x1F0C             SUBS     R4,R1,#+4
   \   0000004E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000050   0xEB10 0x0464      ADDS     R4,R0,R4, ASR #+1
   \   00000054   0x69A4             LDR      R4,[R4, #+24]
   \   00000056   0xF648 0x75FF      MOVW     R5,#+36863
   \   0000005A   0x402C             ANDS     R4,R5,R4
   \   0000005C   0x619C             STR      R4,[R3, #+24]
   2344              
   2345              /* Configure the OCxM bits in the CCMRx register */
   2346              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) |= (u16)(TIM_OCMode << 8);
   \   0000005E   0x1F0B             SUBS     R3,R1,#+4
   \   00000060   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000062   0xEB10 0x0363      ADDS     R3,R0,R3, ASR #+1
   \   00000066   0x1F0C             SUBS     R4,R1,#+4
   \   00000068   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006A   0xEB10 0x0464      ADDS     R4,R0,R4, ASR #+1
   \   0000006E   0x69A4             LDR      R4,[R4, #+24]
   \   00000070   0x0215             LSLS     R5,R2,#+8
   \   00000072   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000074   0x432C             ORRS     R4,R5,R4
   \   00000076   0x619C             STR      R4,[R3, #+24]
   2347            }
   2348          }
   \                     ??TIM_SelectOCxM_2:
   \   00000078   0xBC30             POP      {R4,R5}
   \   0000007A   0x4770             BX       LR               ;; return
   2349          
   2350          /*******************************************************************************
   2351          * Function Name  : TIM_UpdateDisableConfig
   2352          * Description    : Enables or Disables the TIMx Update event.
   2353          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2354          *                  - NewState: new state of the TIMx UDIS bit
   2355          *                    This parameter can be: ENABLE or DISABLE.
   2356          * Output         : None
   2357          * Return         : None
   2358          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2359          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2360          {
   2361            /* Check the parameters */
   2362            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2363            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2364          
   2365            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_UpdateDisableConfig_0
   2366            {
   2367              /* Set the Update Disable Bit */
   2368              TIMx->CR1 |= CR1_UDIS_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??TIM_UpdateDisableConfig_1
   2369            }
   2370            else
   2371            {
   2372              /* Reset the Update Disable Bit */
   2373              TIMx->CR1 &= CR1_UDIS_Reset;
   \                     ??TIM_UpdateDisableConfig_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF240 0x33FD      MOVW     R3,#+1021
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
   2374            }
   2375          }
   \                     ??TIM_UpdateDisableConfig_1:
   \   0000001A   0x4770             BX       LR               ;; return
   2376          
   2377          /*******************************************************************************
   2378          * Function Name  : TIM_UpdateRequestConfig
   2379          * Description    : Configures the TIMx Update Request Interrupt source.
   2380          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2381          *                  - TIM_UpdateSource: specifies the Update source.
   2382          *                    This parameter can be one of the following values:
   2383          *                       - TIM_UpdateSource_Regular
   2384          *                       - TIM_UpdateSource_Global
   2385          * Output         : None
   2386          * Return         : None
   2387          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2388          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   2389          {
   2390            /* Check the parameters */
   2391            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2392            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2393          
   2394            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_UpdateRequestConfig_0
   2395            {
   2396              /* Set the URS Bit */
   2397              TIMx->CR1 |= CR1_URS_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??TIM_UpdateRequestConfig_1
   2398            }
   2399            else
   2400            {
   2401              /* Reset the URS Bit */
   2402              TIMx->CR1 &= CR1_URS_Reset;
   \                     ??TIM_UpdateRequestConfig_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF240 0x33FB      MOVW     R3,#+1019
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
   2403            }
   2404          }
   \                     ??TIM_UpdateRequestConfig_1:
   \   0000001A   0x4770             BX       LR               ;; return
   2405          
   2406          /*******************************************************************************
   2407          * Function Name  : TIM_SelectHallSensor
   2408          * Description    : Enables or disables the TIMxs Hall sensor interface.
   2409          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2410          *                  - NewState: new state of the TIMx Hall sensor interface.
   2411          *                    This parameter can be: ENABLE or DISABLE.
   2412          * Output         : None
   2413          * Return         : None
   2414          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2415          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2416          {
   2417            /* Check the parameters */
   2418            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2419            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2420          
   2421            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??TIM_SelectHallSensor_0
   2422            {
   2423              /* Set the TI1S Bit */
   2424              TIMx->CR2 |= CR2_TI1S_Set;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   \   0000000E   0xE004             B.N      ??TIM_SelectHallSensor_1
   2425            }
   2426            else
   2427            {
   2428              /* Reset the TI1S Bit */
   2429              TIMx->CR2 &= CR2_TI1S_Reset;
   \                     ??TIM_SelectHallSensor_0:
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8082             STRH     R2,[R0, #+4]
   2430            }
   2431          }
   \                     ??TIM_SelectHallSensor_1:
   \   0000001A   0x4770             BX       LR               ;; return
   2432          
   2433          /*******************************************************************************
   2434          * Function Name  : TIM_SelectOnePulseMode
   2435          * Description    : Selects the TIMxs One Pulse Mode.
   2436          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2437          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   2438          *                    This parameter can be one of the following values:
   2439          *                       - TIM_OPMode_Single
   2440          *                       - TIM_OPMode_Repetitive
   2441          * Output         : None
   2442          * Return         : None
   2443          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2444          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   2445          {
   2446            /* Check the parameters */
   2447            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2448            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2449          
   2450            /* Reset the OPM Bit */
   2451            TIMx->CR1 &= CR1_OPM_Reset;
   \                     TIM_SelectOnePulseMode:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF240 0x33F7      MOVW     R3,#+1015
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8002             STRH     R2,[R0, #+0]
   2452          
   2453            /* Configure the OPM Mode */
   2454            TIMx->CR1 |= TIM_OPMode;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
   2455          }
   \   00000010   0x4770             BX       LR               ;; return
   2456          
   2457          /*******************************************************************************
   2458          * Function Name  : TIM_SelectOutputTrigger
   2459          * Description    : Selects the TIMx Trigger Output Mode.
   2460          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2461          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   2462          *                    This paramter can be as follow:
   2463          *                      1/ For TIM1 to TIM8:
   2464          *                       - TIM_TRGOSource_Reset 
   2465          *                       - TIM_TRGOSource_Enable
   2466          *                       - TIM_TRGOSource_Update
   2467          *                      2/ These parameters are available for all TIMx except 
   2468          *                         TIM6 and TIM7:
   2469          *                       - TIM_TRGOSource_OC1
   2470          *                       - TIM_TRGOSource_OC1Ref
   2471          *                       - TIM_TRGOSource_OC2Ref
   2472          *                       - TIM_TRGOSource_OC3Ref
   2473          *                       - TIM_TRGOSource_OC4Ref
   2474          * Output         : None
   2475          * Return         : None
   2476          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2477          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   2478          {
   2479            /* Check the parameters */
   2480            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2481            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2482            assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
   2483          
   2484            /* Reset the MMS Bits */
   2485            TIMx->CR2 &= CR2_MMS_Mask;
   \                     TIM_SelectOutputTrigger:
   \   00000000   0x8882             LDRH     R2,[R0, #+4]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8082             STRH     R2,[R0, #+4]
   2486          
   2487            /* Select the TRGO source */
   2488            TIMx->CR2 |=  TIM_TRGOSource;
   \   0000000A   0x8882             LDRH     R2,[R0, #+4]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8082             STRH     R2,[R0, #+4]
   2489          }
   \   00000010   0x4770             BX       LR               ;; return
   2490          
   2491          /*******************************************************************************
   2492          * Function Name  : TIM_SelectSlaveMode
   2493          * Description    : Selects the TIMx Slave Mode.
   2494          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2495          *                    peripheral.
   2496          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   2497          *                    This paramter can be one of the following values:
   2498          *                       - TIM_SlaveMode_Reset
   2499          *                       - TIM_SlaveMode_Gated
   2500          *                       - TIM_SlaveMode_Trigger
   2501          *                       - TIM_SlaveMode_External1
   2502          * Output         : None
   2503          * Return         : None
   2504          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2505          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   2506          {
   2507            /* Check the parameters */
   2508            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2509            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2510          
   2511            /* Reset the SMS Bits */
   2512            TIMx->SMCR &= SMCR_SMS_Mask;
   \                     TIM_SelectSlaveMode:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x73F8      MOVW     R3,#+65528
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8102             STRH     R2,[R0, #+8]
   2513          
   2514            /* Select the Slave Mode */
   2515            TIMx->SMCR |= TIM_SlaveMode;
   \   0000000A   0x8902             LDRH     R2,[R0, #+8]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8102             STRH     R2,[R0, #+8]
   2516          }
   \   00000010   0x4770             BX       LR               ;; return
   2517          
   2518          /*******************************************************************************
   2519          * Function Name  : TIM_SelectMasterSlaveMode
   2520          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   2521          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2522          *                    peripheral.
   2523          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2524          *                    This paramter can be one of the following values:
   2525          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   2526          *                         current timer and its slaves (through TRGO).
   2527          *                       - TIM_MasterSlaveMode_Disable: No action
   2528          * Output         : None
   2529          * Return         : None
   2530          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2531          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   2532          {
   2533            /* Check the parameters */
   2534            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2535            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2536          
   2537            /* Reset the MSM Bit */
   2538            TIMx->SMCR &= SMCR_MSM_Reset;
   \                     TIM_SelectMasterSlaveMode:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8102             STRH     R2,[R0, #+8]
   2539            
   2540            /* Set or Reset the MSM Bit */
   2541            TIMx->SMCR |= TIM_MasterSlaveMode;
   \   0000000A   0x8902             LDRH     R2,[R0, #+8]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8102             STRH     R2,[R0, #+8]
   2542          }
   \   00000010   0x4770             BX       LR               ;; return
   2543          
   2544          /*******************************************************************************
   2545          * Function Name  : TIM_SetCounter
   2546          * Description    : Sets the TIMx Counter Register value
   2547          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2548          *                  - Counter: specifies the Counter register new value.
   2549          * Output         : None
   2550          * Return         : None
   2551          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2552          void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
   2553          {
   2554            /* Check the parameters */
   2555            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2556          
   2557            /* Set the Counter Register value */
   2558            TIMx->CNT = Counter;
   \                     TIM_SetCounter:
   \   00000000   0x8481             STRH     R1,[R0, #+36]
   2559          }
   \   00000002   0x4770             BX       LR               ;; return
   2560          
   2561          /*******************************************************************************
   2562          * Function Name  : TIM_SetAutoreload
   2563          * Description    : Sets the TIMx Autoreload Register value
   2564          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2565          *                  - Autoreload: specifies the Autoreload register new value.
   2566          * Output         : None
   2567          * Return         : None
   2568          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2569          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   2570          {
   2571            /* Check the parameters */
   2572            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2573          
   2574            /* Set the Autoreload Register value */
   2575            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload:
   \   00000000   0x8581             STRH     R1,[R0, #+44]
   2576          }
   \   00000002   0x4770             BX       LR               ;; return
   2577          
   2578          /*******************************************************************************
   2579          * Function Name  : TIM_SetCompare1
   2580          * Description    : Sets the TIMx Capture Compare1 Register value
   2581          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2582          *                    peripheral.
   2583          *                  - Compare1: specifies the Capture Compare1 register new value.
   2584          * Output         : None
   2585          * Return         : None
   2586          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2587          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   2588          {
   2589            /* Check the parameters */
   2590            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2591          
   2592            /* Set the Capture Compare1 Register value */
   2593            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1:
   \   00000000   0x8681             STRH     R1,[R0, #+52]
   2594          }
   \   00000002   0x4770             BX       LR               ;; return
   2595          
   2596          /*******************************************************************************
   2597          * Function Name  : TIM_SetCompare2
   2598          * Description    : Sets the TIMx Capture Compare2 Register value
   2599          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2600          *                   peripheral.
   2601          *                  - Compare2: specifies the Capture Compare2 register new value.
   2602          * Output         : None
   2603          * Return         : None
   2604          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2605          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   2606          {
   2607            /* Check the parameters */
   2608            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2609          
   2610            /* Set the Capture Compare2 Register value */
   2611            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2:
   \   00000000   0x8701             STRH     R1,[R0, #+56]
   2612          }
   \   00000002   0x4770             BX       LR               ;; return
   2613          
   2614          /*******************************************************************************
   2615          * Function Name  : TIM_SetCompare3
   2616          * Description    : Sets the TIMx Capture Compare3 Register value
   2617          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2618          *                   peripheral.
   2619          *                  - Compare3: specifies the Capture Compare3 register new value.
   2620          * Output         : None
   2621          * Return         : None
   2622          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2623          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   2624          {
   2625            /* Check the parameters */
   2626            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2627          
   2628            /* Set the Capture Compare3 Register value */
   2629            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3:
   \   00000000   0x8781             STRH     R1,[R0, #+60]
   2630          }
   \   00000002   0x4770             BX       LR               ;; return
   2631          
   2632          /*******************************************************************************
   2633          * Function Name  : TIM_SetCompare4
   2634          * Description    : Sets the TIMx Capture Compare4 Register value
   2635          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2636          *                   peripheral.
   2637          *                  - Compare4: specifies the Capture Compare4 register new value.
   2638          * Output         : None
   2639          * Return         : None
   2640          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2641          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   2642          {
   2643            /* Check the parameters */
   2644            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2645          
   2646            /* Set the Capture Compare4 Register value */
   2647            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4:
   \   00000000   0xF8A0 0x1040      STRH     R1,[R0, #+64]
   2648          }
   \   00000004   0x4770             BX       LR               ;; return
   2649          
   2650          /*******************************************************************************
   2651          * Function Name  : TIM_SetIC1Prescaler
   2652          * Description    : Sets the TIMx Input Capture 1 prescaler.
   2653          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2654          *                    peripheral.
   2655          *                  - TIM_ICPSC: specifies the Input Capture1 prescaler
   2656          *                    new value.
   2657          *                    This parameter can be one of the following values:
   2658          *                       - TIM_ICPSC_DIV1: no prescaler
   2659          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2660          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2661          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2662          * Output         : None
   2663          * Return         : None
   2664          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2665          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2666          {
   2667            /* Check the parameters */
   2668            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2669            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2670          
   2671            /* Reset the IC1PSC Bits */
   2672            TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC1Prescaler:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x73F3      MOVW     R3,#+65523
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8302             STRH     R2,[R0, #+24]
   2673          
   2674            /* Set the IC1PSC value */
   2675            TIMx->CCMR1 |= TIM_ICPSC;
   \   0000000A   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
   2676          }
   \   00000010   0x4770             BX       LR               ;; return
   2677          
   2678          /*******************************************************************************
   2679          * Function Name  : TIM_SetIC2Prescaler
   2680          * Description    : Sets the TIMx Input Capture 2 prescaler.
   2681          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2682          *                    peripheral.
   2683          *                  - TIM_ICPSC: specifies the Input Capture2 prescaler
   2684          *                    new value.
   2685          *                    This parameter can be one of the following values:
   2686          *                       - TIM_ICPSC_DIV1: no prescaler
   2687          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2688          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2689          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2690          * Output         : None
   2691          * Return         : None
   2692          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2693          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2694          {
   2695            /* Check the parameters */
   2696            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2697            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2698          
   2699            /* Reset the IC2PSC Bits */
   2700            TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC2Prescaler:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF24F 0x33FF      MOVW     R3,#+62463
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8302             STRH     R2,[R0, #+24]
   2701          
   2702            /* Set the IC2PSC value */
   2703            TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
   \   0000000A   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   00000010   0x8302             STRH     R2,[R0, #+24]
   2704          }
   \   00000012   0x4770             BX       LR               ;; return
   2705          
   2706          /*******************************************************************************
   2707          * Function Name  : TIM_SetIC3Prescaler
   2708          * Description    : Sets the TIMx Input Capture 3 prescaler.
   2709          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2710          *                    peripheral.
   2711          *                  - TIM_ICPSC: specifies the Input Capture3 prescaler
   2712          *                    new value.
   2713          *                    This parameter can be one of the following values:
   2714          *                       - TIM_ICPSC_DIV1: no prescaler
   2715          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2716          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2717          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2718          * Output         : None
   2719          * Return         : None
   2720          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2721          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2722          {
   2723            /* Check the parameters */
   2724            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2725            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2726          
   2727            /* Reset the IC3PSC Bits */
   2728            TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC3Prescaler:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x73F3      MOVW     R3,#+65523
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8382             STRH     R2,[R0, #+28]
   2729          
   2730            /* Set the IC3PSC value */
   2731            TIMx->CCMR2 |= TIM_ICPSC;
   \   0000000A   0x8B82             LDRH     R2,[R0, #+28]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8382             STRH     R2,[R0, #+28]
   2732          }
   \   00000010   0x4770             BX       LR               ;; return
   2733          
   2734          /*******************************************************************************
   2735          * Function Name  : TIM_SetIC4Prescaler
   2736          * Description    : Sets the TIMx Input Capture 4 prescaler.
   2737          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2738          *                    peripheral.
   2739          *                  - TIM_ICPSC: specifies the Input Capture4 prescaler
   2740          *                    new value.
   2741          *                    This parameter can be one of the following values:
   2742          *                      - TIM_ICPSC_DIV1: no prescaler
   2743          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   2744          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   2745          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   2746          * Output         : None
   2747          * Return         : None
   2748          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2749          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2750          {  
   2751            /* Check the parameters */
   2752            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2753            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2754          
   2755            /* Reset the IC4PSC Bits */
   2756            TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC4Prescaler:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF24F 0x33FF      MOVW     R3,#+62463
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8382             STRH     R2,[R0, #+28]
   2757          
   2758            /* Set the IC4PSC value */
   2759            TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
   \   0000000A   0x8B82             LDRH     R2,[R0, #+28]
   \   0000000C   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   00000010   0x8382             STRH     R2,[R0, #+28]
   2760          }
   \   00000012   0x4770             BX       LR               ;; return
   2761          
   2762          /*******************************************************************************
   2763          * Function Name  : TIM_SetClockDivision
   2764          * Description    : Sets the TIMx Clock Division value.
   2765          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2766          *                    peripheral.
   2767          *                  - TIM_CKD: specifies the clock division value.
   2768          *                    This parameter can be one of the following value:
   2769          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   2770          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2771          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2772          * Output         : None
   2773          * Return         : None
   2774          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2775          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   2776          {
   2777            /* Check the parameters */
   2778            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2779            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2780          
   2781            /* Reset the CKD Bits */
   2782            TIMx->CR1 &= CR1_CKD_Mask;
   \                     TIM_SetClockDivision:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x8002             STRH     R2,[R0, #+0]
   2783          
   2784            /* Set the CKD value */
   2785            TIMx->CR1 |= TIM_CKD;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0x430A             ORRS     R2,R1,R2
   \   0000000A   0x8002             STRH     R2,[R0, #+0]
   2786          }
   \   0000000C   0x4770             BX       LR               ;; return
   2787          /*******************************************************************************
   2788          * Function Name  : TIM_GetCapture1
   2789          * Description    : Gets the TIMx Input Capture 1 value.
   2790          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2791          *                   peripheral.
   2792          * Output         : None
   2793          * Return         : Capture Compare 1 Register value.
   2794          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2795          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   2796          {
   2797            /* Check the parameters */
   2798            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2799          
   2800            /* Get the Capture 1 Register value */
   2801            return TIMx->CCR1;
   \                     TIM_GetCapture1:
   \   00000000   0x8E80             LDRH     R0,[R0, #+52]
   \   00000002   0x4770             BX       LR               ;; return
   2802          }
   2803          
   2804          /*******************************************************************************
   2805          * Function Name  : TIM_GetCapture2
   2806          * Description    : Gets the TIMx Input Capture 2 value.
   2807          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2808          *                   peripheral.
   2809          * Output         : None
   2810          * Return         : Capture Compare 2 Register value.
   2811          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2812          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   2813          {
   2814            /* Check the parameters */
   2815            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2816          
   2817            /* Get the Capture 2 Register value */
   2818            return TIMx->CCR2;
   \                     TIM_GetCapture2:
   \   00000000   0x8F00             LDRH     R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2819          }
   2820          
   2821          /*******************************************************************************
   2822          * Function Name  : TIM_GetCapture3
   2823          * Description    : Gets the TIMx Input Capture 3 value.
   2824          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2825          *                   peripheral.
   2826          * Output         : None
   2827          * Return         : Capture Compare 3 Register value.
   2828          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2829          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   2830          {
   2831            /* Check the parameters */
   2832            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
   2833          
   2834            /* Get the Capture 3 Register value */
   2835            return TIMx->CCR3;
   \                     TIM_GetCapture3:
   \   00000000   0x8F80             LDRH     R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   2836          }
   2837          
   2838          /*******************************************************************************
   2839          * Function Name  : TIM_GetCapture4
   2840          * Description    : Gets the TIMx Input Capture 4 value.
   2841          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2842          *                   peripheral.
   2843          * Output         : None
   2844          * Return         : Capture Compare 4 Register value.
   2845          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2846          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   2847          {
   2848            /* Check the parameters */
   2849            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2850          
   2851            /* Get the Capture 4 Register value */
   2852            return TIMx->CCR4;
   \                     TIM_GetCapture4:
   \   00000000   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000004   0x4770             BX       LR               ;; return
   2853          }
   2854          
   2855          /*******************************************************************************
   2856          * Function Name  : TIM_GetCounter
   2857          * Description    : Gets the TIMx Counter value.
   2858          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2859          * Output         : None
   2860          * Return         : Counter Register value.
   2861          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2862          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   2863          {
   2864            /* Check the parameters */
   2865            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2866          
   2867            /* Get the Counter Register value */
   2868            return TIMx->CNT;
   \                     TIM_GetCounter:
   \   00000000   0x8C80             LDRH     R0,[R0, #+36]
   \   00000002   0x4770             BX       LR               ;; return
   2869          }
   2870          
   2871          /*******************************************************************************
   2872          * Function Name  : TIM_GetPrescaler
   2873          * Description    : Gets the TIMx Prescaler value.
   2874          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2875          * Output         : None
   2876          * Return         : Prescaler Register value.
   2877          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2878          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2879          {
   2880            /* Check the parameters */
   2881            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2882          
   2883            /* Get the Prescaler Register value */
   2884            return TIMx->PSC;
   \                     TIM_GetPrescaler:
   \   00000000   0x8D00             LDRH     R0,[R0, #+40]
   \   00000002   0x4770             BX       LR               ;; return
   2885          }
   2886          
   2887          /*******************************************************************************
   2888          * Function Name  : TIM_GetFlagStatus
   2889          * Description    : Checks whether the specified TIM flag is set or not.
   2890          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2891          *                  - TIM_FLAG: specifies the flag to check.
   2892          *                    This parameter can be one of the following values:
   2893          *                       - TIM_FLAG_Update: TIM update Flag
   2894          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2895          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2896          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2897          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2898          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2899          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2900          *                       - TIM_FLAG_Break: TIM Break Flag
   2901          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2902          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2903          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2904          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2905          * Output         : None
   2906          * Return         : The new state of TIM_FLAG (SET or RESET).
   2907          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2908          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2909          { 
   \                     TIM_GetFlagStatus:
   \   00000000   0x0002             MOVS     R2,R0
   2910            ITStatus bitstatus = RESET;  
   \   00000002   0x2000             MOVS     R0,#+0
   2911          
   2912            /* Check the parameters */
   2913            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2914            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2915            assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
   2916            
   2917            if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
   \   00000004   0x8A13             LDRH     R3,[R2, #+16]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD002             BEQ.N    ??TIM_GetFlagStatus_0
   2918            {
   2919              bitstatus = SET;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??TIM_GetFlagStatus_1
   2920            }
   2921            else
   2922            {
   2923              bitstatus = RESET;
   \                     ??TIM_GetFlagStatus_0:
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0018             MOVS     R0,R3
   2924            }
   2925            return bitstatus;
   \                     ??TIM_GetFlagStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
   2926          }
   2927          
   2928          /*******************************************************************************
   2929          * Function Name  : TIM_ClearFlag
   2930          * Description    : Clears the TIMx's pending flags.
   2931          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2932          *                  - TIM_FLAG: specifies the flag bit to clear.
   2933          *                    This parameter can be any combination of the following values:
   2934          *                       - TIM_FLAG_Update: TIM update Flag
   2935          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2936          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2937          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2938          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2939          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2940          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2941          *                       - TIM_FLAG_Break: TIM Break Flag
   2942          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2943          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2944          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2945          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2946          * Output         : None
   2947          * Return         : None
   2948          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2949          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2950          {  
   2951            /* Check the parameters */
   2952            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2953            assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
   2954             
   2955            /* Clear the flags */
   2956            TIMx->SR = (u16)~TIM_FLAG;
   \                     TIM_ClearFlag:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x43CA             MVNS     R2,R1
   \   00000004   0x8202             STRH     R2,[R0, #+16]
   2957          }
   \   00000006   0x4770             BX       LR               ;; return
   2958          
   2959          /*******************************************************************************
   2960          * Function Name  : TIM_GetITStatus
   2961          * Description    : Checks whether the TIM interrupt has occurred or not.
   2962          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2963          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2964          *                    This parameter can be one of the following values:
   2965          *                       - TIM_IT_Update: TIM update Interrupt source
   2966          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2967          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2968          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2969          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2970          *                       - TIM_IT_COM: TIM Commutation Interrupt
   2971          *                         source
   2972          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   2973          *                       - TIM_IT_Break: TIM Break Interrupt source
   2974          * Output         : None
   2975          * Return         : The new state of the TIM_IT(SET or RESET).
   2976          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2977          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2978          {
   \                     TIM_GetITStatus:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   2979            ITStatus bitstatus = RESET;  
   \   00000004   0x2000             MOVS     R0,#+0
   2980            u16 itstatus = 0x0, itenable = 0x0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   2981          
   2982            /* Check the parameters */
   2983            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2984            assert_param(IS_TIM_GET_IT(TIM_IT));
   2985            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   2986             
   2987            itstatus = TIMx->SR & TIM_IT;
   \   0000000A   0x8A15             LDRH     R5,[R2, #+16]
   \   0000000C   0x400D             ANDS     R5,R1,R5
   \   0000000E   0x002B             MOVS     R3,R5
   2988            
   2989            itenable = TIMx->DIER & TIM_IT;
   \   00000010   0x8995             LDRH     R5,[R2, #+12]
   \   00000012   0x400D             ANDS     R5,R1,R5
   \   00000014   0x002C             MOVS     R4,R5
   2990          
   2991            if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
   \   00000016   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xD005             BEQ.N    ??TIM_GetITStatus_0
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD002             BEQ.N    ??TIM_GetITStatus_0
   2992            {
   2993              bitstatus = SET;
   \   00000022   0x2501             MOVS     R5,#+1
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xE001             B.N      ??TIM_GetITStatus_1
   2994            }
   2995            else
   2996            {
   2997              bitstatus = RESET;
   \                     ??TIM_GetITStatus_0:
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0x0028             MOVS     R0,R5
   2998            }
   2999            return bitstatus;
   \                     ??TIM_GetITStatus_1:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
   3000          }
   3001          
   3002          /*******************************************************************************
   3003          * Function Name  : TIM_ClearITPendingBit
   3004          * Description    : Clears the TIMx's interrupt pending bits.
   3005          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   3006          *                  - TIM_IT: specifies the pending bit to clear.
   3007          *                    This parameter can be any combination of the following values:
   3008          *                       - TIM_IT_Update: TIM1 update Interrupt source
   3009          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   3010          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   3011          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   3012          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   3013          *                       - TIM_IT_COM: TIM Commutation Interrupt
   3014          *                         source
   3015          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   3016          *                       - TIM_IT_Break: TIM Break Interrupt source
   3017          * Output         : None
   3018          * Return         : None
   3019          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3020          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   3021          {
   3022            /* Check the parameters */
   3023            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   3024            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   3025          
   3026            /* Clear the IT pending Bit */
   3027            TIMx->SR = (u16)~TIM_IT;
   \                     TIM_ClearITPendingBit:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x43CA             MVNS     R2,R1
   \   00000004   0x8202             STRH     R2,[R0, #+16]
   3028          }
   \   00000006   0x4770             BX       LR               ;; return
   3029          
   3030          /*******************************************************************************
   3031          * Function Name  : TI1_Config
   3032          * Description    : Configure the TI1 as Input.
   3033          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3034          *                    peripheral.
   3035          *                  - TIM_ICPolarity : The Input Polarity.
   3036          *                    This parameter can be one of the following values:
   3037          *                       - TIM_ICPolarity_Rising
   3038          *                       - TIM_ICPolarity_Falling
   3039          *                  - TIM_ICSelection: specifies the input to be used.
   3040          *                    This parameter can be one of the following values:
   3041          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   3042          *                         be connected to IC1.
   3043          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   3044          *                         be connected to IC2.
   3045          *                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
   3046          *                         connected to TRC.
   3047          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3048          *                    This parameter must be a value between 0x00 and 0x0F.
   3049          * Output         : None
   3050          * Return         : None
   3051          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3052          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3053                                 u16 TIM_ICFilter)
   3054          {
   \                     TI1_Config:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3055            u16 tmpccmr1 = 0, tmpccer = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   3056          
   3057            /* Disable the Channel 1: Reset the CC1E Bit */
   3058            TIMx->CCER &= CCER_CC1E_Reset;
   \   00000006   0x8C06             LDRH     R6,[R0, #+32]
   \   00000008   0xF64F 0x77FE      MOVW     R7,#+65534
   \   0000000C   0x403E             ANDS     R6,R7,R6
   \   0000000E   0x8406             STRH     R6,[R0, #+32]
   3059          
   3060            tmpccmr1 = TIMx->CCMR1;
   \   00000010   0x8B06             LDRH     R6,[R0, #+24]
   \   00000012   0x0034             MOVS     R4,R6
   3061            tmpccer = TIMx->CCER;
   \   00000014   0x8C06             LDRH     R6,[R0, #+32]
   \   00000016   0x0035             MOVS     R5,R6
   3062          
   3063            /* Select the Input and set the filter */
   3064            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   \   00000018   0xF64F 0x760C      MOVW     R6,#+65292
   \   0000001C   0x4034             ANDS     R4,R6,R4
   3065            tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   \   0000001E   0xEA52 0x1603      ORRS     R6,R2,R3, LSL #+4
   \   00000022   0x4334             ORRS     R4,R6,R4
   3066          
   3067            /* Select the Polarity and set the CC1E Bit */
   3068            tmpccer &= CCER_CC1P_Reset;
   \   00000024   0xF64F 0x76FD      MOVW     R6,#+65533
   \   00000028   0x4035             ANDS     R5,R6,R5
   3069            tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
   \   0000002A   0xF051 0x0601      ORRS     R6,R1,#0x1
   \   0000002E   0x4335             ORRS     R5,R6,R5
   3070          
   3071            /* Write to TIMx CCMR1 and CCER registers */
   3072            TIMx->CCMR1 = tmpccmr1;
   \   00000030   0x8304             STRH     R4,[R0, #+24]
   3073            TIMx->CCER = tmpccer;
   \   00000032   0x8405             STRH     R5,[R0, #+32]
   3074          }
   \   00000034   0xBCF0             POP      {R4-R7}
   \   00000036   0x4770             BX       LR               ;; return
   3075          
   3076          /*******************************************************************************
   3077          * Function Name  : TI2_Config
   3078          * Description    : Configure the TI2 as Input.
   3079          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3080          *                    peripheral.
   3081          *                  - TIM_ICPolarity : The Input Polarity.
   3082          *                    This parameter can be one of the following values:
   3083          *                       - TIM_ICPolarity_Rising
   3084          *                       - TIM_ICPolarity_Falling
   3085          *                  - TIM_ICSelection: specifies the input to be used.
   3086          *                    This parameter can be one of the following values:
   3087          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   3088          *                         be connected to IC2.
   3089          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   3090          *                         be connected to IC1.
   3091          *                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
   3092          *                         connected to TRC.
   3093          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3094          *                    This parameter must be a value between 0x00 and 0x0F.
   3095          * Output         : None
   3096          * Return         : None
   3097          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3098          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3099                                 u16 TIM_ICFilter)
   3100          {
   \                     TI2_Config:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3101            u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   3102          
   3103            /* Disable the Channel 2: Reset the CC2E Bit */
   3104            TIMx->CCER &= CCER_CC2E_Reset;
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64F 0x7CEF      MOVW     R12,#+65519
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   3105          
   3106            tmpccmr1 = TIMx->CCMR1;
   \   00000014   0x8B07             LDRH     R7,[R0, #+24]
   \   00000016   0x003D             MOVS     R5,R7
   3107            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003E             MOVS     R6,R7
   3108            tmp = (u16)(TIM_ICPolarity << 4);
   \   0000001C   0x010F             LSLS     R7,R1,#+4
   \   0000001E   0x003C             MOVS     R4,R7
   3109          
   3110            /* Select the Input and set the filter */
   3111            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   \   00000020   0xF640 0x47FF      MOVW     R7,#+3327
   \   00000024   0x403D             ANDS     R5,R7,R5
   3112            tmpccmr1 |= (u16)(TIM_ICFilter << 12);
   \   00000026   0xEA55 0x3503      ORRS     R5,R5,R3, LSL #+12
   3113            tmpccmr1 |= (u16)(TIM_ICSelection << 8);
   \   0000002A   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   3114          
   3115            /* Select the Polarity and set the CC2E Bit */
   3116            tmpccer &= CCER_CC2P_Reset;
   \   0000002E   0xF64F 0x77DF      MOVW     R7,#+65503
   \   00000032   0x403E             ANDS     R6,R7,R6
   3117            tmpccer |=  tmp | CCER_CC2E_Set;
   \   00000034   0xF054 0x0710      ORRS     R7,R4,#0x10
   \   00000038   0x433E             ORRS     R6,R7,R6
   3118          
   3119            /* Write to TIMx CCMR1 and CCER registers */
   3120            TIMx->CCMR1 = tmpccmr1 ;
   \   0000003A   0x8305             STRH     R5,[R0, #+24]
   3121            TIMx->CCER = tmpccer;
   \   0000003C   0x8406             STRH     R6,[R0, #+32]
   3122          }
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return
   3123          
   3124          /*******************************************************************************
   3125          * Function Name  : TI3_Config
   3126          * Description    : Configure the TI3 as Input.
   3127          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3128          *                    peripheral.
   3129          *                  - TIM_ICPolarity : The Input Polarity.
   3130          *                    This parameter can be one of the following values:
   3131          *                       - TIM_ICPolarity_Rising
   3132          *                       - TIM_ICPolarity_Falling
   3133          *                  - TIM_ICSelection: specifies the input to be used.
   3134          *                    This parameter can be one of the following values:
   3135          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   3136          *                         be connected to IC3.
   3137          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   3138          *                         be connected to IC4.
   3139          *                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
   3140          *                         connected to TRC.
   3141          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3142          *                    This parameter must be a value between 0x00 and 0x0F.
   3143          * Output         : None
   3144          * Return         : None
   3145          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3146          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3147                                 u16 TIM_ICFilter)
   3148          {
   \                     TI3_Config:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3149            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   3150          
   3151            /* Disable the Channel 3: Reset the CC3E Bit */
   3152            TIMx->CCER &= CCER_CC3E_Reset;
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64F 0x6CFF      MOVW     R12,#+65279
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   3153          
   3154            tmpccmr2 = TIMx->CCMR2;
   \   00000014   0x8B87             LDRH     R7,[R0, #+28]
   \   00000016   0x003E             MOVS     R6,R7
   3155            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003C             MOVS     R4,R7
   3156            tmp = (u16)(TIM_ICPolarity << 8);
   \   0000001C   0x020F             LSLS     R7,R1,#+8
   \   0000001E   0x003D             MOVS     R5,R7
   3157          
   3158            /* Select the Input and set the filter */
   3159            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   \   00000020   0xF64F 0x770C      MOVW     R7,#+65292
   \   00000024   0x403E             ANDS     R6,R7,R6
   3160            tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   \   00000026   0xEA52 0x1703      ORRS     R7,R2,R3, LSL #+4
   \   0000002A   0x433E             ORRS     R6,R7,R6
   3161          
   3162            /* Select the Polarity and set the CC3E Bit */
   3163            tmpccer &= CCER_CC3P_Reset;
   \   0000002C   0xF64F 0x57FF      MOVW     R7,#+65023
   \   00000030   0x403C             ANDS     R4,R7,R4
   3164            tmpccer |= tmp | CCER_CC3E_Set;
   \   00000032   0xF455 0x7780      ORRS     R7,R5,#0x100
   \   00000036   0x433C             ORRS     R4,R7,R4
   3165          
   3166            /* Write to TIMx CCMR2 and CCER registers */
   3167            TIMx->CCMR2 = tmpccmr2;
   \   00000038   0x8386             STRH     R6,[R0, #+28]
   3168            TIMx->CCER = tmpccer;
   \   0000003A   0x8404             STRH     R4,[R0, #+32]
   3169          }
   \   0000003C   0xBCF0             POP      {R4-R7}
   \   0000003E   0x4770             BX       LR               ;; return
   3170          
   3171          /*******************************************************************************
   3172          * Function Name  : TI4_Config
   3173          * Description    : Configure the TI1 as Input.
   3174          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3175          *                    peripheral.
   3176          *                  - TIM_ICPolarity : The Input Polarity.
   3177          *                    This parameter can be one of the following values:
   3178          *                       - TIM_ICPolarity_Rising
   3179          *                       - TIM_ICPolarity_Falling
   3180          *                  - TIM_ICSelection: specifies the input to be used.
   3181          *                    This parameter can be one of the following values:
   3182          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   3183          *                         be connected to IC4.
   3184          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   3185          *                         be connected to IC3.
   3186          *                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
   3187          *                         connected to TRC.
   3188          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3189          *                    This parameter must be a value between 0x00 and 0x0F.
   3190          * Output         : None
   3191          * Return         : None
   3192          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3193          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3194                                 u16 TIM_ICFilter)
   3195          {
   \                     TI4_Config:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3196            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   3197          
   3198            /* Disable the Channel 4: Reset the CC4E Bit */
   3199            TIMx->CCER &= CCER_CC4E_Reset;
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64E 0x7CFF      MOVW     R12,#+61439
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   3200          
   3201            tmpccmr2 = TIMx->CCMR2;
   \   00000014   0x8B87             LDRH     R7,[R0, #+28]
   \   00000016   0x003E             MOVS     R6,R7
   3202            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003C             MOVS     R4,R7
   3203            tmp = (u16)(TIM_ICPolarity << 12);
   \   0000001C   0x030F             LSLS     R7,R1,#+12
   \   0000001E   0x003D             MOVS     R5,R7
   3204          
   3205            /* Select the Input and set the filter */
   3206            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   \   00000020   0xF640 0x47FF      MOVW     R7,#+3327
   \   00000024   0x403E             ANDS     R6,R7,R6
   3207            tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
   \   00000026   0x031F             LSLS     R7,R3,#+12
   \   00000028   0xEA57 0x2702      ORRS     R7,R7,R2, LSL #+8
   \   0000002C   0x433E             ORRS     R6,R7,R6
   3208          
   3209            /* Select the Polarity and set the CC4E Bit */
   3210            tmpccer &= CCER_CC4P_Reset;
   \   0000002E   0xF64D 0x77FF      MOVW     R7,#+57343
   \   00000032   0x403C             ANDS     R4,R7,R4
   3211            tmpccer |= tmp | CCER_CC4E_Set;
   \   00000034   0xF455 0x5780      ORRS     R7,R5,#0x1000
   \   00000038   0x433C             ORRS     R4,R7,R4
   3212          
   3213            /* Write to TIMx CCMR2 and CCER registers */
   3214            TIMx->CCMR2 = tmpccmr2;
   \   0000003A   0x8386             STRH     R6,[R0, #+28]
   3215            TIMx->CCER = tmpccer ;
   \   0000003C   0x8404             STRH     R4,[R0, #+32]
   3216          }
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40001000         DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40001400         DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40013400         DC32     0x40013400
   3217          
   3218          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TI1_Config
      16   TI2_Config
      16   TI3_Config
      16   TI4_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
       4   TIM_CCxCmd
       4   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
      24   TIM_ETRClockMode1Config
        24   -> TIM_ETRConfig
      24   TIM_ETRClockMode2Config
        24   -> TIM_ETRConfig
       8   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       8   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
      16   TIM_ITRxExternalClockConfig
        16   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
      12   TIM_OC1Init
       0   TIM_OC1NPolarityConfig
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
      12   TIM_OC2Init
       0   TIM_OC2NPolarityConfig
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
      12   TIM_OC3Init
       0   TIM_OC3NPolarityConfig
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
      12   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
       8   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      24   TIM_TIxExternalClockConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SelectInputTrigger
       4   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
      56  TI1_Config
      66  TI2_Config
      64  TI3_Config
      66  TI4_Config
      28  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      28  TIM_CCPreloadControl
      28  TIM_CCxCmd
      28  TIM_CCxNCmd
       8  TIM_ClearFlag
       8  TIM_ClearITPendingBit
      18  TIM_ClearOC1Ref
      18  TIM_ClearOC2Ref
      18  TIM_ClearOC3Ref
      18  TIM_ClearOC4Ref
      28  TIM_Cmd
      18  TIM_CounterModeConfig
      34  TIM_CtrlPWMOutputs
      22  TIM_DMACmd
      10  TIM_DMAConfig
     210  TIM_DeInit
      70  TIM_ETRClockMode1Config
      38  TIM_ETRClockMode2Config
      26  TIM_ETRConfig
      62  TIM_EncoderInterfaceConfig
      18  TIM_ForcedOC1Config
      20  TIM_ForcedOC2Config
      18  TIM_ForcedOC3Config
      20  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
      24  TIM_GetFlagStatus
      50  TIM_GetITStatus
       4  TIM_GetPrescaler
     112  TIM_ICInit
      22  TIM_ICStructInit
      22  TIM_ITConfig
      26  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      18  TIM_OC1FastConfig
     120  TIM_OC1Init
      18  TIM_OC1NPolarityConfig
      18  TIM_OC1PolarityConfig
      18  TIM_OC1PreloadConfig
      20  TIM_OC2FastConfig
     134  TIM_OC2Init
      20  TIM_OC2NPolarityConfig
      20  TIM_OC2PolarityConfig
      20  TIM_OC2PreloadConfig
      18  TIM_OC3FastConfig
     132  TIM_OC3Init
      20  TIM_OC3NPolarityConfig
      20  TIM_OC3PolarityConfig
      18  TIM_OC3PreloadConfig
      20  TIM_OC4FastConfig
      98  TIM_OC4Init
      20  TIM_OC4PolarityConfig
      20  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     140  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      28  TIM_SelectCCDMA
      28  TIM_SelectCOM
      28  TIM_SelectHallSensor
      18  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
     124  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      14  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      70  TIM_TIxExternalClockConfig
      54  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      28  TIM_UpdateDisableConfig
      28  TIM_UpdateRequestConfig

 
 3 004 bytes in section .text
 
 3 004 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:24 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_nvic.c                   #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_nvic.c" -D               #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_nvic.lst           #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_nvic.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_nvic.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the NVIC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_nvic.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          #define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
     22          
     23          /* Private macro -------------------------------------------------------------*/
     24          /* Private variables ---------------------------------------------------------*/
     25          /* Private function prototypes -----------------------------------------------*/
     26          /* Private functions ---------------------------------------------------------*/
     27          
     28          /*******************************************************************************
     29          * Function Name  : NVIC_DeInit
     30          * Description    : Deinitializes the NVIC peripheral registers to their default
     31          *                  reset values.
     32          * Input          : None
     33          * Output         : None
     34          * Return         : None
     35          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          void NVIC_DeInit(void)
     37          {
     38            u32 index = 0;
   \                     NVIC_DeInit:
   \   00000000   0x2000             MOVS     R0,#+0
     39            
     40            NVIC->ICER[0] = 0xFFFFFFFF;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0xe000e180
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     41            NVIC->ICER[1] = 0xFFFFFFFF;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0xe000e184
   \   00000010   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000014   0x600A             STR      R2,[R1, #+0]
     42            NVIC->ICER[2] = 0x0000000F;  
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0xe000e188
   \   0000001A   0x220F             MOVS     R2,#+15
   \   0000001C   0x600A             STR      R2,[R1, #+0]
     43            NVIC->ICPR[0] = 0xFFFFFFFF;
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable22_3  ;; 0xe000e280
   \   00000022   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000026   0x600A             STR      R2,[R1, #+0]
     44            NVIC->ICPR[1] = 0xFFFFFFFF;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable22_4  ;; 0xe000e284
   \   0000002C   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000030   0x600A             STR      R2,[R1, #+0]
     45            NVIC->ICPR[2] = 0x0000000F;
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable22_5  ;; 0xe000e288
   \   00000036   0x220F             MOVS     R2,#+15
   \   00000038   0x600A             STR      R2,[R1, #+0]
     46            
     47            for(index = 0; index < 0x11; index++)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x0008             MOVS     R0,R1
   \                     ??NVIC_DeInit_0:
   \   0000003E   0x2811             CMP      R0,#+17
   \   00000040   0xD206             BCS.N    ??NVIC_DeInit_1
     48            {
     49               NVIC->IPR[index] = 0x00000000;
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable22_6  ;; 0xe000e400
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     50            } 
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0xE7F6             B.N      ??NVIC_DeInit_0
     51          }
   \                     ??NVIC_DeInit_1:
   \   00000050   0x4770             BX       LR               ;; return
     52          
     53          /*******************************************************************************
     54          * Function Name  : NVIC_SCBDeInit
     55          * Description    : Deinitializes the SCB peripheral registers to their default 
     56          *                  reset values.
     57          * Input          : None
     58          * Output         : None
     59          * Return         : None
     60          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     61          void NVIC_SCBDeInit(void)
     62          {
     63            u32 index = 0x00;
   \                     NVIC_SCBDeInit:
   \   00000000   0x2000             MOVS     R0,#+0
     64            
     65            SCB->ICSR = 0x0A000000;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable22_7  ;; 0xe000ed04
   \   00000006   0xF05F 0x6220      MOVS     R2,#+167772160
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     66            SCB->VTOR = 0x00000000;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable22_8  ;; 0xe000ed08
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
     67            SCB->AIRCR = AIRCR_VECTKEY_MASK;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable22_9  ;; 0xe000ed0c
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable22_10  ;; 0x5fa0000
   \   0000001C   0x600A             STR      R2,[R1, #+0]
     68            SCB->SCR = 0x00000000;
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable22_11  ;; 0xe000ed10
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x600A             STR      R2,[R1, #+0]
     69            SCB->CCR = 0x00000000;
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable22_12  ;; 0xe000ed14
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x600A             STR      R2,[R1, #+0]
     70            for(index = 0; index < 0x03; index++)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0008             MOVS     R0,R1
   \                     ??NVIC_SCBDeInit_0:
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD206             BCS.N    ??NVIC_SCBDeInit_1
     71            {
     72               SCB->SHPR[index] = 0;
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable22_13  ;; 0xe000ed18
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     73            }
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xE7F6             B.N      ??NVIC_SCBDeInit_0
     74            SCB->SHCSR = 0x00000000;
   \                     ??NVIC_SCBDeInit_1:
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable22_14  ;; 0xe000ed24
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x600A             STR      R2,[R1, #+0]
     75            SCB->CFSR = 0xFFFFFFFF;
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable22_15  ;; 0xe000ed28
   \   00000050   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000054   0x600A             STR      R2,[R1, #+0]
     76            SCB->HFSR = 0xFFFFFFFF;
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable22_16  ;; 0xe000ed2c
   \   0000005A   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000005E   0x600A             STR      R2,[R1, #+0]
     77            SCB->DFSR = 0xFFFFFFFF;
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable22_17  ;; 0xe000ed30
   \   00000064   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000068   0x600A             STR      R2,[R1, #+0]
     78          }
   \   0000006A   0x4770             BX       LR               ;; return
     79          
     80          /*******************************************************************************
     81          * Function Name  : NVIC_PriorityGroupConfig
     82          * Description    : Configures the priority grouping: pre-emption priority
     83          *                  and subpriority.
     84          * Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
     85          *                    length. This parameter can be one of the following values:
     86          *                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     87          *                         4 bits for subpriority
     88          *                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     89          *                         3 bits for subpriority
     90          *                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     91          *                         2 bits for subpriority
     92          *                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     93          *                         1 bits for subpriority
     94          *                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     95          *                         0 bits for subpriority
     96          * Output         : None
     97          * Return         : None
     98          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     99          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
    100          {
    101            /* Check the parameters */
    102            assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
    103            
    104            /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    105            SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
   \                     NVIC_PriorityGroupConfig:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable22_10  ;; 0x5fa0000
   \   00000004   0x4301             ORRS     R1,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable22_9  ;; 0xe000ed0c
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    106          }
   \   0000000C   0x4770             BX       LR               ;; return
    107          
    108          /*******************************************************************************
    109          * Function Name  : NVIC_Init
    110          * Description    : Initializes the NVIC peripheral according to the specified
    111          *                  parameters in the NVIC_InitStruct.
    112          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    113          *                    that contains the configuration information for the
    114          *                    specified NVIC peripheral.
    115          * Output         : None
    116          * Return         : None
    117          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
    119          {
   \                     NVIC_Init:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    120            u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    121            u32 tmppre = 0, tmpsub = 0x0F;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x250F             MOVS     R5,#+15
    122          
    123            /* Check the parameters */
    124            assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
    125            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
    126            assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
    127            assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    128              
    129            if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
   \   0000000C   0x78C6             LDRB     R6,[R0, #+3]
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD03D             BEQ.N    ??NVIC_Init_0
    130            {
    131              /* Compute the Corresponding IRQ Priority --------------------------------*/    
    132              tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable22_9  ;; 0xe000ed0c
   \   00000016   0x6836             LDR      R6,[R6, #+0]
   \   00000018   0xF416 0x66E0      ANDS     R6,R6,#0x700
   \   0000001C   0xF5D6 0x66E0      RSBS     R6,R6,#+1792
   \   00000020   0x0A36             LSRS     R6,R6,#+8
   \   00000022   0x0031             MOVS     R1,R6
    133              tmppre = (0x4 - tmppriority);
   \   00000024   0xF1D1 0x0604      RSBS     R6,R1,#+4
   \   00000028   0x0034             MOVS     R4,R6
    134              tmpsub = tmpsub >> tmppriority;
   \   0000002A   0x40CD             LSRS     R5,R5,R1
    135              
    136              tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
   \   0000002C   0x7846             LDRB     R6,[R0, #+1]
   \   0000002E   0x40A6             LSLS     R6,R6,R4
   \   00000030   0x0031             MOVS     R1,R6
    137              tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
   \   00000032   0x7886             LDRB     R6,[R0, #+2]
   \   00000034   0x402E             ANDS     R6,R5,R6
   \   00000036   0x4331             ORRS     R1,R6,R1
    138          
    139              tmppriority = tmppriority << 0x04;
   \   00000038   0x0109             LSLS     R1,R1,#+4
    140              tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
   \   0000003A   0x7806             LDRB     R6,[R0, #+0]
   \   0000003C   0xF016 0x0603      ANDS     R6,R6,#0x3
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x00F6             LSLS     R6,R6,#+3
   \   00000044   0x40B1             LSLS     R1,R1,R6
    141              
    142              tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
   \   00000046   0x7806             LDRB     R6,[R0, #+0]
   \   00000048   0x10B6             ASRS     R6,R6,#+2
   \   0000004A   0x....             LDR.N    R7,??DataTable22_6  ;; 0xe000e400
   \   0000004C   0xF857 0x6026      LDR      R6,[R7, R6, LSL #+2]
   \   00000050   0x0032             MOVS     R2,R6
    143              tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
   \   00000052   0x26FF             MOVS     R6,#+255
   \   00000054   0x7807             LDRB     R7,[R0, #+0]
   \   00000056   0xF017 0x0703      ANDS     R7,R7,#0x3
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x00FF             LSLS     R7,R7,#+3
   \   0000005E   0x40BE             LSLS     R6,R6,R7
   \   00000060   0x0033             MOVS     R3,R6
    144              tmpreg &= ~tmpmask;
   \   00000062   0x439A             BICS     R2,R2,R3
    145              tmppriority &= tmpmask;  
   \   00000064   0x4019             ANDS     R1,R3,R1
    146              tmpreg |= tmppriority;
   \   00000066   0x430A             ORRS     R2,R1,R2
    147          
    148              NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
   \   00000068   0x7806             LDRB     R6,[R0, #+0]
   \   0000006A   0x10B6             ASRS     R6,R6,#+2
   \   0000006C   0x....             LDR.N    R7,??DataTable22_6  ;; 0xe000e400
   \   0000006E   0xF847 0x2026      STR      R2,[R7, R6, LSL #+2]
    149              
    150              /* Enable the Selected IRQ Channels --------------------------------------*/
    151              NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    152                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
   \   00000072   0x7806             LDRB     R6,[R0, #+0]
   \   00000074   0x1176             ASRS     R6,R6,#+5
   \   00000076   0x....             LDR.N    R7,??DataTable22_18  ;; 0xe000e100
   \   00000078   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000007C   0xF890 0xE000      LDRB     LR,[R0, #+0]
   \   00000080   0xF01E 0x0E1F      ANDS     LR,LR,#0x1F
   \   00000084   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   00000088   0xF847 0xC026      STR      R12,[R7, R6, LSL #+2]
   \   0000008C   0xE00C             B.N      ??NVIC_Init_1
    153            }
    154            else
    155            {
    156              /* Disable the Selected IRQ Channels -------------------------------------*/
    157              NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    158                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
   \                     ??NVIC_Init_0:
   \   0000008E   0x7806             LDRB     R6,[R0, #+0]
   \   00000090   0x1176             ASRS     R6,R6,#+5
   \   00000092   0x....             LDR.N    R7,??DataTable22  ;; 0xe000e180
   \   00000094   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000098   0xF890 0xE000      LDRB     LR,[R0, #+0]
   \   0000009C   0xF01E 0x0E1F      ANDS     LR,LR,#0x1F
   \   000000A0   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   000000A4   0xF847 0xC026      STR      R12,[R7, R6, LSL #+2]
    159            }
    160          }
   \                     ??NVIC_Init_1:
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
    161          
    162          /*******************************************************************************
    163          * Function Name  : NVIC_StructInit
    164          * Description    : Fills each NVIC_InitStruct member with its default value.
    165          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    166          *                    will be initialized.
    167          * Output         : None
    168          * Return         : None
    169          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    170          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    171          {
    172            /* NVIC_InitStruct members default value */
    173            NVIC_InitStruct->NVIC_IRQChannel = 0x00;
   \                     NVIC_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    174            NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    175            NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    176            NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    177          }
   \   00000010   0x4770             BX       LR               ;; return
    178          
    179          /*******************************************************************************
    180          * Function Name  : NVIC_SETPRIMASK
    181          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    182          * Input          : None
    183          * Output         : None
    184          * Return         : None
    185          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    186          void NVIC_SETPRIMASK(void)
    187          {
   \                     NVIC_SETPRIMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    188            __SETPRIMASK();
   \   00000002   0x.... 0x....      BL       __SETPRIMASK
    189          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    190          
    191          /*******************************************************************************
    192          * Function Name  : NVIC_RESETPRIMASK
    193          * Description    : Disables the PRIMASK priority.
    194          * Input          : None
    195          * Output         : None
    196          * Return         : None
    197          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          void NVIC_RESETPRIMASK(void)
    199          {
   \                     NVIC_RESETPRIMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    200            __RESETPRIMASK();
   \   00000002   0x.... 0x....      BL       __RESETPRIMASK
    201          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    202          
    203          /*******************************************************************************
    204          * Function Name  : NVIC_SETFAULTMASK
    205          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    206          * Input          : None
    207          * Output         : None
    208          * Return         : None
    209          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          void NVIC_SETFAULTMASK(void)
    211          {
   \                     NVIC_SETFAULTMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    212            __SETFAULTMASK();
   \   00000002   0x.... 0x....      BL       __SETFAULTMASK
    213          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    214          
    215          /*******************************************************************************
    216          * Function Name  : NVIC_RESETFAULTMASK
    217          * Description    : Disables the FAULTMASK priority.
    218          * Input          : None
    219          * Output         : None
    220          * Return         : None
    221          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    222          void NVIC_RESETFAULTMASK(void)
    223          {
   \                     NVIC_RESETFAULTMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    224            __RESETFAULTMASK();
   \   00000002   0x.... 0x....      BL       __RESETFAULTMASK
    225          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    226          
    227          /*******************************************************************************
    228          * Function Name  : NVIC_BASEPRICONFIG
    229          * Description    : The execution priority can be changed from 15 (lowest 
    230                             configurable priority) to 1. Writing a zero  value will disable 
    231          *                  the mask of execution priority.
    232          * Input          : None
    233          * Output         : None
    234          * Return         : None
    235          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    236          void NVIC_BASEPRICONFIG(u32 NewPriority)
    237          {
   \                     NVIC_BASEPRICONFIG:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    238            /* Check the parameters */
    239            assert_param(IS_NVIC_BASE_PRI(NewPriority));
    240            
    241            __BASEPRICONFIG(NewPriority << 0x04);
   \   00000004   0x0120             LSLS     R0,R4,#+4
   \   00000006   0x.... 0x....      BL       __BASEPRICONFIG
    242          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    243          
    244          /*******************************************************************************
    245          * Function Name  : NVIC_GetBASEPRI
    246          * Description    : Returns the BASEPRI mask value.
    247          * Input          : None
    248          * Output         : None
    249          * Return         : BASEPRI register value
    250          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          u32 NVIC_GetBASEPRI(void)
    252          {
   \                     NVIC_GetBASEPRI:
   \   00000000   0xB580             PUSH     {R7,LR}
    253            return (__GetBASEPRI());
   \   00000002   0x.... 0x....      BL       __GetBASEPRI
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    254          }
    255          
    256          /*******************************************************************************
    257          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    258          * Description    : Returns the current pending IRQ channel identifier.
    259          * Input          : None
    260          * Output         : None
    261          * Return         : Pending IRQ Channel Identifier.
    262          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    263          u16 NVIC_GetCurrentPendingIRQChannel(void)
    264          {
    265            return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
   \                     NVIC_GetCurrentPendingIRQChannel:
   \   00000000   0x....             LDR.N    R0,??DataTable22_7  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0B00             LSRS     R0,R0,#+12
   \   00000006   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000008   0x0D80             LSRS     R0,R0,#+22
   \   0000000A   0x4770             BX       LR               ;; return
    266          }
    267          
    268          /*******************************************************************************
    269          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    270          * Description    : Checks whether the specified IRQ Channel pending bit is set
    271          *                  or not.
    272          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    273          * Output         : None
    274          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    275          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    277          {
   \                     NVIC_GetIRQChannelPendingBitStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    278            ITStatus pendingirqstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    279            u32 tmp = 0x00;
   \   00000006   0x2200             MOVS     R2,#+0
    280            
    281            /* Check the parameters */
    282            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    283            
    284            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xF011 0x041F      ANDS     R4,R1,#0x1F
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0x001A             MOVS     R2,R3
    285          
    286            if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x114B             ASRS     R3,R1,#+5
   \   00000016   0x....             LDR.N    R4,??DataTable22_19  ;; 0xe000e200
   \   00000018   0xF854 0x3023      LDR      R3,[R4, R3, LSL #+2]
   \   0000001C   0x4013             ANDS     R3,R2,R3
   \   0000001E   0x4293             CMP      R3,R2
   \   00000020   0xD102             BNE.N    ??NVIC_GetIRQChannelPendingBitStatus_0
    287            {
    288              pendingirqstatus = SET;
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x0018             MOVS     R0,R3
   \   00000026   0xE001             B.N      ??NVIC_GetIRQChannelPendingBitStatus_1
    289            }
    290            else
    291            {
    292              pendingirqstatus = RESET;
   \                     ??NVIC_GetIRQChannelPendingBitStatus_0:
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x0018             MOVS     R0,R3
    293            }
    294            return pendingirqstatus;
   \                     ??NVIC_GetIRQChannelPendingBitStatus_1:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    295          }
    296          
    297          /*******************************************************************************
    298          * Function Name  : NVIC_SetIRQChannelPendingBit
    299          * Description    : Sets the NVIC’s interrupt pending bit.
    300          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    301          * Output         : None
    302          * Return         : None
    303          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    304          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    305          {
    306            /* Check the parameters */
    307            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    308            
    309            *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
   \                     NVIC_SetIRQChannelPendingBit:
   \   00000000   0x....             LDR.N    R1,??DataTable22_20  ;; 0xe000ef00
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x6008             STR      R0,[R1, #+0]
    310          }
   \   00000006   0x4770             BX       LR               ;; return
    311          
    312          /*******************************************************************************
    313          * Function Name  : NVIC_ClearIRQChannelPendingBit
    314          * Description    : Clears the NVIC’s interrupt pending bit.
    315          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    316          * Output         : None
    317          * Return         : None
    318          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    319          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    320          {
   \                     NVIC_ClearIRQChannelPendingBit:
   \   00000000   0xB410             PUSH     {R4}
    321            /* Check the parameters */
    322            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    323            
    324            NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x1141             ASRS     R1,R0,#+5
   \   00000006   0x....             LDR.N    R2,??DataTable22_3  ;; 0xe000e280
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    325          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    326          
    327          /*******************************************************************************
    328          * Function Name  : NVIC_GetCurrentActiveHandler
    329          * Description    : Returns the current active Handler (IRQ Channel and
    330          *                  SystemHandler) identifier.
    331          * Input          : None
    332          * Output         : None
    333          * Return         : Active Handler Identifier.
    334          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          u16 NVIC_GetCurrentActiveHandler(void)
    336          {
    337            return ((u16)(SCB->ICSR & (u32)0x3FF));
   \                     NVIC_GetCurrentActiveHandler:
   \   00000000   0x....             LDR.N    R0,??DataTable22_7  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000006   0x0D80             LSRS     R0,R0,#+22
   \   00000008   0x4770             BX       LR               ;; return
    338          }
    339          
    340          /*******************************************************************************
    341          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    342          * Description    : Checks whether the specified IRQ Channel active bit is set
    343          *                  or not.
    344          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    345          * Output         : None
    346          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    347          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    349          {
   \                     NVIC_GetIRQChannelActiveBitStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    350            ITStatus activeirqstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    351            u32 tmp = 0x00;
   \   00000006   0x2200             MOVS     R2,#+0
    352          
    353            /* Check the parameters */
    354            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    355            
    356            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xF011 0x041F      ANDS     R4,R1,#0x1F
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0x001A             MOVS     R2,R3
    357          
    358            if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x114B             ASRS     R3,R1,#+5
   \   00000016   0x....             LDR.N    R4,??DataTable22_21  ;; 0xe000e300
   \   00000018   0xF854 0x3023      LDR      R3,[R4, R3, LSL #+2]
   \   0000001C   0x4013             ANDS     R3,R2,R3
   \   0000001E   0x4293             CMP      R3,R2
   \   00000020   0xD102             BNE.N    ??NVIC_GetIRQChannelActiveBitStatus_0
    359            {
    360              activeirqstatus = SET;
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x0018             MOVS     R0,R3
   \   00000026   0xE001             B.N      ??NVIC_GetIRQChannelActiveBitStatus_1
    361            }
    362            else
    363            {
    364              activeirqstatus = RESET;
   \                     ??NVIC_GetIRQChannelActiveBitStatus_0:
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x0018             MOVS     R0,R3
    365            }
    366            return activeirqstatus;
   \                     ??NVIC_GetIRQChannelActiveBitStatus_1:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    367          }
    368          
    369          /*******************************************************************************
    370          * Function Name  : NVIC_GetCPUID
    371          * Description    : Returns the ID number, the version number and the implementation
    372          *                  details of the Cortex-M3 core.
    373          * Input          : None
    374          * Output         : None
    375          * Return         : CPU ID.
    376          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    377          u32 NVIC_GetCPUID(void)
    378          {
    379            return (SCB->CPUID);
   \                     NVIC_GetCPUID:
   \   00000000   0x....             LDR.N    R0,??DataTable22_22  ;; 0xe000ed00
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    380          }
    381          
    382          /*******************************************************************************
    383          * Function Name  : NVIC_SetVectorTable
    384          * Description    : Sets the vector table location and Offset.
    385          * Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
    386          *                    FLASH memory.
    387          *                    This parameter can be one of the following values:
    388          *                       - NVIC_VectTab_RAM
    389          *                       - NVIC_VectTab_FLASH
    390          *                  - Offset: Vector Table base offset field. 
    391          *                            This value must be a multiple of 0x100.
    392          * Output         : None
    393          * Return         : None
    394          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    395          void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
    396          { 
    397            /* Check the parameters */
    398            assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
    399            assert_param(IS_NVIC_OFFSET(Offset));  
    400             
    401            SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
   \                     NVIC_SetVectorTable:
   \   00000000   0x....             LDR.N    R2,??DataTable22_23  ;; 0x1fffff80
   \   00000002   0x400A             ANDS     R2,R2,R1
   \   00000004   0x4302             ORRS     R2,R2,R0
   \   00000006   0x....             LDR.N    R3,??DataTable22_8  ;; 0xe000ed08
   \   00000008   0x601A             STR      R2,[R3, #+0]
    402          }
   \   0000000A   0x4770             BX       LR               ;; return
    403          
    404          /*******************************************************************************
    405          * Function Name  : NVIC_GenerateSystemReset
    406          * Description    : Generates a system reset.
    407          * Input          : None
    408          * Output         : None
    409          * Return         : None
    410          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    411          void NVIC_GenerateSystemReset(void)
    412          {
    413            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
   \                     NVIC_GenerateSystemReset:
   \   00000000   0x....             LDR.N    R0,??DataTable22_9  ;; 0xe000ed0c
   \   00000002   0x....             LDR.N    R1,??DataTable22_24  ;; 0x5fa0004
   \   00000004   0x6001             STR      R1,[R0, #+0]
    414          }
   \   00000006   0x4770             BX       LR               ;; return
    415          
    416          /*******************************************************************************
    417          * Function Name  : NVIC_GenerateCoreReset
    418          * Description    : Generates a Core (Core + NVIC) reset.
    419          * Input          : None
    420          * Output         : None
    421          * Return         : None
    422          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          void NVIC_GenerateCoreReset(void)
    424          {
    425            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
   \                     NVIC_GenerateCoreReset:
   \   00000000   0x....             LDR.N    R0,??DataTable22_9  ;; 0xe000ed0c
   \   00000002   0x....             LDR.N    R1,??DataTable22_25  ;; 0x5fa0001
   \   00000004   0x6001             STR      R1,[R0, #+0]
    426          }
   \   00000006   0x4770             BX       LR               ;; return
    427          
    428          /*******************************************************************************
    429          * Function Name  : NVIC_SystemLPConfig
    430          * Description    : Selects the condition for the system to enter low power mode.
    431          * Input          : - LowPowerMode: Specifies the new mode for the system to enter
    432          *                    low power mode.
    433          *                    This parameter can be one of the following values:
    434          *                       - NVIC_LP_SEVONPEND
    435          *                       - NVIC_LP_SLEEPDEEP
    436          *                       - NVIC_LP_SLEEPONEXIT
    437          *                  - NewState: new state of LP condition.
    438          *                    This parameter can be: ENABLE or DISABLE.
    439          * Output         : None
    440          * Return         : None
    441          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    442          void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_NVIC_LP(LowPowerMode));
    446            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    447            
    448            if (NewState != DISABLE)
   \                     NVIC_SystemLPConfig:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD006             BEQ.N    ??NVIC_SystemLPConfig_0
    449            {
    450              SCB->SCR |= LowPowerMode;
   \   00000006   0x....             LDR.N    R2,??DataTable22_11  ;; 0xe000ed10
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4302             ORRS     R2,R0,R2
   \   0000000E   0x....             LDR.N    R3,??DataTable22_11  ;; 0xe000ed10
   \   00000010   0x601A             STR      R2,[R3, #+0]
   \   00000012   0xE005             B.N      ??NVIC_SystemLPConfig_1
    451            }
    452            else
    453            {
    454              SCB->SCR &= (u32)(~(u32)LowPowerMode);
   \                     ??NVIC_SystemLPConfig_0:
   \   00000014   0x....             LDR.N    R2,??DataTable22_11  ;; 0xe000ed10
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4382             BICS     R2,R2,R0
   \   0000001C   0x....             LDR.N    R3,??DataTable22_11  ;; 0xe000ed10
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    455            }
    456          }
   \                     ??NVIC_SystemLPConfig_1:
   \   00000020   0x4770             BX       LR               ;; return
    457          
    458          /*******************************************************************************
    459          * Function Name  : NVIC_SystemHandlerConfig
    460          * Description    : Enables or disables the specified System Handlers.
    461          * Input          : - SystemHandler: specifies the system handler to be enabled
    462          *                    or disabled.
    463          *                    This parameter can be one of the following values:
    464          *                       - SystemHandler_MemoryManage
    465          *                       - SystemHandler_BusFault
    466          *                       - SystemHandler_UsageFault
    467          *                  - NewState: new state of  specified System Handlers.
    468          *                    This parameter can be: ENABLE or DISABLE.
    469          * Output         : None
    470          * Return         : None
    471          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    472          void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
    473          {
   \                     NVIC_SystemHandlerConfig:
   \   00000000   0xB410             PUSH     {R4}
    474            u32 tmpreg = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    475          
    476            /* Check the parameters */
    477            assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    478            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    479            
    480            tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000A   0x40A3             LSLS     R3,R3,R4
   \   0000000C   0x001A             MOVS     R2,R3
    481          
    482            if (NewState != DISABLE)
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD005             BEQ.N    ??NVIC_SystemHandlerConfig_0
    483            {
    484              SCB->SHCSR |= tmpreg;
   \   00000014   0x....             LDR.N    R3,??DataTable22_14  ;; 0xe000ed24
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x4313             ORRS     R3,R2,R3
   \   0000001A   0x....             LDR.N    R4,??DataTable22_14  ;; 0xe000ed24
   \   0000001C   0x6023             STR      R3,[R4, #+0]
   \   0000001E   0xE004             B.N      ??NVIC_SystemHandlerConfig_1
    485            }
    486            else
    487            {
    488              SCB->SHCSR &= ~tmpreg;
   \                     ??NVIC_SystemHandlerConfig_0:
   \   00000020   0x....             LDR.N    R3,??DataTable22_14  ;; 0xe000ed24
   \   00000022   0x681B             LDR      R3,[R3, #+0]
   \   00000024   0x4393             BICS     R3,R3,R2
   \   00000026   0x....             LDR.N    R4,??DataTable22_14  ;; 0xe000ed24
   \   00000028   0x6023             STR      R3,[R4, #+0]
    489            }
    490          }
   \                     ??NVIC_SystemHandlerConfig_1:
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    491          
    492          /*******************************************************************************
    493          * Function Name  : NVIC_SystemHandlerPriorityConfig
    494          * Description    : Configures the specified System Handlers priority.
    495          * Input          : - SystemHandler: specifies the system handler to be
    496          *                    enabled or disabled.
    497          *                    This parameter can be one of the following values:
    498          *                       - SystemHandler_MemoryManage
    499          *                       - SystemHandler_BusFault
    500          *                       - SystemHandler_UsageFault
    501          *                       - SystemHandler_SVCall
    502          *                       - SystemHandler_DebugMonitor
    503          *                       - SystemHandler_PSV
    504          *                       - SystemHandler_SysTick
    505          *                  - SystemHandlerPreemptionPriority: new priority group of the
    506          *                    specified system handlers.
    507          *                  - SystemHandlerSubPriority: new sub priority of the specified
    508          *                    system handlers.
    509          * Output         : None
    510          * Return         : None
    511          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    512          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    513                                                u8 SystemHandlerSubPriority)
    514          {
   \                     NVIC_SystemHandlerPriorityConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    515            u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x25FF             MOVS     R5,#+255
   \   00000006   0x2400             MOVS     R4,#+0
    516            u32 tmppriority = 0x00;
   \   00000008   0x2600             MOVS     R6,#+0
    517          
    518            /* Check the parameters */
    519            assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
    520            assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    521            assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    522              
    523            tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
   \   0000000A   0x....             LDR.N    R7,??DataTable22_9  ;; 0xe000ed0c
   \   0000000C   0x683F             LDR      R7,[R7, #+0]
   \   0000000E   0xF417 0x67E0      ANDS     R7,R7,#0x700
   \   00000012   0xF5D7 0x67E0      RSBS     R7,R7,#+1792
   \   00000016   0x0A3F             LSRS     R7,R7,#+8
   \   00000018   0x003E             MOVS     R6,R7
    524            tmp1 = (0x4 - tmppriority);
   \   0000001A   0xF1D6 0x0704      RSBS     R7,R6,#+4
   \   0000001E   0x003B             MOVS     R3,R7
    525            tmp2 = tmp2 >> tmppriority;
   \   00000020   0x40F5             LSRS     R5,R5,R6
    526              
    527            tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xFA11 0xF703      LSLS     R7,R1,R3
   \   00000028   0x003E             MOVS     R6,R7
    528            tmppriority |=  SystemHandlerSubPriority & tmp2;
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0xEA15 0x0702      ANDS     R7,R5,R2
   \   00000030   0x433E             ORRS     R6,R7,R6
    529          
    530            tmppriority = tmppriority << 0x04;
   \   00000032   0x0136             LSLS     R6,R6,#+4
    531            tmp1 = SystemHandler & (u32)0xC0;
   \   00000034   0xF010 0x07C0      ANDS     R7,R0,#0xC0
   \   00000038   0x003B             MOVS     R3,R7
    532            tmp1 = tmp1 >> 0x06; 
   \   0000003A   0x099B             LSRS     R3,R3,#+6
    533            tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
   \   0000003C   0xF3C0 0x2701      UBFX     R7,R0,#+8,#+2
   \   00000040   0x003D             MOVS     R5,R7
    534            tmppriority = tmppriority << (tmp2 * 0x08);
   \   00000042   0x002F             MOVS     R7,R5
   \   00000044   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000046   0x00FF             LSLS     R7,R7,#+3
   \   00000048   0x40BE             LSLS     R6,R6,R7
    535            handlermask = (u32)0xFF << (tmp2 * 0x08);
   \   0000004A   0x27FF             MOVS     R7,#+255
   \   0000004C   0x46AC             MOV      R12,R5
   \   0000004E   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000052   0xEA5F 0x0CCC      LSLS     R12,R12,#+3
   \   00000056   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   0000005A   0x003C             MOVS     R4,R7
    536            
    537            SCB->SHPR[tmp1] &= ~handlermask;
   \   0000005C   0x....             LDR.N    R7,??DataTable22_13  ;; 0xe000ed18
   \   0000005E   0xF857 0x7023      LDR      R7,[R7, R3, LSL #+2]
   \   00000062   0x43A7             BICS     R7,R7,R4
   \   00000064   0x.... 0x....      LDR.W    R12,??DataTable22_13  ;; 0xe000ed18
   \   00000068   0xF84C 0x7023      STR      R7,[R12, R3, LSL #+2]
    538            SCB->SHPR[tmp1] |= tmppriority;
   \   0000006C   0x....             LDR.N    R7,??DataTable22_13  ;; 0xe000ed18
   \   0000006E   0xF857 0x7023      LDR      R7,[R7, R3, LSL #+2]
   \   00000072   0x4337             ORRS     R7,R6,R7
   \   00000074   0x.... 0x....      LDR.W    R12,??DataTable22_13  ;; 0xe000ed18
   \   00000078   0xF84C 0x7023      STR      R7,[R12, R3, LSL #+2]
    539          }
   \   0000007C   0xBCF0             POP      {R4-R7}
   \   0000007E   0x4770             BX       LR               ;; return
    540          
    541          /*******************************************************************************
    542          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    543          * Description    : Checks whether the specified System handlers pending bit is
    544          *                  set or not.
    545          * Input          : - SystemHandler: specifies the system handler pending bit to
    546          *                    check.
    547          *                    This parameter can be one of the following values:
    548          *                       - SystemHandler_MemoryManage
    549          *                       - SystemHandler_BusFault
    550          *                       - SystemHandler_SVCall
    551          * Output         : None
    552          * Return         : The new state of System Handler pending bit(SET or RESET).
    553          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    554          ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    555          {
   \                     NVIC_GetSystemHandlerPendingBitStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    556            ITStatus bitstatus  = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    557            u32 tmp = 0x00, tmppos = 0x00;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
    558          
    559            /* Check the parameters */
    560            assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    561            
    562            tmppos = (SystemHandler >> 0x0A);
   \   0000000A   0x0A8C             LSRS     R4,R1,#+10
   \   0000000C   0x0023             MOVS     R3,R4
    563            tmppos &= (u32)0x0F;
   \   0000000E   0xF013 0x030F      ANDS     R3,R3,#0xF
    564          
    565            tmppos = (u32)0x01 << tmppos;
   \   00000012   0x2401             MOVS     R4,#+1
   \   00000014   0xFA14 0xF303      LSLS     R3,R4,R3
    566          
    567            tmp = SCB->SHCSR & tmppos;
   \   00000018   0x....             LDR.N    R4,??DataTable22_14  ;; 0xe000ed24
   \   0000001A   0x6824             LDR      R4,[R4, #+0]
   \   0000001C   0x401C             ANDS     R4,R3,R4
   \   0000001E   0x0022             MOVS     R2,R4
    568          
    569            if (tmp == tmppos)
   \   00000020   0x429A             CMP      R2,R3
   \   00000022   0xD102             BNE.N    ??NVIC_GetSystemHandlerPendingBitStatus_0
    570            {
    571              bitstatus = SET;
   \   00000024   0x2401             MOVS     R4,#+1
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xE001             B.N      ??NVIC_GetSystemHandlerPendingBitStatus_1
    572            }
    573            else
    574            {
    575              bitstatus = RESET;
   \                     ??NVIC_GetSystemHandlerPendingBitStatus_0:
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0x0020             MOVS     R0,R4
    576            }
    577            return bitstatus;
   \                     ??NVIC_GetSystemHandlerPendingBitStatus_1:
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR               ;; return
    578          }
    579          
    580          /*******************************************************************************
    581          * Function Name  : NVIC_SetSystemHandlerPendingBit
    582          * Description    : Sets System Handler pending bit.
    583          * Input          : - SystemHandler: specifies the system handler pending bit
    584          *                    to be set.
    585          *                    This parameter can be one of the following values:
    586          *                       - SystemHandler_NMI
    587          *                       - SystemHandler_PSV
    588          *                       - SystemHandler_SysTick
    589          * Output         : None
    590          * Return         : None
    591          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    592          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    593          {
    594            u32 tmp = 0x00;
   \                     NVIC_SetSystemHandlerPendingBit:
   \   00000000   0x2100             MOVS     R1,#+0
    595          
    596            /* Check the parameters */
    597            assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    598            
    599            /* Get the System Handler pending bit position */
    600            tmp = SystemHandler & (u32)0x1F;
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x0011             MOVS     R1,R2
    601            /* Set the corresponding System Handler pending bit */
    602            SCB->ICSR |= ((u32)0x01 << tmp);
   \   00000008   0x....             LDR.N    R2,??DataTable22_7  ;; 0xe000ed04
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x408B             LSLS     R3,R3,R1
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x....             LDR.N    R3,??DataTable22_7  ;; 0xe000ed04
   \   00000014   0x601A             STR      R2,[R3, #+0]
    603          }
   \   00000016   0x4770             BX       LR               ;; return
    604          
    605          /*******************************************************************************
    606          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    607          * Description    : Clears System Handler pending bit.
    608          * Input          : - SystemHandler: specifies the system handler pending bit to
    609          *                    be clear.
    610          *                    This parameter can be one of the following values:
    611          *                       - SystemHandler_PSV
    612          *                       - SystemHandler_SysTick
    613          * Output         : None
    614          * Return         : None
    615          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    616          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    617          {
   \                     NVIC_ClearSystemHandlerPendingBit:
   \   00000000   0xB410             PUSH     {R4}
    618            u32 tmp = 0x00;
   \   00000002   0x2100             MOVS     R1,#+0
    619          
    620            /* Check the parameters */
    621            assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    622            
    623            /* Get the System Handler pending bit position */
    624            tmp = SystemHandler & (u32)0x1F;
   \   00000004   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000008   0x0011             MOVS     R1,R2
    625            /* Clear the corresponding System Handler pending bit */
    626            SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
   \   0000000A   0x....             LDR.N    R2,??DataTable22_7  ;; 0xe000ed04
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x000C             MOVS     R4,R1
   \   00000012   0x1E64             SUBS     R4,R4,#+1
   \   00000014   0x40A3             LSLS     R3,R3,R4
   \   00000016   0x431A             ORRS     R2,R3,R2
   \   00000018   0x....             LDR.N    R3,??DataTable22_7  ;; 0xe000ed04
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    627          }
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    628          
    629          /*******************************************************************************
    630          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    631          * Description    : Checks whether the specified System handlers active bit is
    632          *                  set or not.
    633          * Input          : - SystemHandler: specifies the system handler active bit to
    634          *                    check.
    635          *                    This parameter can be one of the following values:
    636          *                       - SystemHandler_MemoryManage
    637          *                       - SystemHandler_BusFault
    638          *                       - SystemHandler_UsageFault
    639          *                       - SystemHandler_SVCall
    640          *                       - SystemHandler_DebugMonitor
    641          *                       - SystemHandler_PSV
    642          *                       - SystemHandler_SysTick
    643          * Output         : None
    644          * Return         : The new state of System Handler active bit(SET or RESET).
    645          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    646          ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    647          {
   \                     NVIC_GetSystemHandlerActiveBitStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    648            ITStatus bitstatus  = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    649          
    650            u32 tmp = 0x00, tmppos = 0x00;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
    651          
    652            /* Check the parameters */
    653            assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    654            
    655            tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
   \   0000000A   0xF3C1 0x3483      UBFX     R4,R1,#+14,#+4
   \   0000000E   0x0023             MOVS     R3,R4
    656          
    657            tmppos = (u32)0x01 << tmppos;
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xFA14 0xF303      LSLS     R3,R4,R3
    658          
    659            tmp = SCB->SHCSR & tmppos;
   \   00000016   0x....             LDR.N    R4,??DataTable22_14  ;; 0xe000ed24
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0x401C             ANDS     R4,R3,R4
   \   0000001C   0x0022             MOVS     R2,R4
    660          
    661            if (tmp == tmppos)
   \   0000001E   0x429A             CMP      R2,R3
   \   00000020   0xD102             BNE.N    ??NVIC_GetSystemHandlerActiveBitStatus_0
    662            {
    663              bitstatus = SET;
   \   00000022   0x2401             MOVS     R4,#+1
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xE001             B.N      ??NVIC_GetSystemHandlerActiveBitStatus_1
    664            }
    665            else
    666            {
    667              bitstatus = RESET;
   \                     ??NVIC_GetSystemHandlerActiveBitStatus_0:
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0x0020             MOVS     R0,R4
    668            }
    669            return bitstatus;
   \                     ??NVIC_GetSystemHandlerActiveBitStatus_1:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    670          }
    671          
    672          /*******************************************************************************
    673          * Function Name  : NVIC_GetFaultHandlerSources
    674          * Description    : Returns the system fault handlers sources.
    675          * Input          : - SystemHandler: specifies the system handler to get its fault
    676          *                    sources.
    677          *                    This parameter can be one of the following values:
    678          *                       - SystemHandler_HardFault
    679          *                       - SystemHandler_MemoryManage
    680          *                       - SystemHandler_BusFault
    681          *                       - SystemHandler_UsageFault
    682          *                       - SystemHandler_DebugMonitor
    683          * Output         : None
    684          * Return         : Source of the fault handler.
    685          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    686          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    687          {
   \                     NVIC_GetFaultHandlerSources:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
    688            u32 faultsources = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
    689            u32 tmpreg = 0x00, tmppos = 0x00;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
    690          
    691            /* Check the parameters */
    692            assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    693            
    694            tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
   \   0000000A   0xF3C1 0x4481      UBFX     R4,R1,#+18,#+2
   \   0000000E   0x0022             MOVS     R2,R4
    695            tmppos = (SystemHandler >> 0x14) & (u32)0x03;
   \   00000010   0xF3C1 0x5401      UBFX     R4,R1,#+20,#+2
   \   00000014   0x0023             MOVS     R3,R4
    696          
    697            if (tmpreg == 0x00)
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD103             BNE.N    ??NVIC_GetFaultHandlerSources_0
    698            {
    699              faultsources = SCB->HFSR;
   \   0000001A   0x....             LDR.N    R4,??DataTable22_16  ;; 0xe000ed2c
   \   0000001C   0x6824             LDR      R4,[R4, #+0]
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xE012             B.N      ??NVIC_GetFaultHandlerSources_1
    700            }
    701            else if (tmpreg == 0x01)
   \                     ??NVIC_GetFaultHandlerSources_0:
   \   00000022   0x2A01             CMP      R2,#+1
   \   00000024   0xD10D             BNE.N    ??NVIC_GetFaultHandlerSources_2
    702            {
    703              faultsources = SCB->CFSR >> (tmppos * 0x08);
   \   00000026   0x....             LDR.N    R4,??DataTable22_15  ;; 0xe000ed28
   \   00000028   0x6824             LDR      R4,[R4, #+0]
   \   0000002A   0x001D             MOVS     R5,R3
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x00ED             LSLS     R5,R5,#+3
   \   00000030   0x40EC             LSRS     R4,R4,R5
   \   00000032   0x0020             MOVS     R0,R4
    704              if (tmppos != 0x02)
   \   00000034   0x2B02             CMP      R3,#+2
   \   00000036   0xD002             BEQ.N    ??NVIC_GetFaultHandlerSources_3
    705              {
    706                faultsources &= (u32)0x0F;
   \   00000038   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000003C   0xE004             B.N      ??NVIC_GetFaultHandlerSources_1
    707              }
    708              else
    709              {
    710                faultsources &= (u32)0xFF;
   \                     ??NVIC_GetFaultHandlerSources_3:
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE002             B.N      ??NVIC_GetFaultHandlerSources_1
    711              }
    712            }
    713            else
    714            {
    715              faultsources = SCB->DFSR;
   \                     ??NVIC_GetFaultHandlerSources_2:
   \   00000042   0x....             LDR.N    R4,??DataTable22_17  ;; 0xe000ed30
   \   00000044   0x6824             LDR      R4,[R4, #+0]
   \   00000046   0x0020             MOVS     R0,R4
    716            }
    717            return faultsources;
   \                     ??NVIC_GetFaultHandlerSources_1:
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    718          }
    719          
    720          /*******************************************************************************
    721          * Function Name  : NVIC_GetFaultAddress
    722          * Description    : Returns the address of the location that generated a fault
    723          *                  handler.
    724          * Input          : - SystemHandler: specifies the system handler to get its
    725          *                    fault address.
    726          *                    This parameter can be one of the following values:
    727          *                       - SystemHandler_MemoryManage
    728          *                       - SystemHandler_BusFault
    729          * Output         : None
    730          * Return         : Fault address.
    731          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    732          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    733          {
   \                     NVIC_GetFaultAddress:
   \   00000000   0x0001             MOVS     R1,R0
    734            u32 faultaddress = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
    735            u32 tmp = 0x00;
   \   00000004   0x2200             MOVS     R2,#+0
    736          
    737            /* Check the parameters */
    738            assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    739            
    740            tmp = (SystemHandler >> 0x16) & (u32)0x01;
   \   00000006   0xF3C1 0x5380      UBFX     R3,R1,#+22,#+1
   \   0000000A   0x001A             MOVS     R2,R3
    741          
    742            if (tmp == 0x00)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD103             BNE.N    ??NVIC_GetFaultAddress_0
    743            {
    744              faultaddress = SCB->MMFAR;
   \   00000010   0x....             LDR.N    R3,??DataTable22_26  ;; 0xe000ed34
   \   00000012   0x681B             LDR      R3,[R3, #+0]
   \   00000014   0x0018             MOVS     R0,R3
   \   00000016   0xE002             B.N      ??NVIC_GetFaultAddress_1
    745            }
    746            else
    747            {
    748              faultaddress = SCB->BFAR;
   \                     ??NVIC_GetFaultAddress_0:
   \   00000018   0x....             LDR.N    R3,??DataTable22_27  ;; 0xe000ed38
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0x0018             MOVS     R0,R3
    749            }
    750            return faultaddress;
   \                     ??NVIC_GetFaultAddress_1:
   \   0000001E   0x4770             BX       LR               ;; return
    751          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xE000E184         DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xE000E188         DC32     0xe000e188

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0xE000E284         DC32     0xe000e284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0xE000E288         DC32     0xe000e288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x05FA0000         DC32     0x5fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0xE000ED14         DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0xE000ED24         DC32     0xe000ed24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \   00000000   0xE000ED28         DC32     0xe000ed28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \   00000000   0xE000ED2C         DC32     0xe000ed2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \   00000000   0xE000ED30         DC32     0xe000ed30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \   00000000   0xE000EF00         DC32     0xe000ef00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_21:
   \   00000000   0xE000E300         DC32     0xe000e300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_22:
   \   00000000   0xE000ED00         DC32     0xe000ed00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_23:
   \   00000000   0x1FFFFF80         DC32     0x1fffff80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_24:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_25:
   \   00000000   0x05FA0001         DC32     0x5fa0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_26:
   \   00000000   0xE000ED34         DC32     0xe000ed34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_27:
   \   00000000   0xE000ED38         DC32     0xe000ed38
    752          
    753          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   NVIC_BASEPRICONFIG
         8   -> __BASEPRICONFIG
       4   NVIC_ClearIRQChannelPendingBit
       4   NVIC_ClearSystemHandlerPendingBit
       0   NVIC_DeInit
       0   NVIC_GenerateCoreReset
       0   NVIC_GenerateSystemReset
       8   NVIC_GetBASEPRI
         8   -> __GetBASEPRI
       0   NVIC_GetCPUID
       0   NVIC_GetCurrentActiveHandler
       0   NVIC_GetCurrentPendingIRQChannel
       0   NVIC_GetFaultAddress
       8   NVIC_GetFaultHandlerSources
       4   NVIC_GetIRQChannelActiveBitStatus
       4   NVIC_GetIRQChannelPendingBitStatus
       4   NVIC_GetSystemHandlerActiveBitStatus
       4   NVIC_GetSystemHandlerPendingBitStatus
      20   NVIC_Init
       0   NVIC_PriorityGroupConfig
       8   NVIC_RESETFAULTMASK
         8   -> __RESETFAULTMASK
       8   NVIC_RESETPRIMASK
         8   -> __RESETPRIMASK
       0   NVIC_SCBDeInit
       8   NVIC_SETFAULTMASK
         8   -> __SETFAULTMASK
       8   NVIC_SETPRIMASK
         8   -> __SETPRIMASK
       0   NVIC_SetIRQChannelPendingBit
       0   NVIC_SetSystemHandlerPendingBit
       0   NVIC_SetVectorTable
       0   NVIC_StructInit
       4   NVIC_SystemHandlerConfig
      16   NVIC_SystemHandlerPriorityConfig
       0   NVIC_SystemLPConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_27
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      12  NVIC_BASEPRICONFIG
      24  NVIC_ClearIRQChannelPendingBit
      32  NVIC_ClearSystemHandlerPendingBit
      82  NVIC_DeInit
       8  NVIC_GenerateCoreReset
       8  NVIC_GenerateSystemReset
       8  NVIC_GetBASEPRI
       6  NVIC_GetCPUID
      10  NVIC_GetCurrentActiveHandler
      12  NVIC_GetCurrentPendingIRQChannel
      32  NVIC_GetFaultAddress
      76  NVIC_GetFaultHandlerSources
      50  NVIC_GetIRQChannelActiveBitStatus
      50  NVIC_GetIRQChannelPendingBitStatus
      50  NVIC_GetSystemHandlerActiveBitStatus
      52  NVIC_GetSystemHandlerPendingBitStatus
     170  NVIC_Init
      14  NVIC_PriorityGroupConfig
       8  NVIC_RESETFAULTMASK
       8  NVIC_RESETPRIMASK
     108  NVIC_SCBDeInit
       8  NVIC_SETFAULTMASK
       8  NVIC_SETPRIMASK
       8  NVIC_SetIRQChannelPendingBit
      24  NVIC_SetSystemHandlerPendingBit
      12  NVIC_SetVectorTable
      18  NVIC_StructInit
      46  NVIC_SystemHandlerConfig
     128  NVIC_SystemHandlerPriorityConfig
      34  NVIC_SystemLPConfig

 
 1 218 bytes in section .text
 
 1 218 bytes of CODE memory

Errors: none
Warnings: none

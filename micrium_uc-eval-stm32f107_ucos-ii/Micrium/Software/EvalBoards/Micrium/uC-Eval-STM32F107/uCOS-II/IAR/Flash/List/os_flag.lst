###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_flag.c         #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_flag.c" -D     #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_flag.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_flag.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_flag.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                         EVENT FLAG  MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_FLAG.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #include <ucos_ii.h>
     28          #endif
     29          
     30          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
     31          /*
     32          *********************************************************************************************************
     33          *                                          LOCAL PROTOTYPES
     34          *********************************************************************************************************
     35          */
     36          
     37          static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
     38          static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
     39          
     40          /*$PAGE*/
     41          /*
     42          *********************************************************************************************************
     43          *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
     44          *
     45          * Description: This function is called to check the status of a combination of bits to be set or cleared
     46          *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
     47          *              bits to be set/cleared.
     48          *
     49          *              This call does not block if the desired flags are not present.
     50          *
     51          * Arguments  : pgrp          is a pointer to the desired event flag group.
     52          *
     53          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
     54          *                            The bits you want are specified by setting the corresponding bits in
     55          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
     56          *                            'flags' would contain 0x03.
     57          *
     58          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
     59          *                            to be set/cleared.
     60          *                            You can specify the following argument:
     61          *
     62          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
     63          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
     64          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
     65          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
     66          *
     67          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
     68          *                                  the call.  Example, to wait for any flag in a group AND then clear
     69          *                                  the flags that are present, set 'wait_type' to:
     70          *
     71          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
     72          *
     73          *              perr          is a pointer to an error code and can be:
     74          *                            OS_ERR_NONE               No error
     75          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
     76          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
     77          *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
     78          *                                                      group handle.
     79          *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
     80          *                                                      available.
     81          *
     82          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
     83          *              occurred.
     84          *
     85          * Called from: Task or ISR
     86          *
     87          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
     88          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
     89          *                 event flags.
     90          *********************************************************************************************************
     91          */
     92          
     93          #if OS_FLAG_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     94          OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
     95                                  OS_FLAGS      flags,
     96                                  INT8U         wait_type,
     97                                  INT8U        *perr)
     98          {
   \                     OSFlagAccept:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     99              OS_FLAGS      flags_rdy;
    100              INT8U         result;
    101              BOOLEAN       consume;
    102          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    103              OS_CPU_SR     cpu_sr = 0u;
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    104          #endif
    105          
    106          
    107          
    108          #ifdef OS_SAFETY_CRITICAL
    109              if (perr == (INT8U *)0) {
    110                  OS_SAFETY_CRITICAL_EXCEPTION();
    111                  return ((OS_FLAGS)0);
    112              }
    113          #endif
    114          
    115          #if OS_ARG_CHK_EN > 0u
    116              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    117                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    118                  return ((OS_FLAGS)0);
    119              }
    120          #endif
    121              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD003             BEQ.N    ??OSFlagAccept_0
    122                  *perr = OS_ERR_EVENT_TYPE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7038             STRB     R0,[R7, #+0]
    123                  return ((OS_FLAGS)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE087             B.N      ??OSFlagAccept_1
    124              }
    125              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagAccept_0:
   \   0000001E   0xF016 0x0080      ANDS     R0,R6,#0x80
   \   00000022   0x4681             MOV      R9,R0
    126              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   00000024   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000028   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002C   0xD004             BEQ.N    ??OSFlagAccept_2
    127                  wait_type &= ~OS_FLAG_CONSUME;
   \   0000002E   0xF016 0x067F      ANDS     R6,R6,#0x7F
    128                  consume    = OS_TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4682             MOV      R10,R0
   \   00000036   0xE001             B.N      ??OSFlagAccept_3
    129              } else {
    130                  consume    = OS_FALSE;
   \                     ??OSFlagAccept_2:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4682             MOV      R10,R0
    131              }
    132          /*$PAGE*/
    133              *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
   \                     ??OSFlagAccept_3:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7038             STRB     R0,[R7, #+0]
    134              OS_ENTER_CRITICAL();
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000044   0x4683             MOV      R11,R0
    135              switch (wait_type) {
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD035             BEQ.N    ??OSFlagAccept_4
   \   0000004C   0x2E02             CMP      R6,#+2
   \   0000004E   0xD003             BEQ.N    ??OSFlagAccept_5
   \   00000050   0xD34B             BCC.N    ??OSFlagAccept_6
   \   00000052   0x2E03             CMP      R6,#+3
   \   00000054   0xD018             BEQ.N    ??OSFlagAccept_7
   \   00000056   0xE061             B.N      ??OSFlagAccept_8
    136                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    137                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_5:
   \   00000058   0x8920             LDRH     R0,[R4, #+8]
   \   0000005A   0x4028             ANDS     R0,R5,R0
   \   0000005C   0x4680             MOV      R8,R0
    138                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000005E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0x45A8             CMP      R8,R5
   \   00000066   0xD109             BNE.N    ??OSFlagAccept_9
    139                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000068   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006C   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000070   0xD106             BNE.N    ??OSFlagAccept_10
    140                               pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0xEA30 0x0008      BICS     R0,R0,R8
   \   00000078   0x8120             STRH     R0,[R4, #+8]
   \   0000007A   0xE001             B.N      ??OSFlagAccept_10
    141                           }
    142                       } else {
    143                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_9:
   \   0000007C   0x2070             MOVS     R0,#+112
   \   0000007E   0x7038             STRB     R0,[R7, #+0]
    144                       }
    145                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_10:
   \   00000080   0x4658             MOV      R0,R11
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    146                       break;
   \   00000086   0xE050             B.N      ??OSFlagAccept_11
    147          
    148                  case OS_FLAG_WAIT_SET_ANY:
    149                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_7:
   \   00000088   0x8920             LDRH     R0,[R4, #+8]
   \   0000008A   0x4028             ANDS     R0,R5,R0
   \   0000008C   0x4680             MOV      R8,R0
    150                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
   \   0000008E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD009             BEQ.N    ??OSFlagAccept_12
    151                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000098   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000009C   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000A0   0xD106             BNE.N    ??OSFlagAccept_13
    152                               pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
   \   000000A2   0x8920             LDRH     R0,[R4, #+8]
   \   000000A4   0xEA30 0x0008      BICS     R0,R0,R8
   \   000000A8   0x8120             STRH     R0,[R4, #+8]
   \   000000AA   0xE001             B.N      ??OSFlagAccept_13
    153                           }
    154                       } else {
    155                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_12:
   \   000000AC   0x2070             MOVS     R0,#+112
   \   000000AE   0x7038             STRB     R0,[R7, #+0]
    156                       }
    157                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_13:
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       OS_CPU_SR_Restore
    158                       break;
   \   000000B6   0xE038             B.N      ??OSFlagAccept_11
    159          
    160          #if OS_FLAG_WAIT_CLR_EN > 0u
    161                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    162                       flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
   \                     ??OSFlagAccept_4:
   \   000000B8   0x8920             LDRH     R0,[R4, #+8]
   \   000000BA   0xEA35 0x0000      BICS     R0,R5,R0
   \   000000BE   0x4680             MOV      R8,R0
    163                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   000000C0   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000C4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C6   0x45A8             CMP      R8,R5
   \   000000C8   0xD109             BNE.N    ??OSFlagAccept_14
    164                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000CA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CE   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000D2   0xD106             BNE.N    ??OSFlagAccept_15
    165                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
   \   000000D4   0x8920             LDRH     R0,[R4, #+8]
   \   000000D6   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000000DA   0x8120             STRH     R0,[R4, #+8]
   \   000000DC   0xE001             B.N      ??OSFlagAccept_15
    166                           }
    167                       } else {
    168                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_14:
   \   000000DE   0x2070             MOVS     R0,#+112
   \   000000E0   0x7038             STRB     R0,[R7, #+0]
    169                       }
    170                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_15:
   \   000000E2   0x4658             MOV      R0,R11
   \   000000E4   0x.... 0x....      BL       OS_CPU_SR_Restore
    171                       break;
   \   000000E8   0xE01F             B.N      ??OSFlagAccept_11
    172          
    173                  case OS_FLAG_WAIT_CLR_ANY:
    174                       flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
   \                     ??OSFlagAccept_6:
   \   000000EA   0x8920             LDRH     R0,[R4, #+8]
   \   000000EC   0xEA35 0x0000      BICS     R0,R5,R0
   \   000000F0   0x4680             MOV      R8,R0
    175                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
   \   000000F2   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000F6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000FA   0xD009             BEQ.N    ??OSFlagAccept_16
    176                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000FC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000100   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000104   0xD106             BNE.N    ??OSFlagAccept_17
    177                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
   \   00000106   0x8920             LDRH     R0,[R4, #+8]
   \   00000108   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000010C   0x8120             STRH     R0,[R4, #+8]
   \   0000010E   0xE001             B.N      ??OSFlagAccept_17
    178                           }
    179                       } else {
    180                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_16:
   \   00000110   0x2070             MOVS     R0,#+112
   \   00000112   0x7038             STRB     R0,[R7, #+0]
    181                       }
    182                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_17:
   \   00000114   0x4658             MOV      R0,R11
   \   00000116   0x.... 0x....      BL       OS_CPU_SR_Restore
    183                       break;
   \   0000011A   0xE006             B.N      ??OSFlagAccept_11
    184          #endif
    185          
    186                  default:
    187                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_8:
   \   0000011C   0x4658             MOV      R0,R11
   \   0000011E   0x.... 0x....      BL       OS_CPU_SR_Restore
    188                       flags_rdy = (OS_FLAGS)0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x4680             MOV      R8,R0
    189                       *perr     = OS_ERR_FLAG_WAIT_TYPE;
   \   00000126   0x206F             MOVS     R0,#+111
   \   00000128   0x7038             STRB     R0,[R7, #+0]
    190                       break;
    191              }
    192              return (flags_rdy);
   \                     ??OSFlagAccept_11:
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagAccept_1:
   \   0000012E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    193          }
    194          #endif
    195          
    196          /*$PAGE*/
    197          /*
    198          *********************************************************************************************************
    199          *                                        CREATE AN EVENT FLAG
    200          *
    201          * Description: This function is called to create an event flag group.
    202          *
    203          * Arguments  : flags         Contains the initial value to store in the event flag group.
    204          *
    205          *              perr          is a pointer to an error code which will be returned to your application:
    206          *                               OS_ERR_NONE               if the call was successful.
    207          *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
    208          *                                                         ISR.
    209          *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
    210          *
    211          * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
    212          *
    213          * Called from: Task ONLY
    214          *********************************************************************************************************
    215          */
    216          

   \                                 In section .text, align 2, keep-with-next
    217          OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
    218                                      INT8U    *perr)
    219          {
   \                     OSFlagCreate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    220              OS_FLAG_GRP *pgrp;
    221          #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
    222              OS_CPU_SR    cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
    223          #endif
    224          
    225          
    226          
    227          #ifdef OS_SAFETY_CRITICAL
    228              if (perr == (INT8U *)0) {
    229                  OS_SAFETY_CRITICAL_EXCEPTION();
    230                  return ((OS_FLAG_GRP *)0);
    231              }
    232          #endif
    233          
    234          #ifdef OS_SAFETY_CRITICAL_IEC61508
    235              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    236                  OS_SAFETY_CRITICAL_EXCEPTION();
    237                  return ((OS_FLAG_GRP *)0);
    238              }
    239          #endif
    240          
    241              if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSFlagCreate_0
    242                  *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    243                  return ((OS_FLAG_GRP *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE022             B.N      ??OSFlagCreate_1
    244              }
    245              OS_ENTER_CRITICAL();
   \                     ??OSFlagCreate_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    246              pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0006             MOVS     R6,R0
    247              if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD013             BEQ.N    ??OSFlagCreate_2
    248                                                              /* Adjust free list                                */
    249                  OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6840             LDR      R0,[R0, #+4]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000038   0x6008             STR      R0,[R1, #+0]
    250                  pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
   \   0000003A   0x2005             MOVS     R0,#+5
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    251                  pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
   \   0000003E   0x8134             STRH     R4,[R6, #+8]
    252                  pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6070             STR      R0,[R6, #+4]
    253          #if OS_FLAG_NAME_EN > 0u
    254                  pgrp->OSFlagName     = (INT8U *)(void *)"?";
   \   00000044   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   00000046   0x60F0             STR      R0,[R6, #+12]
    255          #endif
    256                  OS_EXIT_CRITICAL();
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    257                  *perr                = OS_ERR_NONE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7028             STRB     R0,[R5, #+0]
   \   00000052   0xE004             B.N      ??OSFlagCreate_3
    258              } else {
    259                  OS_EXIT_CRITICAL();
   \                     ??OSFlagCreate_2:
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    260                  *perr                = OS_ERR_FLAG_GRP_DEPLETED;
   \   0000005A   0x2072             MOVS     R0,#+114
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
    261              }
    262              return (pgrp);                                  /* Return pointer to event flag group              */
   \                     ??OSFlagCreate_3:
   \   0000005E   0x0030             MOVS     R0,R6
   \                     ??OSFlagCreate_1:
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    263          }
    264          
    265          /*$PAGE*/
    266          /*
    267          *********************************************************************************************************
    268          *                                     DELETE AN EVENT FLAG GROUP
    269          *
    270          * Description: This function deletes an event flag group and readies all tasks pending on the event flag
    271          *              group.
    272          *
    273          * Arguments  : pgrp          is a pointer to the desired event flag group.
    274          *
    275          *              opt           determines delete options as follows:
    276          *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
    277          *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
    278          *                                                    waiting.  In this case, all the tasks pending will be
    279          *                                                    readied.
    280          *
    281          *              perr          is a pointer to an error code that can contain one of the following values:
    282          *                            OS_ERR_NONE               The call was successful and the event flag group was
    283          *                                                      deleted
    284          *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
    285          *                                                      an ISR
    286          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    287          *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
    288          *                            OS_ERR_INVALID_OPT        An invalid option was specified
    289          *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
    290          *                                                      group.
    291          *
    292          * Returns    : pgrp          upon error
    293          *              (OS_EVENT *)0 if the event flag group was successfully deleted.
    294          *
    295          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    296          *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
    297          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    298          *                 time is directly proportional to the number of tasks waiting on the event flag group.
    299          *              3) All tasks that were waiting for the event flag will be readied and returned an 
    300          *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
    301          *********************************************************************************************************
    302          */
    303          
    304          #if OS_FLAG_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    305          OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
    306                                   INT8U         opt,
    307                                   INT8U        *perr)
    308          {
   \                     OSFlagDel:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    309              BOOLEAN       tasks_waiting;
    310              OS_FLAG_NODE *pnode;
    311              OS_FLAG_GRP  *pgrp_return;
    312          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    313              OS_CPU_SR     cpu_sr = 0u;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    314          #endif
    315          
    316          
    317          
    318          #ifdef OS_SAFETY_CRITICAL
    319              if (perr == (INT8U *)0) {
    320                  OS_SAFETY_CRITICAL_EXCEPTION();
    321                  return ((OS_FLAG_GRP *)0);
    322              }
    323          #endif
    324          
    325          #if OS_ARG_CHK_EN > 0u
    326              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    327                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    328                  return (pgrp);
    329              }
    330          #endif
    331              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSFlagDel_0
    332                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000018   0x200F             MOVS     R0,#+15
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    333                  return (pgrp);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xE064             B.N      ??OSFlagDel_1
    334              }
    335              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
   \                     ??OSFlagDel_0:
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD003             BEQ.N    ??OSFlagDel_2
    336                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7030             STRB     R0,[R6, #+0]
    337                  return (pgrp);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xE05D             B.N      ??OSFlagDel_1
    338              }
    339              OS_ENTER_CRITICAL();
   \                     ??OSFlagDel_2:
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000032   0x4682             MOV      R10,R0
    340              if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??OSFlagDel_3
    341                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE001             B.N      ??OSFlagDel_4
    342              } else {
    343                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSFlagDel_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
    344              }
    345              switch (opt) {
   \                     ??OSFlagDel_4:
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD002             BEQ.N    ??OSFlagDel_5
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD01F             BEQ.N    ??OSFlagDel_6
   \   0000004E   0xE045             B.N      ??OSFlagDel_7
    346                  case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
    347                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSFlagDel_5:
   \   00000050   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD114             BNE.N    ??OSFlagDel_8
    348          #if OS_FLAG_NAME_EN > 0u
    349                           pgrp->OSFlagName     = (INT8U *)(void *)"?";
   \   00000056   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   00000058   0x60E0             STR      R0,[R4, #+12]
    350          #endif
    351                           pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7020             STRB     R0,[R4, #+0]
    352                           pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6060             STR      R0,[R4, #+4]
    353                           pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x8120             STRH     R0,[R4, #+8]
    354                           OSFlagFreeList       = pgrp;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000006E   0x6004             STR      R4,[R0, #+0]
    355                           OS_EXIT_CRITICAL();
   \   00000070   0x4650             MOV      R0,R10
   \   00000072   0x.... 0x....      BL       OS_CPU_SR_Restore
    356                           *perr                = OS_ERR_NONE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x7030             STRB     R0,[R6, #+0]
    357                           pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0xE005             B.N      ??OSFlagDel_9
    358                       } else {
    359                           OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_8:
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    360                           *perr                = OS_ERR_TASK_WAITING;
   \   00000086   0x2049             MOVS     R0,#+73
   \   00000088   0x7030             STRB     R0,[R6, #+0]
    361                           pgrp_return          = pgrp;
   \   0000008A   0x46A1             MOV      R9,R4
    362                       }
    363                       break;
   \                     ??OSFlagDel_9:
   \   0000008C   0xE02C             B.N      ??OSFlagDel_10
    364          
    365                  case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
    366                       pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \                     ??OSFlagDel_6:
   \   0000008E   0x6860             LDR      R0,[R4, #+4]
   \   00000090   0x4680             MOV      R8,R0
    367                       while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
   \                     ??OSFlagDel_11:
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD007             BEQ.N    ??OSFlagDel_12
    368                           (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
   \   00000098   0x2202             MOVS     R2,#+2
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       OS_FlagTaskRdy
    369                           pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   000000A2   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   000000A6   0xE7F4             B.N      ??OSFlagDel_11
    370                       }
    371          #if OS_FLAG_NAME_EN > 0u
    372                       pgrp->OSFlagName     = (INT8U *)(void *)"?";
   \                     ??OSFlagDel_12:
   \   000000A8   0x....             ADR.N    R0,??DataTable3  ;; "\?"
   \   000000AA   0x60E0             STR      R0,[R4, #+12]
    373          #endif
    374                       pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x7020             STRB     R0,[R4, #+0]
    375                       pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x6060             STR      R0,[R4, #+4]
    376                       pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x8120             STRH     R0,[R4, #+8]
    377                       OSFlagFreeList       = pgrp;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000C0   0x6004             STR      R4,[R0, #+0]
    378                       OS_EXIT_CRITICAL();
   \   000000C2   0x4650             MOV      R0,R10
   \   000000C4   0x.... 0x....      BL       OS_CPU_SR_Restore
    379                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x2F01             CMP      R7,#+1
   \   000000CC   0xD101             BNE.N    ??OSFlagDel_13
    380                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000CE   0x.... 0x....      BL       OS_Sched
    381                       }
    382                       *perr = OS_ERR_NONE;
   \                     ??OSFlagDel_13:
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x7030             STRB     R0,[R6, #+0]
    383                       pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x4681             MOV      R9,R0
    384                       break;
   \   000000DA   0xE005             B.N      ??OSFlagDel_10
    385          
    386                  default:
    387                       OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_7:
   \   000000DC   0x4650             MOV      R0,R10
   \   000000DE   0x.... 0x....      BL       OS_CPU_SR_Restore
    388                       *perr                = OS_ERR_INVALID_OPT;
   \   000000E2   0x2007             MOVS     R0,#+7
   \   000000E4   0x7030             STRB     R0,[R6, #+0]
    389                       pgrp_return          = pgrp;
   \   000000E6   0x46A1             MOV      R9,R4
    390                       break;
    391              }
    392              return (pgrp_return);
   \                     ??OSFlagDel_10:
   \   000000E8   0x4648             MOV      R0,R9
   \                     ??OSFlagDel_1:
   \   000000EA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    393          }
    394          #endif
    395          /*$PAGE*/
    396          /*
    397          *********************************************************************************************************
    398          *                                 GET THE NAME OF AN EVENT FLAG GROUP
    399          *
    400          * Description: This function is used to obtain the name assigned to an event flag group
    401          *
    402          * Arguments  : pgrp      is a pointer to the event flag group.
    403          *
    404          *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
    405          *                        group.
    406          *
    407          *              perr      is a pointer to an error code that can contain one of the following values:
    408          *
    409          *                        OS_ERR_NONE                if the requested task is resumed
    410          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    411          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    412          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    413          *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
    414          *
    415          * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
    416          *********************************************************************************************************
    417          */
    418          
    419          #if OS_FLAG_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    420          INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
    421                                INT8U        **pname,
    422                                INT8U         *perr)
    423          {
   \                     OSFlagNameGet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    424              INT8U      len;
    425          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    426              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    427          #endif
    428          
    429          
    430          
    431          #ifdef OS_SAFETY_CRITICAL
    432              if (perr == (INT8U *)0) {
    433                  OS_SAFETY_CRITICAL_EXCEPTION();
    434                  return (0u);
    435              }
    436          #endif
    437          
    438          #if OS_ARG_CHK_EN > 0u
    439              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    440                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    441                  return (0u);
    442              }
    443              if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
    444                  *perr = OS_ERR_PNAME_NULL;
    445                  return (0u);
    446              }
    447          #endif
    448              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSFlagNameGet_0
    449                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    450                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE019             B.N      ??OSFlagNameGet_1
    451              }
    452              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameGet_0:
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000024   0x4680             MOV      R8,R0
    453              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD006             BEQ.N    ??OSFlagNameGet_2
    454                  OS_EXIT_CRITICAL();
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
    455                  *perr = OS_ERR_EVENT_TYPE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    456                  return (0u);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE00C             B.N      ??OSFlagNameGet_1
    457              }
    458              *pname = pgrp->OSFlagName;
   \                     ??OSFlagNameGet_2:
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    459              len    = OS_StrLen(*pname);
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      BL       OS_StrLen
   \   00000044   0x0007             MOVS     R7,R0
    460              OS_EXIT_CRITICAL();
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    461              *perr  = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7030             STRB     R0,[R6, #+0]
    462              return (len);
   \   00000050   0x0038             MOVS     R0,R7
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSFlagNameGet_1:
   \   00000054   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    463          }
    464          #endif
    465          
    466          /*$PAGE*/
    467          /*
    468          *********************************************************************************************************
    469          *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
    470          *
    471          * Description: This function assigns a name to an event flag group.
    472          *
    473          * Arguments  : pgrp      is a pointer to the event flag group.
    474          *
    475          *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
    476          *                        group.
    477          *
    478          *              perr      is a pointer to an error code that can contain one of the following values:
    479          *
    480          *                        OS_ERR_NONE                if the requested task is resumed
    481          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    482          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    483          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    484          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    485          *
    486          * Returns    : None
    487          *********************************************************************************************************
    488          */
    489          
    490          #if OS_FLAG_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    491          void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
    492                               INT8U        *pname,
    493                               INT8U        *perr)
    494          {
   \                     OSFlagNameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    495          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    496              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    497          #endif
    498          
    499          
    500          
    501          #ifdef OS_SAFETY_CRITICAL
    502              if (perr == (INT8U *)0) {
    503                  OS_SAFETY_CRITICAL_EXCEPTION();
    504                  return;
    505              }
    506          #endif
    507          
    508          #if OS_ARG_CHK_EN > 0u
    509              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    510                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    511                  return;
    512              }
    513              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    514                  *perr = OS_ERR_PNAME_NULL;
    515                  return;
    516              }
    517          #endif
    518              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??OSFlagNameSet_0
    519                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    520                  return;
   \   00000018   0xE011             B.N      ??OSFlagNameSet_1
    521              }
    522              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameSet_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    523              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD005             BEQ.N    ??OSFlagNameSet_2
    524                  OS_EXIT_CRITICAL();
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    525                  *perr = OS_ERR_EVENT_TYPE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
    526                  return;
   \   00000030   0xE005             B.N      ??OSFlagNameSet_1
    527              }
    528              pgrp->OSFlagName = pname;
   \                     ??OSFlagNameSet_2:
   \   00000032   0x60E5             STR      R5,[R4, #+12]
    529              OS_EXIT_CRITICAL();
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
    530              *perr            = OS_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    531              return;
   \                     ??OSFlagNameSet_1:
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    532          }
    533          #endif
    534          
    535          /*$PAGE*/
    536          /*
    537          *********************************************************************************************************
    538          *                                     WAIT ON AN EVENT FLAG GROUP
    539          *
    540          * Description: This function is called to wait for a combination of bits to be set in an event flag
    541          *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
    542          *
    543          * Arguments  : pgrp          is a pointer to the desired event flag group.
    544          *
    545          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    546          *                            The bits you want are specified by setting the corresponding bits in
    547          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    548          *                            'flags' would contain 0x03.
    549          *
    550          *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
    551          *                            You can specify the following argument:
    552          *
    553          *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
    554          *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
    555          *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
    556          *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
    557          *
    558          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
    559          *                                  the call.  Example, to wait for any flag in a group AND then clear
    560          *                                  the flags that are present, set 'wait_type' to:
    561          *
    562          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
    563          *
    564          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    565          *                            desired bit combination.  If you specify 0, however, your task will wait
    566          *                            forever at the specified event flag group or, until a message arrives.
    567          *
    568          *              perr          is a pointer to an error code and can be:
    569          *                            OS_ERR_NONE               The desired bits have been set within the specified
    570          *                                                      'timeout'.
    571          *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
    572          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    573          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
    574          *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
    575          *                                                      'timeout'.
    576          *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
    577          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
    578          *
    579          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    580          *              occurred.
    581          *
    582          * Called from: Task ONLY
    583          *
    584          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
    585          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
    586          *                 event flags.
    587          *********************************************************************************************************
    588          */
    589          

   \                                 In section .text, align 2, keep-with-next
    590          OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
    591                                OS_FLAGS      flags,
    592                                INT8U         wait_type,
    593                                INT32U        timeout,
    594                                INT8U        *perr)
    595          {
   \                     OSFlagPend:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x001E             MOVS     R6,R3
   \   0000000E   0x9F10             LDR      R7,[SP, #+64]
    596              OS_FLAG_NODE  node;
    597              OS_FLAGS      flags_rdy;
    598              INT8U         result;
    599              INT8U         pend_stat;
    600              BOOLEAN       consume;
    601          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    602              OS_CPU_SR     cpu_sr = 0u;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    603          #endif
    604          
    605          
    606          
    607          #ifdef OS_SAFETY_CRITICAL
    608              if (perr == (INT8U *)0) {
    609                  OS_SAFETY_CRITICAL_EXCEPTION();
    610                  return ((OS_FLAGS)0);
    611              }
    612          #endif
    613          
    614          #if OS_ARG_CHK_EN > 0u
    615              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    616                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    617                  return ((OS_FLAGS)0);
    618              }
    619          #endif
    620              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSFlagPend_0
    621                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7038             STRB     R0,[R7, #+0]
    622                  return ((OS_FLAGS)0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE145             B.N      ??OSFlagPend_1
    623              }
    624              if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
   \                     ??OSFlagPend_0:
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??OSFlagPend_2
    625                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   00000030   0x200D             MOVS     R0,#+13
   \   00000032   0x7038             STRB     R0,[R7, #+0]
    626                  return ((OS_FLAGS)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE13C             B.N      ??OSFlagPend_1
    627              }
    628              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \                     ??OSFlagPend_2:
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2805             CMP      R0,#+5
   \   0000003C   0xD003             BEQ.N    ??OSFlagPend_3
    629                  *perr = OS_ERR_EVENT_TYPE;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7038             STRB     R0,[R7, #+0]
    630                  return ((OS_FLAGS)0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE135             B.N      ??OSFlagPend_1
    631              }
    632              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
   \                     ??OSFlagPend_3:
   \   00000046   0xF01A 0x0080      ANDS     R0,R10,#0x80
   \   0000004A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    633              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   0000004E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD004             BEQ.N    ??OSFlagPend_4
    634                  wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
   \   00000056   0xF01A 0x0A7F      ANDS     R10,R10,#0x7F
    635                  consume    = OS_TRUE;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xE001             B.N      ??OSFlagPend_5
    636              } else {
    637                  consume    = OS_FALSE;
   \                     ??OSFlagPend_4:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x4680             MOV      R8,R0
    638              }
    639          /*$PAGE*/
    640              OS_ENTER_CRITICAL();
   \                     ??OSFlagPend_5:
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000068   0x4681             MOV      R9,R0
    641              switch (wait_type) {
   \   0000006A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000072   0xD05E             BEQ.N    ??OSFlagPend_6
   \   00000074   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000078   0xD005             BEQ.N    ??OSFlagPend_7
   \   0000007A   0xF0C0 0x8086      BCC.W    ??OSFlagPend_8
   \   0000007E   0xF1BA 0x0F03      CMP      R10,#+3
   \   00000082   0xD02B             BEQ.N    ??OSFlagPend_9
   \   00000084   0xE0AD             B.N      ??OSFlagPend_10
    642                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    643                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
   \                     ??OSFlagPend_7:
   \   00000086   0x8920             LDRH     R0,[R4, #+8]
   \   00000088   0x4028             ANDS     R0,R5,R0
   \   0000008A   0x4683             MOV      R11,R0
    644                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000008C   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000090   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000092   0x45AB             CMP      R11,R5
   \   00000094   0xD115             BNE.N    ??OSFlagPend_11
    645                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000009E   0xD103             BNE.N    ??OSFlagPend_12
    646                               pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
   \   000000A0   0x8920             LDRH     R0,[R4, #+8]
   \   000000A2   0xEA30 0x000B      BICS     R0,R0,R11
   \   000000A6   0x8120             STRH     R0,[R4, #+8]
    647                           }
    648                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_12:
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    649                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x.... 0x....      BL       OS_CPU_SR_Restore
    650                           *perr                   = OS_ERR_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7038             STRB     R0,[R7, #+0]
    651                           return (flags_rdy);
   \   000000BC   0x4658             MOV      R0,R11
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0xE0F7             B.N      ??OSFlagPend_1
    652                       } else {                                      /* Block task until events occur or timeout */
    653                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_11:
   \   000000C2   0x9600             STR      R6,[SP, #+0]
   \   000000C4   0x4653             MOV      R3,R10
   \   000000C6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C8   0x002A             MOVS     R2,R5
   \   000000CA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000CC   0xA902             ADD      R1,SP,#+8
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       OS_FlagBlock
    654                           OS_EXIT_CRITICAL();
   \   000000D4   0x4648             MOV      R0,R9
   \   000000D6   0x.... 0x....      BL       OS_CPU_SR_Restore
    655                       }
    656                       break;
   \   000000DA   0xE08C             B.N      ??OSFlagPend_13
    657          
    658                  case OS_FLAG_WAIT_SET_ANY:
    659                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
   \                     ??OSFlagPend_9:
   \   000000DC   0x8920             LDRH     R0,[R4, #+8]
   \   000000DE   0x4028             ANDS     R0,R5,R0
   \   000000E0   0x4683             MOV      R11,R0
    660                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
   \   000000E2   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000E6   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000EA   0xD015             BEQ.N    ??OSFlagPend_14
    661                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   000000EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F0   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000F4   0xD103             BNE.N    ??OSFlagPend_15
    662                               pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
   \   000000F6   0x8920             LDRH     R0,[R4, #+8]
   \   000000F8   0xEA30 0x000B      BICS     R0,R0,R11
   \   000000FC   0x8120             STRH     R0,[R4, #+8]
    663                           }
    664                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_15:
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    665                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   00000108   0x4648             MOV      R0,R9
   \   0000010A   0x.... 0x....      BL       OS_CPU_SR_Restore
    666                           *perr                   = OS_ERR_NONE;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x7038             STRB     R0,[R7, #+0]
    667                           return (flags_rdy);
   \   00000112   0x4658             MOV      R0,R11
   \   00000114   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000116   0xE0CC             B.N      ??OSFlagPend_1
    668                       } else {                                      /* Block task until events occur or timeout */
    669                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_14:
   \   00000118   0x9600             STR      R6,[SP, #+0]
   \   0000011A   0x4653             MOV      R3,R10
   \   0000011C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000011E   0x002A             MOVS     R2,R5
   \   00000120   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000122   0xA902             ADD      R1,SP,#+8
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       OS_FlagBlock
    670                           OS_EXIT_CRITICAL();
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x.... 0x....      BL       OS_CPU_SR_Restore
    671                       }
    672                       break;
   \   00000130   0xE061             B.N      ??OSFlagPend_13
    673          
    674          #if OS_FLAG_WAIT_CLR_EN > 0u
    675                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    676                       flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
   \                     ??OSFlagPend_6:
   \   00000132   0x8920             LDRH     R0,[R4, #+8]
   \   00000134   0xEA35 0x0000      BICS     R0,R5,R0
   \   00000138   0x4683             MOV      R11,R0
    677                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000013A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000013E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000140   0x45AB             CMP      R11,R5
   \   00000142   0xD115             BNE.N    ??OSFlagPend_16
    678                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   00000144   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000148   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000014C   0xD103             BNE.N    ??OSFlagPend_17
    679                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
   \   0000014E   0x8920             LDRH     R0,[R4, #+8]
   \   00000150   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   00000154   0x8120             STRH     R0,[R4, #+8]
    680                           }
    681                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_17:
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    682                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   00000160   0x4648             MOV      R0,R9
   \   00000162   0x.... 0x....      BL       OS_CPU_SR_Restore
    683                           *perr                   = OS_ERR_NONE;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x7038             STRB     R0,[R7, #+0]
    684                           return (flags_rdy);
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000016E   0xE0A0             B.N      ??OSFlagPend_1
    685                       } else {                                      /* Block task until events occur or timeout */
    686                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_16:
   \   00000170   0x9600             STR      R6,[SP, #+0]
   \   00000172   0x4653             MOV      R3,R10
   \   00000174   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000176   0x002A             MOVS     R2,R5
   \   00000178   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000017A   0xA902             ADD      R1,SP,#+8
   \   0000017C   0x0020             MOVS     R0,R4
   \   0000017E   0x.... 0x....      BL       OS_FlagBlock
    687                           OS_EXIT_CRITICAL();
   \   00000182   0x4648             MOV      R0,R9
   \   00000184   0x.... 0x....      BL       OS_CPU_SR_Restore
    688                       }
    689                       break;
   \   00000188   0xE035             B.N      ??OSFlagPend_13
    690          
    691                  case OS_FLAG_WAIT_CLR_ANY:
    692                       flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
   \                     ??OSFlagPend_8:
   \   0000018A   0x8920             LDRH     R0,[R4, #+8]
   \   0000018C   0xEA35 0x0000      BICS     R0,R5,R0
   \   00000190   0x4683             MOV      R11,R0
    693                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
   \   00000192   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000196   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000019A   0xD015             BEQ.N    ??OSFlagPend_18
    694                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
   \   0000019C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A0   0xF1B8 0x0F01      CMP      R8,#+1
   \   000001A4   0xD103             BNE.N    ??OSFlagPend_19
    695                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
   \   000001A6   0x8920             LDRH     R0,[R4, #+8]
   \   000001A8   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   000001AC   0x8120             STRH     R0,[R4, #+8]
    696                           }
    697                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
   \                     ??OSFlagPend_19:
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000001B2   0x6800             LDR      R0,[R0, #+0]
   \   000001B4   0xF8A0 0xB02C      STRH     R11,[R0, #+44]
    698                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
   \   000001B8   0x4648             MOV      R0,R9
   \   000001BA   0x.... 0x....      BL       OS_CPU_SR_Restore
    699                           *perr                   = OS_ERR_NONE;
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x7038             STRB     R0,[R7, #+0]
    700                           return (flags_rdy);
   \   000001C2   0x4658             MOV      R0,R11
   \   000001C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001C6   0xE074             B.N      ??OSFlagPend_1
    701                       } else {                                      /* Block task until events occur or timeout */
    702                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_18:
   \   000001C8   0x9600             STR      R6,[SP, #+0]
   \   000001CA   0x4653             MOV      R3,R10
   \   000001CC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001CE   0x002A             MOVS     R2,R5
   \   000001D0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001D2   0xA902             ADD      R1,SP,#+8
   \   000001D4   0x0020             MOVS     R0,R4
   \   000001D6   0x.... 0x....      BL       OS_FlagBlock
    703                           OS_EXIT_CRITICAL();
   \   000001DA   0x4648             MOV      R0,R9
   \   000001DC   0x.... 0x....      BL       OS_CPU_SR_Restore
    704                       }
    705                       break;
   \   000001E0   0xE009             B.N      ??OSFlagPend_13
    706          #endif
    707          
    708                  default:
    709                       OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_10:
   \   000001E2   0x4648             MOV      R0,R9
   \   000001E4   0x.... 0x....      BL       OS_CPU_SR_Restore
    710                       flags_rdy = (OS_FLAGS)0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x4683             MOV      R11,R0
    711                       *perr      = OS_ERR_FLAG_WAIT_TYPE;
   \   000001EC   0x206F             MOVS     R0,#+111
   \   000001EE   0x7038             STRB     R0,[R7, #+0]
    712                       return (flags_rdy);
   \   000001F0   0x4658             MOV      R0,R11
   \   000001F2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001F4   0xE05D             B.N      ??OSFlagPend_1
    713              }
    714          /*$PAGE*/
    715              OS_Sched();                                            /* Find next HPT ready to run               */
   \                     ??OSFlagPend_13:
   \   000001F6   0x.... 0x....      BL       OS_Sched
    716              OS_ENTER_CRITICAL();
   \   000001FA   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000001FE   0x4681             MOV      R9,R0
    717              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD026             BEQ.N    ??OSFlagPend_20
    718                  pend_stat                = OSTCBCur->OSTCBStatPend;
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000212   0x6800             LDR      R0,[R0, #+0]
   \   00000214   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000218   0xF88D 0x0004      STRB     R0,[SP, #+4]
    719                  OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0x2100             MOVS     R1,#+0
   \   00000224   0xF880 0x1035      STRB     R1,[R0, #+53]
    720                  OS_FlagUnlink(&node);
   \   00000228   0xA802             ADD      R0,SP,#+8
   \   0000022A   0x.... 0x....      BL       OS_FlagUnlink
    721                  OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000232   0x6800             LDR      R0,[R0, #+0]
   \   00000234   0x2100             MOVS     R1,#+0
   \   00000236   0xF880 0x1034      STRB     R1,[R0, #+52]
    722                  OS_EXIT_CRITICAL();
   \   0000023A   0x4648             MOV      R0,R9
   \   0000023C   0x.... 0x....      BL       OS_CPU_SR_Restore
    723                  flags_rdy                = (OS_FLAGS)0;
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0x4683             MOV      R11,R0
    724                  switch (pend_stat) {
   \   00000244   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000248   0x2802             CMP      R0,#+2
   \   0000024A   0xD102             BNE.N    ??OSFlagPend_21
    725                      case OS_STAT_PEND_ABORT:
    726                           *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
   \   0000024C   0x200E             MOVS     R0,#+14
   \   0000024E   0x7038             STRB     R0,[R7, #+0]
    727                           break;
   \   00000250   0xE001             B.N      ??OSFlagPend_22
    728          
    729                      case OS_STAT_PEND_TO:
    730                      default:
    731                           *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
   \                     ??OSFlagPend_21:
   \   00000252   0x200A             MOVS     R0,#+10
   \   00000254   0x7038             STRB     R0,[R7, #+0]
    732                           break;
    733                  }
    734                  return (flags_rdy);
   \                     ??OSFlagPend_22:
   \   00000256   0x4658             MOV      R0,R11
   \   00000258   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000025A   0xE02A             B.N      ??OSFlagPend_1
    735              }
    736              flags_rdy = OSTCBCur->OSTCBFlagsRdy;
   \                     ??OSFlagPend_20:
   \   0000025C   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000260   0x6800             LDR      R0,[R0, #+0]
   \   00000262   0x8D80             LDRH     R0,[R0, #+44]
   \   00000264   0x4683             MOV      R11,R0
    737              if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
   \   00000266   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000026A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000026E   0xD119             BNE.N    ??OSFlagPend_23
    738                  switch (wait_type) {
   \   00000270   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000274   0x4650             MOV      R0,R10
   \   00000276   0x2800             CMP      R0,#+0
   \   00000278   0x2801             CMP      R0,#+1
   \   0000027A   0xD907             BLS.N    ??OSFlagPend_24
   \   0000027C   0x1E80             SUBS     R0,R0,#+2
   \   0000027E   0x2801             CMP      R0,#+1
   \   00000280   0xD809             BHI.N    ??OSFlagPend_25
    739                      case OS_FLAG_WAIT_SET_ALL:
    740                      case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
    741                           pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
   \                     ??OSFlagPend_26:
   \   00000282   0x8920             LDRH     R0,[R4, #+8]
   \   00000284   0xEA30 0x000B      BICS     R0,R0,R11
   \   00000288   0x8120             STRH     R0,[R4, #+8]
    742                           break;
   \   0000028A   0xE00B             B.N      ??OSFlagPend_23
    743          
    744          #if OS_FLAG_WAIT_CLR_EN > 0u
    745                      case OS_FLAG_WAIT_CLR_ALL:
    746                      case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
    747                           pgrp->OSFlagFlags |=  flags_rdy;
   \                     ??OSFlagPend_24:
   \   0000028C   0x8920             LDRH     R0,[R4, #+8]
   \   0000028E   0xEA5B 0x0000      ORRS     R0,R11,R0
   \   00000292   0x8120             STRH     R0,[R4, #+8]
    748                           break;
   \   00000294   0xE006             B.N      ??OSFlagPend_23
    749          #endif
    750                      default:
    751                           OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_25:
   \   00000296   0x4648             MOV      R0,R9
   \   00000298   0x.... 0x....      BL       OS_CPU_SR_Restore
    752                           *perr = OS_ERR_FLAG_WAIT_TYPE;
   \   0000029C   0x206F             MOVS     R0,#+111
   \   0000029E   0x7038             STRB     R0,[R7, #+0]
    753                           return ((OS_FLAGS)0);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0xE006             B.N      ??OSFlagPend_1
    754                  }
    755              }
    756              OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_23:
   \   000002A4   0x4648             MOV      R0,R9
   \   000002A6   0x.... 0x....      BL       OS_CPU_SR_Restore
    757              *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
   \   000002AA   0x2000             MOVS     R0,#+0
   \   000002AC   0x7038             STRB     R0,[R7, #+0]
    758              return (flags_rdy);
   \   000002AE   0x4658             MOV      R0,R11
   \   000002B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPend_1:
   \   000002B2   0xB007             ADD      SP,SP,#+28
   \   000002B4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    759          }
    760          /*$PAGE*/
    761          /*
    762          *********************************************************************************************************
    763          *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
    764          *
    765          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    766          *              In other words, this function allows you to tell "Who done it!".
    767          *
    768          * Arguments  : None
    769          *
    770          * Returns    : The flags that caused the task to be ready.
    771          *
    772          * Called from: Task ONLY
    773          *********************************************************************************************************
    774          */
    775          

   \                                 In section .text, align 2, keep-with-next
    776          OS_FLAGS  OSFlagPendGetFlagsRdy (void)
    777          {
   \                     OSFlagPendGetFlagsRdy:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    778              OS_FLAGS      flags;
    779          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    780              OS_CPU_SR     cpu_sr = 0u;
   \   00000002   0x2500             MOVS     R5,#+0
    781          #endif
    782          
    783          
    784          
    785              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0005             MOVS     R5,R0
    786              flags = OSTCBCur->OSTCBFlagsRdy;
   \   0000000A   0x....             LDR.N    R0,??DataTable8_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x8D80             LDRH     R0,[R0, #+44]
   \   00000010   0x0004             MOVS     R4,R0
    787              OS_EXIT_CRITICAL();
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Restore
    788              return (flags);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    789          }
    790          
    791          /*$PAGE*/
    792          /*
    793          *********************************************************************************************************
    794          *                                       POST EVENT FLAG BIT(S)
    795          *
    796          * Description: This function is called to set or clear some bits in an event flag group.  The bits to
    797          *              set or clear are specified by a 'bit mask'.
    798          *
    799          * Arguments  : pgrp          is a pointer to the desired event flag group.
    800          *
    801          *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
    802          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    803          *                            and 5 you would set 'flags' to:
    804          *
    805          *                                0x31     (note, bit 0 is least significant bit)
    806          *
    807          *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
    808          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    809          *                            4 and 5 you would specify 'flags' as:
    810          *
    811          *                                0x31     (note, bit 0 is least significant bit)
    812          *
    813          *              opt           indicates whether the flags will be:
    814          *                                set     (OS_FLAG_SET) or
    815          *                                cleared (OS_FLAG_CLR)
    816          *
    817          *              perr          is a pointer to an error code and can be:
    818          *                            OS_ERR_NONE                The call was successfull
    819          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    820          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    821          *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
    822          *
    823          * Returns    : the new value of the event flags bits that are still set.
    824          *
    825          * Called From: Task or ISR
    826          *
    827          * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
    828          *                 flag group.
    829          *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
    830          *                 the event flag group.
    831          *********************************************************************************************************
    832          */

   \                                 In section .text, align 2, keep-with-next
    833          OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
    834                                OS_FLAGS      flags,
    835                                INT8U         opt,
    836                                INT8U        *perr)
    837          {
   \                     OSFlagPost:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x001D             MOVS     R5,R3
    838              OS_FLAG_NODE *pnode;
    839              BOOLEAN       sched;
    840              OS_FLAGS      flags_cur;
    841              OS_FLAGS      flags_rdy;
    842              BOOLEAN       rdy;
    843          #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
    844              OS_CPU_SR     cpu_sr = 0u;
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
    845          #endif
    846          
    847          
    848          
    849          #ifdef OS_SAFETY_CRITICAL
    850              if (perr == (INT8U *)0) {
    851                  OS_SAFETY_CRITICAL_EXCEPTION();
    852                  return ((OS_FLAGS)0);
    853              }
    854          #endif
    855          
    856          #if OS_ARG_CHK_EN > 0u
    857              if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
    858                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    859                  return ((OS_FLAGS)0);
    860              }
    861          #endif
    862              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD003             BEQ.N    ??OSFlagPost_0
    863                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    864                  return ((OS_FLAGS)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0AA             B.N      ??OSFlagPost_1
    865              }
    866          /*$PAGE*/
    867              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4683             MOV      R11,R0
    868              switch (opt) {
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ.N    ??OSFlagPost_2
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD006             BEQ.N    ??OSFlagPost_3
   \   0000002C   0xE00B             B.N      ??OSFlagPost_4
    869                  case OS_FLAG_CLR:
    870                       pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
   \                     ??OSFlagPost_2:
   \   0000002E   0x8920             LDRH     R0,[R4, #+8]
   \   00000030   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000034   0x4388             BICS     R0,R0,R1
   \   00000036   0x8120             STRH     R0,[R4, #+8]
    871                       break;
   \   00000038   0xE00C             B.N      ??OSFlagPost_5
    872          
    873                  case OS_FLAG_SET:
    874                       pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
   \                     ??OSFlagPost_3:
   \   0000003A   0x8920             LDRH     R0,[R4, #+8]
   \   0000003C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000040   0x4308             ORRS     R0,R1,R0
   \   00000042   0x8120             STRH     R0,[R4, #+8]
    875                       break;
   \   00000044   0xE006             B.N      ??OSFlagPost_5
    876          
    877                  default:
    878                       OS_EXIT_CRITICAL();                     /* INVALID option                                 */
   \                     ??OSFlagPost_4:
   \   00000046   0x4658             MOV      R0,R11
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    879                       *perr = OS_ERR_FLAG_INVALID_OPT;
   \   0000004C   0x2071             MOVS     R0,#+113
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
    880                       return ((OS_FLAGS)0);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE08D             B.N      ??OSFlagPost_1
    881              }
    882              sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
   \                     ??OSFlagPost_5:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x0007             MOVS     R7,R0
    883              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x0006             MOVS     R6,R0
    884              while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
   \                     ??OSFlagPost_6:
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD073             BEQ.N    ??OSFlagPost_7
    885                  switch (pnode->OSFlagNodeWaitType) {
   \   00000060   0x7CB0             LDRB     R0,[R6, #+18]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD035             BEQ.N    ??OSFlagPost_8
   \   00000066   0x2802             CMP      R0,#+2
   \   00000068   0xD003             BEQ.N    ??OSFlagPost_9
   \   0000006A   0xD34B             BCC.N    ??OSFlagPost_10
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD018             BEQ.N    ??OSFlagPost_11
   \   00000070   0xE061             B.N      ??OSFlagPost_12
    886                      case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
    887                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_9:
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0x8A31             LDRH     R1,[R6, #+16]
   \   00000076   0x4008             ANDS     R0,R1,R0
   \   00000078   0x4681             MOV      R9,R0
    888                           if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
   \   0000007A   0x8A30             LDRH     R0,[R6, #+16]
   \   0000007C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000080   0x4581             CMP      R9,R0
   \   00000082   0xD10D             BNE.N    ??OSFlagPost_13
    889                               rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x4649             MOV      R1,R9
   \   00000088   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0x.... 0x....      BL       OS_FlagTaskRdy
   \   00000090   0x4682             MOV      R10,R0
    890                               if (rdy == OS_TRUE) {
   \   00000092   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000096   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000009A   0xD101             BNE.N    ??OSFlagPost_13
    891                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x0007             MOVS     R7,R0
    892                               }
    893                           }
    894                           break;
   \                     ??OSFlagPost_13:
   \   000000A0   0xE050             B.N      ??OSFlagPost_14
    895          
    896                      case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
    897                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_11:
   \   000000A2   0x8920             LDRH     R0,[R4, #+8]
   \   000000A4   0x8A31             LDRH     R1,[R6, #+16]
   \   000000A6   0x4008             ANDS     R0,R1,R0
   \   000000A8   0x4681             MOV      R9,R0
    898                           if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
   \   000000AA   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000AE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B2   0xD00D             BEQ.N    ??OSFlagPost_15
    899                               rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x4649             MOV      R1,R9
   \   000000B8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BA   0x0030             MOVS     R0,R6
   \   000000BC   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000C0   0x4682             MOV      R10,R0
    900                               if (rdy == OS_TRUE) {
   \   000000C2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C6   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000CA   0xD101             BNE.N    ??OSFlagPost_15
    901                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x0007             MOVS     R7,R0
    902                               }
    903                           }
    904                           break;
   \                     ??OSFlagPost_15:
   \   000000D0   0xE038             B.N      ??OSFlagPost_14
    905          
    906          #if OS_FLAG_WAIT_CLR_EN > 0u
    907                      case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
    908                           flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
   \                     ??OSFlagPost_8:
   \   000000D2   0x8920             LDRH     R0,[R4, #+8]
   \   000000D4   0x8A31             LDRH     R1,[R6, #+16]
   \   000000D6   0xEA31 0x0000      BICS     R0,R1,R0
   \   000000DA   0x4681             MOV      R9,R0
    909                           if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
   \   000000DC   0x8A30             LDRH     R0,[R6, #+16]
   \   000000DE   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000E2   0x4581             CMP      R9,R0
   \   000000E4   0xD10D             BNE.N    ??OSFlagPost_16
    910                               rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
   \   000000E6   0x2200             MOVS     R2,#+0
   \   000000E8   0x4649             MOV      R1,R9
   \   000000EA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0x.... 0x....      BL       OS_FlagTaskRdy
   \   000000F2   0x4682             MOV      R10,R0
    911                               if (rdy == OS_TRUE) {
   \   000000F4   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F8   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000FC   0xD101             BNE.N    ??OSFlagPost_16
    912                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x0007             MOVS     R7,R0
    913                               }
    914                           }
    915                           break;
   \                     ??OSFlagPost_16:
   \   00000102   0xE01F             B.N      ??OSFlagPost_14
    916          
    917                      case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
    918                           flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
   \                     ??OSFlagPost_10:
   \   00000104   0x8920             LDRH     R0,[R4, #+8]
   \   00000106   0x8A31             LDRH     R1,[R6, #+16]
   \   00000108   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000010C   0x4681             MOV      R9,R0
    919                           if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
   \   0000010E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000112   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000116   0xD00D             BEQ.N    ??OSFlagPost_17
    920                               rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0x4649             MOV      R1,R9
   \   0000011C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000011E   0x0030             MOVS     R0,R6
   \   00000120   0x.... 0x....      BL       OS_FlagTaskRdy
   \   00000124   0x4682             MOV      R10,R0
    921                               if (rdy == OS_TRUE) {
   \   00000126   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000012A   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000012E   0xD101             BNE.N    ??OSFlagPost_17
    922                                   sched = OS_TRUE;                     /* When done we will reschedule          */
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0x0007             MOVS     R7,R0
    923                               }
    924                           }
    925                           break;
   \                     ??OSFlagPost_17:
   \   00000134   0xE006             B.N      ??OSFlagPost_14
    926          #endif
    927                      default:
    928                           OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_12:
   \   00000136   0x4658             MOV      R0,R11
   \   00000138   0x.... 0x....      BL       OS_CPU_SR_Restore
    929                           *perr = OS_ERR_FLAG_WAIT_TYPE;
   \   0000013C   0x206F             MOVS     R0,#+111
   \   0000013E   0x7028             STRB     R0,[R5, #+0]
    930                           return ((OS_FLAGS)0);
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE015             B.N      ??OSFlagPost_1
    931                  }
    932                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
   \                     ??OSFlagPost_14:
   \   00000144   0x6836             LDR      R6,[R6, #+0]
   \   00000146   0xE789             B.N      ??OSFlagPost_6
    933              }
    934              OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_7:
   \   00000148   0x4658             MOV      R0,R11
   \   0000014A   0x.... 0x....      BL       OS_CPU_SR_Restore
    935              if (sched == OS_TRUE) {
   \   0000014E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000150   0x2F01             CMP      R7,#+1
   \   00000152   0xD101             BNE.N    ??OSFlagPost_18
    936                  OS_Sched();
   \   00000154   0x.... 0x....      BL       OS_Sched
    937              }
    938              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_18:
   \   00000158   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000015C   0x4683             MOV      R11,R0
    939              flags_cur = pgrp->OSFlagFlags;
   \   0000015E   0x8920             LDRH     R0,[R4, #+8]
   \   00000160   0x4680             MOV      R8,R0
    940              OS_EXIT_CRITICAL();
   \   00000162   0x4658             MOV      R0,R11
   \   00000164   0x.... 0x....      BL       OS_CPU_SR_Restore
    941              *perr     = OS_ERR_NONE;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x7028             STRB     R0,[R5, #+0]
    942              return (flags_cur);
   \   0000016C   0x4640             MOV      R0,R8
   \   0000016E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPost_1:
   \   00000170   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    943          }
    944          /*$PAGE*/
    945          /*
    946          *********************************************************************************************************
    947          *                                          QUERY EVENT FLAG
    948          *
    949          * Description: This function is used to check the value of the event flag group.
    950          *
    951          * Arguments  : pgrp         is a pointer to the desired event flag group.
    952          *
    953          *              perr          is a pointer to an error code returned to the called:
    954          *                            OS_ERR_NONE                The call was successfull
    955          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    956          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    957          *
    958          * Returns    : The current value of the event flag group.
    959          *
    960          * Called From: Task or ISR
    961          *********************************************************************************************************
    962          */
    963          
    964          #if OS_FLAG_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    965          OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
    966                                 INT8U        *perr)
    967          {
   \                     OSFlagQuery:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    968              OS_FLAGS   flags;
    969          #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
    970              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
    971          #endif
    972          
    973          
    974          
    975          #ifdef OS_SAFETY_CRITICAL
    976              if (perr == (INT8U *)0) {
    977                  OS_SAFETY_CRITICAL_EXCEPTION();
    978                  return ((OS_FLAGS)0);
    979              }
    980          #endif
    981          
    982          #if OS_ARG_CHK_EN > 0u
    983              if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
    984                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    985                  return ((OS_FLAGS)0);
    986              }
    987          #endif
    988              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD003             BEQ.N    ??OSFlagQuery_0
    989                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7028             STRB     R0,[R5, #+0]
    990                  return ((OS_FLAGS)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE00B             B.N      ??OSFlagQuery_1
    991              }
    992              OS_ENTER_CRITICAL();
   \                     ??OSFlagQuery_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x0007             MOVS     R7,R0
    993              flags = pgrp->OSFlagFlags;
   \   0000001C   0x8920             LDRH     R0,[R4, #+8]
   \   0000001E   0x0006             MOVS     R6,R0
    994              OS_EXIT_CRITICAL();
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    995              *perr = OS_ERR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    996              return (flags);                               /* Return the current value of the event flags       */
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagQuery_1:
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    997          }
    998          #endif
    999          
   1000          /*$PAGE*/
   1001          /*
   1002          *********************************************************************************************************
   1003          *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
   1004          *
   1005          * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
   1006          *              event flag bit(s) are set.
   1007          *
   1008          * Arguments  : pgrp          is a pointer to the desired event flag group.
   1009          *
   1010          *              pnode         is a pointer to a structure which contains data about the task waiting for
   1011          *                            event flag bit(s) to be set.
   1012          *
   1013          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
   1014          *                            The bits you want are specified by setting the corresponding bits in
   1015          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
   1016          *                            'flags' would contain 0x03.
   1017          *
   1018          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
   1019          *                            to be set/cleared.
   1020          *                            You can specify the following argument:
   1021          *
   1022          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
   1023          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
   1024          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
   1025          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
   1026          *
   1027          *              timeout       is the desired amount of time that the task will wait for the event flag
   1028          *                            bit(s) to be set.
   1029          *
   1030          * Returns    : none
   1031          *
   1032          * Called by  : OSFlagPend()  OS_FLAG.C
   1033          *
   1034          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
   1035          *********************************************************************************************************
   1036          */
   1037          

   \                                 In section .text, align 2, keep-with-next
   1038          static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
   1039                                      OS_FLAG_NODE *pnode,
   1040                                      OS_FLAGS      flags,
   1041                                      INT8U         wait_type,
   1042                                      INT32U        timeout)
   1043          {
   \                     OS_FlagBlock:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   1044              OS_FLAG_NODE  *pnode_next;
   1045              INT8U          y;
   1046          
   1047          
   1048              OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
   \   00000004   0x....             LDR.N    R7,??DataTable8_4
   \   00000006   0x683F             LDR      R7,[R7, #+0]
   \   00000008   0xF897 0x7034      LDRB     R7,[R7, #+52]
   \   0000000C   0xF057 0x0720      ORRS     R7,R7,#0x20
   \   00000010   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000014   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000018   0xF88C 0x7034      STRB     R7,[R12, #+52]
   1049              OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
   \   0000001C   0x....             LDR.N    R7,??DataTable8_4
   \   0000001E   0x683F             LDR      R7,[R7, #+0]
   \   00000020   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000024   0xF887 0xC035      STRB     R12,[R7, #+53]
   1050              OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
   \   00000028   0x....             LDR.N    R7,??DataTable8_4
   \   0000002A   0x683F             LDR      R7,[R7, #+0]
   \   0000002C   0x633C             STR      R4,[R7, #+48]
   1051          #if OS_TASK_DEL_EN > 0u
   1052              OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
   \   0000002E   0x....             LDR.N    R7,??DataTable8_4
   \   00000030   0x683F             LDR      R7,[R7, #+0]
   \   00000032   0x62B9             STR      R1,[R7, #+40]
   1053          #endif
   1054              pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
   \   00000034   0x820A             STRH     R2,[R1, #+16]
   1055              pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
   \   00000036   0x748B             STRB     R3,[R1, #+18]
   1056              pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
   \   00000038   0x....             LDR.N    R7,??DataTable8_4
   \   0000003A   0x683F             LDR      R7,[R7, #+0]
   \   0000003C   0x608F             STR      R7,[R1, #+8]
   1057              pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
   \   0000003E   0x6847             LDR      R7,[R0, #+4]
   \   00000040   0x600F             STR      R7,[R1, #+0]
   1058              pnode->OSFlagNodePrev     = (void *)0;
   \   00000042   0x2700             MOVS     R7,#+0
   \   00000044   0x604F             STR      R7,[R1, #+4]
   1059              pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1060              pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   00000048   0x6847             LDR      R7,[R0, #+4]
   \   0000004A   0x003D             MOVS     R5,R7
   1061              if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD000             BEQ.N    ??OS_FlagBlock_0
   1062                  pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
   \   00000050   0x6069             STR      R1,[R5, #+4]
   1063              }
   1064              pgrp->OSFlagWaitList = (void *)pnode;
   \                     ??OS_FlagBlock_0:
   \   00000052   0x6041             STR      R1,[R0, #+4]
   1065          
   1066              y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
   \   00000054   0x....             LDR.N    R7,??DataTable8_4
   \   00000056   0x683F             LDR      R7,[R7, #+0]
   \   00000058   0xF897 0x7038      LDRB     R7,[R7, #+56]
   \   0000005C   0x003E             MOVS     R6,R7
   1067              OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x....             LDR.N    R7,??DataTable8_5
   \   00000062   0x5DF7             LDRB     R7,[R6, R7]
   \   00000064   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000068   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000006C   0xF89C 0xC039      LDRB     R12,[R12, #+57]
   \   00000070   0xEA37 0x070C      BICS     R7,R7,R12
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x.... 0x....      LDR.W    R12,??DataTable8_5
   \   0000007A   0xF806 0x700C      STRB     R7,[R6, R12]
   1068              if (OSRdyTbl[y] == 0x00u) {
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x....             LDR.N    R7,??DataTable8_5
   \   00000082   0x5DF7             LDRB     R7,[R6, R7]
   \   00000084   0x2F00             CMP      R7,#+0
   \   00000086   0xD10D             BNE.N    ??OS_FlagBlock_1
   1069                  OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   00000088   0x....             LDR.N    R7,??DataTable8_6
   \   0000008A   0x783F             LDRB     R7,[R7, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R12,??DataTable8_4
   \   00000090   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000094   0xF89C 0xC03A      LDRB     R12,[R12, #+58]
   \   00000098   0xEA37 0x070C      BICS     R7,R7,R12
   \   0000009C   0x.... 0x....      LDR.W    R12,??DataTable8_6
   \   000000A0   0xF88C 0x7000      STRB     R7,[R12, #+0]
   1070              }
   1071          }
   \                     ??OS_FlagBlock_1:
   \   000000A4   0xBCF0             POP      {R4-R7}
   \   000000A6   0x4770             BX       LR               ;; return
   1072          
   1073          /*$PAGE*/
   1074          /*
   1075          *********************************************************************************************************
   1076          *                                  INITIALIZE THE EVENT FLAG MODULE
   1077          *
   1078          * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
   1079          *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
   1080          *
   1081          * Arguments  : none
   1082          *
   1083          * Returns    : none
   1084          *
   1085          * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
   1086          *********************************************************************************************************
   1087          */
   1088          

   \                                 In section .text, align 2, keep-with-next
   1089          void  OS_FlagInit (void)
   1090          {
   \                     OS_FlagInit:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1091          #if OS_MAX_FLAGS == 1u
   1092              OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
   1093              OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   1094              OSFlagFreeList->OSFlagWaitList = (void *)0;
   1095              OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
   1096          #if OS_FLAG_NAME_EN > 0u
   1097              OSFlagFreeList->OSFlagName     = (INT8U *)"?";
   1098          #endif
   1099          #endif
   1100          
   1101          #if OS_MAX_FLAGS >= 2u
   1102              INT16U        ix;
   1103              INT16U        ix_next;
   1104              OS_FLAG_GRP  *pgrp1;
   1105              OS_FLAG_GRP  *pgrp2;
   1106          
   1107          
   1108              OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable8_7
   \   00000006   0x.... 0x....      BL       OS_MemClr
   1109              for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \                     ??OS_FlagInit_0:
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD212             BCS.N    ??OS_FlagInit_1
   1110                  ix_next = ix + 1u;
   \   00000014   0x1C60             ADDS     R0,R4,#+1
   \   00000016   0x0005             MOVS     R5,R0
   1111                  pgrp1 = &OSFlagTbl[ix];
   \   00000018   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001A   0x....             LDR.N    R0,??DataTable8_7
   \   0000001C   0xEB10 0x1004      ADDS     R0,R0,R4, LSL #+4
   \   00000020   0x0006             MOVS     R6,R0
   1112                  pgrp2 = &OSFlagTbl[ix_next];
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x....             LDR.N    R0,??DataTable8_7
   \   00000026   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   0000002A   0x0007             MOVS     R7,R0
   1113                  pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
   1114                  pgrp1->OSFlagWaitList = (void *)pgrp2;
   \   00000030   0x6077             STR      R7,[R6, #+4]
   1115          #if OS_FLAG_NAME_EN > 0u
   1116                  pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
   \   00000032   0x....             ADR.N    R0,??DataTable8  ;; "\?"
   \   00000034   0x60F0             STR      R0,[R6, #+12]
   1117          #endif
   1118              }
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   \   00000038   0xE7E9             B.N      ??OS_FlagInit_0
   1119              pgrp1                 = &OSFlagTbl[ix];
   \                     ??OS_FlagInit_1:
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0x....             LDR.N    R0,??DataTable8_7
   \   0000003E   0xEB10 0x1004      ADDS     R0,R0,R4, LSL #+4
   \   00000042   0x0006             MOVS     R6,R0
   1120              pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7030             STRB     R0,[R6, #+0]
   1121              pgrp1->OSFlagWaitList = (void *)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6070             STR      R0,[R6, #+4]
   1122          #if OS_FLAG_NAME_EN > 0u
   1123              pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
   \   0000004C   0x....             ADR.N    R0,??DataTable8  ;; "\?"
   \   0000004E   0x60F0             STR      R0,[R6, #+12]
   1124          #endif
   1125              OSFlagFreeList        = &OSFlagTbl[0];
   \   00000050   0x....             LDR.N    R0,??DataTable8_2
   \   00000052   0x....             LDR.N    R1,??DataTable8_7
   \   00000054   0x6001             STR      R1,[R0, #+0]
   1126          #endif
   1127          }
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1128          
   1129          /*$PAGE*/
   1130          /*
   1131          *********************************************************************************************************
   1132          *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1133          *
   1134          * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
   1135          *              desired event flag bits have been set.
   1136          *
   1137          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1138          *                            event flag bit(s) to be set.
   1139          *
   1140          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
   1141          *                            ready-to-run.
   1142          *
   1143          *              pend_stat   is used to indicate the readied task's pending status:
   1144          *
   1145          *
   1146          * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
   1147          *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
   1148          *
   1149          * Called by  : OSFlagsPost() OS_FLAG.C
   1150          *
   1151          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1152          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1153          *********************************************************************************************************
   1154          */
   1155          

   \                                 In section .text, align 2, keep-with-next
   1156          static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
   1157                                           OS_FLAGS      flags_rdy,
   1158                                           INT8U         pend_stat)
   1159          {
   \                     OS_FlagTaskRdy:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1160              OS_TCB   *ptcb;
   1161              BOOLEAN   sched;
   1162          
   1163          
   1164              ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x0007             MOVS     R7,R0
   1165              ptcb->OSTCBDly       = 0u;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6338             STR      R0,[R7, #+48]
   1166              ptcb->OSTCBFlagsRdy  = flags_rdy;
   \   00000012   0x85BD             STRH     R5,[R7, #+44]
   1167              ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
   \   00000014   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   00000018   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000001C   0xF887 0x0034      STRB     R0,[R7, #+52]
   1168              ptcb->OSTCBStatPend  = pend_stat;
   \   00000020   0xF887 0x6035      STRB     R6,[R7, #+53]
   1169              if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
   \   00000024   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD114             BNE.N    ??OS_FlagTaskRdy_0
   1170                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
   \   0000002C   0x....             LDR.N    R0,??DataTable8_6
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF897 0x103A      LDRB     R1,[R7, #+58]
   \   00000034   0x4308             ORRS     R0,R1,R0
   \   00000036   0x....             LDR.N    R1,??DataTable8_6
   \   00000038   0x7008             STRB     R0,[R1, #+0]
   1171                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000003A   0xF897 0x0038      LDRB     R0,[R7, #+56]
   \   0000003E   0x....             LDR.N    R1,??DataTable8_5
   \   00000040   0x5C40             LDRB     R0,[R0, R1]
   \   00000042   0xF897 0x1039      LDRB     R1,[R7, #+57]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0xF897 0x1038      LDRB     R1,[R7, #+56]
   \   0000004C   0x....             LDR.N    R2,??DataTable8_5
   \   0000004E   0x5488             STRB     R0,[R1, R2]
   1172                  sched                   = OS_TRUE;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x4680             MOV      R8,R0
   \   00000054   0xE001             B.N      ??OS_FlagTaskRdy_1
   1173              } else {
   1174                  sched                   = OS_FALSE;
   \                     ??OS_FlagTaskRdy_0:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4680             MOV      R8,R0
   1175              }
   1176              OS_FlagUnlink(pnode);
   \                     ??OS_FlagTaskRdy_1:
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       OS_FlagUnlink
   1177              return (sched);
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1178          }
   1179          
   1180          /*$PAGE*/
   1181          /*
   1182          *********************************************************************************************************
   1183          *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
   1184          *
   1185          * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
   1186          *              list of tasks waiting for the event flag.
   1187          *
   1188          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1189          *                            event flag bit(s) to be set.
   1190          *
   1191          * Returns    : none
   1192          *
   1193          * Called by  : OS_FlagTaskRdy() OS_FLAG.C
   1194          *              OSFlagPend()     OS_FLAG.C
   1195          *              OSTaskDel()      OS_TASK.C
   1196          *
   1197          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1198          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1199          *********************************************************************************************************
   1200          */
   1201          

   \                                 In section .text, align 2, keep-with-next
   1202          void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
   1203          {
   \                     OS_FlagUnlink:
   \   00000000   0xB430             PUSH     {R4,R5}
   1204          #if OS_TASK_DEL_EN > 0u
   1205              OS_TCB       *ptcb;
   1206          #endif
   1207              OS_FLAG_GRP  *pgrp;
   1208              OS_FLAG_NODE *pnode_prev;
   1209              OS_FLAG_NODE *pnode_next;
   1210          
   1211          
   1212              pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
   \   00000002   0x6845             LDR      R5,[R0, #+4]
   \   00000004   0x002B             MOVS     R3,R5
   1213              pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   00000006   0x6805             LDR      R5,[R0, #+0]
   \   00000008   0x002C             MOVS     R4,R5
   1214              if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD107             BNE.N    ??OS_FlagUnlink_0
   1215                  pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
   \   0000000E   0x68C5             LDR      R5,[R0, #+12]
   \   00000010   0x002A             MOVS     R2,R5
   1216                  pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
   \   00000012   0x6054             STR      R4,[R2, #+4]
   1217                  if (pnode_next != (OS_FLAG_NODE *)0) {
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD006             BEQ.N    ??OS_FlagUnlink_1
   1218                      pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0x6065             STR      R5,[R4, #+4]
   \   0000001C   0xE003             B.N      ??OS_FlagUnlink_1
   1219                  }
   1220              } else {                                                    /* No,  A node somewhere in the list   */
   1221                  pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
   \                     ??OS_FlagUnlink_0:
   \   0000001E   0x601C             STR      R4,[R3, #+0]
   1222                  if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD000             BEQ.N    ??OS_FlagUnlink_1
   1223                      pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
   \   00000024   0x6063             STR      R3,[R4, #+4]
   1224                  }
   1225              }
   1226          #if OS_TASK_DEL_EN > 0u
   1227              ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
   \                     ??OS_FlagUnlink_1:
   \   00000026   0x6885             LDR      R5,[R0, #+8]
   \   00000028   0x0029             MOVS     R1,R5
   1228              ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x628D             STR      R5,[R1, #+40]
   1229          #endif
   1230          }
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSFlagFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     OSFlagTbl

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
   1231          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSFlagAccept
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
      24   OSFlagCreate
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      32   OSFlagDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_FlagTaskRdy
        32   -> OS_Sched
      24   OSFlagNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrLen
      24   OSFlagNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      64   OSFlagPend
        64   -> OS_CPU_SR_Restore
        64   -> OS_CPU_SR_Save
        64   -> OS_FlagBlock
        64   -> OS_FlagUnlink
        64   -> OS_Sched
      16   OSFlagPendGetFlagsRdy
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      48   OSFlagPost
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_FlagTaskRdy
        48   -> OS_Sched
      24   OSFlagQuery
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   OS_FlagBlock
      24   OS_FlagInit
        24   -> OS_MemClr
      24   OS_FlagTaskRdy
        24   -> OS_FlagUnlink
       8   OS_FlagUnlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
     306  OSFlagAccept
      98  OSFlagCreate
     238  OSFlagDel
      88  OSFlagNameGet
      64  OSFlagNameSet
     696  OSFlagPend
      30  OSFlagPendGetFlagsRdy
     372  OSFlagPost
      48  OSFlagQuery
     168  OS_FlagBlock
      88  OS_FlagInit
     104  OS_FlagTaskRdy
      50  OS_FlagUnlink

 
     2 bytes in section .rodata
 2 386 bytes in section .text
 
 2 386 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none

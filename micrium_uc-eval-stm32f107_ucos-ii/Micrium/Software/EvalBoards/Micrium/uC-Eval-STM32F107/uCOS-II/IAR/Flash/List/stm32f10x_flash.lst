###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:23 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_flash.c                  #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_flash.c" -D              #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_flash.lst          #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_flash.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_flash.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_flash.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the FLASH firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_flash.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          /* Flash Access Control Register bits */
     22          #define ACR_LATENCY_Mask         ((u32)0x00000038)
     23          #define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
     24          #define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
     25          
     26          #ifdef _FLASH_PROG
     27          /* Flash Access Control Register bits */
     28          #define ACR_PRFTBS_Mask          ((u32)0x00000020) 
     29          
     30          /* Flash Control Register bits */
     31          #define CR_PG_Set                ((u32)0x00000001)
     32          #define CR_PG_Reset              ((u32)0x00001FFE) 
     33          
     34          #define CR_PER_Set               ((u32)0x00000002)
     35          #define CR_PER_Reset             ((u32)0x00001FFD)
     36          
     37          #define CR_MER_Set               ((u32)0x00000004)
     38          #define CR_MER_Reset             ((u32)0x00001FFB)
     39          
     40          #define CR_OPTPG_Set             ((u32)0x00000010)
     41          #define CR_OPTPG_Reset           ((u32)0x00001FEF)
     42          
     43          #define CR_OPTER_Set             ((u32)0x00000020)
     44          #define CR_OPTER_Reset           ((u32)0x00001FDF)
     45          
     46          #define CR_STRT_Set              ((u32)0x00000040)
     47          							 
     48          #define CR_LOCK_Set              ((u32)0x00000080)
     49          
     50          /* FLASH Mask */
     51          #define RDPRT_Mask               ((u32)0x00000002)
     52          #define WRP0_Mask                ((u32)0x000000FF)
     53          #define WRP1_Mask                ((u32)0x0000FF00)
     54          #define WRP2_Mask                ((u32)0x00FF0000)
     55          #define WRP3_Mask                ((u32)0xFF000000)
     56          
     57          /* FLASH Keys */
     58          #define RDP_Key                  ((u16)0x00A5)
     59          #define FLASH_KEY1               ((u32)0x45670123)
     60          #define FLASH_KEY2               ((u32)0xCDEF89AB)
     61          
     62          /* Delay definition */   
     63          #define EraseTimeout             ((u32)0x00000FFF)
     64          #define ProgramTimeout           ((u32)0x0000000F)
     65          #endif
     66          
     67          /* Private macro -------------------------------------------------------------*/
     68          /* Private variables ---------------------------------------------------------*/
     69          /* Private function prototypes -----------------------------------------------*/
     70          #ifdef _FLASH_PROG
     71          static void delay(void);
     72          #endif
     73          
     74          /* Private functions ---------------------------------------------------------*/
     75          /*******************************************************************************
     76          * Function Name  : FLASH_SetLatency
     77          * Description    : Sets the code latency value.
     78          * Input          : - FLASH_Latency: specifies the FLASH Latency value.
     79          *                    This parameter can be one of the following values:
     80          *                       - FLASH_Latency_0: FLASH Zero Latency cycle
     81          *                       - FLASH_Latency_1: FLASH One Latency cycle
     82          *                       - FLASH_Latency_2: FLASH Two Latency cycles
     83          * Output         : None
     84          * Return         : None
     85          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     86          void FLASH_SetLatency(u32 FLASH_Latency)
     87          {
     88            /* Check the parameters */
     89            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
     90            
     91            /* Sets the Latency value */
     92            FLASH->ACR &= ACR_LATENCY_Mask;
   \                     FLASH_SetLatency:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF011 0x0138      ANDS     R1,R1,#0x38
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000000E   0x6011             STR      R1,[R2, #+0]
     93            FLASH->ACR |= FLASH_Latency;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4301             ORRS     R1,R0,R1
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000001C   0x6011             STR      R1,[R2, #+0]
     94          }
   \   0000001E   0x4770             BX       LR               ;; return
     95          
     96          /*******************************************************************************
     97          * Function Name  : FLASH_HalfCycleAccessCmd
     98          * Description    : Enables or disables the Half cycle flash access.
     99          * Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
    100          *                    This parameter can be one of the following values:
    101          *                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    102          *                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    103          * Output         : None
    104          * Return         : None
    105          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
    107          {
    108            /* Check the parameters */
    109            assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    110            
    111            /* Enable or disable the Half cycle access */
    112            FLASH->ACR &= ACR_HLFCYA_Mask;
   \                     FLASH_HalfCycleAccessCmd:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF031 0x0108      BICS     R1,R1,#0x8
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    113            FLASH->ACR |= FLASH_HalfCycleAccess;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4301             ORRS     R1,R0,R1
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000001C   0x6011             STR      R1,[R2, #+0]
    114          }
   \   0000001E   0x4770             BX       LR               ;; return
    115          
    116          /*******************************************************************************
    117          * Function Name  : FLASH_PrefetchBufferCmd
    118          * Description    : Enables or disables the Prefetch Buffer.
    119          * Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    120          *                    This parameter can be one of the following values:
    121          *                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    122          *                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
    127          {
    128            /* Check the parameters */
    129            assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    130            
    131            /* Enable or disable the Prefetch Buffer */
    132            FLASH->ACR &= ACR_PRFTBE_Mask;
   \                     FLASH_PrefetchBufferCmd:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF031 0x0110      BICS     R1,R1,#0x10
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    133            FLASH->ACR |= FLASH_PrefetchBuffer;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40022000
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4301             ORRS     R1,R0,R1
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x40022000
   \   0000001C   0x6011             STR      R1,[R2, #+0]
    134          }
   \   0000001E   0x4770             BX       LR               ;; return
    135          
    136          #ifdef _FLASH_PROG
    137          /*******************************************************************************
    138          * Function Name  : FLASH_Unlock
    139          * Description    : Unlocks the FLASH Program Erase Controller.
    140          * Input          : None
    141          * Output         : None
    142          * Return         : None
    143          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          void FLASH_Unlock(void)
    145          {
    146            /* Authorize the FPEC Access */
    147            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_Unlock:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21_1  ;; 0x40022004
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable21_2  ;; 0x45670123
   \   00000008   0x6001             STR      R1,[R0, #+0]
    148            FLASH->KEYR = FLASH_KEY2;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable21_1  ;; 0x40022004
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000012   0x6001             STR      R1,[R0, #+0]
    149          }
   \   00000014   0x4770             BX       LR               ;; return
    150          
    151          /*******************************************************************************
    152          * Function Name  : FLASH_Lock
    153          * Description    : Locks the FLASH Program Erase Controller.
    154          * Input          : None
    155          * Output         : None
    156          * Return         : None
    157          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    158          void FLASH_Lock(void)
    159          {
    160            /* Set the Lock Bit to lock the FPEC and the FCR */
    161            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_Lock:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    162          }
   \   00000010   0x4770             BX       LR               ;; return
    163          
    164          /*******************************************************************************
    165          * Function Name  : FLASH_ErasePage
    166          * Description    : Erases a specified FLASH page.
    167          * Input          : - Page_Address: The page address to be erased.
    168          * Output         : None
    169          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    170          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    171          *                  FLASH_TIMEOUT.
    172          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          FLASH_Status FLASH_ErasePage(u32 Page_Address)
    174          {
   \                     FLASH_ErasePage:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    175            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    176          
    177            /* Check the parameters */
    178            assert_param(IS_FLASH_ADDRESS(Page_Address));
    179          
    180            /* Wait for last operation to be completed */
    181            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000006   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0005             MOVS     R5,R0
    182            
    183            if(status == FLASH_COMPLETE)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD123             BNE.N    ??FLASH_ErasePage_0
    184            { 
    185              /* if the previous operation is completed, proceed to erase the page */
    186              FLASH->CR|= CR_PER_Set;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000024   0x6008             STR      R0,[R1, #+0]
    187              FLASH->AR = Page_Address; 
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable21_5  ;; 0x40022014
   \   0000002A   0x6004             STR      R4,[R0, #+0]
    188              FLASH->CR|= CR_STRT_Set;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    189              
    190              /* Wait for last operation to be completed */
    191              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   0000003C   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000040   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000044   0x0005             MOVS     R5,R0
    192          
    193              if(status != FLASH_BUSY)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xD008             BEQ.N    ??FLASH_ErasePage_0
    194              {
    195                /* if the erase operation is completed, disable the PER Bit */
    196                FLASH->CR &= CR_PER_Reset;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF641 0x71FD      MOVW     R1,#+8189
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    197              }
    198            }
    199            /* Return the Erase Status */
    200            return status;
   \                     ??FLASH_ErasePage_0:
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    201          }
    202          
    203          /*******************************************************************************
    204          * Function Name  : FLASH_EraseAllPages
    205          * Description    : Erases all FLASH pages.
    206          * Input          : None
    207          * Output         : None
    208          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    209          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    210          *                  FLASH_TIMEOUT.
    211          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    212          FLASH_Status FLASH_EraseAllPages(void)
    213          {
   \                     FLASH_EraseAllPages:
   \   00000000   0xB510             PUSH     {R4,LR}
    214            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2404             MOVS     R4,#+4
    215          
    216            /* Wait for last operation to be completed */
    217            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000004   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000C   0x0004             MOVS     R4,R0
    218            
    219            if(status == FLASH_COMPLETE)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD120             BNE.N    ??FLASH_EraseAllPages_0
    220            {
    221              /* if the previous operation is completed, proceed to erase all pages */
    222               FLASH->CR |= CR_MER_Set;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000022   0x6008             STR      R0,[R1, #+0]
    223               FLASH->CR |= CR_STRT_Set;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000032   0x6008             STR      R0,[R1, #+0]
    224              
    225              /* Wait for last operation to be completed */
    226              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000034   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003C   0x0004             MOVS     R4,R0
    227          
    228              if(status != FLASH_BUSY)
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD008             BEQ.N    ??FLASH_EraseAllPages_0
    229              {
    230                /* if the erase operation is completed, disable the MER Bit */
    231                FLASH->CR &= CR_MER_Reset;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF641 0x71FB      MOVW     R1,#+8187
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000054   0x6008             STR      R0,[R1, #+0]
    232              }
    233            }	   
    234            /* Return the Erase Status */
    235            return status;
   \                     ??FLASH_EraseAllPages_0:
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    236          }
    237          
    238          /*******************************************************************************
    239          * Function Name  : FLASH_EraseOptionBytes
    240          * Description    : Erases the FLASH option bytes.
    241          * Input          : None
    242          * Output         : None
    243          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    244          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    245          *                  FLASH_TIMEOUT.
    246          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          FLASH_Status FLASH_EraseOptionBytes(void)
    248          {
   \                     FLASH_EraseOptionBytes:
   \   00000000   0xB510             PUSH     {R4,LR}
    249            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2404             MOVS     R4,#+4
    250            
    251            /* Wait for last operation to be completed */
    252            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000004   0xF640 0x70FF      MOVW     R0,#+4095
   \   00000008   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000C   0x0004             MOVS     R4,R0
    253          
    254            if(status == FLASH_COMPLETE)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD153             BNE.N    ??FLASH_EraseOptionBytes_0
    255            {
    256              /* Authorize the small information block programming */
    257              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x40022008
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable21_2  ;; 0x45670123
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    258              FLASH->OPTKEYR = FLASH_KEY2;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x40022008
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000026   0x6001             STR      R1,[R0, #+0]
    259              
    260              /* if the previous operation is completed, proceed to erase the option bytes */
    261              FLASH->CR |= CR_OPTER_Set;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000036   0x6008             STR      R0,[R1, #+0]
    262              FLASH->CR |= CR_STRT_Set;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000046   0x6008             STR      R0,[R1, #+0]
    263          
    264              /* Wait for last operation to be completed */
    265              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000048   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000004C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000050   0x0004             MOVS     R4,R0
    266              
    267              if(status == FLASH_COMPLETE)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C04             CMP      R4,#+4
   \   00000056   0xD125             BNE.N    ??FLASH_EraseOptionBytes_1
    268              {
    269                /* if the erase operation is completed, disable the OPTER Bit */
    270                FLASH->CR &= CR_OPTER_Reset;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF641 0x71DF      MOVW     R1,#+8159
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000068   0x6008             STR      R0,[R1, #+0]
    271                 
    272                /* Enable the Option Bytes Programming operation */
    273                FLASH->CR |= CR_OPTPG_Set;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000078   0x6008             STR      R0,[R1, #+0]
    274          
    275                /* Enable the readout access */
    276                OB->RDP= RDP_Key; 
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable21_7  ;; 0x1ffff800
   \   0000007E   0x21A5             MOVS     R1,#+165
   \   00000080   0x8001             STRH     R1,[R0, #+0]
    277          
    278                /* Wait for last operation to be completed */
    279                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000082   0x200F             MOVS     R0,#+15
   \   00000084   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000088   0x0004             MOVS     R4,R0
    280           
    281                if(status != FLASH_BUSY)
   \   0000008A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   0x2C01             CMP      R4,#+1
   \   0000008E   0xD015             BEQ.N    ??FLASH_EraseOptionBytes_0
    282                {
    283                  /* if the program operation is completed, disable the OPTPG Bit */
    284                  FLASH->CR &= CR_OPTPG_Reset;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF641 0x71EF      MOVW     R1,#+8175
   \   0000009A   0x4008             ANDS     R0,R1,R0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0xE00B             B.N      ??FLASH_EraseOptionBytes_0
    285                }
    286              }
    287              else
    288              {
    289                if (status != FLASH_BUSY)
   \                     ??FLASH_EraseOptionBytes_1:
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x2C01             CMP      R4,#+1
   \   000000A8   0xD008             BEQ.N    ??FLASH_EraseOptionBytes_0
    290                {
    291                  /* Disable the OPTPG Bit */
    292                  FLASH->CR &= CR_OPTPG_Reset;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF641 0x71EF      MOVW     R1,#+8175
   \   000000B4   0x4008             ANDS     R0,R1,R0
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    293                }
    294              }  
    295            }
    296            /* Return the erase status */
    297            return status;
   \                     ??FLASH_EraseOptionBytes_0:
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xBD10             POP      {R4,PC}          ;; return
    298          }
    299          
    300          /*******************************************************************************
    301          * Function Name  : FLASH_ProgramWord
    302          * Description    : Programs a word at a specified address.
    303          * Input          : - Address: specifies the address to be programmed.
    304          *                  - Data: specifies the data to be programmed.
    305          * Output         : None
    306          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    307          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    308          *                  FLASH_TIMEOUT. 
    309          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
    311          {
   \                     FLASH_ProgramWord:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    312            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    313          
    314            /* Check the parameters */
    315            assert_param(IS_FLASH_ADDRESS(Address));
    316          
    317            /* Wait for last operation to be completed */
    318            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0006             MOVS     R6,R0
    319            
    320            if(status == FLASH_COMPLETE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E04             CMP      R6,#+4
   \   00000014   0xD12E             BNE.N    ??FLASH_ProgramWord_0
    321            {
    322              /* if the previous operation is completed, proceed to program the new first 
    323              half word */
    324              FLASH->CR |= CR_PG_Set;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000024   0x6008             STR      R0,[R1, #+0]
    325            
    326              *(vu16*)Address = (u16)Data;
   \   00000026   0x8025             STRH     R5,[R4, #+0]
    327          
    328              /* Wait for last operation to be completed */
    329              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000028   0x200F             MOVS     R0,#+15
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
    330           
    331              if(status == FLASH_COMPLETE)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E04             CMP      R6,#+4
   \   00000034   0xD112             BNE.N    ??FLASH_ProgramWord_1
    332              {
    333                /* if the previous operation is completed, proceed to program the new second 
    334                half word */
    335                *(vu16*)(Address + 2) = Data >> 16;
   \   00000036   0x0C28             LSRS     R0,R5,#+16
   \   00000038   0x8060             STRH     R0,[R4, #+2]
    336              
    337                /* Wait for last operation to be completed */
    338                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000003A   0x200F             MOVS     R0,#+15
   \   0000003C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000040   0x0006             MOVS     R6,R0
    339                  
    340                if(status != FLASH_BUSY)
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E01             CMP      R6,#+1
   \   00000046   0xD015             BEQ.N    ??FLASH_ProgramWord_0
    341                {
    342                  /* Disable the PG Bit */
    343                  FLASH->CR &= CR_PG_Reset;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF641 0x71FE      MOVW     R1,#+8190
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0xE00B             B.N      ??FLASH_ProgramWord_0
    344                }
    345              }
    346              else
    347              {
    348                if (status != FLASH_BUSY)
   \                     ??FLASH_ProgramWord_1:
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD008             BEQ.N    ??FLASH_ProgramWord_0
    349                {
    350                  /* Disable the PG Bit */
    351                  FLASH->CR &= CR_PG_Reset;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF641 0x71FE      MOVW     R1,#+8190
   \   0000006C   0x4008             ANDS     R0,R1,R0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000072   0x6008             STR      R0,[R1, #+0]
    352                }
    353               }
    354            }
    355            /* Return the Program Status */
    356            return status;
   \                     ??FLASH_ProgramWord_0:
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    357          }
    358          
    359          /*******************************************************************************
    360          * Function Name  : FLASH_ProgramHalfWord
    361          * Description    : Programs a half word at a specified address.
    362          * Input          : - Address: specifies the address to be programmed.
    363          *                  - Data: specifies the data to be programmed.
    364          * Output         : None
    365          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    366          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    367          *                  FLASH_TIMEOUT. 
    368          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    369          FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
    370          {
   \                     FLASH_ProgramHalfWord:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    371            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    372          
    373            /* Check the parameters */
    374            assert_param(IS_FLASH_ADDRESS(Address));
    375          
    376            /* Wait for last operation to be completed */
    377            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0006             MOVS     R6,R0
    378            
    379            if(status == FLASH_COMPLETE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E04             CMP      R6,#+4
   \   00000014   0xD118             BNE.N    ??FLASH_ProgramHalfWord_0
    380            {
    381              /* if the previous operation is completed, proceed to program the new data */
    382              FLASH->CR |= CR_PG_Set;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000024   0x6008             STR      R0,[R1, #+0]
    383            
    384              *(vu16*)Address = Data;
   \   00000026   0x8025             STRH     R5,[R4, #+0]
    385              /* Wait for last operation to be completed */
    386              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000028   0x200F             MOVS     R0,#+15
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
    387          
    388              if(status != FLASH_BUSY)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E01             CMP      R6,#+1
   \   00000034   0xD008             BEQ.N    ??FLASH_ProgramHalfWord_0
    389              {
    390                /* if the program operation is completed, disable the PG Bit */
    391                FLASH->CR &= CR_PG_Reset;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x40022010
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF641 0x71FE      MOVW     R1,#+8190
   \   00000040   0x4008             ANDS     R0,R1,R0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x40022010
   \   00000046   0x6008             STR      R0,[R1, #+0]
    392              }
    393            } 
    394            /* Return the Program Status */
    395            return status;
   \                     ??FLASH_ProgramHalfWord_0:
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    396          }
    397          
    398          /*******************************************************************************
    399          * Function Name  : FLASH_ProgramOptionByteData
    400          * Description    : Programs a half word at a specified Option Byte Data address.
    401          * Input          : - Address: specifies the address to be programmed.
    402          *                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    403          *                  - Data: specifies the data to be programmed.
    404          * Output         : None
    405          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    406          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    407          *                  FLASH_TIMEOUT. 
    408          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    409          FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
    410          {
   \                     FLASH_ProgramOptionByteData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    411            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    412          
    413            /* Check the parameters */
    414            assert_param(IS_OB_DATA_ADDRESS(Address));
    415          
    416            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0006             MOVS     R6,R0
    417          
    418            if(status == FLASH_COMPLETE)
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E04             CMP      R6,#+4
   \   00000014   0xD11D             BNE.N    ??FLASH_ProgramOptionByteData_0
    419            {
    420              /* Authorize the small information block programming */
    421              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x40022008
   \   0000001A   0x....             LDR.N    R1,??DataTable21_2  ;; 0x45670123
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    422              FLASH->OPTKEYR = FLASH_KEY2;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x40022008
   \   00000022   0x....             LDR.N    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000024   0x6001             STR      R1,[R0, #+0]
    423          
    424              /* Enables the Option Bytes Programming operation */
    425              FLASH->CR |= CR_OPTPG_Set; 
   \   00000026   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002E   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000030   0x6008             STR      R0,[R1, #+0]
    426              *(vu16*)Address = Data;
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x8025             STRH     R5,[R4, #+0]
    427              
    428              /* Wait for last operation to be completed */
    429              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000036   0x200F             MOVS     R0,#+15
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003C   0x0006             MOVS     R6,R0
    430          
    431              if(status != FLASH_BUSY)
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E01             CMP      R6,#+1
   \   00000042   0xD006             BEQ.N    ??FLASH_ProgramOptionByteData_0
    432              {
    433                /* if the program operation is completed, disable the OPTPG Bit */
    434                FLASH->CR &= CR_OPTPG_Reset;
   \   00000044   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF641 0x71EF      MOVW     R1,#+8175
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000050   0x6008             STR      R0,[R1, #+0]
    435              }
    436            }    
    437            /* Return the Option Byte Data Program Status */
    438            return status;      
   \                     ??FLASH_ProgramOptionByteData_0:
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    439          }
    440          
    441          /*******************************************************************************
    442          * Function Name  : FLASH_EnableWriteProtection
    443          * Description    : Write protects the desired pages
    444          * Input          : - FLASH_Pages: specifies the address of the pages to be 
    445          *                    write protected. This parameter can be:
    446          *                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
    447          *                       - A value between FLASH_WRProt_Pages0to3 and 
    448          *                         FLASH_WRProt_Pages124to127
    449          *                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
    450          *                       - A value between FLASH_WRProt_Pages0to1 and
    451          *                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
    452          *                       - FLASH_WRProt_AllPages
    453          *                    - For STM32F10Xxx Connectivity devices (FLASH page size equal to 2 KB) 
    454          *                       - A value between FLASH_WRProt_Pages0to1 and
    455          *                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127 
    456          *                       - FLASH_WRProt_AllPages
    457          * Output         : None
    458          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    459          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    460          *                  FLASH_TIMEOUT.
    461          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    462          FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
    463          {
   \                     FLASH_EnableWriteProtection:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    464            u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
   \   00000006   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000000A   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000E   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000012   0xF64F 0x77FF      MOVW     R7,#+65535
    465            
    466            FLASH_Status status = FLASH_COMPLETE;
   \   00000016   0xF05F 0x0804      MOVS     R8,#+4
    467            
    468            /* Check the parameters */
    469            assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    470            
    471            FLASH_Pages = (u32)(~FLASH_Pages);
   \   0000001A   0xEA7F 0x0909      MVNS     R9,R9
    472            WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
   \   0000001E   0xF019 0x00FF      ANDS     R0,R9,#0xFF
   \   00000022   0x0004             MOVS     R4,R0
    473            WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
   \   00000024   0xF3C9 0x2007      UBFX     R0,R9,#+8,#+8
   \   00000028   0x0005             MOVS     R5,R0
    474            WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
   \   0000002A   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x0006             MOVS     R6,R0
    475            WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
   \   00000032   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   00000036   0x0007             MOVS     R7,R0
    476            
    477            /* Wait for last operation to be completed */
    478            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000038   0x200F             MOVS     R0,#+15
   \   0000003A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003E   0x4680             MOV      R8,R0
    479            
    480            if(status == FLASH_COMPLETE)
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000048   0xD14A             BNE.N    ??FLASH_EnableWriteProtection_0
    481            {
    482              /* Authorizes the small information block programming */
    483              FLASH->OPTKEYR = FLASH_KEY1;
   \   0000004A   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   0000004C   0x....             LDR.N    R1,??DataTable21_2  ;; 0x45670123
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    484              FLASH->OPTKEYR = FLASH_KEY2;
   \   00000050   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   00000052   0x....             LDR.N    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000054   0x6001             STR      R1,[R0, #+0]
    485              FLASH->CR |= CR_OPTPG_Set;
   \   00000056   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005E   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000060   0x6008             STR      R0,[R1, #+0]
    486          
    487              if(WRP0_Data != 0xFF)
   \   00000062   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000064   0x2CFF             CMP      R4,#+255
   \   00000066   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_1
    488              {
    489                OB->WRP0 = WRP0_Data;
   \   00000068   0x....             LDR.N    R0,??DataTable21_8  ;; 0x1ffff808
   \   0000006A   0x8004             STRH     R4,[R0, #+0]
    490                
    491                /* Wait for last operation to be completed */
    492                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000006C   0x200F             MOVS     R0,#+15
   \   0000006E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000072   0x4680             MOV      R8,R0
    493              }
    494              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_1:
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0xF1B8 0x0F04      CMP      R8,#+4
   \   0000007C   0xD108             BNE.N    ??FLASH_EnableWriteProtection_2
   \   0000007E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000080   0x2DFF             CMP      R5,#+255
   \   00000082   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_2
    495              {
    496                OB->WRP1 = WRP1_Data;
   \   00000084   0x....             LDR.N    R0,??DataTable21_9  ;; 0x1ffff80a
   \   00000086   0x8005             STRH     R5,[R0, #+0]
    497                
    498                /* Wait for last operation to be completed */
    499                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000088   0x200F             MOVS     R0,#+15
   \   0000008A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000008E   0x4680             MOV      R8,R0
    500              }
    501          
    502              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_2:
   \   00000090   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000094   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000098   0xD108             BNE.N    ??FLASH_EnableWriteProtection_3
   \   0000009A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009C   0x2EFF             CMP      R6,#+255
   \   0000009E   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_3
    503              {
    504                OB->WRP2 = WRP2_Data;
   \   000000A0   0x....             LDR.N    R0,??DataTable21_10  ;; 0x1ffff80c
   \   000000A2   0x8006             STRH     R6,[R0, #+0]
    505                
    506                /* Wait for last operation to be completed */
    507                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   000000A4   0x200F             MOVS     R0,#+15
   \   000000A6   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000AA   0x4680             MOV      R8,R0
    508              }
    509              
    510              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_3:
   \   000000AC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B0   0xF1B8 0x0F04      CMP      R8,#+4
   \   000000B4   0xD108             BNE.N    ??FLASH_EnableWriteProtection_4
   \   000000B6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000B8   0x2FFF             CMP      R7,#+255
   \   000000BA   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_4
    511              {
    512                OB->WRP3 = WRP3_Data;
   \   000000BC   0x....             LDR.N    R0,??DataTable21_11  ;; 0x1ffff80e
   \   000000BE   0x8007             STRH     R7,[R0, #+0]
    513               
    514                /* Wait for last operation to be completed */
    515                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   000000C0   0x200F             MOVS     R0,#+15
   \   000000C2   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000C6   0x4680             MOV      R8,R0
    516              }
    517                    
    518              if(status != FLASH_BUSY)
   \                     ??FLASH_EnableWriteProtection_4:
   \   000000C8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CC   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000D0   0xD006             BEQ.N    ??FLASH_EnableWriteProtection_0
    519              {
    520                /* if the program operation is completed, disable the OPTPG Bit */
    521                FLASH->CR &= CR_OPTPG_Reset;
   \   000000D2   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0xF641 0x71EF      MOVW     R1,#+8175
   \   000000DA   0x4008             ANDS     R0,R1,R0
   \   000000DC   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    522              }
    523            } 
    524            /* Return the write protection operation Status */
    525            return status;       
   \                     ??FLASH_EnableWriteProtection_0:
   \   000000E0   0x4640             MOV      R0,R8
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    526          }
    527          
    528          /*******************************************************************************
    529          * Function Name  : FLASH_ReadOutProtection
    530          * Description    : Enables or disables the read out protection.
    531          *                  If the user has already programmed the other option bytes before 
    532          *                  calling this function, he must re-program them since this 
    533          *                  function erases all option bytes.
    534          * Input          : - Newstate: new state of the ReadOut Protection.
    535          *                    This parameter can be: ENABLE or DISABLE.
    536          * Output         : None
    537          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    538          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    539          *                  FLASH_TIMEOUT.
    540          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    541          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
    542          {
   \                     FLASH_ReadOutProtection:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    543            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    544          
    545            /* Check the parameters */
    546            assert_param(IS_FUNCTIONAL_STATE(NewState));
    547          
    548            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000006   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0005             MOVS     R5,R0
    549          
    550            if(status == FLASH_COMPLETE)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD14A             BNE.N    ??FLASH_ReadOutProtection_0
    551            {
    552              /* Authorizes the small information block programming */
    553              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000016   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   00000018   0x....             LDR.N    R1,??DataTable21_2  ;; 0x45670123
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    554              FLASH->OPTKEYR = FLASH_KEY2;
   \   0000001C   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   0000001E   0x....             LDR.N    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000020   0x6001             STR      R1,[R0, #+0]
    555          
    556              FLASH->CR |= CR_OPTER_Set;
   \   00000022   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002A   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    557              FLASH->CR |= CR_STRT_Set;
   \   0000002E   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000036   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000038   0x6008             STR      R0,[R1, #+0]
    558          
    559              /* Wait for last operation to be completed */
    560              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   0000003A   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000003E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000042   0x0005             MOVS     R5,R0
    561          
    562              if(status == FLASH_COMPLETE)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D04             CMP      R5,#+4
   \   00000048   0xD126             BNE.N    ??FLASH_ReadOutProtection_1
    563              {
    564                /* if the erase operation is completed, disable the OPTER Bit */
    565                FLASH->CR &= CR_OPTER_Reset;
   \   0000004A   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF641 0x71DF      MOVW     R1,#+8159
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000056   0x6008             STR      R0,[R1, #+0]
    566          
    567                /* Enable the Option Bytes Programming operation */
    568                FLASH->CR |= CR_OPTPG_Set; 
   \   00000058   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000060   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000062   0x6008             STR      R0,[R1, #+0]
    569          
    570                if(NewState != DISABLE)
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD003             BEQ.N    ??FLASH_ReadOutProtection_2
    571                {
    572                  OB->RDP = 0x00;
   \   0000006A   0x....             LDR.N    R0,??DataTable21_7  ;; 0x1ffff800
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x8001             STRH     R1,[R0, #+0]
   \   00000070   0xE002             B.N      ??FLASH_ReadOutProtection_3
    573                }
    574                else
    575                {
    576                  OB->RDP = RDP_Key;  
   \                     ??FLASH_ReadOutProtection_2:
   \   00000072   0x....             LDR.N    R0,??DataTable21_7  ;; 0x1ffff800
   \   00000074   0x21A5             MOVS     R1,#+165
   \   00000076   0x8001             STRH     R1,[R0, #+0]
    577                }
    578          
    579                /* Wait for last operation to be completed */
    580                status = FLASH_WaitForLastOperation(EraseTimeout); 
   \                     ??FLASH_ReadOutProtection_3:
   \   00000078   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000007C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000080   0x0005             MOVS     R5,R0
    581              
    582                if(status != FLASH_BUSY)
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D01             CMP      R5,#+1
   \   00000086   0xD011             BEQ.N    ??FLASH_ReadOutProtection_0
    583                {
    584                  /* if the program operation is completed, disable the OPTPG Bit */
    585                  FLASH->CR &= CR_OPTPG_Reset;
   \   00000088   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF641 0x71EF      MOVW     R1,#+8175
   \   00000090   0x4008             ANDS     R0,R1,R0
   \   00000092   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000094   0x6008             STR      R0,[R1, #+0]
   \   00000096   0xE009             B.N      ??FLASH_ReadOutProtection_0
    586                }
    587              }
    588              else 
    589              {
    590                if(status != FLASH_BUSY)
   \                     ??FLASH_ReadOutProtection_1:
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0x2D01             CMP      R5,#+1
   \   0000009C   0xD006             BEQ.N    ??FLASH_ReadOutProtection_0
    591                {
    592                  /* Disable the OPTER Bit */
    593                  FLASH->CR &= CR_OPTER_Reset;
   \   0000009E   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF641 0x71DF      MOVW     R1,#+8159
   \   000000A6   0x4008             ANDS     R0,R1,R0
   \   000000A8   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    594                }
    595              }
    596            }
    597            /* Return the protection operation Status */
    598            return status;      
   \                     ??FLASH_ReadOutProtection_0:
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    599          }
    600            	
    601          /*******************************************************************************
    602          * Function Name  : FLASH_UserOptionByteConfig
    603          * Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
    604          *                  RST_STDBY.
    605          * Input          : - OB_IWDG: Selects the IWDG mode
    606          *                     This parameter can be one of the following values:
    607          *                     - OB_IWDG_SW: Software IWDG selected
    608          *                     - OB_IWDG_HW: Hardware IWDG selected
    609          *                  - OB_STOP: Reset event when entering STOP mode.
    610          *                     This parameter can be one of the following values:
    611          *                     - OB_STOP_NoRST: No reset generated when entering in STOP
    612          *                     - OB_STOP_RST: Reset generated when entering in STOP
    613          *                  - OB_STDBY: Reset event when entering Standby mode.
    614          *                    This parameter can be one of the following values:
    615          *                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
    616          *                     - OB_STDBY_RST: Reset generated when entering in STANDBY
    617          * Output         : None
    618          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    619          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    620          *                  FLASH_TIMEOUT.
    621          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
    623          {
   \                     FLASH_UserOptionByteConfig:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    624            FLASH_Status status = FLASH_COMPLETE; 
   \   00000008   0x2704             MOVS     R7,#+4
    625          
    626            /* Check the parameters */
    627            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    628            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    629            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    630          
    631            /* Authorize the small information block programming */
    632            FLASH->OPTKEYR = FLASH_KEY1;
   \   0000000A   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   0000000C   0x....             LDR.N    R1,??DataTable21_2  ;; 0x45670123
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    633            FLASH->OPTKEYR = FLASH_KEY2;
   \   00000010   0x....             LDR.N    R0,??DataTable21_6  ;; 0x40022008
   \   00000012   0x....             LDR.N    R1,??DataTable21_3  ;; 0xcdef89ab
   \   00000014   0x6001             STR      R1,[R0, #+0]
    634            
    635            /* Wait for last operation to be completed */
    636            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000001C   0x0007             MOVS     R7,R0
    637            
    638            if(status == FLASH_COMPLETE)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F04             CMP      R7,#+4
   \   00000022   0xD11A             BNE.N    ??FLASH_UserOptionByteConfig_0
    639            {  
    640              /* Enable the Option Bytes Programming operation */
    641              FLASH->CR |= CR_OPTPG_Set; 
   \   00000024   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002C   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    642                     
    643              OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
   \   00000030   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000034   0x4330             ORRS     R0,R6,R0
   \   00000036   0xF050 0x00F8      ORRS     R0,R0,#0xF8
   \   0000003A   0x....             LDR.N    R1,??DataTable21_12  ;; 0x1ffff802
   \   0000003C   0x8008             STRH     R0,[R1, #+0]
    644            
    645              /* Wait for last operation to be completed */
    646              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000003E   0x200F             MOVS     R0,#+15
   \   00000040   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000044   0x0007             MOVS     R7,R0
    647          
    648              if(status != FLASH_BUSY)
   \   00000046   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000048   0x2F01             CMP      R7,#+1
   \   0000004A   0xD006             BEQ.N    ??FLASH_UserOptionByteConfig_0
    649              {
    650                /* if the program operation is completed, disable the OPTPG Bit */
    651                FLASH->CR &= CR_OPTPG_Reset;
   \   0000004C   0x....             LDR.N    R0,??DataTable21_4  ;; 0x40022010
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF641 0x71EF      MOVW     R1,#+8175
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x....             LDR.N    R1,??DataTable21_4  ;; 0x40022010
   \   00000058   0x6008             STR      R0,[R1, #+0]
    652              }
    653            }    
    654            /* Return the Option Byte program Status */
    655            return status;
   \                     ??FLASH_UserOptionByteConfig_0:
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    656          }
    657          
    658          /*******************************************************************************
    659          * Function Name  : FLASH_GetUserOptionByte
    660          * Description    : Returns the FLASH User Option Bytes values.
    661          * Input          : None
    662          * Output         : None
    663          * Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    664          *                  and RST_STDBY(Bit2).
    665          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    666          u32 FLASH_GetUserOptionByte(void)
    667          {
    668            /* Return the User Option Byte */
    669            return (u32)(FLASH->OBR >> 2);
   \                     FLASH_GetUserOptionByte:
   \   00000000   0x....             LDR.N    R0,??DataTable21_13  ;; 0x4002201c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0880             LSRS     R0,R0,#+2
   \   00000006   0x4770             BX       LR               ;; return
    670          }
    671          
    672          /*******************************************************************************
    673          * Function Name  : FLASH_GetWriteProtectionOptionByte
    674          * Description    : Returns the FLASH Write Protection Option Bytes Register value.
    675          * Input          : None
    676          * Output         : None
    677          * Return         : The FLASH Write Protection  Option Bytes Register value
    678          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    679          u32 FLASH_GetWriteProtectionOptionByte(void)
    680          {
    681            /* Return the Falsh write protection Register value */
    682            return (u32)(FLASH->WRPR);
   \                     FLASH_GetWriteProtectionOptionByte:
   \   00000000   0x....             LDR.N    R0,??DataTable21_14  ;; 0x40022020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    683          }
    684          
    685          /*******************************************************************************
    686          * Function Name  : FLASH_GetReadOutProtectionStatus
    687          * Description    : Checks whether the FLASH Read Out Protection Status is set 
    688          *                  or not.
    689          * Input          : None
    690          * Output         : None
    691          * Return         : FLASH ReadOut Protection Status(SET or RESET)
    692          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          FlagStatus FLASH_GetReadOutProtectionStatus(void)
    694          {
    695            FlagStatus readoutstatus = RESET;
   \                     FLASH_GetReadOutProtectionStatus:
   \   00000000   0x2000             MOVS     R0,#+0
    696          
    697            if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable21_13  ;; 0x4002201c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0789             LSLS     R1,R1,#+30
   \   00000008   0xD502             BPL.N    ??FLASH_GetReadOutProtectionStatus_0
    698            {
    699              readoutstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE001             B.N      ??FLASH_GetReadOutProtectionStatus_1
    700            }
    701            else
    702            {
    703              readoutstatus = RESET;
   \                     ??FLASH_GetReadOutProtectionStatus_0:
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x0008             MOVS     R0,R1
    704            }
    705            return readoutstatus;
   \                     ??FLASH_GetReadOutProtectionStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    706          }
    707          
    708          /*******************************************************************************
    709          * Function Name  : FLASH_GetPrefetchBufferStatus
    710          * Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
    711          * Input          : None
    712          * Output         : None
    713          * Return         : FLASH Prefetch Buffer Status (SET or RESET).
    714          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    715          FlagStatus FLASH_GetPrefetchBufferStatus(void)
    716          {
    717            FlagStatus bitstatus = RESET;
   \                     FLASH_GetPrefetchBufferStatus:
   \   00000000   0x2000             MOVS     R0,#+0
    718            
    719            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable21  ;; 0x40022000
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0689             LSLS     R1,R1,#+26
   \   00000008   0xD502             BPL.N    ??FLASH_GetPrefetchBufferStatus_0
    720            {
    721              bitstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE001             B.N      ??FLASH_GetPrefetchBufferStatus_1
    722            }
    723            else
    724            {
    725              bitstatus = RESET;
   \                     ??FLASH_GetPrefetchBufferStatus_0:
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x0008             MOVS     R0,R1
    726            }
    727            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
    728            return bitstatus; 
   \                     ??FLASH_GetPrefetchBufferStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    729          }
    730          
    731          /*******************************************************************************
    732          * Function Name  : FLASH_ITConfig
    733          * Description    : Enables or disables the specified FLASH interrupts.
    734          * Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
    735          *                    enabled or disabled.
    736          *                    This parameter can be any combination of the following values:
    737          *                       - FLASH_IT_ERROR: FLASH Error Interrupt
    738          *                       - FLASH_IT_EOP: FLASH end of operation Interrupt
    739          * Output         : None
    740          * Return         : None 
    741          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    742          void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
    743          {
    744            /* Check the parameters */
    745            assert_param(IS_FLASH_IT(FLASH_IT)); 
    746            assert_param(IS_FUNCTIONAL_STATE(NewState));
    747          
    748            if(NewState != DISABLE)
   \                     FLASH_ITConfig:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD006             BEQ.N    ??FLASH_ITConfig_0
    749            {
    750              /* Enable the interrupt sources */
    751              FLASH->CR |= FLASH_IT;
   \   00000006   0x....             LDR.N    R2,??DataTable21_4  ;; 0x40022010
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4302             ORRS     R2,R0,R2
   \   0000000E   0x....             LDR.N    R3,??DataTable21_4  ;; 0x40022010
   \   00000010   0x601A             STR      R2,[R3, #+0]
   \   00000012   0xE005             B.N      ??FLASH_ITConfig_1
    752            }
    753            else
    754            {
    755              /* Disable the interrupt sources */
    756              FLASH->CR &= ~(u32)FLASH_IT;
   \                     ??FLASH_ITConfig_0:
   \   00000014   0x....             LDR.N    R2,??DataTable21_4  ;; 0x40022010
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x4382             BICS     R2,R2,R0
   \   0000001C   0x....             LDR.N    R3,??DataTable21_4  ;; 0x40022010
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    757            }
    758          }
   \                     ??FLASH_ITConfig_1:
   \   00000020   0x4770             BX       LR               ;; return
    759          
    760          /*******************************************************************************
    761          * Function Name  : FLASH_GetFlagStatus
    762          * Description    : Checks whether the specified FLASH flag is set or not.
    763          * Input          : - FLASH_FLAG: specifies the FLASH flag to check.
    764          *                     This parameter can be one of the following values:
    765          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    766          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    767          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    768          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    769          *                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
    770          * Output         : None
    771          * Return         : The new state of FLASH_FLAG (SET or RESET).
    772          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    773          FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
    774          {
   \                     FLASH_GetFlagStatus:
   \   00000000   0x0001             MOVS     R1,R0
    775            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    776          
    777            /* Check the parameters */
    778            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
    779          
    780            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD109             BNE.N    ??FLASH_GetFlagStatus_0
    781            {
    782              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
   \   0000000A   0x....             LDR.N    R2,??DataTable21_13  ;; 0x4002201c
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x07D2             LSLS     R2,R2,#+31
   \   00000010   0xD502             BPL.N    ??FLASH_GetFlagStatus_1
    783              {
    784                bitstatus = SET;
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0010             MOVS     R0,R2
   \   00000016   0xE00C             B.N      ??FLASH_GetFlagStatus_2
    785              }
    786              else
    787              {
    788                bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_1:
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x0010             MOVS     R0,R2
   \   0000001C   0xE009             B.N      ??FLASH_GetFlagStatus_2
    789              }
    790            }
    791            else
    792            {
    793             if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
   \                     ??FLASH_GetFlagStatus_0:
   \   0000001E   0x....             LDR.N    R2,??DataTable21_15  ;; 0x4002200c
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   0x420A             TST      R2,R1
   \   00000026   0xD002             BEQ.N    ??FLASH_GetFlagStatus_3
    794              {
    795                bitstatus = SET;
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xE001             B.N      ??FLASH_GetFlagStatus_2
    796              }
    797              else
    798              {
    799                bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_3:
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x0010             MOVS     R0,R2
    800              }
    801            }
    802            /* Return the new state of FLASH_FLAG (SET or RESET) */
    803            return bitstatus;
   \                     ??FLASH_GetFlagStatus_2:
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x4770             BX       LR               ;; return
    804          }
    805          
    806          /*******************************************************************************
    807          * Function Name  : FLASH_ClearFlag
    808          * Description    : Clears the FLASHs pending flags.
    809          * Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
    810          *                    This parameter can be any combination of the following values:
    811          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    812          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    813          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    814          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    815          * Output         : None
    816          * Return         : None
    817          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    818          void FLASH_ClearFlag(u16 FLASH_FLAG)
    819          {
    820            /* Check the parameters */
    821            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
    822            
    823            /* Clear the flags */
    824            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag:
   \   00000000   0x....             LDR.N    R1,??DataTable21_15  ;; 0x4002200c
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x6008             STR      R0,[R1, #+0]
    825          }
   \   00000006   0x4770             BX       LR               ;; return
    826          
    827          /*******************************************************************************
    828          * Function Name  : FLASH_GetStatus
    829          * Description    : Returns the FLASH Status.
    830          * Input          : None
    831          * Output         : None
    832          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    833          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
    834          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    835          FLASH_Status FLASH_GetStatus(void)
    836          {
    837            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus:
   \   00000000   0x2004             MOVS     R0,#+4
    838            
    839            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable21_15  ;; 0x4002200c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x07C9             LSLS     R1,R1,#+31
   \   00000008   0xD502             BPL.N    ??FLASH_GetStatus_0
    840            {
    841              flashstatus = FLASH_BUSY;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE00F             B.N      ??FLASH_GetStatus_1
    842            }
    843            else 
    844            {  
    845              if(FLASH->SR & FLASH_FLAG_PGERR)
   \                     ??FLASH_GetStatus_0:
   \   00000010   0x....             LDR.N    R1,??DataTable21_15  ;; 0x4002200c
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x0749             LSLS     R1,R1,#+29
   \   00000016   0xD502             BPL.N    ??FLASH_GetStatus_2
    846              { 
    847                flashstatus = FLASH_ERROR_PG;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xE008             B.N      ??FLASH_GetStatus_1
    848              }
    849              else 
    850              {
    851                if(FLASH->SR & FLASH_FLAG_WRPRTERR)
   \                     ??FLASH_GetStatus_2:
   \   0000001E   0x....             LDR.N    R1,??DataTable21_15  ;; 0x4002200c
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x06C9             LSLS     R1,R1,#+27
   \   00000024   0xD502             BPL.N    ??FLASH_GetStatus_3
    852                {
    853                  flashstatus = FLASH_ERROR_WRP;
   \   00000026   0x2103             MOVS     R1,#+3
   \   00000028   0x0008             MOVS     R0,R1
   \   0000002A   0xE001             B.N      ??FLASH_GetStatus_1
    854                }
    855                else
    856                {
    857                  flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_3:
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x0008             MOVS     R0,R1
    858                }
    859              }
    860            }
    861            /* Return the Flash Status */
    862            return flashstatus;
   \                     ??FLASH_GetStatus_1:
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x4770             BX       LR               ;; return
    863          }
    864          
    865          /*******************************************************************************
    866          * Function Name  : FLASH_WaitForLastOperation
    867          * Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
    868          * Input          : - Timeout: FLASH progamming Timeout
    869          * Output         : None
    870          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    871          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    872          *                  FLASH_TIMEOUT.
    873          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    874          FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
    875          { 
   \                     FLASH_WaitForLastOperation:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    876            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    877             
    878            /* Check for the Flash Status */
    879            status = FLASH_GetStatus();
   \   00000006   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000A   0x0005             MOVS     R5,R0
    880          
    881            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
    882            while((status == FLASH_BUSY) && (Timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_0:
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD108             BNE.N    ??FLASH_WaitForLastOperation_1
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD006             BEQ.N    ??FLASH_WaitForLastOperation_1
    883            {
    884              delay();
   \   00000016   0x.... 0x....      BL       delay
    885              status = FLASH_GetStatus();
   \   0000001A   0x.... 0x....      BL       FLASH_GetStatus
   \   0000001E   0x0005             MOVS     R5,R0
    886              Timeout--;
   \   00000020   0x1E64             SUBS     R4,R4,#+1
   \   00000022   0xE7F3             B.N      ??FLASH_WaitForLastOperation_0
    887            }
    888          
    889            if(Timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_1:
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD101             BNE.N    ??FLASH_WaitForLastOperation_2
    890            {
    891              status = FLASH_TIMEOUT;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0x0005             MOVS     R5,R0
    892            }
    893          
    894            /* Return the operation status */
    895            return status;
   \                     ??FLASH_WaitForLastOperation_2:
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    896          }
    897          
    898          /*******************************************************************************
    899          * Function Name  : delay
    900          * Description    : Inserts a time delay.
    901          * Input          : None
    902          * Output         : None
    903          * Return         : None
    904          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    905          static void delay(void)
    906          {
   \                     delay:
   \   00000000   0xB081             SUB      SP,SP,#+4
    907            vu32 i = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    908          
    909            for(i = 0xFF; i != 0; i--)
   \   00000006   0x20FF             MOVS     R0,#+255
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \                     ??delay_0:
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??delay_1
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0xE7F8             B.N      ??delay_0
    910            {
    911            }
    912          }
   \                     ??delay_1:
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40022004         DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x40022010         DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x40022014         DC32     0x40022014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x40022008         DC32     0x40022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x1FFFF800         DC32     0x1ffff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x1FFFF808         DC32     0x1ffff808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x1FFFF80A         DC32     0x1ffff80a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x1FFFF80C         DC32     0x1ffff80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x1FFFF80E         DC32     0x1ffff80e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x1FFFF802         DC32     0x1ffff802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x4002201C         DC32     0x4002201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x40022020         DC32     0x40022020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x4002200C         DC32     0x4002200c
    913          #endif
    914          
    915          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
      32   FLASH_EnableWriteProtection
        32   -> FLASH_WaitForLastOperation
       8   FLASH_EraseAllPages
         8   -> FLASH_WaitForLastOperation
       8   FLASH_EraseOptionBytes
         8   -> FLASH_WaitForLastOperation
      16   FLASH_ErasePage
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetPrefetchBufferStatus
       0   FLASH_GetReadOutProtectionStatus
       0   FLASH_GetStatus
       0   FLASH_GetUserOptionByte
       0   FLASH_GetWriteProtectionOptionByte
       0   FLASH_HalfCycleAccessCmd
       0   FLASH_ITConfig
       0   FLASH_Lock
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramOptionByteData
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ReadOutProtection
        16   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
      24   FLASH_UserOptionByteConfig
        24   -> FLASH_WaitForLastOperation
      16   FLASH_WaitForLastOperation
        16   -> FLASH_GetStatus
        16   -> delay
       4   delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       8  FLASH_ClearFlag
     232  FLASH_EnableWriteProtection
      92  FLASH_EraseAllPages
     194  FLASH_EraseOptionBytes
     100  FLASH_ErasePage
      54  FLASH_GetFlagStatus
      24  FLASH_GetPrefetchBufferStatus
      24  FLASH_GetReadOutProtectionStatus
      52  FLASH_GetStatus
       8  FLASH_GetUserOptionByte
       6  FLASH_GetWriteProtectionOptionByte
      32  FLASH_HalfCycleAccessCmd
      34  FLASH_ITConfig
      18  FLASH_Lock
      32  FLASH_PrefetchBufferCmd
      78  FLASH_ProgramHalfWord
      88  FLASH_ProgramOptionByteData
     122  FLASH_ProgramWord
     178  FLASH_ReadOutProtection
      32  FLASH_SetLatency
      22  FLASH_Unlock
      96  FLASH_UserOptionByteConfig
      50  FLASH_WaitForLastOperation
      28  delay

 
 1 668 bytes in section .text
 
 1 668 bytes of CODE memory

Errors: none
Warnings: none

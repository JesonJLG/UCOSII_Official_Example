###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:22 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_time.c         #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_time.c" -D     #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_time.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_time.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_time.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             TIME MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TIME.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #include <ucos_ii.h>
     28          #endif
     29          
     30          /*
     31          *********************************************************************************************************
     32          *                                        DELAY TASK 'n' TICKS
     33          *
     34          * Description: This function is called to delay execution of the currently running task until the
     35          *              specified number of system ticks expires.  This, of course, directly equates to delaying
     36          *              the current task for some time to expire.  No delay will result If the specified delay is
     37          *              0.  If the specified delay is greater than 0 then, a context switch will result.
     38          *
     39          * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
     40          *                        Note that by specifying 0, the task will not be delayed.
     41          *
     42          * Returns    : none
     43          *********************************************************************************************************
     44          */
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void  OSTimeDly (INT32U ticks)
     47          {
   \                     OSTimeDly:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     48              INT8U      y;
     49          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     50              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
     51          #endif
     52          
     53          
     54          
     55              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   00000006   0x....             LDR.N    R0,??DataTable4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD12E             BNE.N    ??OSTimeDly_0
     56                  return;
     57              }
     58              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
   \                     ??OSTimeDly_1:
   \   0000000E   0x....             LDR.N    R0,??DataTable4_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD12A             BNE.N    ??OSTimeDly_0
     59                  return;
     60              }
     61              if (ticks > 0u) {                            /* 0 means no delay!                                  */
   \                     ??OSTimeDly_2:
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD028             BEQ.N    ??OSTimeDly_3
     62                  OS_ENTER_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0006             MOVS     R6,R0
     63                  y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
   \   00000020   0x....             LDR.N    R0,??DataTable4_2
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF890 0x0038      LDRB     R0,[R0, #+56]
   \   00000028   0x0005             MOVS     R5,R0
     64                  OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x....             LDR.N    R0,??DataTable4_3
   \   0000002E   0x5C28             LDRB     R0,[R5, R0]
   \   00000030   0x....             LDR.N    R1,??DataTable4_2
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0xF891 0x1039      LDRB     R1,[R1, #+57]
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x....             LDR.N    R1,??DataTable4_3
   \   0000003E   0x5468             STRB     R0,[R5, R1]
     65                  if (OSRdyTbl[y] == 0u) {
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x....             LDR.N    R0,??DataTable4_3
   \   00000044   0x5C28             LDRB     R0,[R5, R0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD108             BNE.N    ??OSTimeDly_4
     66                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   0000004A   0x....             LDR.N    R0,??DataTable4_4
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x....             LDR.N    R1,??DataTable4_2
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0xF891 0x103A      LDRB     R1,[R1, #+58]
   \   00000056   0x4388             BICS     R0,R0,R1
   \   00000058   0x....             LDR.N    R1,??DataTable4_4
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
     67                  }
     68                  OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
   \                     ??OSTimeDly_4:
   \   0000005C   0x....             LDR.N    R0,??DataTable4_2
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6304             STR      R4,[R0, #+48]
     69                  OS_EXIT_CRITICAL();
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Restore
     70                  OS_Sched();                              /* Find next task to run!                             */
   \   00000068   0x.... 0x....      BL       OS_Sched
     71              }
     72          }
   \                     ??OSTimeDly_3:
   \                     ??OSTimeDly_0:
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
     73          /*$PAGE*/
     74          /*
     75          *********************************************************************************************************
     76          *                                    DELAY TASK FOR SPECIFIED TIME
     77          *
     78          * Description: This function is called to delay execution of the currently running task until some time
     79          *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
     80          *              MILLISECONDS instead of ticks.
     81          *
     82          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
     83          *              minutes   specifies the number of minutes (max. 59)
     84          *              seconds   specifies the number of seconds (max. 59)
     85          *              ms        specifies the number of milliseconds (max. 999)
     86          *
     87          * Returns    : OS_ERR_NONE
     88          *              OS_ERR_TIME_INVALID_MINUTES
     89          *              OS_ERR_TIME_INVALID_SECONDS
     90          *              OS_ERR_TIME_INVALID_MS
     91          *              OS_ERR_TIME_ZERO_DLY
     92          *              OS_ERR_TIME_DLY_ISR
     93          *
     94          * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
     95          *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
     96          *              set to 0.  The actual delay is rounded to the nearest tick.
     97          *********************************************************************************************************
     98          */
     99          
    100          #if OS_TIME_DLY_HMSM_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    101          INT8U  OSTimeDlyHMSM (INT8U   hours,
    102                                INT8U   minutes,
    103                                INT8U   seconds,
    104                                INT16U  ms)
    105          {
   \                     OSTimeDlyHMSM:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    106              INT32U ticks;
    107          
    108          
    109              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??OSTimeDlyHMSM_0
    110                  return (OS_ERR_TIME_DLY_ISR);
   \   00000014   0x2055             MOVS     R0,#+85
   \   00000016   0xE022             B.N      ??OSTimeDlyHMSM_1
    111              }
    112              if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
   \                     ??OSTimeDlyHMSM_0:
   \   00000018   0x....             LDR.N    R0,??DataTable4_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??OSTimeDlyHMSM_2
    113                  return (OS_ERR_SCHED_LOCKED);
   \   00000020   0x2032             MOVS     R0,#+50
   \   00000022   0xE01C             B.N      ??OSTimeDlyHMSM_1
    114              }
    115          #if OS_ARG_CHK_EN > 0u
    116              if (hours == 0u) {
    117                  if (minutes == 0u) {
    118                      if (seconds == 0u) {
    119                          if (ms == 0u) {
    120                              return (OS_ERR_TIME_ZERO_DLY);
    121                          }
    122                      }
    123                  }
    124              }
    125              if (minutes > 59u) {
    126                  return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
    127              }
    128              if (seconds > 59u) {
    129                  return (OS_ERR_TIME_INVALID_SECONDS);
    130              }
    131              if (ms > 999u) {
    132                  return (OS_ERR_TIME_INVALID_MS);
    133              }
    134          #endif
    135                                                           /* Compute the total number of clock ticks required.. */
    136                                                           /* .. (rounded to the nearest tick)                   */
    137              ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
    138                    + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
   \                     ??OSTimeDlyHMSM_2:
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xF44F 0x6061      MOV      R0,#+3600
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x213C             MOVS     R1,#+60
   \   0000002E   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000032   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000003E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000040   0xF44F 0x727A      MOV      R2,#+1000
   \   00000044   0xFB02 0xF207      MUL      R2,R2,R7
   \   00000048   0xF44F 0x737A      MOV      R3,#+1000
   \   0000004C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000050   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000054   0x4680             MOV      R8,R0
    139              OSTimeDly(ticks);
   \   00000056   0x4640             MOV      R0,R8
   \   00000058   0x.... 0x....      BL       OSTimeDly
    140              return (OS_ERR_NONE);
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDlyHMSM_1:
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    141          }
    142          #endif
    143          /*$PAGE*/
    144          /*
    145          *********************************************************************************************************
    146          *                                        RESUME A DELAYED TASK
    147          *
    148          * Description: This function is used resume a task that has been delayed through a call to either
    149          *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
    150          *              task that is waiting for an event with timeout.  This would make the task look
    151          *              like a timeout occurred.
    152          *
    153          * Arguments  : prio                      specifies the priority of the task to resume
    154          *
    155          * Returns    : OS_ERR_NONE               Task has been resumed
    156          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    157          *                                        (i.e. >= OS_LOWEST_PRIO)
    158          *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
    159          *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
    160          *********************************************************************************************************
    161          */
    162          
    163          #if OS_TIME_DLY_RESUME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    164          INT8U  OSTimeDlyResume (INT8U prio)
    165          {
   \                     OSTimeDlyResume:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    166              OS_TCB    *ptcb;
    167          #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
    168              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    169          #endif
    170          
    171          
    172          
    173              if (prio >= OS_LOWEST_PRIO) {
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C3F             CMP      R4,#+63
   \   0000000A   0xDB01             BLT.N    ??OSTimeDlyResume_0
    174                  return (OS_ERR_PRIO_INVALID);
   \   0000000C   0x202A             MOVS     R0,#+42
   \   0000000E   0xE051             B.N      ??OSTimeDlyResume_1
    175              }
    176              OS_ENTER_CRITICAL();
   \                     ??OSTimeDlyResume_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x0006             MOVS     R6,R0
    177              ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x....             LDR.N    R0,??DataTable4_5
   \   0000001A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001E   0x0005             MOVS     R5,R0
    178              if (ptcb == (OS_TCB *)0) {
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD104             BNE.N    ??OSTimeDlyResume_2
    179                  OS_EXIT_CRITICAL();
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       OS_CPU_SR_Restore
    180                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
   \   0000002A   0x2043             MOVS     R0,#+67
   \   0000002C   0xE042             B.N      ??OSTimeDlyResume_1
    181              }
    182              if (ptcb == OS_TCB_RESERVED) {
   \                     ??OSTimeDlyResume_2:
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD104             BNE.N    ??OSTimeDlyResume_3
    183                  OS_EXIT_CRITICAL();
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Restore
    184                  return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
   \   00000038   0x2043             MOVS     R0,#+67
   \   0000003A   0xE03B             B.N      ??OSTimeDlyResume_1
    185              }
    186              if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
   \                     ??OSTimeDlyResume_3:
   \   0000003C   0x6B28             LDR      R0,[R5, #+48]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD104             BNE.N    ??OSTimeDlyResume_4
    187                  OS_EXIT_CRITICAL();
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
    188                  return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
   \   00000048   0x2050             MOVS     R0,#+80
   \   0000004A   0xE033             B.N      ??OSTimeDlyResume_1
    189              }
    190          
    191              ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
   \                     ??OSTimeDlyResume_4:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6328             STR      R0,[R5, #+48]
    192              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   00000050   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000054   0x2137             MOVS     R1,#+55
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xD009             BEQ.N    ??OSTimeDlyResume_5
    193                  ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
   \   0000005A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000005E   0xF010 0x00C8      ANDS     R0,R0,#0xC8
   \   00000062   0xF885 0x0034      STRB     R0,[R5, #+52]
    194                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000006C   0xE002             B.N      ??OSTimeDlyResume_6
    195              } else {
    196                  ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
   \                     ??OSTimeDlyResume_5:
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF885 0x0035      STRB     R0,[R5, #+53]
    197              }
    198              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
   \                     ??OSTimeDlyResume_6:
   \   00000074   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000078   0x0700             LSLS     R0,R0,#+28
   \   0000007A   0xD417             BMI.N    ??OSTimeDlyResume_7
    199                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
   \   0000007C   0x....             LDR.N    R0,??DataTable4_4
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0xF895 0x103A      LDRB     R1,[R5, #+58]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x....             LDR.N    R1,??DataTable4_4
   \   00000088   0x7008             STRB     R0,[R1, #+0]
    200                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000008A   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   0000008E   0x....             LDR.N    R1,??DataTable4_3
   \   00000090   0x5C40             LDRB     R0,[R0, R1]
   \   00000092   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000096   0x4308             ORRS     R0,R1,R0
   \   00000098   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   0000009C   0x....             LDR.N    R2,??DataTable4_3
   \   0000009E   0x5488             STRB     R0,[R1, R2]
    201                  OS_EXIT_CRITICAL();
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    202                  OS_Sched();                                            /* See if this is new highest priority  */
   \   000000A6   0x.... 0x....      BL       OS_Sched
   \   000000AA   0xE002             B.N      ??OSTimeDlyResume_8
    203              } else {
    204                  OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
   \                     ??OSTimeDlyResume_7:
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0x.... 0x....      BL       OS_CPU_SR_Restore
    205              }
    206              return (OS_ERR_NONE);
   \                     ??OSTimeDlyResume_8:
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??OSTimeDlyResume_1:
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return
    207          }
    208          #endif
    209          /*$PAGE*/
    210          /*
    211          *********************************************************************************************************
    212          *                                       GET CURRENT SYSTEM TIME
    213          *
    214          * Description: This function is used by your application to obtain the current value of the 32-bit
    215          *              counter which keeps track of the number of clock ticks.
    216          *
    217          * Arguments  : none
    218          *
    219          * Returns    : The current value of OSTime
    220          *********************************************************************************************************
    221          */
    222          
    223          #if OS_TIME_GET_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    224          INT32U  OSTimeGet (void)
    225          {
   \                     OSTimeGet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    226              INT32U     ticks;
    227          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    228              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2500             MOVS     R5,#+0
    229          #endif
    230          
    231          
    232          
    233              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0005             MOVS     R5,R0
    234              ticks = OSTime;
   \   0000000A   0x....             LDR.N    R0,??DataTable4_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
    235              OS_EXIT_CRITICAL();
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    236              return (ticks);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    237          }
    238          #endif
    239          
    240          /*
    241          *********************************************************************************************************
    242          *                                          SET SYSTEM CLOCK
    243          *
    244          * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
    245          *
    246          * Arguments  : ticks      specifies the new value that OSTime needs to take.
    247          *
    248          * Returns    : none
    249          *********************************************************************************************************
    250          */
    251          
    252          #if OS_TIME_GET_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    253          void  OSTimeSet (INT32U ticks)
    254          {
   \                     OSTimeSet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    255          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    256              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
    257          #endif
    258          
    259          
    260          
    261              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
    262              OSTime = ticks;
   \   0000000C   0x....             LDR.N    R0,??DataTable4_6
   \   0000000E   0x6004             STR      R4,[R0, #+0]
    263              OS_EXIT_CRITICAL();
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    264          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     OSTime
    265          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSTimeDly
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      24   OSTimeDlyHMSM
        24   -> OSTimeDly
      16   OSTimeDlyResume
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      16   OSTimeGet
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OSTimeSet
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
     110  OSTimeDly
      98  OSTimeDlyHMSM
     182  OSTimeDlyResume
      26  OSTimeGet
      24  OSTimeSet

 
 468 bytes in section .text
 
 468 bytes of CODE memory

Errors: none
Warnings: none

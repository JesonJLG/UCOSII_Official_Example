###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_core.c         #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_core.c" -D     #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_core.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_core.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #define  OS_GLOBALS
     28          #include <ucos_ii.h>

   \                                 In section .bss, align 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_event *OSEventFreeList
   \                     OSEventFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_EVENT OSEventTbl[175]
   \                     OSEventTbl:
   \   00000000                      DS8 4200

   \                                 In section .bss, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[5]
   \                     OSFlagTbl:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \   __absolute struct os_flag_grp *OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute INT8U OSCPUUsage
   \                     OSCPUUsage:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT32U OSIdleCtrMax
   \                     OSIdleCtrMax:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT32U OSIdleCtrRun
   \                     OSIdleCtrRun:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute BOOLEAN OSStatRdy
   \                     OSStatRdy:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTaskStatStk[128]
   \                     OSTaskStatStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 1
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8U OSRdyTbl[8U]
   \                     OSRdyTbl:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBCur
   \                     OSTCBCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBFreeList
   \                     OSTCBFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBList
   \                     OSTCBList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_tcb *OSTCBPrioTbl[64U]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
   \   __absolute OS_TCB OSTCBTbl[22U]
   \                     OSTCBTbl:
   \   00000000                      DS8 1936

   \                                 In section .bss, align 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute struct os_mem *OSMemFreeList
   \                     OSMemFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_MEM OSMemTbl[5]
   \                     OSMemTbl:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
   \   __absolute OS_Q *OSQFreeList
   \                     OSQFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_Q OSQTbl[4]
   \                     OSQTbl:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \   __absolute INT8U OSTaskRegNextAvailID
   \                     OSTaskRegNextAvailID:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
   \   __absolute INT16U OSTmrFree
   \                     OSTmrFree:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute INT16U OSTmrUsed
   \                     OSTmrUsed:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute INT32U OSTmrTime
   \                     OSTmrTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_event *OSTmrSem
   \                     OSTmrSem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute struct os_event *OSTmrSemSignal
   \                     OSTmrSemSignal:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_TMR OSTmrTbl[16]
   \                     OSTmrTbl:
   \   00000000                      DS8 640

   \                                 In section .bss, align 4
   \   __absolute struct os_tmr *OSTmrFreeList
   \                     OSTmrFreeList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_STK OSTmrTaskStk[128]
   \                     OSTmrTaskStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TMR_WHEEL OSTmrWheelTbl[8]
   \                     OSTmrWheelTbl:
   \   00000000                      DS8 64
     29          #endif
     30          
     31          /*
     32          *********************************************************************************************************
     33          *                                      PRIORITY RESOLUTION TABLE
     34          *
     35          * Note: Index into table is bit pattern to resolve highest priority
     36          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     37          *********************************************************************************************************
     38          */
     39          

   \                                 In section .rodata, align 4
     40          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   00000017   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   0000002E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \   00000045   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \   0000005C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \   00000073   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \   0000008A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \   000000A1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \   000000B8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   000000CF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   000000E6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \   000000FD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     41              0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
     42              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
     43              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
     44              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
     45              6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
     46              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
     47              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
     48              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
     49              7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
     50              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
     51              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
     52              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
     53              6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
     54              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
     55              5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
     56              4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
     57          };
     58          
     59          /*$PAGE*/
     60          /*
     61          *********************************************************************************************************
     62          *                                         FUNCTION PROTOTYPES
     63          *********************************************************************************************************
     64          */
     65          
     66          static  void  OS_InitEventList(void);
     67          
     68          static  void  OS_InitMisc(void);
     69          
     70          static  void  OS_InitRdyList(void);
     71          
     72          static  void  OS_InitTaskIdle(void);
     73          
     74          #if OS_TASK_STAT_EN > 0u
     75          static  void  OS_InitTaskStat(void);
     76          #endif
     77          
     78          static  void  OS_InitTCBList(void);
     79          
     80          static  void  OS_SchedNew(void);
     81          
     82          /*$PAGE*/
     83          /*
     84          *********************************************************************************************************
     85          *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     86          *
     87          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     88          *
     89          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     90          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     91          *                        type is irrelevant.
     92          *
     93          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
     94          *                        mutex, mailbox or queue.
     95          *
     96          *              perr      is a pointer to an error code that can contain one of the following values:
     97          *
     98          *                        OS_ERR_NONE                if the name was copied to 'pname'
     99          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    100          *                                                   control block type.
    101          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    102          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    103          *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
    104          *
    105          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    106          *********************************************************************************************************
    107          */
    108          
    109          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    110          INT8U  OSEventNameGet (OS_EVENT   *pevent,
    111                                 INT8U     **pname,
    112                                 INT8U      *perr)
    113          {
   \                     OSEventNameGet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    114              INT8U      len;
    115          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    116              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    117          #endif
    118          
    119          
    120          
    121          #ifdef OS_SAFETY_CRITICAL
    122              if (perr == (INT8U *)0) {
    123                  OS_SAFETY_CRITICAL_EXCEPTION();
    124                  return (0u);
    125              }
    126          #endif
    127          
    128          #if OS_ARG_CHK_EN > 0u
    129              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    130                  *perr = OS_ERR_PEVENT_NULL;
    131                  return (0u);
    132              }
    133              if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
    134                  *perr = OS_ERR_PNAME_NULL;
    135                  return (0u);
    136              }
    137          #endif
    138              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSEventNameGet_0
    139                  *perr  = OS_ERR_NAME_GET_ISR;
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    140                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE017             B.N      ??OSEventNameGet_1
    141              }
    142              switch (pevent->OSEventType) {
   \                     ??OSEventNameGet_0:
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD810             BHI.N    ??OSEventNameGet_2
    143                  case OS_EVENT_TYPE_SEM:
    144                  case OS_EVENT_TYPE_MUTEX:
    145                  case OS_EVENT_TYPE_MBOX:
    146                  case OS_EVENT_TYPE_Q:
    147                       break;
    148          
    149                  default:
    150                       *perr = OS_ERR_EVENT_TYPE;
    151                       return (0u);
    152              }
    153              OS_ENTER_CRITICAL();
   \                     ??OSEventNameGet_3:
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002C   0x4680             MOV      R8,R0
    154              *pname = pevent->OSEventName;
   \   0000002E   0x6960             LDR      R0,[R4, #+20]
   \   00000030   0x6028             STR      R0,[R5, #+0]
    155              len    = OS_StrLen(*pname);
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       OS_StrLen
   \   00000038   0x0007             MOVS     R7,R0
    156              OS_EXIT_CRITICAL();
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    157              *perr  = OS_ERR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7030             STRB     R0,[R6, #+0]
    158              return (len);
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xE002             B.N      ??OSEventNameGet_1
   \                     ??OSEventNameGet_2:
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??OSEventNameGet_1:
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    159          }
    160          #endif
    161          
    162          /*$PAGE*/
    163          /*
    164          *********************************************************************************************************
    165          *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    166          *
    167          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    168          *
    169          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    170          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    171          *                        matter the actual type.
    172          *
    173          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    174          *                        mutex, mailbox or queue.
    175          *
    176          *              perr      is a pointer to an error code that can contain one of the following values:
    177          *
    178          *                        OS_ERR_NONE                if the requested task is resumed
    179          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    180          *                                                   control block type.
    181          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    182          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    183          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    184          *
    185          * Returns    : None
    186          *********************************************************************************************************
    187          */
    188          
    189          #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    190          void  OSEventNameSet (OS_EVENT  *pevent,
    191                                INT8U     *pname,
    192                                INT8U     *perr)
    193          {
   \                     OSEventNameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    194          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    195              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    196          #endif
    197          
    198          
    199          
    200          #ifdef OS_SAFETY_CRITICAL
    201              if (perr == (INT8U *)0) {
    202                  OS_SAFETY_CRITICAL_EXCEPTION();
    203                  return;
    204              }
    205          #endif
    206          
    207          #if OS_ARG_CHK_EN > 0u
    208              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    209                  *perr = OS_ERR_PEVENT_NULL;
    210                  return;
    211              }
    212              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    213                  *perr = OS_ERR_PNAME_NULL;
    214                  return;
    215              }
    216          #endif
    217              if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??OSEventNameSet_0
    218                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    219                  return;
   \   00000018   0xE00F             B.N      ??OSEventNameSet_1
    220              }
    221              switch (pevent->OSEventType) {
   \                     ??OSEventNameSet_0:
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD809             BHI.N    ??OSEventNameSet_2
    222                  case OS_EVENT_TYPE_SEM:
    223                  case OS_EVENT_TYPE_MUTEX:
    224                  case OS_EVENT_TYPE_MBOX:
    225                  case OS_EVENT_TYPE_Q:
    226                       break;
    227          
    228                  default:
    229                       *perr = OS_ERR_EVENT_TYPE;
    230                       return;
    231              }
    232              OS_ENTER_CRITICAL();
   \                     ??OSEventNameSet_3:
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000026   0x0007             MOVS     R7,R0
    233              pevent->OSEventName = pname;
   \   00000028   0x6165             STR      R5,[R4, #+20]
    234              OS_EXIT_CRITICAL();
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
    235              *perr = OS_ERR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7030             STRB     R0,[R6, #+0]
    236          }
   \   00000034   0xE001             B.N      ??OSEventNameSet_1
   \                     ??OSEventNameSet_2:
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   \                     ??OSEventNameSet_1:
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    237          #endif
    238          
    239          /*$PAGE*/
    240          /*
    241          *********************************************************************************************************
    242          *                                       PEND ON MULTIPLE EVENTS
    243          *
    244          * Description: This function waits for multiple events.  If multiple events are ready at the start of the
    245          *              pend call, then all available events are returned as ready.  If the task must pend on the
    246          *              multiple events, then only the first posted or aborted event is returned as ready.
    247          *
    248          * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
    249          *
    250          *              pevents_rdy   is a pointer to an array to return which event control blocks are available
    251          *                            or ready.  The size of the array MUST be greater than or equal to the size
    252          *                            of the 'pevents_pend' array, including terminating NULL.
    253          *
    254          *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
    255          *                            events.  The size of the array MUST be greater than or equal to the size of
    256          *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
    257          *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
    258          *                            every available message-type event returns its messages in the 'pmsgs_rdy'
    259          *                            array at the same index as the event is returned in the 'pevents_rdy' array.
    260          *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
    261          *
    262          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    263          *                            wait for the resources up to the amount of time specified by this argument.
    264          *                            If you specify 0, however, your task will wait forever for the specified
    265          *                            events or, until the resources becomes available (or the events occur).
    266          *
    267          *              perr          is a pointer to where an error message will be deposited.  Possible error
    268          *                            messages are:
    269          *
    270          *                            OS_ERR_NONE         The call was successful and your task owns the resources
    271          *                                                or, the events you are waiting for occurred; check the
    272          *                                                'pevents_rdy' array for which events are available.
    273          *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
    274          *                                                'pevents_rdy' array for which events were aborted.
    275          *                            OS_ERR_TIMEOUT      The events were not received within the specified
    276          *                                                'timeout'.
    277          *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
    278          *                                                NULL pointer.
    279          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
    280          *                                                mailboxes, and/or queues.
    281          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    282          *                                                would lead to a suspension.
    283          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
    284          *
    285          * Returns    : >  0          the number of events returned as ready or aborted.
    286          *              == 0          if no events are returned as ready because of timeout or upon error.
    287          *
    288          * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
    289          *
    290          *                        semaphores, mailboxes, queues
    291          *
    292          *                 b. Return ALL available events and messages, if any
    293          *
    294          *                 c. Add    current task priority as pending to   each events's wait list
    295          *                      Performed in OS_EventTaskWaitMulti()
    296          *
    297          *                 d. Wait on any of multiple events
    298          *
    299          *                 e. Remove current task priority as pending from each events's wait list
    300          *                      Performed in OS_EventTaskRdy(), if events posted or aborted
    301          *
    302          *                 f. Return any event posted or aborted, if any
    303          *                      else
    304          *                    Return timeout
    305          *
    306          *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
    307          *                 case of any error(s).
    308          *********************************************************************************************************
    309          */
    310          /*$PAGE*/
    311          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
    312          INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
    313                                    OS_EVENT  **pevents_rdy,
    314                                    void      **pmsgs_rdy,
    315                                    INT32U      timeout,
    316                                    INT8U      *perr)
    317          {
   \                     OSEventPendMulti:
   \   00000000   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x9C0E             LDR      R4,[SP, #+56]
    318              OS_EVENT  **pevents;
    319              OS_EVENT   *pevent;
    320          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    321              OS_Q       *pq;
    322          #endif
    323              BOOLEAN     events_rdy;
    324              INT16U      events_rdy_nbr;
    325              INT8U       events_stat;
    326          #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
    327              OS_CPU_SR   cpu_sr = 0u;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    328          #endif
    329          
    330          
    331          
    332          #ifdef OS_SAFETY_CRITICAL
    333              if (perr == (INT8U *)0) {
    334                  OS_SAFETY_CRITICAL_EXCEPTION();
    335                  return (0u);
    336              }
    337          #endif
    338          
    339          #if (OS_ARG_CHK_EN > 0u)
    340              if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
    341                 *perr =  OS_ERR_PEVENT_NULL;
    342                  return (0u);
    343              }
    344              if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
    345                 *perr =  OS_ERR_PEVENT_NULL;
    346                  return (0u);
    347              }
    348              if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
    349                 *perr =  OS_ERR_PEVENT_NULL;
    350                  return (0u);
    351              }
    352              if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
    353                 *perr =  OS_ERR_PEVENT_NULL;
    354                  return (0u);
    355              }
    356          #endif
    357          
    358             *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8CB 0x0000      STR      R0,[R11, #+0]
    359          
    360              pevents     =  pevents_pend;
   \   00000016   0x9803             LDR      R0,[SP, #+12]
   \   00000018   0x0007             MOVS     R7,R0
    361              pevent      = *pevents;
   \   0000001A   0x6838             LDR      R0,[R7, #+0]
   \   0000001C   0x0005             MOVS     R5,R0
    362              while  (pevent != (OS_EVENT *)0) {
   \                     ??OSEventPendMulti_0:
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD012             BEQ.N    ??OSEventPendMulti_1
    363                  switch (pevent->OSEventType) {                  /* Validate event block types                  */
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD005             BEQ.N    ??OSEventPendMulti_2
   \   00000028   0xD306             BCC.N    ??OSEventPendMulti_3
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD001             BEQ.N    ??OSEventPendMulti_4
   \   0000002E   0xD302             BCC.N    ??OSEventPendMulti_5
   \   00000030   0xE002             B.N      ??OSEventPendMulti_3
    364          #if (OS_SEM_EN  > 0u)
    365                      case OS_EVENT_TYPE_SEM:
    366                           break;
   \                     ??OSEventPendMulti_4:
   \   00000032   0xE005             B.N      ??OSEventPendMulti_6
    367          #endif
    368          #if (OS_MBOX_EN > 0u)
    369                      case OS_EVENT_TYPE_MBOX:
    370                           break;
   \                     ??OSEventPendMulti_2:
   \   00000034   0xE004             B.N      ??OSEventPendMulti_6
    371          #endif
    372          #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
    373                      case OS_EVENT_TYPE_Q:
    374                           break;
   \                     ??OSEventPendMulti_5:
   \   00000036   0xE003             B.N      ??OSEventPendMulti_6
    375          #endif
    376          
    377                      case OS_EVENT_TYPE_MUTEX:
    378                      case OS_EVENT_TYPE_FLAG:
    379                      default:
    380                          *perr = OS_ERR_EVENT_TYPE;
   \                     ??OSEventPendMulti_3:
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    381                           return (0u);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE149             B.N      ??OSEventPendMulti_7
    382                  }
    383                  pevents++;
   \                     ??OSEventPendMulti_6:
   \   00000040   0x1D3F             ADDS     R7,R7,#+4
    384                  pevent = *pevents;
   \   00000042   0x6838             LDR      R0,[R7, #+0]
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xE7EA             B.N      ??OSEventPendMulti_0
    385              }
    386          
    387              if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
   \                     ??OSEventPendMulti_1:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD003             BEQ.N    ??OSEventPendMulti_8
    388                 *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    389                  return (0u);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE13C             B.N      ??OSEventPendMulti_7
    390              }
    391              if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
   \                     ??OSEventPendMulti_8:
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??OSEventPendMulti_9
    392                 *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
   \   00000064   0x200D             MOVS     R0,#+13
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    393                  return (0u);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE133             B.N      ??OSEventPendMulti_7
    394              }
    395          
    396          /*$PAGE*/
    397              events_rdy     =  OS_FALSE;
   \                     ??OSEventPendMulti_9:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    398              events_rdy_nbr =  0u;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4680             MOV      R8,R0
    399              events_stat    =  OS_STAT_RDY;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x4681             MOV      R9,R0
    400              pevents        =  pevents_pend;
   \   0000007A   0x9803             LDR      R0,[SP, #+12]
   \   0000007C   0x0007             MOVS     R7,R0
    401              pevent         = *pevents;
   \   0000007E   0x6838             LDR      R0,[R7, #+0]
   \   00000080   0x0005             MOVS     R5,R0
    402              OS_ENTER_CRITICAL();
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000086   0x9000             STR      R0,[SP, #+0]
    403              while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
   \                     ??OSEventPendMulti_10:
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD068             BEQ.N    ??OSEventPendMulti_11
    404                  switch (pevent->OSEventType) {
   \   0000008C   0x7828             LDRB     R0,[R5, #+0]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD01C             BEQ.N    ??OSEventPendMulti_12
   \   00000092   0xD355             BCC.N    ??OSEventPendMulti_13
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xD001             BEQ.N    ??OSEventPendMulti_14
   \   00000098   0xD32F             BCC.N    ??OSEventPendMulti_15
   \   0000009A   0xE051             B.N      ??OSEventPendMulti_13
    405          #if (OS_SEM_EN > 0u)
    406                      case OS_EVENT_TYPE_SEM:
    407                           if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
   \                     ??OSEventPendMulti_14:
   \   0000009C   0x8928             LDRH     R0,[R5, #+8]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD011             BEQ.N    ??OSEventPendMulti_16
    408                               pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
   \   000000A2   0x8928             LDRH     R0,[R5, #+8]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x8128             STRH     R0,[R5, #+8]
    409                              *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
   \   000000A8   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000000AC   0xF11B 0x0B04      ADDS     R11,R11,#+4
    410                                events_rdy   =  OS_TRUE;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF88D 0x0004      STRB     R0,[SP, #+4]
    411                              *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000BC   0xF11A 0x0A04      ADDS     R10,R10,#+4
    412                                events_rdy_nbr++;
   \   000000C0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000C4   0xE001             B.N      ??OSEventPendMulti_17
    413          
    414                           } else {
    415                                events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
   \                     ??OSEventPendMulti_16:
   \   000000C6   0xF059 0x0901      ORRS     R9,R9,#0x1
    416                           }
    417                           break;
   \                     ??OSEventPendMulti_17:
   \   000000CA   0xE044             B.N      ??OSEventPendMulti_18
    418          #endif
    419          
    420          #if (OS_MBOX_EN > 0u)
    421                      case OS_EVENT_TYPE_MBOX:
    422                           if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
   \                     ??OSEventPendMulti_12:
   \   000000CC   0x6868             LDR      R0,[R5, #+4]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD010             BEQ.N    ??OSEventPendMulti_19
    423                                                                  /* ... return available message,           ... */
    424                              *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
   \   000000D2   0x6868             LDR      R0,[R5, #+4]
   \   000000D4   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000D8   0xF11A 0x0A04      ADDS     R10,R10,#+4
    425                               pevent->OSEventPtr  = (void *)0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x6068             STR      R0,[R5, #+4]
    426                              *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
   \   000000E0   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000000E4   0xF11B 0x0B04      ADDS     R11,R11,#+4
    427                                events_rdy         =  OS_TRUE;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    428                                events_rdy_nbr++;
   \   000000EE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F2   0xE001             B.N      ??OSEventPendMulti_20
    429          
    430                           } else {
    431                                events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
   \                     ??OSEventPendMulti_19:
   \   000000F4   0xF059 0x0902      ORRS     R9,R9,#0x2
    432                           }
    433                           break;
   \                     ??OSEventPendMulti_20:
   \   000000F8   0xE02D             B.N      ??OSEventPendMulti_18
    434          #endif
    435          
    436          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
    437                      case OS_EVENT_TYPE_Q:
    438                           pq = (OS_Q *)pevent->OSEventPtr;
   \                     ??OSEventPendMulti_15:
   \   000000FA   0x6868             LDR      R0,[R5, #+4]
   \   000000FC   0x0006             MOVS     R6,R0
    439                           if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
   \   000000FE   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD01A             BEQ.N    ??OSEventPendMulti_21
    440                                                                  /* ... return available message,           ... */
    441                              *pmsgs_rdy++ = (void *)*pq->OSQOut++;
   \   00000104   0x6930             LDR      R0,[R6, #+16]
   \   00000106   0x1D01             ADDS     R1,R0,#+4
   \   00000108   0x6131             STR      R1,[R6, #+16]
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000110   0xF11A 0x0A04      ADDS     R10,R10,#+4
    442                               if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
   \   00000114   0x6930             LDR      R0,[R6, #+16]
   \   00000116   0x68B1             LDR      R1,[R6, #+8]
   \   00000118   0x4288             CMP      R0,R1
   \   0000011A   0xD101             BNE.N    ??OSEventPendMulti_22
    443                                   pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
   \   0000011C   0x6870             LDR      R0,[R6, #+4]
   \   0000011E   0x6130             STR      R0,[R6, #+16]
    444                               }
    445                               pq->OSQEntries--;                  /* Update number of queue entries              */
   \                     ??OSEventPendMulti_22:
   \   00000120   0x8AF0             LDRH     R0,[R6, #+22]
   \   00000122   0x1E40             SUBS     R0,R0,#+1
   \   00000124   0x82F0             STRH     R0,[R6, #+22]
    446                              *pevents_rdy++ = pevent;            /* ... and return available queue event        */
   \   00000126   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   0000012A   0xF11B 0x0B04      ADDS     R11,R11,#+4
    447                                events_rdy   = OS_TRUE;
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0xF88D 0x0004      STRB     R0,[SP, #+4]
    448                                events_rdy_nbr++;
   \   00000134   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000138   0xE001             B.N      ??OSEventPendMulti_23
    449          
    450                           } else {
    451                                events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
   \                     ??OSEventPendMulti_21:
   \   0000013A   0xF059 0x0904      ORRS     R9,R9,#0x4
    452                           }
    453                           break;
   \                     ??OSEventPendMulti_23:
   \   0000013E   0xE00A             B.N      ??OSEventPendMulti_18
    454          #endif
    455          
    456                      case OS_EVENT_TYPE_MUTEX:
    457                      case OS_EVENT_TYPE_FLAG:
    458                      default:
    459                           OS_EXIT_CRITICAL();
   \                     ??OSEventPendMulti_13:
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x.... 0x....      BL       OS_CPU_SR_Restore
    460                          *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF8CB 0x0000      STR      R0,[R11, #+0]
    461                          *perr        =  OS_ERR_EVENT_TYPE;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x7020             STRB     R0,[R4, #+0]
    462                           return (events_rdy_nbr);
   \   00000150   0x4640             MOV      R0,R8
   \   00000152   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000154   0xE0BE             B.N      ??OSEventPendMulti_7
    463                  }
    464                  pevents++;
   \                     ??OSEventPendMulti_18:
   \   00000156   0x1D3F             ADDS     R7,R7,#+4
    465                  pevent = *pevents;
   \   00000158   0x6838             LDR      R0,[R7, #+0]
   \   0000015A   0x0005             MOVS     R5,R0
   \   0000015C   0xE794             B.N      ??OSEventPendMulti_10
    466              }
    467          
    468              if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
   \                     ??OSEventPendMulti_11:
   \   0000015E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000162   0x2801             CMP      R0,#+1
   \   00000164   0xD10A             BNE.N    ??OSEventPendMulti_24
    469                 *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF8CB 0x0000      STR      R0,[R11, #+0]
    470                  OS_EXIT_CRITICAL();
   \   0000016C   0x9800             LDR      R0,[SP, #+0]
   \   0000016E   0x.... 0x....      BL       OS_CPU_SR_Restore
    471                 *perr        =  OS_ERR_NONE;
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x7020             STRB     R0,[R4, #+0]
    472                  return (events_rdy_nbr);
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017A   0xE0AB             B.N      ??OSEventPendMulti_7
    473              }
    474          /*$PAGE*/
    475                                                                  /* Otherwise, must wait until any event occurs */
    476              OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
    477                                         OS_STAT_MULTI;           /* ... pend on multiple events                 */
   \                     ??OSEventPendMulti_24:
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000186   0xF059 0x0180      ORRS     R1,R9,#0x80
   \   0000018A   0x4308             ORRS     R0,R1,R0
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000190   0x6809             LDR      R1,[R1, #+0]
   \   00000192   0xF881 0x0034      STRB     R0,[R1, #+52]
    478              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0x2100             MOVS     R1,#+0
   \   0000019E   0xF880 0x1035      STRB     R1,[R0, #+53]
    479              OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x9904             LDR      R1,[SP, #+16]
   \   000001AA   0x6301             STR      R1,[R0, #+48]
    480              OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
   \   000001AC   0x9803             LDR      R0,[SP, #+12]
   \   000001AE   0x.... 0x....      BL       OS_EventTaskWaitMulti
    481          
    482              OS_EXIT_CRITICAL();
   \   000001B2   0x9800             LDR      R0,[SP, #+0]
   \   000001B4   0x.... 0x....      BL       OS_CPU_SR_Restore
    483              OS_Sched();                                         /* Find next highest priority task ready       */
   \   000001B8   0x.... 0x....      BL       OS_Sched
    484              OS_ENTER_CRITICAL();
   \   000001BC   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000001C0   0x9000             STR      R0,[SP, #+0]
    485          
    486              switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD001             BEQ.N    ??OSEventPendMulti_25
   \   000001D0   0x2802             CMP      R0,#+2
   \   000001D2   0xD11D             BNE.N    ??OSEventPendMulti_26
    487                  case OS_STAT_PEND_OK:
    488                  case OS_STAT_PEND_ABORT:
    489                       pevent = OSTCBCur->OSTCBEventPtr;
   \                     ??OSEventPendMulti_25:
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0x69C0             LDR      R0,[R0, #+28]
   \   000001DC   0x0005             MOVS     R5,R0
    490                       if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
   \   000001DE   0x2D00             CMP      R5,#+0
   \   000001E0   0xD009             BEQ.N    ??OSEventPendMulti_27
    491                          *pevents_rdy++   =  pevent;             /* ... return available event ...              */
   \   000001E2   0xF8CB 0x5000      STR      R5,[R11, #+0]
   \   000001E6   0xF11B 0x0B04      ADDS     R11,R11,#+4
    492                          *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0xF8CB 0x0000      STR      R0,[R11, #+0]
    493                            events_rdy_nbr =  1;
   \   000001F0   0x2001             MOVS     R0,#+1
   \   000001F2   0x4680             MOV      R8,R0
   \   000001F4   0xE00B             B.N      ??OSEventPendMulti_28
    494          
    495                       } else {                                   /* Else NO event available, handle as timeout  */
    496                           OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
   \                     ??OSEventPendMulti_27:
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000001FA   0x6800             LDR      R0,[R0, #+0]
   \   000001FC   0x2101             MOVS     R1,#+1
   \   000001FE   0xF880 0x1035      STRB     R1,[R0, #+53]
    497                           OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \   00000202   0x9903             LDR      R1,[SP, #+12]
   \   00000204   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000208   0x6800             LDR      R0,[R0, #+0]
   \   0000020A   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    498                       }
    499                       break;
   \                     ??OSEventPendMulti_28:
   \   0000020E   0xE005             B.N      ??OSEventPendMulti_29
    500          
    501                  case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
    502                  default:                                        /* ... remove task from events' wait lists     */
    503                       OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
   \                     ??OSEventPendMulti_26:
   \   00000210   0x9903             LDR      R1,[SP, #+12]
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    504                       break;
    505              }
    506          
    507              switch (OSTCBCur->OSTCBStatPend) {
   \                     ??OSEventPendMulti_29:
   \   0000021C   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000220   0x6800             LDR      R0,[R0, #+0]
   \   00000222   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD002             BEQ.N    ??OSEventPendMulti_30
   \   0000022A   0x2802             CMP      R0,#+2
   \   0000022C   0xD023             BEQ.N    ??OSEventPendMulti_31
   \   0000022E   0xE02A             B.N      ??OSEventPendMulti_32
    508                  case OS_STAT_PEND_OK:
    509                       switch (pevent->OSEventType) {             /* Return event's message                      */
   \                     ??OSEventPendMulti_30:
   \   00000230   0x7828             LDRB     R0,[R5, #+0]
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0x2801             CMP      R0,#+1
   \   00000236   0xD907             BLS.N    ??OSEventPendMulti_33
   \   00000238   0x1E80             SUBS     R0,R0,#+2
   \   0000023A   0xD10E             BNE.N    ??OSEventPendMulti_34
    510          #if (OS_SEM_EN > 0u)
    511                           case OS_EVENT_TYPE_SEM:
    512                               *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
   \                     ??OSEventPendMulti_35:
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000242   0xF11A 0x0A04      ADDS     R10,R10,#+4
    513                                break;
   \   00000246   0xE013             B.N      ??OSEventPendMulti_36
    514          #endif
    515          
    516          #if ((OS_MBOX_EN > 0u) ||                 \
    517              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    518                           case OS_EVENT_TYPE_MBOX:
    519                           case OS_EVENT_TYPE_Q:
    520                               *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
   \                     ??OSEventPendMulti_33:
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000024C   0x6800             LDR      R0,[R0, #+0]
   \   0000024E   0x6A40             LDR      R0,[R0, #+36]
   \   00000250   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000254   0xF11A 0x0A04      ADDS     R10,R10,#+4
    521                                break;
   \   00000258   0xE00A             B.N      ??OSEventPendMulti_36
    522          #endif
    523          
    524                           case OS_EVENT_TYPE_MUTEX:
    525                           case OS_EVENT_TYPE_FLAG:
    526                           default:
    527                                OS_EXIT_CRITICAL();
   \                     ??OSEventPendMulti_34:
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x.... 0x....      BL       OS_CPU_SR_Restore
    528                               *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xF8CB 0x0000      STR      R0,[R11, #+0]
    529                               *perr        =  OS_ERR_EVENT_TYPE;
   \   00000266   0x2001             MOVS     R0,#+1
   \   00000268   0x7020             STRB     R0,[R4, #+0]
    530                                return (events_rdy_nbr);
   \   0000026A   0x4640             MOV      R0,R8
   \   0000026C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000026E   0xE031             B.N      ??OSEventPendMulti_7
    531                       }
    532                      *perr = OS_ERR_NONE;
   \                     ??OSEventPendMulti_36:
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0x7020             STRB     R0,[R4, #+0]
    533                       break;
   \   00000274   0xE00E             B.N      ??OSEventPendMulti_37
    534          
    535                  case OS_STAT_PEND_ABORT:
    536                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
   \                     ??OSEventPendMulti_31:
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000027C   0xF11A 0x0A04      ADDS     R10,R10,#+4
    537                      *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
   \   00000280   0x200E             MOVS     R0,#+14
   \   00000282   0x7020             STRB     R0,[R4, #+0]
    538                       break;
   \   00000284   0xE006             B.N      ??OSEventPendMulti_37
    539          
    540                  case OS_STAT_PEND_TO:
    541                  default:
    542                      *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
   \                     ??OSEventPendMulti_32:
   \   00000286   0x2000             MOVS     R0,#+0
   \   00000288   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000028C   0xF11A 0x0A04      ADDS     R10,R10,#+4
    543                      *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
   \   00000290   0x200A             MOVS     R0,#+10
   \   00000292   0x7020             STRB     R0,[R4, #+0]
    544                       break;
    545              }
    546          
    547              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
   \                     ??OSEventPendMulti_37:
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0x2100             MOVS     R1,#+0
   \   0000029C   0xF880 0x1034      STRB     R1,[R0, #+52]
    548              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000002A4   0x6800             LDR      R0,[R0, #+0]
   \   000002A6   0x2100             MOVS     R1,#+0
   \   000002A8   0xF880 0x1035      STRB     R1,[R0, #+53]
    549              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000002B0   0x6800             LDR      R0,[R0, #+0]
   \   000002B2   0x2100             MOVS     R1,#+0
   \   000002B4   0x61C1             STR      R1,[R0, #+28]
    550              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000002BA   0x6800             LDR      R0,[R0, #+0]
   \   000002BC   0x2100             MOVS     R1,#+0
   \   000002BE   0x6201             STR      R1,[R0, #+32]
    551          #if ((OS_MBOX_EN > 0u) ||                 \
    552              ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
    553              OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000002C4   0x6800             LDR      R0,[R0, #+0]
   \   000002C6   0x2100             MOVS     R1,#+0
   \   000002C8   0x6241             STR      R1,[R0, #+36]
    554          #endif
    555              OS_EXIT_CRITICAL();
   \   000002CA   0x9800             LDR      R0,[SP, #+0]
   \   000002CC   0x.... 0x....      BL       OS_CPU_SR_Restore
    556          
    557              return (events_rdy_nbr);
   \   000002D0   0x4640             MOV      R0,R8
   \   000002D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSEventPendMulti_7:
   \   000002D4   0xB005             ADD      SP,SP,#+20
   \   000002D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    558          }
    559          #endif
    560          
    561          /*$PAGE*/
    562          /*
    563          *********************************************************************************************************
    564          *                                           INITIALIZATION
    565          *
    566          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    567          *              creating any uC/OS-II object and, prior to calling OSStart().
    568          *
    569          * Arguments  : none
    570          *
    571          * Returns    : none
    572          *********************************************************************************************************
    573          */
    574          

   \                                 In section .text, align 2, keep-with-next
    575          void  OSInit (void)
    576          {
   \                     OSInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    577              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000002   0x.... 0x....      BL       OSInitHookBegin
    578          
    579              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000006   0x.... 0x....      BL       OS_InitMisc
    580          
    581              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   0000000A   0x.... 0x....      BL       OS_InitRdyList
    582          
    583              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   0000000E   0x.... 0x....      BL       OS_InitTCBList
    584          
    585              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   00000012   0x.... 0x....      BL       OS_InitEventList
    586          
    587          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    588              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   00000016   0x.... 0x....      BL       OS_FlagInit
    589          #endif
    590          
    591          #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
    592              OS_MemInit();                                                /* Initialize the memory manager            */
   \   0000001A   0x.... 0x....      BL       OS_MemInit
    593          #endif
    594          
    595          #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
    596              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   0000001E   0x.... 0x....      BL       OS_QInit
    597          #endif
    598          
    599              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   00000022   0x.... 0x....      BL       OS_InitTaskIdle
    600          #if OS_TASK_STAT_EN > 0u
    601              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \   00000026   0x.... 0x....      BL       OS_InitTaskStat
    602          #endif
    603          
    604          #if OS_TMR_EN > 0u
    605              OSTmr_Init();                                                /* Initialize the Timer Manager             */
   \   0000002A   0x.... 0x....      BL       OSTmr_Init
    606          #endif
    607          
    608              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   0000002E   0x.... 0x....      BL       OSInitHookEnd
    609          
    610          #if OS_DEBUG_EN > 0u
    611              OSDebugInit();
   \   00000032   0x.... 0x....      BL       OSDebugInit
    612          #endif
    613          }
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
    614          /*$PAGE*/
    615          /*
    616          *********************************************************************************************************
    617          *                                              ENTER ISR
    618          *
    619          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    620          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    621          *              only perform rescheduling at the last nested ISR.
    622          *
    623          * Arguments  : none
    624          *
    625          * Returns    : none
    626          *
    627          * Notes      : 1) This function should be called with interrupts already disabled
    628          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    629          *                 OSIntNesting has been declared 'global'.
    630          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    631          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    632          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    633          *                 end of the ISR.
    634          *              5) You are allowed to nest interrupts up to 255 levels deep.
    635          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    636          *                 OSIntEnter() is always called with interrupts disabled.
    637          *********************************************************************************************************
    638          */
    639          

   \                                 In section .text, align 2, keep-with-next
    640          void  OSIntEnter (void)
    641          {
    642              if (OSRunning == OS_TRUE) {
   \                     OSIntEnter:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSIntEnter_0
    643                  if (OSIntNesting < 255u) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x28FF             CMP      R0,#+255
   \   00000012   0xD006             BEQ.N    ??OSIntEnter_0
    644                      OSIntNesting++;                      /* Increment ISR nesting level                        */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    645                  }
    646              }
    647          }
   \                     ??OSIntEnter_0:
   \   00000022   0x4770             BX       LR               ;; return
    648          /*$PAGE*/
    649          /*
    650          *********************************************************************************************************
    651          *                                              EXIT ISR
    652          *
    653          * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
    654          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    655          *              a new, high-priority task, is ready to run.
    656          *
    657          * Arguments  : none
    658          *
    659          * Returns    : none
    660          *
    661          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    662          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    663          *                 end of the ISR.
    664          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    665          *********************************************************************************************************
    666          */
    667          

   \                                 In section .text, align 2, keep-with-next
    668          void  OSIntExit (void)
    669          {
   \                     OSIntExit:
   \   00000000   0xB510             PUSH     {R4,LR}
    670          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    671              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    672          #endif
    673          
    674          
    675          
    676              if (OSRunning == OS_TRUE) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD141             BNE.N    ??OSIntExit_0
    677                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    678                  if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD006             BEQ.N    ??OSIntExit_1
    679                      OSIntNesting--;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    680                  }
    681                  if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
   \                     ??OSIntExit_1:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD12A             BNE.N    ??OSIntExit_2
    682                      if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD125             BNE.N    ??OSIntExit_2
    683                          OS_SchedNew();
   \   00000040   0x.... 0x....      BL       OS_SchedNew
    684                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable24_4
   \   0000004E   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable24_5
   \   00000056   0x6008             STR      R0,[R1, #+0]
    685                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable24_6
   \   00000062   0x7809             LDRB     R1,[R1, #+0]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD011             BEQ.N    ??OSIntExit_2
    686          #if OS_TASK_PROFILE_EN > 0u
    687                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable24_5
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x6BC0             LDR      R0,[R0, #+60]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable24_5
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x63C8             STR      R0,[R1, #+60]
    688          #endif
    689                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable24_7
   \   00000086   0x6008             STR      R0,[R1, #+0]
    690                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000088   0x.... 0x....      BL       OSIntCtxSw
    691                          }
    692                      }
    693                  }
    694                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2:
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
    695              }
    696          }
   \                     ??OSIntExit_0:
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    697          /*$PAGE*/
    698          /*
    699          *********************************************************************************************************
    700          *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    701          *
    702          * Description: This function is called by the application code to indicate that all initialization has
    703          *              been completed and that kernel objects are no longer allowed to be created.
    704          *
    705          * Arguments  : none
    706          *
    707          * Returns    : none
    708          *
    709          * Note(s)    : 1) You should call this function when you no longer want to allow application code to
    710          *                 create kernel objects.
    711          *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
    712          *********************************************************************************************************
    713          */
    714          
    715          #ifdef OS_SAFETY_CRITICAL_IEC61508
    716          void  OSSafetyCriticalStart (void)
    717          {
    718              OSSafetyCriticalStartFlag = OS_TRUE;
    719          }
    720          
    721          #endif
    722          
    723          /*$PAGE*/
    724          /*
    725          *********************************************************************************************************
    726          *                                         PREVENT SCHEDULING
    727          *
    728          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    729          *              to prevent context switches until you are ready to permit context switching.
    730          *
    731          * Arguments  : none
    732          *
    733          * Returns    : none
    734          *
    735          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    736          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    737          *********************************************************************************************************
    738          */
    739          
    740          #if OS_SCHED_LOCK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    741          void  OSSchedLock (void)
    742          {
   \                     OSSchedLock:
   \   00000000   0xB510             PUSH     {R4,LR}
    743          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    744              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    745          #endif
    746          
    747          
    748          
    749              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD116             BNE.N    ??OSSchedLock_0
    750                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    751                  if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD10B             BNE.N    ??OSSchedLock_1
    752                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x28FF             CMP      R0,#+255
   \   00000026   0xD006             BEQ.N    ??OSSchedLock_1
    753                          OSLockNesting++;                 /* Increment lock nesting level                       */
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    754                      }
    755                  }
    756                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1:
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    757              }
    758          }
   \                     ??OSSchedLock_0:
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    759          #endif
    760          
    761          /*$PAGE*/
    762          /*
    763          *********************************************************************************************************
    764          *                                          ENABLE SCHEDULING
    765          *
    766          * Description: This function is used to re-allow rescheduling.
    767          *
    768          * Arguments  : none
    769          *
    770          * Returns    : none
    771          *
    772          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    773          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    774          *********************************************************************************************************
    775          */
    776          
    777          #if OS_SCHED_LOCK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    778          void  OSSchedUnlock (void)
    779          {
   \                     OSSchedUnlock:
   \   00000000   0xB510             PUSH     {R4,LR}
    780          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    781              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    782          #endif
    783          
    784          
    785          
    786              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD129             BNE.N    ??OSSchedUnlock_0
    787                  OS_ENTER_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    788                  if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD11E             BNE.N    ??OSSchedUnlock_1
    789                      if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD015             BEQ.N    ??OSSchedUnlock_2
    790                          OSLockNesting--;                           /* Decrement lock nesting level             */
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    791                          if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD105             BNE.N    ??OSSchedUnlock_3
    792                              OS_EXIT_CRITICAL();
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    793                              OS_Sched();                            /* See if a HPT is ready                    */
   \   00000046   0x.... 0x....      BL       OS_Sched
   \   0000004A   0xE00A             B.N      ??OSSchedUnlock_0
    794                          } else {
    795                              OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_3:
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000052   0xE006             B.N      ??OSSchedUnlock_0
    796                          }
    797                      } else {
    798                          OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_2:
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000005A   0xE002             B.N      ??OSSchedUnlock_0
    799                      }
    800                  } else {
    801                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1:
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Restore
    802                  }
    803              }
    804          }
   \                     ??OSSchedUnlock_0:
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    805          #endif
    806          
    807          /*$PAGE*/
    808          /*
    809          *********************************************************************************************************
    810          *                                         START MULTITASKING
    811          *
    812          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    813          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    814          *              and you MUST have created at least one task.
    815          *
    816          * Arguments  : none
    817          *
    818          * Returns    : none
    819          *
    820          * Note       : OSStartHighRdy() MUST:
    821          *                 a) Call OSTaskSwHook() then,
    822          *                 b) Set OSRunning to OS_TRUE.
    823          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    824          *                 d_ Execute the task.
    825          *********************************************************************************************************
    826          */
    827          

   \                                 In section .text, align 2, keep-with-next
    828          void  OSStart (void)
    829          {
   \                     OSStart:
   \   00000000   0xB580             PUSH     {R7,LR}
    830              if (OSRunning == OS_FALSE) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD119             BNE.N    ??OSStart_0
    831                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   0000000C   0x.... 0x....      BL       OS_SchedNew
    832                  OSPrioCur     = OSPrioHighRdy;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_6
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable24_3
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    833                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable24_4
   \   00000026   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24_5
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    834                  OSTCBCur      = OSTCBHighRdy;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable24_5
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    835                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   0000003C   0x.... 0x....      BL       OSStartHighRdy
    836              }
    837          }
   \                     ??OSStart_0:
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    838          /*$PAGE*/
    839          /*
    840          *********************************************************************************************************
    841          *                                      STATISTICS INITIALIZATION
    842          *
    843          * Description: This function is called by your application to establish CPU usage by first determining
    844          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    845          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    846          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    847          *              determined by:
    848          *
    849          *                                             OSIdleCtr
    850          *                 CPU Usage (%) = 100 * (1 - ------------)
    851          *                                            OSIdleCtrMax
    852          *
    853          * Arguments  : none
    854          *
    855          * Returns    : none
    856          *********************************************************************************************************
    857          */
    858          
    859          #if OS_TASK_STAT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    860          void  OSStatInit (void)
    861          {
   \                     OSStatInit:
   \   00000000   0xB510             PUSH     {R4,LR}
    862          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    863              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    864          #endif
    865          
    866          
    867          
    868              OSTimeDly(2u);                               /* Synchronize with clock tick                        */
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       OSTimeDly
    869              OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000E   0x0004             MOVS     R4,R0
    870              OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6001             STR      R1,[R0, #+0]
    871              OS_EXIT_CRITICAL();
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
    872              OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
   \   0000001E   0x2064             MOVS     R0,#+100
   \   00000020   0x.... 0x....      BL       OSTimeDly
    873              OS_ENTER_CRITICAL();
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000028   0x0004             MOVS     R4,R0
    874              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable24_9
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable24_8
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x6001             STR      R1,[R0, #+0]
    875              OSStatRdy    = OS_TRUE;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
    876              OS_EXIT_CRITICAL();
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Restore
    877          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    878          #endif
    879          /*$PAGE*/
    880          /*
    881          *********************************************************************************************************
    882          *                                         PROCESS SYSTEM TICK
    883          *
    884          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    885          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    886          *              called by a high priority task.
    887          *
    888          * Arguments  : none
    889          *
    890          * Returns    : none
    891          *********************************************************************************************************
    892          */
    893          

   \                                 In section .text, align 2, keep-with-next
    894          void  OSTimeTick (void)
    895          {
   \                     OSTimeTick:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    896              OS_TCB    *ptcb;
    897          #if OS_TICK_STEP_EN > 0u
    898              BOOLEAN    step;
    899          #endif
    900          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
    901              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2600             MOVS     R6,#+0
    902          #endif
    903          
    904          
    905          
    906          #if OS_TIME_TICK_HOOK_EN > 0u
    907              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000004   0x.... 0x....      BL       OSTimeTickHook
    908          #endif
    909          #if OS_TIME_GET_SET_EN > 0u
    910              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
    911              OSTime++;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_11
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable24_11
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    912              OS_EXIT_CRITICAL();
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    913          #endif
    914              if (OSRunning == OS_TRUE) {
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD163             BNE.N    ??OSTimeTick_0
    915          #if OS_TICK_STEP_EN > 0u
    916                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable24_12
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD003             BEQ.N    ??OSTimeTick_1
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD007             BEQ.N    ??OSTimeTick_2
   \   0000003A   0xD303             BCC.N    ??OSTimeTick_3
   \   0000003C   0xE00C             B.N      ??OSTimeTick_4
    917                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    918                           step = OS_TRUE;
   \                     ??OSTimeTick_1:
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0005             MOVS     R5,R0
    919                           break;
   \   00000042   0xE00F             B.N      ??OSTimeTick_5
    920          
    921                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    922                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
   \                     ??OSTimeTick_3:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    923                           break;
   \   00000048   0xE00C             B.N      ??OSTimeTick_5
    924          
    925                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    926                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
   \                     ??OSTimeTick_2:
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0005             MOVS     R5,R0
    927                           OSTickStepState = OS_TICK_STEP_WAIT;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable24_12
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x7001             STRB     R1,[R0, #+0]
    928                           break;
   \   00000056   0xE005             B.N      ??OSTimeTick_5
    929          
    930                      default:                                       /* Invalid case, correct situation              */
    931                           step            = OS_TRUE;
   \                     ??OSTimeTick_4:
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x0005             MOVS     R5,R0
    932                           OSTickStepState = OS_TICK_STEP_DIS;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable24_12
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x7001             STRB     R1,[R0, #+0]
    933                           break;
    934                  }
    935                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
   \                     ??OSTimeTick_5:
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD044             BEQ.N    ??OSTimeTick_6
    936                      return;
    937                  }
    938          #endif
    939                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_7:
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable24_13
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0004             MOVS     R4,R0
    940                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
   \                     ??OSTimeTick_8:
   \   00000072   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000076   0x283F             CMP      R0,#+63
   \   00000078   0xD03C             BEQ.N    ??OSTimeTick_0
    941                      OS_ENTER_CRITICAL();
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000007E   0x0006             MOVS     R6,R0
    942                      if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
   \   00000080   0x6B20             LDR      R0,[R4, #+48]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD031             BEQ.N    ??OSTimeTick_9
    943                          ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
   \   00000086   0x6B20             LDR      R0,[R4, #+48]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x6320             STR      R0,[R4, #+48]
    944                          if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
   \   0000008C   0x6B20             LDR      R0,[R4, #+48]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD12B             BNE.N    ??OSTimeTick_9
    945          
    946                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   00000092   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000096   0x2137             MOVS     R1,#+55
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD009             BEQ.N    ??OSTimeTick_10
    947                                  ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
   \   0000009C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000A0   0xF010 0x00C8      ANDS     R0,R0,#0xC8
   \   000000A4   0xF884 0x0034      STRB     R0,[R4, #+52]
    948                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000AE   0xE002             B.N      ??OSTimeTick_11
    949                              } else {
    950                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \                     ??OSTimeTick_10:
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF884 0x0035      STRB     R0,[R4, #+53]
    951                              }
    952          
    953                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \                     ??OSTimeTick_11:
   \   000000B6   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000BA   0x0700             LSLS     R0,R0,#+28
   \   000000BC   0xD415             BMI.N    ??OSTimeTick_9
    954                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0xF894 0x103A      LDRB     R1,[R4, #+58]
   \   000000C8   0x4308             ORRS     R0,R1,R0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
    955                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000000D0   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable24_15
   \   000000D8   0x5C40             LDRB     R0,[R0, R1]
   \   000000DA   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   000000DE   0x4308             ORRS     R0,R1,R0
   \   000000E0   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   000000E4   0x.... 0x....      LDR.W    R2,??DataTable24_15
   \   000000E8   0x5488             STRB     R0,[R1, R2]
    956                              }
    957                          }
    958                      }
    959                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_9:
   \   000000EA   0x6964             LDR      R4,[R4, #+20]
    960                      OS_EXIT_CRITICAL();
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   000000F2   0xE7BE             B.N      ??OSTimeTick_8
    961                  }
    962              }
    963          }
   \                     ??OSTimeTick_0:
   \                     ??OSTimeTick_6:
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
    964          
    965          /*$PAGE*/
    966          /*
    967          *********************************************************************************************************
    968          *                                             GET VERSION
    969          *
    970          * Description: This function is used to return the version number of uC/OS-II.  The returned value 
    971          *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
    972          *              2.01.00 would be returned as 20100.
    973          *
    974          * Arguments  : none
    975          *
    976          * Returns    : The version number of uC/OS-II multiplied by 10000.
    977          *********************************************************************************************************
    978          */
    979          

   \                                 In section .text, align 2, keep-with-next
    980          INT16U  OSVersion (void)
    981          {
    982              return (OS_VERSION);
   \                     OSVersion:
   \   00000000   0xF247 0x2017      MOVW     R0,#+29207
   \   00000004   0x4770             BX       LR               ;; return
    983          }
    984          
    985          /*$PAGE*/
    986          /*
    987          *********************************************************************************************************
    988          *                                           DUMMY FUNCTION
    989          *
    990          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    991          *
    992          * Arguments  : none
    993          *
    994          * Returns    : none
    995          *********************************************************************************************************
    996          */
    997          
    998          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    999          void  OS_Dummy (void)
   1000          {
   1001          }
   \                     OS_Dummy:
   \   00000000   0x4770             BX       LR               ;; return
   1002          #endif
   1003          
   1004          /*$PAGE*/
   1005          /*
   1006          *********************************************************************************************************
   1007          *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
   1008          *
   1009          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
   1010          *              waiting for an event to occur.
   1011          *
   1012          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
   1013          *
   1014          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
   1015          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
   1016          *                          service functions.
   1017          *
   1018          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
   1019          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
   1020          *
   1021          *              pend_stat   is used to indicate the readied task's pending status:
   1022          *
   1023          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
   1024          *                                               an abort.
   1025          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
   1026          *
   1027          * Returns    : none
   1028          *
   1029          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1030          *********************************************************************************************************
   1031          */
   1032          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1033          INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
   1034                                  void      *pmsg,
   1035                                  INT8U      msk,
   1036                                  INT8U      pend_stat)
   1037          {
   \                     OS_EventTaskRdy:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1038              OS_TCB   *ptcb;
   1039              INT8U     y;
   1040              INT8U     x;
   1041              INT8U     prio;
   1042          #if OS_LOWEST_PRIO > 63u
   1043              OS_PRIO  *ptbl;
   1044          #endif
   1045          
   1046          
   1047          #if OS_LOWEST_PRIO <= 63u
   1048              y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
   \   0000000C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable24_16
   \   00000012   0x5C40             LDRB     R0,[R0, R1]
   \   00000014   0x4681             MOV      R9,R0
   1049              x    = OSUnMapTbl[pevent->OSEventTbl[y]];
   \   00000016   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001A   0xEB19 0x0004      ADDS     R0,R9,R4
   \   0000001E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable24_16
   \   00000024   0x5C40             LDRB     R0,[R0, R1]
   \   00000026   0x4682             MOV      R10,R0
   1050              prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
   \   00000028   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000030   0xEB1A 0x00C9      ADDS     R0,R10,R9, LSL #+3
   \   00000034   0x4683             MOV      R11,R0
   1051          #else
   1052              if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
   1053                  y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
   1054              } else {
   1055                  y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
   1056              }
   1057              ptbl = &pevent->OSEventTbl[y];
   1058              if ((*ptbl & 0xFFu) != 0u) {
   1059                  x = OSUnMapTbl[*ptbl & 0xFFu];
   1060              } else {
   1061                  x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
   1062              }
   1063              prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
   1064          #endif
   1065          
   1066              ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
   \   00000036   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   0000003E   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   00000042   0x4680             MOV      R8,R0
   1067              ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8C8 0x0030      STR      R0,[R8, #+48]
   1068          #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
   1069              ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
   \   0000004A   0xF8C8 0x5024      STR      R5,[R8, #+36]
   1070          #else
   1071              pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
   1072          #endif
   1073              ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
   \   0000004E   0xF898 0x0034      LDRB     R0,[R8, #+52]
   \   00000052   0x43B0             BICS     R0,R0,R6
   \   00000054   0xF888 0x0034      STRB     R0,[R8, #+52]
   1074              ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
   \   00000058   0xF888 0x7035      STRB     R7,[R8, #+53]
   1075                                                                  /* See if task is ready (could be susp'd)      */
   1076              if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
   \   0000005C   0xF898 0x0034      LDRB     R0,[R8, #+52]
   \   00000060   0x0700             LSLS     R0,R0,#+28
   \   00000062   0xD417             BMI.N    ??OS_EventTaskRdy_0
   1077                  OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   1078                  OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
   \   00000076   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable24_15
   \   0000007E   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000082   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   00000086   0x4308             ORRS     R0,R1,R0
   \   00000088   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable24_15
   \   00000090   0xF809 0x0001      STRB     R0,[R9, R1]
   1079              }
   1080          
   1081              OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
   \                     ??OS_EventTaskRdy_0:
   \   00000094   0x0021             MOVS     R1,R4
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       OS_EventTaskRemove
   1082          #if (OS_EVENT_MULTI_EN > 0u)
   1083              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
   \   0000009C   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD006             BEQ.N    ??OS_EventTaskRdy_1
   1084                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000A4   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       OS_EventTaskRemoveMulti
   1085                  ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
   \   000000AE   0xF8C8 0x401C      STR      R4,[R8, #+28]
   1086              }
   1087          #endif
   1088          
   1089              return (prio);
   \                     ??OS_EventTaskRdy_1:
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1090          }
   1091          #endif
   1092          /*$PAGE*/
   1093          /*
   1094          *********************************************************************************************************
   1095          *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
   1096          *
   1097          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
   1098          *              not occurred.
   1099          *
   1100          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
   1101          *
   1102          * Returns    : none
   1103          *
   1104          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1105          *********************************************************************************************************
   1106          */
   1107          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1108          void  OS_EventTaskWait (OS_EVENT *pevent)
   1109          {
   1110              INT8U  y;
   1111          
   1112          
   1113              OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
   \                     OS_EventTaskWait:
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable24
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x61D0             STR      R0,[R2, #+28]
   1114          
   1115              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable24
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF892 0x2038      LDRB     R2,[R2, #+56]
   \   00000012   0x1812             ADDS     R2,R2,R0
   \   00000014   0x7AD2             LDRB     R2,[R2, #+11]
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable24
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0xF893 0x3039      LDRB     R3,[R3, #+57]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable24
   \   00000026   0x681B             LDR      R3,[R3, #+0]
   \   00000028   0xF893 0x3038      LDRB     R3,[R3, #+56]
   \   0000002C   0x181B             ADDS     R3,R3,R0
   \   0000002E   0x72DA             STRB     R2,[R3, #+11]
   1116              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000030   0x7A82             LDRB     R2,[R0, #+10]
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable24
   \   00000036   0x681B             LDR      R3,[R3, #+0]
   \   00000038   0xF893 0x303A      LDRB     R3,[R3, #+58]
   \   0000003C   0x431A             ORRS     R2,R3,R2
   \   0000003E   0x7282             STRB     R2,[R0, #+10]
   1117          
   1118              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable24
   \   00000044   0x6812             LDR      R2,[R2, #+0]
   \   00000046   0xF892 0x2038      LDRB     R2,[R2, #+56]
   \   0000004A   0x0011             MOVS     R1,R2
   1119              OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable24_15
   \   00000052   0x5C8A             LDRB     R2,[R1, R2]
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable24
   \   00000058   0x681B             LDR      R3,[R3, #+0]
   \   0000005A   0xF893 0x3039      LDRB     R3,[R3, #+57]
   \   0000005E   0x439A             BICS     R2,R2,R3
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable24_15
   \   00000066   0x54CA             STRB     R2,[R1, R3]
   1120              if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable24_15
   \   0000006E   0x5C8A             LDRB     R2,[R1, R2]
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD10B             BNE.N    ??OS_EventTaskWait_0
   1121                  OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable24_14
   \   00000078   0x7812             LDRB     R2,[R2, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable24
   \   0000007E   0x681B             LDR      R3,[R3, #+0]
   \   00000080   0xF893 0x303A      LDRB     R3,[R3, #+58]
   \   00000084   0x439A             BICS     R2,R2,R3
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable24_14
   \   0000008A   0x701A             STRB     R2,[R3, #+0]
   1122              }
   1123          }
   \                     ??OS_EventTaskWait_0:
   \   0000008C   0x4770             BX       LR               ;; return
   1124          #endif
   1125          /*$PAGE*/
   1126          /*
   1127          *********************************************************************************************************
   1128          *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
   1129          *
   1130          * Description: This function is called by other uC/OS-II services to suspend a task because any one of
   1131          *              multiple events has not occurred.
   1132          *
   1133          * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
   1134          *                               which the task will be waiting for.
   1135          *
   1136          * Returns    : none.
   1137          *
   1138          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1139          *********************************************************************************************************
   1140          */
   1141          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
   1142          void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
   1143          {
   \                     OS_EventTaskWaitMulti:
   \   00000000   0xB430             PUSH     {R4,R5}
   1144              OS_EVENT **pevents;
   1145              OS_EVENT  *pevent;
   1146              INT8U      y;
   1147          
   1148          
   1149              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable24
   \   00000006   0x6824             LDR      R4,[R4, #+0]
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x61E5             STR      R5,[R4, #+28]
   1150              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable24
   \   00000010   0x6824             LDR      R4,[R4, #+0]
   \   00000012   0x6220             STR      R0,[R4, #+32]
   1151          
   1152              pevents =  pevents_wait;
   \   00000014   0x0001             MOVS     R1,R0
   1153              pevent  = *pevents;
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0x0022             MOVS     R2,R4
   1154              while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
   \                     ??OS_EventTaskWaitMulti_0:
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD01F             BEQ.N    ??OS_EventTaskWaitMulti_1
   1155                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable24
   \   00000022   0x6824             LDR      R4,[R4, #+0]
   \   00000024   0xF894 0x4038      LDRB     R4,[R4, #+56]
   \   00000028   0x18A4             ADDS     R4,R4,R2
   \   0000002A   0x7AE4             LDRB     R4,[R4, #+11]
   \   0000002C   0x.... 0x....      LDR.W    R5,??DataTable24
   \   00000030   0x682D             LDR      R5,[R5, #+0]
   \   00000032   0xF895 0x5039      LDRB     R5,[R5, #+57]
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x.... 0x....      LDR.W    R5,??DataTable24
   \   0000003C   0x682D             LDR      R5,[R5, #+0]
   \   0000003E   0xF895 0x5038      LDRB     R5,[R5, #+56]
   \   00000042   0x18AD             ADDS     R5,R5,R2
   \   00000044   0x72EC             STRB     R4,[R5, #+11]
   1156                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   00000046   0x7A94             LDRB     R4,[R2, #+10]
   \   00000048   0x.... 0x....      LDR.W    R5,??DataTable24
   \   0000004C   0x682D             LDR      R5,[R5, #+0]
   \   0000004E   0xF895 0x503A      LDRB     R5,[R5, #+58]
   \   00000052   0x432C             ORRS     R4,R5,R4
   \   00000054   0x7294             STRB     R4,[R2, #+10]
   1157                  pevents++;
   \   00000056   0x1D09             ADDS     R1,R1,#+4
   1158                  pevent = *pevents;
   \   00000058   0x680C             LDR      R4,[R1, #+0]
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0xE7DD             B.N      ??OS_EventTaskWaitMulti_0
   1159              }
   1160          
   1161              y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
   \                     ??OS_EventTaskWaitMulti_1:
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable24
   \   00000062   0x6824             LDR      R4,[R4, #+0]
   \   00000064   0xF894 0x4038      LDRB     R4,[R4, #+56]
   \   00000068   0x0023             MOVS     R3,R4
   1162              OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
   \   0000006A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006C   0x.... 0x....      LDR.W    R4,??DataTable24_15
   \   00000070   0x5D1C             LDRB     R4,[R3, R4]
   \   00000072   0x.... 0x....      LDR.W    R5,??DataTable24
   \   00000076   0x682D             LDR      R5,[R5, #+0]
   \   00000078   0xF895 0x5039      LDRB     R5,[R5, #+57]
   \   0000007C   0x43AC             BICS     R4,R4,R5
   \   0000007E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000080   0x.... 0x....      LDR.W    R5,??DataTable24_15
   \   00000084   0x555C             STRB     R4,[R3, R5]
   1163              if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
   \   00000086   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000088   0x.... 0x....      LDR.W    R4,??DataTable24_15
   \   0000008C   0x5D1C             LDRB     R4,[R3, R4]
   \   0000008E   0x2C00             CMP      R4,#+0
   \   00000090   0xD10B             BNE.N    ??OS_EventTaskWaitMulti_2
   1164                  OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
   \   00000092   0x.... 0x....      LDR.W    R4,??DataTable24_14
   \   00000096   0x7824             LDRB     R4,[R4, #+0]
   \   00000098   0x.... 0x....      LDR.W    R5,??DataTable24
   \   0000009C   0x682D             LDR      R5,[R5, #+0]
   \   0000009E   0xF895 0x503A      LDRB     R5,[R5, #+58]
   \   000000A2   0x43AC             BICS     R4,R4,R5
   \   000000A4   0x.... 0x....      LDR.W    R5,??DataTable24_14
   \   000000A8   0x702C             STRB     R4,[R5, #+0]
   1165              }
   1166          }
   \                     ??OS_EventTaskWaitMulti_2:
   \   000000AA   0xBC30             POP      {R4,R5}
   \   000000AC   0x4770             BX       LR               ;; return
   1167          #endif
   1168          /*$PAGE*/
   1169          /*
   1170          *********************************************************************************************************
   1171          *                                  REMOVE TASK FROM EVENT WAIT LIST
   1172          *
   1173          * Description: Remove a task from an event's wait list.
   1174          *
   1175          * Arguments  : ptcb     is a pointer to the task to remove.
   1176          *
   1177          *              pevent   is a pointer to the event control block.
   1178          *
   1179          * Returns    : none
   1180          *
   1181          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1182          *********************************************************************************************************
   1183          */
   1184          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1185          void  OS_EventTaskRemove (OS_TCB   *ptcb,
   1186                                    OS_EVENT *pevent)
   1187          {
   \                     OS_EventTaskRemove:
   \   00000000   0xB410             PUSH     {R4}
   1188              INT8U  y;
   1189          
   1190          
   1191              y                       =  ptcb->OSTCBY;
   \   00000002   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000006   0x001A             MOVS     R2,R3
   1192              pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x1853             ADDS     R3,R2,R1
   \   0000000C   0x7ADB             LDRB     R3,[R3, #+11]
   \   0000000E   0xF890 0x4039      LDRB     R4,[R0, #+57]
   \   00000012   0x43A3             BICS     R3,R3,R4
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1854             ADDS     R4,R2,R1
   \   00000018   0x72E3             STRB     R3,[R4, #+11]
   1193              if (pevent->OSEventTbl[y] == 0u) {
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x1853             ADDS     R3,R2,R1
   \   0000001E   0x7ADB             LDRB     R3,[R3, #+11]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD104             BNE.N    ??OS_EventTaskRemove_0
   1194                  pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000024   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000026   0xF890 0x403A      LDRB     R4,[R0, #+58]
   \   0000002A   0x43A3             BICS     R3,R3,R4
   \   0000002C   0x728B             STRB     R3,[R1, #+10]
   1195              }
   1196          }
   \                     ??OS_EventTaskRemove_0:
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
   1197          #endif
   1198          /*$PAGE*/
   1199          /*
   1200          *********************************************************************************************************
   1201          *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
   1202          *
   1203          * Description: Remove a task from multiple events' wait lists.
   1204          *
   1205          * Arguments  : ptcb             is a pointer to the task to remove.
   1206          *
   1207          *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
   1208          *
   1209          * Returns    : none
   1210          *
   1211          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1212          *********************************************************************************************************
   1213          */
   1214          #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))

   \                                 In section .text, align 2, keep-with-next
   1215          void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
   1216                                         OS_EVENT **pevents_multi)
   1217          {
   \                     OS_EventTaskRemoveMulti:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1218              OS_EVENT **pevents;
   1219              OS_EVENT  *pevent;
   1220              INT8U      y;
   1221              OS_PRIO    bity;
   1222              OS_PRIO    bitx;
   1223          
   1224          
   1225              y       =  ptcb->OSTCBY;
   \   00000002   0xF890 0x7038      LDRB     R7,[R0, #+56]
   \   00000006   0x003C             MOVS     R4,R7
   1226              bity    =  ptcb->OSTCBBitY;
   \   00000008   0xF890 0x703A      LDRB     R7,[R0, #+58]
   \   0000000C   0x003D             MOVS     R5,R7
   1227              bitx    =  ptcb->OSTCBBitX;
   \   0000000E   0xF890 0x7039      LDRB     R7,[R0, #+57]
   \   00000012   0x003E             MOVS     R6,R7
   1228              pevents =  pevents_multi;
   \   00000014   0x000A             MOVS     R2,R1
   1229              pevent  = *pevents;
   \   00000016   0x6817             LDR      R7,[R2, #+0]
   \   00000018   0x003B             MOVS     R3,R7
   1230              while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
   \                     ??OS_EventTaskRemoveMulti_0:
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD014             BEQ.N    ??OS_EventTaskRemoveMulti_1
   1231                  pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x18E7             ADDS     R7,R4,R3
   \   00000022   0x7AFF             LDRB     R7,[R7, #+11]
   \   00000024   0x43B7             BICS     R7,R7,R6
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xEB14 0x0C03      ADDS     R12,R4,R3
   \   0000002C   0xF88C 0x700B      STRB     R7,[R12, #+11]
   1232                  if (pevent->OSEventTbl[y] == 0u) {
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x18E7             ADDS     R7,R4,R3
   \   00000034   0x7AFF             LDRB     R7,[R7, #+11]
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD102             BNE.N    ??OS_EventTaskRemoveMulti_2
   1233                      pevent->OSEventGrp &= (OS_PRIO)~bity;
   \   0000003A   0x7A9F             LDRB     R7,[R3, #+10]
   \   0000003C   0x43AF             BICS     R7,R7,R5
   \   0000003E   0x729F             STRB     R7,[R3, #+10]
   1234                  }
   1235                  pevents++;
   \                     ??OS_EventTaskRemoveMulti_2:
   \   00000040   0x1D12             ADDS     R2,R2,#+4
   1236                  pevent = *pevents;
   \   00000042   0x6817             LDR      R7,[R2, #+0]
   \   00000044   0x003B             MOVS     R3,R7
   \   00000046   0xE7E8             B.N      ??OS_EventTaskRemoveMulti_0
   1237              }
   1238          }
   \                     ??OS_EventTaskRemoveMulti_1:
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
   1239          #endif
   1240          /*$PAGE*/
   1241          /*
   1242          *********************************************************************************************************
   1243          *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
   1244          *
   1245          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
   1246          *
   1247          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
   1248          *
   1249          * Returns    : none
   1250          *
   1251          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1252          *********************************************************************************************************
   1253          */
   1254          #if (OS_EVENT_EN)

   \                                 In section .text, align 2, keep-with-next
   1255          void  OS_EventWaitListInit (OS_EVENT *pevent)
   1256          {
   1257              INT8U  i;
   1258          
   1259          
   1260              pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
   \                     OS_EventWaitListInit:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x7282             STRB     R2,[R0, #+10]
   1261              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x0011             MOVS     R1,R2
   \                     ??OS_EventWaitListInit_0:
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2908             CMP      R1,#+8
   \   0000000C   0xD205             BCS.N    ??OS_EventWaitListInit_1
   1262                  pevent->OSEventTbl[i] = 0u;
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x180A             ADDS     R2,R1,R0
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x72D3             STRB     R3,[R2, #+11]
   1263              }
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xE7F6             B.N      ??OS_EventWaitListInit_0
   1264          }
   \                     ??OS_EventWaitListInit_1:
   \   0000001A   0x4770             BX       LR               ;; return
   1265          #endif
   1266          /*$PAGE*/
   1267          /*
   1268          *********************************************************************************************************
   1269          *                                             INITIALIZATION
   1270          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
   1271          *
   1272          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
   1273          *
   1274          * Arguments  : none
   1275          *
   1276          * Returns    : none
   1277          *********************************************************************************************************
   1278          */
   1279          

   \                                 In section .text, align 2, keep-with-next
   1280          static  void  OS_InitEventList (void)
   1281          {
   \                     OS_InitEventList:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1282          #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
   1283          #if (OS_MAX_EVENTS > 1u)
   1284              INT16U     ix;
   1285              INT16U     ix_next;
   1286              OS_EVENT  *pevent1;
   1287              OS_EVENT  *pevent2;
   1288          
   1289          
   1290              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
   \   00000002   0xF241 0x0168      MOVW     R1,#+4200
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_17
   \   0000000A   0x.... 0x....      BL       OS_MemClr
   1291              for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0004             MOVS     R4,R0
   \                     ??OS_InitEventList_0:
   \   00000012   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   0x2CAE             CMP      R4,#+174
   \   00000016   0xD216             BCS.N    ??OS_InitEventList_1
   1292                  ix_next = ix + 1u;
   \   00000018   0x1C60             ADDS     R0,R4,#+1
   \   0000001A   0x0005             MOVS     R5,R0
   1293                  pevent1 = &OSEventTbl[ix];
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable24_17
   \   00000024   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000028   0x0006             MOVS     R6,R0
   1294                  pevent2 = &OSEventTbl[ix_next];
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2018             MOVS     R0,#+24
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable24_17
   \   00000032   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000036   0x0007             MOVS     R7,R0
   1295                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7030             STRB     R0,[R6, #+0]
   1296                  pevent1->OSEventPtr     = pevent2;
   \   0000003C   0x6077             STR      R7,[R6, #+4]
   1297          #if OS_EVENT_NAME_EN > 0u
   1298                  pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
   \   0000003E   0x....             ADR.N    R0,??DataTable21  ;; "\?"
   \   00000040   0x6170             STR      R0,[R6, #+20]
   1299          #endif
   1300              }
   \   00000042   0x1C64             ADDS     R4,R4,#+1
   \   00000044   0xE7E5             B.N      ??OS_InitEventList_0
   1301              pevent1                         = &OSEventTbl[ix];
   \                     ??OS_InitEventList_1:
   \   00000046   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000048   0x2018             MOVS     R0,#+24
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable24_17
   \   0000004E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000052   0x0006             MOVS     R6,R0
   1302              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x7030             STRB     R0,[R6, #+0]
   1303              pevent1->OSEventPtr             = (OS_EVENT *)0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6070             STR      R0,[R6, #+4]
   1304          #if OS_EVENT_NAME_EN > 0u
   1305              pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
   \   0000005C   0x....             ADR.N    R0,??DataTable21  ;; "\?"
   \   0000005E   0x6170             STR      R0,[R6, #+20]
   1306          #endif
   1307              OSEventFreeList                 = &OSEventTbl[0];
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable24_18
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable24_17
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1308          #else
   1309              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
   1310              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
   1311              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
   1312          #if OS_EVENT_NAME_EN > 0u
   1313              OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
   1314          #endif
   1315          #endif
   1316          #endif
   1317          }
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1318          /*$PAGE*/
   1319          /*
   1320          *********************************************************************************************************
   1321          *                                             INITIALIZATION
   1322          *                                    INITIALIZE MISCELLANEOUS VARIABLES
   1323          *
   1324          * Description: This function is called by OSInit() to initialize miscellaneous variables.
   1325          *
   1326          * Arguments  : none
   1327          *
   1328          * Returns    : none
   1329          *********************************************************************************************************
   1330          */
   1331          

   \                                 In section .text, align 2, keep-with-next
   1332          static  void  OS_InitMisc (void)
   1333          {
   1334          #if OS_TIME_GET_SET_EN > 0u
   1335              OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
   \                     OS_InitMisc:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_11
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
   1336          #endif
   1337          
   1338              OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
   \   00000008   0x....             LDR.N    R0,??DataTable21_1
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   1339              OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
   \   0000000E   0x....             LDR.N    R0,??DataTable21_2
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   1340          
   1341              OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24_19
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   1342          
   1343              OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   1344          
   1345              OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   1346              OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable24_8
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6001             STR      R1,[R0, #+0]
   1347          
   1348          #if OS_TASK_STAT_EN > 0u
   1349              OSIdleCtrRun              = 0uL;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable24_20
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   1350              OSIdleCtrMax              = 0uL;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable24_9
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
   1351              OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   1352          #endif
   1353          
   1354          #ifdef OS_SAFETY_CRITICAL_IEC61508
   1355              OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
   1356          #endif
   1357          
   1358          #if OS_TASK_REG_TBL_SIZE > 0u
   1359              OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable24_21
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x7001             STRB     R1,[R0, #+0]
   1360          #endif
   1361          }
   \   00000054   0x4770             BX       LR               ;; return
   1362          /*$PAGE*/
   1363          /*
   1364          *********************************************************************************************************
   1365          *                                             INITIALIZATION
   1366          *                                       INITIALIZE THE READY LIST
   1367          *
   1368          * Description: This function is called by OSInit() to initialize the Ready List.
   1369          *
   1370          * Arguments  : none
   1371          *
   1372          * Returns    : none
   1373          *********************************************************************************************************
   1374          */
   1375          

   \                                 In section .text, align 2, keep-with-next
   1376          static  void  OS_InitRdyList (void)
   1377          {
   1378              INT8U  i;
   1379          
   1380          
   1381              OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
   \                     OS_InitRdyList:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x700A             STRB     R2,[R1, #+0]
   1382              for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0008             MOVS     R0,R1
   \                     ??OS_InitRdyList_0:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD206             BCS.N    ??OS_InitRdyList_1
   1383                  OSRdyTbl[i] = 0u;
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable24_15
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x5442             STRB     R2,[R0, R1]
   1384              }
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xE7F5             B.N      ??OS_InitRdyList_0
   1385          
   1386              OSPrioCur     = 0u;
   \                     ??OS_InitRdyList_1:
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable24_6
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x700A             STRB     R2,[R1, #+0]
   1387              OSPrioHighRdy = 0u;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable24_3
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x700A             STRB     R2,[R1, #+0]
   1388          
   1389              OSTCBHighRdy  = (OS_TCB *)0;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable24_5
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1390              OSTCBCur      = (OS_TCB *)0;
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x600A             STR      R2,[R1, #+0]
   1391          }
   \   00000040   0x4770             BX       LR               ;; return
   1392          
   1393          /*$PAGE*/
   1394          /*
   1395          *********************************************************************************************************
   1396          *                                             INITIALIZATION
   1397          *                                         CREATING THE IDLE TASK
   1398          *
   1399          * Description: This function creates the Idle Task.
   1400          *
   1401          * Arguments  : none
   1402          *
   1403          * Returns    : none
   1404          *********************************************************************************************************
   1405          */
   1406          

   \                                 In section .text, align 2, keep-with-next
   1407          static  void  OS_InitTaskIdle (void)
   1408          {
   \                     OS_InitTaskIdle:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1409          #if OS_TASK_NAME_EN > 0u
   1410              INT8U  err;
   1411          #endif
   1412          
   1413          
   1414          #if OS_TASK_CREATE_EXT_EN > 0u
   1415              #if OS_STK_GROWTH == 1u
   1416              (void)OSTaskCreateExt(OS_TaskIdle,
   1417                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1418                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
   1419                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1420                                    OS_TASK_IDLE_ID,
   1421                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
   1422                                    OS_TASK_IDLE_STK_SIZE,
   1423                                    (void *)0,                                 /* No TCB extension                     */
   1424                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x9004             STR      R0,[SP, #+16]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_22
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x233F             MOVS     R3,#+63
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24_23
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      ADR.W    R0,OS_TaskIdle
   \   00000028   0x.... 0x....      BL       OSTaskCreateExt
   \   0000002C   0x0004             MOVS     R4,R0
   1425              #else
   1426              (void)OSTaskCreateExt(OS_TaskIdle,
   1427                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1428                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1429                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1430                                    OS_TASK_IDLE_ID,
   1431                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
   1432                                    OS_TASK_IDLE_STK_SIZE,
   1433                                    (void *)0,                                 /* No TCB extension                     */
   1434                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1435              #endif
   1436          #else
   1437              #if OS_STK_GROWTH == 1u
   1438              (void)OSTaskCreate(OS_TaskIdle,
   1439                                 (void *)0,
   1440                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
   1441                                 OS_TASK_IDLE_PRIO);
   1442              #else
   1443              (void)OSTaskCreate(OS_TaskIdle,
   1444                                 (void *)0,
   1445                                 &OSTaskIdleStk[0],
   1446                                 OS_TASK_IDLE_PRIO);
   1447              #endif
   1448          #endif
   1449          
   1450          #if OS_TASK_NAME_EN > 0u
   1451              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
   \   0000002E   0xAA05             ADD      R2,SP,#+20
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable24_24
   \   00000034   0x203F             MOVS     R0,#+63
   \   00000036   0x.... 0x....      BL       OSTaskNameSet
   1452          #endif
   1453          }
   \   0000003A   0xB006             ADD      SP,SP,#+24
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1454          /*$PAGE*/
   1455          /*
   1456          *********************************************************************************************************
   1457          *                                             INITIALIZATION
   1458          *                                      CREATING THE STATISTIC TASK
   1459          *
   1460          * Description: This function creates the Statistic Task.
   1461          *
   1462          * Arguments  : none
   1463          *
   1464          * Returns    : none
   1465          *********************************************************************************************************
   1466          */
   1467          
   1468          #if OS_TASK_STAT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1469          static  void  OS_InitTaskStat (void)
   1470          {
   \                     OS_InitTaskStat:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1471          #if OS_TASK_NAME_EN > 0u
   1472              INT8U  err;
   1473          #endif
   1474          
   1475          
   1476          #if OS_TASK_CREATE_EXT_EN > 0u
   1477              #if OS_STK_GROWTH == 1u
   1478              (void)OSTaskCreateExt(OS_TaskStat,
   1479                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1480                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
   1481                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1482                                    OS_TASK_STAT_ID,
   1483                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1484                                    OS_TASK_STAT_STK_SIZE,
   1485                                    (void *)0,                                   /* No TCB extension               */
   1486                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x9004             STR      R0,[SP, #+16]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_25
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xF64F 0x70FE      MOVW     R0,#+65534
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x233E             MOVS     R3,#+62
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24_26
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      ADR.W    R0,OS_TaskStat
   \   00000028   0x.... 0x....      BL       OSTaskCreateExt
   \   0000002C   0x0004             MOVS     R4,R0
   1487              #else
   1488              (void)OSTaskCreateExt(OS_TaskStat,
   1489                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1490                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1491                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1492                                    OS_TASK_STAT_ID,
   1493                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
   1494                                    OS_TASK_STAT_STK_SIZE,
   1495                                    (void *)0,                                   /* No TCB extension               */
   1496                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1497              #endif
   1498          #else
   1499              #if OS_STK_GROWTH == 1u
   1500              (void)OSTaskCreate(OS_TaskStat,
   1501                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1502                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
   1503                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1504              #else
   1505              (void)OSTaskCreate(OS_TaskStat,
   1506                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1507                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1508                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1509              #endif
   1510          #endif
   1511          
   1512          #if OS_TASK_NAME_EN > 0u
   1513              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
   \   0000002E   0xAA05             ADD      R2,SP,#+20
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable24_27
   \   00000034   0x203E             MOVS     R0,#+62
   \   00000036   0x.... 0x....      BL       OSTaskNameSet
   1514          #endif
   1515          }
   \   0000003A   0xB006             ADD      SP,SP,#+24
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1516          #endif
   1517          /*$PAGE*/
   1518          /*
   1519          *********************************************************************************************************
   1520          *                                             INITIALIZATION
   1521          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1522          *
   1523          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1524          *
   1525          * Arguments  : none
   1526          *
   1527          * Returns    : none
   1528          *********************************************************************************************************
   1529          */
   1530          

   \                                 In section .text, align 2, keep-with-next
   1531          static  void  OS_InitTCBList (void)
   1532          {
   \                     OS_InitTCBList:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1533              INT8U    ix;
   1534              INT8U    ix_next;
   1535              OS_TCB  *ptcb1;
   1536              OS_TCB  *ptcb2;
   1537          
   1538          
   1539              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   \   00000002   0xF44F 0x61F2      MOV      R1,#+1936
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_28
   \   0000000A   0x.... 0x....      BL       OS_MemClr
   1540              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   00000016   0x.... 0x....      BL       OS_MemClr
   1541              for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0004             MOVS     R4,R0
   \                     ??OS_InitTCBList_0:
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C15             CMP      R4,#+21
   \   00000022   0xD214             BCS.N    ??OS_InitTCBList_1
   1542                  ix_next =  ix + 1u;
   \   00000024   0x1C60             ADDS     R0,R4,#+1
   \   00000026   0x0005             MOVS     R5,R0
   1543                  ptcb1   = &OSTCBTbl[ix];
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2058             MOVS     R0,#+88
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable24_28
   \   00000030   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000034   0x0006             MOVS     R6,R0
   1544                  ptcb2   = &OSTCBTbl[ix_next];
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2058             MOVS     R0,#+88
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable24_28
   \   0000003E   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000042   0x0007             MOVS     R7,R0
   1545                  ptcb1->OSTCBNext = ptcb2;
   \   00000044   0x6177             STR      R7,[R6, #+20]
   1546          #if OS_TASK_NAME_EN > 0u
   1547                  ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
   \   00000046   0x....             ADR.N    R0,??DataTable21  ;; "\?"
   \   00000048   0x6530             STR      R0,[R6, #+80]
   1548          #endif
   1549              }
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xE7E7             B.N      ??OS_InitTCBList_0
   1550              ptcb1                   = &OSTCBTbl[ix];
   \                     ??OS_InitTCBList_1:
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x2058             MOVS     R0,#+88
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable24_28
   \   00000056   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000005A   0x0006             MOVS     R6,R0
   1551              ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6170             STR      R0,[R6, #+20]
   1552          #if OS_TASK_NAME_EN > 0u
   1553              ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
   \   00000060   0x....             ADR.N    R0,??DataTable21  ;; "\?"
   \   00000062   0x6530             STR      R0,[R6, #+80]
   1554          #endif
   1555              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable24_13
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   1556              OSTCBFreeList           = &OSTCBTbl[0];
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable24_29
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable24_28
   \   00000074   0x6001             STR      R1,[R0, #+0]
   1557          }
   \   00000076   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1558          /*$PAGE*/
   1559          /*
   1560          *********************************************************************************************************
   1561          *                                      CLEAR A SECTION OF MEMORY
   1562          *
   1563          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1564          *
   1565          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1566          *
   1567          *              size     is the number of bytes to clear.
   1568          *
   1569          * Returns    : none
   1570          *
   1571          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1572          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1573          *                 of the uses of this function gets close to this limit.
   1574          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1575          *                 of the alignment of the destination.
   1576          *********************************************************************************************************
   1577          */
   1578          

   \                                 In section .text, align 2, keep-with-next
   1579          void  OS_MemClr (INT8U  *pdest,
   1580                           INT16U  size)
   1581          {
   1582              while (size > 0u) {
   \                     OS_MemClr:
   \                     ??OS_MemClr_0:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??OS_MemClr_1
   1583                  *pdest++ = (INT8U)0;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x7002             STRB     R2,[R0, #+0]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   1584                  size--;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xE7F7             B.N      ??OS_MemClr_0
   1585              }
   1586          }
   \                     ??OS_MemClr_1:
   \   00000010   0x4770             BX       LR               ;; return
   1587          /*$PAGE*/
   1588          /*
   1589          *********************************************************************************************************
   1590          *                                       COPY A BLOCK OF MEMORY
   1591          *
   1592          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1593          *              location to another.
   1594          *
   1595          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1596          *
   1597          *              psrc     is a pointer to the 'source'      memory block
   1598          *
   1599          *              size     is the number of bytes to copy.
   1600          *
   1601          * Returns    : none
   1602          *
   1603          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1604          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1605          *                 is not a situation that will happen.
   1606          *              2) Note that we can only copy up to 64K bytes of RAM
   1607          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1608          *                 of the alignment of the source and destination.
   1609          *********************************************************************************************************
   1610          */
   1611          

   \                                 In section .text, align 2, keep-with-next
   1612          void  OS_MemCopy (INT8U  *pdest,
   1613                            INT8U  *psrc,
   1614                            INT16U  size)
   1615          {
   1616              while (size > 0u) {
   \                     OS_MemCopy:
   \                     ??OS_MemCopy_0:
   \   00000000   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD005             BEQ.N    ??OS_MemCopy_1
   1617                  *pdest++ = *psrc++;
   \   00000006   0x780B             LDRB     R3,[R1, #+0]
   \   00000008   0x7003             STRB     R3,[R0, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   1618                  size--;
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0xE7F6             B.N      ??OS_MemCopy_0
   1619              }
   1620          }
   \                     ??OS_MemCopy_1:
   \   00000012   0x4770             BX       LR               ;; return
   1621          /*$PAGE*/
   1622          /*
   1623          *********************************************************************************************************
   1624          *                                              SCHEDULER
   1625          *
   1626          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1627          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1628          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1629          *
   1630          * Arguments  : none
   1631          *
   1632          * Returns    : none
   1633          *
   1634          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1635          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1636          *********************************************************************************************************
   1637          */
   1638          

   \                                 In section .text, align 2, keep-with-next
   1639          void  OS_Sched (void)
   1640          {
   \                     OS_Sched:
   \   00000000   0xB510             PUSH     {R4,LR}
   1641          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
   1642              OS_CPU_SR  cpu_sr = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
   1643          #endif
   1644          
   1645          
   1646          
   1647              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   1648              if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
   \   0000000A   0x....             LDR.N    R0,??DataTable21_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD120             BNE.N    ??OS_Sched_0
   1649                  if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
   \   00000012   0x....             LDR.N    R0,??DataTable21_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD11C             BNE.N    ??OS_Sched_0
   1650                      OS_SchedNew();
   \   0000001A   0x.... 0x....      BL       OS_SchedNew
   1651                      OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000001E   0x....             LDR.N    R0,??DataTable24_3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x....             LDR.N    R1,??DataTable24_4
   \   00000024   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000028   0x....             LDR.N    R1,??DataTable24_5
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1652                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   0000002C   0x....             LDR.N    R0,??DataTable24_3
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x....             LDR.N    R1,??DataTable24_6
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD00D             BEQ.N    ??OS_Sched_0
   1653          #if OS_TASK_PROFILE_EN > 0u
   1654                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000038   0x....             LDR.N    R0,??DataTable24_5
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x....             LDR.N    R1,??DataTable24_5
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x63C8             STR      R0,[R1, #+60]
   1655          #endif
   1656                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   00000046   0x....             LDR.N    R0,??DataTable24_7
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R1,??DataTable24_7
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1657                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000050   0x.... 0x....      BL       OSCtxSw
   1658                      }
   1659                  }
   1660              }
   1661              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0:
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
   1662          }
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1663          
   1664          
   1665          /*
   1666          *********************************************************************************************************
   1667          *                               FIND HIGHEST PRIORITY TASK READY TO RUN
   1668          *
   1669          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1670          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1671          *
   1672          * Arguments  : none
   1673          *
   1674          * Returns    : none
   1675          *
   1676          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1677          *              2) Interrupts are assumed to be disabled when this function is called.
   1678          *********************************************************************************************************
   1679          */
   1680          

   \                                 In section .text, align 2, keep-with-next
   1681          static  void  OS_SchedNew (void)
   1682          {
   1683          #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
   1684              INT8U   y;
   1685          
   1686          
   1687              y             = OSUnMapTbl[OSRdyGrp];
   \                     OS_SchedNew:
   \   00000000   0x....             LDR.N    R1,??DataTable24_14
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable24_16
   \   00000006   0x5C89             LDRB     R1,[R1, R2]
   \   00000008   0x0008             MOVS     R0,R1
   1688              OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x....             LDR.N    R1,??DataTable24_15
   \   00000010   0x5C41             LDRB     R1,[R0, R1]
   \   00000012   0x....             LDR.N    R2,??DataTable24_16
   \   00000014   0x5C89             LDRB     R1,[R1, R2]
   \   00000016   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   0000001A   0x....             LDR.N    R2,??DataTable24_3
   \   0000001C   0x7011             STRB     R1,[R2, #+0]
   1689          #else                                            /* We support up to 256 tasks                         */
   1690              INT8U     y;
   1691              OS_PRIO  *ptbl;
   1692          
   1693          
   1694              if ((OSRdyGrp & 0xFFu) != 0u) {
   1695                  y = OSUnMapTbl[OSRdyGrp & 0xFFu];
   1696              } else {
   1697                  y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
   1698              }
   1699              ptbl = &OSRdyTbl[y];
   1700              if ((*ptbl & 0xFFu) != 0u) {
   1701                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
   1702              } else {
   1703                  OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
   1704              }
   1705          #endif
   1706          }
   \   0000001E   0x4770             BX       LR               ;; return
   1707          
   1708          /*$PAGE*/
   1709          /*
   1710          *********************************************************************************************************
   1711          *                               DETERMINE THE LENGTH OF AN ASCII STRING
   1712          *
   1713          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1714          *              (excluding the NUL character).
   1715          *
   1716          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1717          *
   1718          * Returns    : The size of the string (excluding the NUL terminating character)
   1719          *
   1720          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1721          *              2) The string to check must be less than 255 characters long.
   1722          *********************************************************************************************************
   1723          */
   1724          
   1725          #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1726          INT8U  OS_StrLen (INT8U *psrc)
   1727          {
   \                     OS_StrLen:
   \   00000000   0x0001             MOVS     R1,R0
   1728              INT8U  len;
   1729          
   1730          
   1731          #if OS_ARG_CHK_EN > 0u
   1732              if (psrc == (INT8U *)0) {
   1733                  return (0u);
   1734              }
   1735          #endif
   1736          
   1737              len = 0u;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0010             MOVS     R0,R2
   1738              while (*psrc != OS_ASCII_NUL) {
   \                     ??OS_StrLen_0:
   \   00000006   0x780A             LDRB     R2,[R1, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD002             BEQ.N    ??OS_StrLen_1
   1739                  psrc++;
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   1740                  len++;
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0xE7F9             B.N      ??OS_StrLen_0
   1741              }
   1742              return (len);
   \                     ??OS_StrLen_1:
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1743          }
   1744          #endif
   1745          /*$PAGE*/
   1746          /*
   1747          *********************************************************************************************************
   1748          *                                              IDLE TASK
   1749          *
   1750          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1751          *              executes because they are ALL waiting for event(s) to occur.
   1752          *
   1753          * Arguments  : none
   1754          *
   1755          * Returns    : none
   1756          *
   1757          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1758          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1759          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1760          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1761          *                 interrupts.
   1762          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1763          *                 power.
   1764          *********************************************************************************************************
   1765          */
   1766          

   \                                 In section .text, align 4, keep-with-next
   1767          void  OS_TaskIdle (void *p_arg)
   1768          {
   \                     OS_TaskIdle:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1769          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1770              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
   1771          #endif
   1772          
   1773          
   1774          
   1775              p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
   1776              for (;;) {
   1777                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0:
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   1778                  OSIdleCtr++;
   \   0000000C   0x....             LDR.N    R0,??DataTable24_8
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable24_8
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1779                  OS_EXIT_CRITICAL();
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Restore
   1780                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   0000001C   0x.... 0x....      BL       OSTaskIdleHook
   \   00000020   0xE7F1             B.N      ??OS_TaskIdle_0
   1781              }
   1782          }
   1783          /*$PAGE*/
   1784          /*
   1785          *********************************************************************************************************
   1786          *                                           STATISTICS TASK
   1787          *
   1788          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1789          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1790          *              CPU usage is determined by:
   1791          *
   1792          *                                          OSIdleCtr
   1793          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1794          *                                         OSIdleCtrMax
   1795          *
   1796          * Arguments  : parg     this pointer is not used at this time.
   1797          *
   1798          * Returns    : none
   1799          *
   1800          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1801          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1802          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1803          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1804          *                 maximum value for the idle counter.
   1805          *********************************************************************************************************
   1806          */
   1807          
   1808          #if OS_TASK_STAT_EN > 0u

   \                                 In section .text, align 4, keep-with-next
   1809          void  OS_TaskStat (void *p_arg)
   1810          {
   \                     OS_TaskStat:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1811          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1812              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2400             MOVS     R4,#+0
   1813          #endif
   1814          
   1815          
   1816          
   1817              p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
   1818              while (OSStatRdy == OS_FALSE) {
   \                     ??OS_TaskStat_0:
   \   00000006   0x....             LDR.N    R0,??DataTable24_10
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE.N    ??OS_TaskStat_1
   1819                  OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
   \   0000000E   0x20C8             MOVS     R0,#+200
   \   00000010   0x.... 0x....      BL       OSTimeDly
   \   00000014   0xE7F7             B.N      ??OS_TaskStat_0
   1820              }
   1821              OSIdleCtrMax /= 100uL;
   \                     ??OS_TaskStat_1:
   \   00000016   0x....             LDR.N    R0,??DataTable24_9
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2164             MOVS     R1,#+100
   \   0000001C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000020   0x....             LDR.N    R1,??DataTable24_9
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1822              if (OSIdleCtrMax == 0uL) {
   \   00000024   0x....             LDR.N    R0,??DataTable24_9
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD105             BNE.N    ??OS_TaskStat_2
   1823                  OSCPUUsage = 0u;
   \   0000002C   0x....             LDR.N    R0,??DataTable24_30
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x7001             STRB     R1,[R0, #+0]
   1824          #if OS_TASK_SUSPEND_EN > 0u
   1825                  (void)OSTaskSuspend(OS_PRIO_SELF);
   \   00000032   0x20FF             MOVS     R0,#+255
   \   00000034   0x.... 0x....      BL       OSTaskSuspend
   1826          #else
   1827                  for (;;) {
   1828                      OSTimeDly(OS_TICKS_PER_SEC);
   1829                  }
   1830          #endif
   1831              }
   1832              OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_2:
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000003C   0x0004             MOVS     R4,R0
   1833              OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
   \   0000003E   0x....             LDR.N    R0,??DataTable24_9
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2164             MOVS     R1,#+100
   \   00000044   0x4348             MULS     R0,R1,R0
   \   00000046   0x....             LDR.N    R1,??DataTable24_8
   \   00000048   0x6008             STR      R0,[R1, #+0]
   1834              OS_EXIT_CRITICAL();
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       OS_CPU_SR_Restore
   1835              for (;;) {
   1836                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskStat_3:
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000054   0x0004             MOVS     R4,R0
   1837                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   \   00000056   0x....             LDR.N    R0,??DataTable24_20
   \   00000058   0x....             LDR.N    R1,??DataTable24_8
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   1838                  OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
   \   0000005E   0x....             LDR.N    R0,??DataTable24_8
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x6001             STR      R1,[R0, #+0]
   1839                  OS_EXIT_CRITICAL();
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Restore
   1840                  OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
   \   0000006A   0x....             LDR.N    R0,??DataTable24_20
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x....             LDR.N    R1,??DataTable24_9
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000076   0xF1D0 0x0064      RSBS     R0,R0,#+100
   \   0000007A   0x....             LDR.N    R1,??DataTable24_30
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   1841                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \   0000007E   0x.... 0x....      BL       OSTaskStatHook
   1842          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
   1843                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   \   00000082   0x.... 0x....      BL       OS_TaskStatStkChk
   1844          #endif
   1845                  OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
   \   00000086   0x2064             MOVS     R0,#+100
   \   00000088   0x.... 0x....      BL       OSTimeDly
   \   0000008C   0xE7E0             B.N      ??OS_TaskStat_3
   1846              }
   1847          }
   1848          #endif
   1849          /*$PAGE*/
   1850          /*
   1851          *********************************************************************************************************
   1852          *                                        CHECK ALL TASK STACKS
   1853          *
   1854          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1855          *
   1856          * Arguments  : none
   1857          *
   1858          * Returns    : none
   1859          *********************************************************************************************************
   1860          */
   1861          
   1862          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1863          void  OS_TaskStatStkChk (void)
   1864          {
   \                     OS_TaskStatStkChk:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   1865              OS_TCB      *ptcb;
   1866              OS_STK_DATA  stk_data;
   1867              INT8U        err;
   1868              INT8U        prio;
   1869          
   1870          
   1871              for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0006             MOVS     R6,R0
   \                     ??OS_TaskStatStkChk_0:
   \   00000006   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000008   0x2E40             CMP      R6,#+64
   \   0000000A   0xDA1A             BGE.N    ??OS_TaskStatStkChk_1
   1872                  err = OSTaskStkChk(prio, &stk_data);
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       OSTaskStkChk
   \   00000016   0x0005             MOVS     R5,R0
   1873                  if (err == OS_ERR_NONE) {
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD10F             BNE.N    ??OS_TaskStatStkChk_2
   1874                      ptcb = OSTCBPrioTbl[prio];
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x....             LDR.N    R0,??DataTable24_4
   \   00000022   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000026   0x0004             MOVS     R4,R0
   1875                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD008             BEQ.N    ??OS_TaskStatStkChk_2
   1876                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD006             BEQ.N    ??OS_TaskStatStkChk_2
   1877          #if OS_TASK_PROFILE_EN > 0u
   1878                              #if OS_STK_GROWTH == 1u
   1879                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   00000038   0x64A0             STR      R0,[R4, #+72]
   1880                              #else
   1881                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1882                              #endif
   1883                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0x64E0             STR      R0,[R4, #+76]
   1884          #endif
   1885                          }
   1886                      }
   1887                  }
   1888              }
   \                     ??OS_TaskStatStkChk_2:
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0xE7E1             B.N      ??OS_TaskStatStkChk_0
   1889          }
   \                     ??OS_TaskStatStkChk_1:
   \   00000042   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1890          #endif
   1891          /*$PAGE*/
   1892          /*
   1893          *********************************************************************************************************
   1894          *                                           INITIALIZE TCB
   1895          *
   1896          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1897          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1898          *
   1899          * Arguments  : prio          is the priority of the task being created
   1900          *
   1901          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1902          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1903          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1904          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1905          *                            specific.
   1906          *
   1907          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1908          *                            'OSTaskCreate()'.
   1909          *
   1910          *              id            is the task's ID (0..65535)
   1911          *
   1912          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1913          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1914          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1915          *                            units are established by the #define constant OS_STK which is CPU
   1916          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1917          *
   1918          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1919          *                            control block.  This allows you to store the contents of floating-point
   1920          *                            registers, MMU registers or anything else you could find useful during a
   1921          *                            context switch.  You can even assign a name to each task and store this name
   1922          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1923          *
   1924          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1925          *                            0 if called from 'OSTaskCreate()'.
   1926          *
   1927          * Returns    : OS_ERR_NONE         if the call was successful
   1928          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1929          *                                  be created.
   1930          *
   1931          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1932          *********************************************************************************************************
   1933          */
   1934          

   \                                 In section .text, align 2, keep-with-next
   1935          INT8U  OS_TCBInit (INT8U    prio,
   1936                             OS_STK  *ptos,
   1937                             OS_STK  *pbos,
   1938                             INT16U   id,
   1939                             INT32U   stk_size,
   1940                             void    *pext,
   1941                             INT16U   opt)
   1942          {
   \                     OS_TCBInit:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9F0C             LDR      R7,[SP, #+48]
   \   0000000A   0xF8DD 0x8034      LDR      R8,[SP, #+52]
   \   0000000E   0x9C0E             LDR      R4,[SP, #+56]
   1943              OS_TCB    *ptcb;
   1944          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
   1945              OS_CPU_SR  cpu_sr = 0u;
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   1946          #endif
   1947          #if OS_TASK_REG_TBL_SIZE > 0u
   1948              INT8U      i;
   1949          #endif
   1950          
   1951          
   1952              OS_ENTER_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x4682             MOV      R10,R0
   1953              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   0000001A   0x....             LDR.N    R0,??DataTable24_29
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x4681             MOV      R9,R0
   1954              if (ptcb != (OS_TCB *)0) {
   \   00000020   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000024   0xF000 0x80A6      BEQ.W    ??OS_TCBInit_0
   1955                  OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
   \   00000028   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   0000002C   0x....             LDR.N    R1,??DataTable24_29
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1956                  OS_EXIT_CRITICAL();
   \   00000030   0x4650             MOV      R0,R10
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
   1957                  ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
   \   00000036   0x9801             LDR      R0,[SP, #+4]
   \   00000038   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1958                  ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
   \   0000003C   0xF889 0x5036      STRB     R5,[R9, #+54]
   1959                  ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF889 0x0034      STRB     R0,[R9, #+52]
   1960                  ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF889 0x0035      STRB     R0,[R9, #+53]
   1961                  ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C9 0x0030      STR      R0,[R9, #+48]
   1962          
   1963          #if OS_TASK_CREATE_EXT_EN > 0u
   1964                  ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
   \   00000052   0xF8C9 0x8004      STR      R8,[R9, #+4]
   1965                  ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
   \   00000056   0xF8C9 0x700C      STR      R7,[R9, #+12]
   1966                  ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0xF8C9 0x0008      STR      R0,[R9, #+8]
   1967                  ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
   \   00000060   0xF8A9 0x4010      STRH     R4,[R9, #+16]
   1968                  ptcb->OSTCBId            = id;                     /* Store task ID                            */
   \   00000064   0xF8A9 0x6012      STRH     R6,[R9, #+18]
   1969          #else
   1970                  pext                     = pext;                   /* Prevent compiler warning if not used     */
   1971                  stk_size                 = stk_size;
   1972                  pbos                     = pbos;
   1973                  opt                      = opt;
   1974                  id                       = id;
   1975          #endif
   1976          
   1977          #if OS_TASK_DEL_EN > 0u
   1978                  ptcb->OSTCBDelReq        = OS_ERR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF889 0x003B      STRB     R0,[R9, #+59]
   1979          #endif
   1980          
   1981          #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
   1982                  ptcb->OSTCBY             = (INT8U)(prio >> 3u);
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x08E8             LSRS     R0,R5,#+3
   \   00000072   0xF889 0x0038      STRB     R0,[R9, #+56]
   1983                  ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
   \   00000076   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   0000007A   0xF889 0x0037      STRB     R0,[R9, #+55]
   1984          #else                                                             /* Pre-compute X, Y                  */
   1985                  ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
   1986                  ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
   1987          #endif
   1988                                                                            /* Pre-compute BitX and BitY         */
   1989                  ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF899 0x1038      LDRB     R1,[R9, #+56]
   \   00000084   0x4088             LSLS     R0,R0,R1
   \   00000086   0xF889 0x003A      STRB     R0,[R9, #+58]
   1990                  ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF899 0x1037      LDRB     R1,[R9, #+55]
   \   00000090   0x4088             LSLS     R0,R0,R1
   \   00000092   0xF889 0x0039      STRB     R0,[R9, #+57]
   1991          
   1992          #if (OS_EVENT_EN)
   1993                  ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF8C9 0x001C      STR      R0,[R9, #+28]
   1994          #if (OS_EVENT_MULTI_EN > 0u)
   1995                  ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF8C9 0x0020      STR      R0,[R9, #+32]
   1996          #endif
   1997          #endif
   1998          
   1999          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
   2000                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8C9 0x0028      STR      R0,[R9, #+40]
   2001          #endif
   2002          
   2003          #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
   2004                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8C9 0x0024      STR      R0,[R9, #+36]
   2005          #endif
   2006          
   2007          #if OS_TASK_PROFILE_EN > 0u
   2008                  ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8C9 0x003C      STR      R0,[R9, #+60]
   2009                  ptcb->OSTCBCyclesStart = 0uL;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF8C9 0x0044      STR      R0,[R9, #+68]
   2010                  ptcb->OSTCBCyclesTot   = 0uL;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF8C9 0x0040      STR      R0,[R9, #+64]
   2011                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8C9 0x0048      STR      R0,[R9, #+72]
   2012                  ptcb->OSTCBStkUsed     = 0uL;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF8C9 0x004C      STR      R0,[R9, #+76]
   2013          #endif
   2014          
   2015          #if OS_TASK_NAME_EN > 0u
   2016                  ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
   \   000000CC   0x....             ADR.N    R0,??DataTable24_1  ;; "\?"
   \   000000CE   0xF8C9 0x0050      STR      R0,[R9, #+80]
   2017          #endif
   2018          
   2019          #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
   2020                  for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x4683             MOV      R11,R0
   \                     ??OS_TCBInit_1:
   \   000000D6   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000DA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000DE   0xD108             BNE.N    ??OS_TCBInit_2
   2021                      ptcb->OSTCBRegTbl[i] = 0u;
   \   000000E0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000E4   0xEB19 0x008B      ADDS     R0,R9,R11, LSL #+2
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x6541             STR      R1,[R0, #+84]
   2022                  }
   \   000000EC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000F0   0xE7F1             B.N      ??OS_TCBInit_1
   2023          #endif
   2024          
   2025                  OSTCBInitHook(ptcb);
   \                     ??OS_TCBInit_2:
   \   000000F2   0x4648             MOV      R0,R9
   \   000000F4   0x.... 0x....      BL       OSTCBInitHook
   2026          
   2027                  OS_ENTER_CRITICAL();
   \   000000F8   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000FC   0x4682             MOV      R10,R0
   2028                  OSTCBPrioTbl[prio] = ptcb;
   \   000000FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000100   0x....             LDR.N    R0,??DataTable24_4
   \   00000102   0xF840 0x9025      STR      R9,[R0, R5, LSL #+2]
   2029                  OS_EXIT_CRITICAL();
   \   00000106   0x4650             MOV      R0,R10
   \   00000108   0x.... 0x....      BL       OS_CPU_SR_Restore
   2030          
   2031                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   0000010C   0x4648             MOV      R0,R9
   \   0000010E   0x.... 0x....      BL       OSTaskCreateHook
   2032          
   2033                  OS_ENTER_CRITICAL();
   \   00000112   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000116   0x4682             MOV      R10,R0
   2034                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   00000118   0x....             LDR.N    R0,??DataTable24_13
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF8C9 0x0014      STR      R0,[R9, #+20]
   2035                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF8C9 0x0018      STR      R0,[R9, #+24]
   2036                  if (OSTCBList != (OS_TCB *)0) {
   \   00000126   0x....             LDR.N    R0,??DataTable24_13
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD003             BEQ.N    ??OS_TCBInit_3
   2037                      OSTCBList->OSTCBPrev = ptcb;
   \   0000012E   0x....             LDR.N    R0,??DataTable24_13
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0xF8C0 0x9018      STR      R9,[R0, #+24]
   2038                  }
   2039                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_3:
   \   00000136   0x....             LDR.N    R0,??DataTable24_13
   \   00000138   0xF8C0 0x9000      STR      R9,[R0, #+0]
   2040                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   0000013C   0x....             LDR.N    R0,??DataTable24_14
   \   0000013E   0x7800             LDRB     R0,[R0, #+0]
   \   00000140   0xF899 0x103A      LDRB     R1,[R9, #+58]
   \   00000144   0x4308             ORRS     R0,R1,R0
   \   00000146   0x....             LDR.N    R1,??DataTable24_14
   \   00000148   0x7008             STRB     R0,[R1, #+0]
   2041                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000014A   0xF899 0x0038      LDRB     R0,[R9, #+56]
   \   0000014E   0x....             LDR.N    R1,??DataTable24_15
   \   00000150   0x5C40             LDRB     R0,[R0, R1]
   \   00000152   0xF899 0x1039      LDRB     R1,[R9, #+57]
   \   00000156   0x4308             ORRS     R0,R1,R0
   \   00000158   0xF899 0x1038      LDRB     R1,[R9, #+56]
   \   0000015C   0x....             LDR.N    R2,??DataTable24_15
   \   0000015E   0x5488             STRB     R0,[R1, R2]
   2042                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   00000160   0x....             LDR.N    R0,??DataTable24_19
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0x1C40             ADDS     R0,R0,#+1
   \   00000166   0x....             LDR.N    R1,??DataTable24_19
   \   00000168   0x7008             STRB     R0,[R1, #+0]
   2043                  OS_EXIT_CRITICAL();
   \   0000016A   0x4650             MOV      R0,R10
   \   0000016C   0x.... 0x....      BL       OS_CPU_SR_Restore
   2044                  return (OS_ERR_NONE);
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xE003             B.N      ??OS_TCBInit_4
   2045              }
   2046              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0:
   \   00000174   0x4650             MOV      R0,R10
   \   00000176   0x.... 0x....      BL       OS_CPU_SR_Restore
   2047              return (OS_ERR_TASK_NO_MORE_TCB);
   \   0000017A   0x2042             MOVS     R0,#+66
   \                     ??OS_TCBInit_4:
   \   0000017C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2048          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x........         DC32     OSTCBHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     OSCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     OSIdleCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     OSIdleCtrMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     OSStatRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     OSTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     OSTickStepState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x........         DC32     OSUnMapTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x........         DC32     OSEventTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x........         DC32     OSIdleCtrRun

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x........         DC32     OSTaskIdleStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_23:
   \   00000000   0x........         DC32     OSTaskIdleStk+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_24:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II Idle">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_25:
   \   00000000   0x........         DC32     OSTaskStatStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_26:
   \   00000000   0x........         DC32     OSTaskStatStk+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_27:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II Stat">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_28:
   \   00000000   0x........         DC32     OSTCBTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_29:
   \   00000000   0x........         DC32     OSTCBFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_30:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Idle">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Idle"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x49    
   \              0x64 0x6C    
   \              0x65 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Stat">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Stat"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x74 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSEventNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrLen
      24   OSEventNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      56   OSEventPendMulti
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
        56   -> OS_EventTaskRemoveMulti
        56   -> OS_EventTaskWaitMulti
        56   -> OS_Sched
       8   OSInit
         8   -> OSDebugInit
         8   -> OSInitHookBegin
         8   -> OSInitHookEnd
         8   -> OSTmr_Init
         8   -> OS_FlagInit
         8   -> OS_InitEventList
         8   -> OS_InitMisc
         8   -> OS_InitRdyList
         8   -> OS_InitTCBList
         8   -> OS_InitTaskIdle
         8   -> OS_InitTaskStat
         8   -> OS_MemInit
         8   -> OS_QInit
       0   OSIntEnter
       8   OSIntExit
         8   -> OSIntCtxSw
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_SchedNew
       8   OSSchedLock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
       8   OSSchedUnlock
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_Sched
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_SchedNew
       8   OSStatInit
         8   -> OSTimeDly
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      16   OSTimeTick
        16   -> OSTimeTickHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSVersion
       0   OS_Dummy
      40   OS_EventTaskRdy
        40   -> OS_EventTaskRemove
        40   -> OS_EventTaskRemoveMulti
       4   OS_EventTaskRemove
      16   OS_EventTaskRemoveMulti
       0   OS_EventTaskWait
       8   OS_EventTaskWaitMulti
       0   OS_EventWaitListInit
      24   OS_InitEventList
        24   -> OS_MemClr
       0   OS_InitMisc
       0   OS_InitRdyList
      24   OS_InitTCBList
        24   -> OS_MemClr
      32   OS_InitTaskIdle
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
      32   OS_InitTaskStat
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
       0   OS_MemClr
       0   OS_MemCopy
       8   OS_Sched
         8   -> OSCtxSw
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_SchedNew
       0   OS_SchedNew
       0   OS_StrLen
      48   OS_TCBInit
        48   -> OSTCBInitHook
        48   -> OSTaskCreateHook
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
      16   OS_TaskIdle
        16   -> OSTaskIdleHook
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OS_TaskStat
        16   -> OSTaskStatHook
        16   -> OSTaskSuspend
        16   -> OSTimeDly
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_TaskStatStkChk
      24   OS_TaskStatStkChk
        24   -> OSTaskStkChk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
      16  ?<Constant "uC/OS-II Idle">
      16  ?<Constant "uC/OS-II Stat">
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_27
       4  ??DataTable24_28
       4  ??DataTable24_29
       4  ??DataTable24_3
       4  ??DataTable24_30
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       1  OSCPUUsage
       4  OSCtxSwCtr
       4  OSEventFreeList
      84  OSEventNameGet
      60  OSEventNameSet
     730  OSEventPendMulti
    4200  OSEventTbl
       4  OSFlagFreeList
      80  OSFlagTbl
       4  OSIdleCtr
       4  OSIdleCtrMax
       4  OSIdleCtrRun
      56  OSInit
      36  OSIntEnter
     148  OSIntExit
       1  OSIntNesting
       1  OSLockNesting
       4  OSMemFreeList
     120  OSMemTbl
       1  OSPrioCur
       1  OSPrioHighRdy
       4  OSQFreeList
      96  OSQTbl
       1  OSRdyGrp
       8  OSRdyTbl
       1  OSRunning
      62  OSSchedLock
     100  OSSchedUnlock
      66  OSStart
      70  OSStatInit
       1  OSStatRdy
       4  OSTCBCur
       4  OSTCBFreeList
       4  OSTCBHighRdy
       4  OSTCBList
     256  OSTCBPrioTbl
    1936  OSTCBTbl
       1  OSTaskCtr
     512  OSTaskIdleStk
       1  OSTaskRegNextAvailID
     512  OSTaskStatStk
       1  OSTickStepState
       4  OSTime
     246  OSTimeTick
       2  OSTmrFree
       4  OSTmrFreeList
       4  OSTmrSem
       4  OSTmrSemSignal
     512  OSTmrTaskStk
     640  OSTmrTbl
       4  OSTmrTime
       2  OSTmrUsed
      64  OSTmrWheelTbl
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
     186  OS_EventTaskRdy
      50  OS_EventTaskRemove
      76  OS_EventTaskRemoveMulti
     142  OS_EventTaskWait
     174  OS_EventTaskWaitMulti
      28  OS_EventWaitListInit
     108  OS_InitEventList
      86  OS_InitMisc
      66  OS_InitRdyList
     120  OS_InitTCBList
      62  OS_InitTaskIdle
      62  OS_InitTaskStat
      18  OS_MemClr
      20  OS_MemCopy
      92  OS_Sched
      32  OS_SchedNew
      22  OS_StrLen
     384  OS_TCBInit
      34  OS_TaskIdle
     142  OS_TaskStat
      68  OS_TaskStatStkChk

 
 9 019 bytes in section .bss
   290 bytes in section .rodata
 3 774 bytes in section .text
 
 3 774 bytes of CODE  memory
   290 bytes of CONST memory
 9 019 bytes of DATA  memory

Errors: none
Warnings: none

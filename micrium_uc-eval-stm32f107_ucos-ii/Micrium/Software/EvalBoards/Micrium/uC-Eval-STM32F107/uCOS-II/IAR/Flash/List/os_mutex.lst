###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_mutex.c        #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_mutex.c" -D    #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_mutex.lst                 #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_mutex.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_mutex.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MUTEX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #include <ucos_ii.h>
     28          #endif
     29          
     30          
     31          #if OS_MUTEX_EN > 0u
     32          /*
     33          *********************************************************************************************************
     34          *                                           LOCAL CONSTANTS
     35          *********************************************************************************************************
     36          */
     37          
     38          #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
     39          #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
     40          
     41          #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
     42          
     43          /*
     44          *********************************************************************************************************
     45          *                                           LOCAL CONSTANTS
     46          *********************************************************************************************************
     47          */
     48          
     49          static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
     50          
     51          /*$PAGE*/
     52          /*
     53          *********************************************************************************************************
     54          *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
     55          *
     56          * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
     57          *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
     58          *              not available or the event did not occur.
     59          *
     60          * Arguments  : pevent     is a pointer to the event control block
     61          *
     62          *              perr       is a pointer to an error code which will be returned to your application:
     63          *                            OS_ERR_NONE         if the call was successful.
     64          *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
     65          *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
     66          *                            OS_ERR_PEND_ISR     if you called this function from an ISR
     67          *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
     68          *                                                HIGHER (i.e. a lower number) than the PCP.  This error
     69          *                                                indicates that you did not set the PCP higher (lower
     70          *                                                number) than ALL the tasks that compete for the Mutex.
     71          *                                                Unfortunately, this is something that could not be
     72          *                                                detected when the Mutex is created because we don't know
     73          *                                                what tasks will be using the Mutex.
     74          *
     75          * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
     76          *              == OS_FALSE   a) if the resource is not available
     77          *                            b) you didn't pass a pointer to a mutual exclusion semaphore
     78          *                            c) you called this function from an ISR
     79          *
     80          * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
     81          *              intended to be used by tasks only.
     82          *********************************************************************************************************
     83          */
     84          
     85          #if OS_MUTEX_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     86          BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
     87                                  INT8U     *perr)
     88          {
   \                     OSMutexAccept:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     89              INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
     90          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
     91              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
     92          #endif
     93          
     94          
     95          
     96          #ifdef OS_SAFETY_CRITICAL
     97              if (perr == (INT8U *)0) {
     98                  OS_SAFETY_CRITICAL_EXCEPTION();
     99                  return (OS_FALSE);
    100              }
    101          #endif
    102          
    103          #if OS_ARG_CHK_EN > 0u
    104              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
    105                  *perr = OS_ERR_PEVENT_NULL;
    106                  return (OS_FALSE);
    107              }
    108          #endif
    109              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD003             BEQ.N    ??OSMutexAccept_0
    110                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7028             STRB     R0,[R5, #+0]
    111                  return (OS_FALSE);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE041             B.N      ??OSMutexAccept_1
    112              }
    113              if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
   \                     ??OSMutexAccept_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD003             BEQ.N    ??OSMutexAccept_2
    114                  *perr = OS_ERR_PEND_ISR;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7028             STRB     R0,[R5, #+0]
    115                  return (OS_FALSE);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE038             B.N      ??OSMutexAccept_1
    116              }
    117              OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
   \                     ??OSMutexAccept_2:
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
    118              pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
   \   0000002E   0x8920             LDRH     R0,[R4, #+8]
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x0A00             LSRS     R0,R0,#+8
   \   00000034   0x0006             MOVS     R6,R0
    119              if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   00000036   0x7A20             LDRB     R0,[R4, #+8]
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x28FF             CMP      R0,#+255
   \   0000003C   0xD127             BNE.N    ??OSMutexAccept_3
    120                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
   \   0000003E   0x8920             LDRH     R0,[R4, #+8]
   \   00000040   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000044   0x8120             STRH     R0,[R4, #+8]
    121                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
   \   00000046   0x8920             LDRH     R0,[R4, #+8]
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000052   0x4308             ORRS     R0,R1,R0
   \   00000054   0x8120             STRH     R0,[R4, #+8]
    122                  pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x6060             STR      R0,[R4, #+4]
    123                  if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
    124                      (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2EFF             CMP      R6,#+255
   \   00000062   0xD00D             BEQ.N    ??OSMutexAccept_4
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xD305             BCC.N    ??OSMutexAccept_4
    125                       OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       OS_CPU_SR_Restore
    126                      *perr = OS_ERR_PCP_LOWER;
   \   0000007A   0x2078             MOVS     R0,#+120
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
   \   0000007E   0xE004             B.N      ??OSMutexAccept_5
    127                  } else {
    128                       OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_4:
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    129                      *perr = OS_ERR_NONE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x7028             STRB     R0,[R5, #+0]
    130                  }
    131                  return (OS_TRUE);
   \                     ??OSMutexAccept_5:
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE005             B.N      ??OSMutexAccept_1
    132              }
    133              OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_3:
   \   0000008E   0x0038             MOVS     R0,R7
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Restore
    134              *perr = OS_ERR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x7028             STRB     R0,[R5, #+0]
    135              return (OS_FALSE);
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??OSMutexAccept_1:
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    136          }
    137          #endif
    138          
    139          /*$PAGE*/
    140          /*
    141          *********************************************************************************************************
    142          *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
    143          *
    144          * Description: This function creates a mutual exclusion semaphore.
    145          *
    146          * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
    147          *                            other words, when the semaphore is acquired and a higher priority task
    148          *                            attempts to obtain the semaphore then the priority of the task owning the
    149          *                            semaphore is raised to this priority.  It is assumed that you will specify
    150          *                            a priority that is LOWER in value than ANY of the tasks competing for the
    151          *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
    152          *                            priority ceiling promotion is disabled. This way, the tasks accessing the
    153          *                            semaphore do not have their priority promoted.
    154          *
    155          *              perr          is a pointer to an error code which will be returned to your application:
    156          *                               OS_ERR_NONE         if the call was successful.
    157          *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
    158          *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
    159          *                                                   already exist.
    160          *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
    161          *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
    162          *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
    163          *
    164          * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    165          *                            created mutex.
    166          *              == (void *)0  if an error is detected.
    167          *
    168          * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
    169          *                 owning the mutex or 0xFF if no task owns the mutex.
    170          *
    171          *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
    172          *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
    173          *                 promotion is disabled.
    174          *********************************************************************************************************
    175          */
    176          

   \                                 In section .text, align 2, keep-with-next
    177          OS_EVENT  *OSMutexCreate (INT8U   prio,
    178                                    INT8U  *perr)
    179          {
   \                     OSMutexCreate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    180              OS_EVENT  *pevent;
    181          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    182              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
    183          #endif
    184          
    185          
    186          
    187          #ifdef OS_SAFETY_CRITICAL
    188              if (perr == (INT8U *)0) {
    189                  OS_SAFETY_CRITICAL_EXCEPTION();
    190                  return ((OS_EVENT *)0);
    191              }
    192          #endif
    193          
    194          #ifdef OS_SAFETY_CRITICAL_IEC61508
    195              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    196                  OS_SAFETY_CRITICAL_EXCEPTION();
    197                  return ((OS_EVENT *)0);
    198              }
    199          #endif
    200          
    201          #if OS_ARG_CHK_EN > 0u
    202              if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
    203                  if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
    204                     *perr = OS_ERR_PRIO_INVALID;
    205                      return ((OS_EVENT *)0);
    206                  }
    207              }
    208          #endif
    209              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSMutexCreate_0
    210                  *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    211                  return ((OS_EVENT *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE04A             B.N      ??OSMutexCreate_1
    212              }
    213              OS_ENTER_CRITICAL();
   \                     ??OSMutexCreate_0:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x0007             MOVS     R7,R0
    214              if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2CFF             CMP      R4,#+255
   \   00000024   0xD013             BEQ.N    ??OSMutexCreate_2
    215                  if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   0000002C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD006             BEQ.N    ??OSMutexCreate_3
    216                      OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
    217                     *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
   \   0000003A   0x2028             MOVS     R0,#+40
   \   0000003C   0x7028             STRB     R0,[R5, #+0]
    218                      return ((OS_EVENT *)0);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE036             B.N      ??OSMutexCreate_1
    219                  }
    220                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
   \                     ??OSMutexCreate_3:
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    221              }
    222          
    223              pevent = OSEventFreeList;                              /* Get next free event control block        */
   \                     ??OSMutexCreate_2:
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0006             MOVS     R6,R0
    224              if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD10F             BNE.N    ??OSMutexCreate_4
    225                  if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2CFF             CMP      R4,#+255
   \   0000005E   0xD005             BEQ.N    ??OSMutexCreate_5
    226                      OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    227                  }
    228                  OS_EXIT_CRITICAL();
   \                     ??OSMutexCreate_5:
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    229                 *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x7028             STRB     R0,[R5, #+0]
    230                  return (pevent);
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0xE01A             B.N      ??OSMutexCreate_1
    231              }
    232              OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
   \                     ??OSMutexCreate_4:
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x6840             LDR      R0,[R0, #+4]
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \   00000086   0x6008             STR      R0,[R1, #+0]
    233              OS_EXIT_CRITICAL();
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0x.... 0x....      BL       OS_CPU_SR_Restore
    234              pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0x7030             STRB     R0,[R6, #+0]
    235              pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0x0220             LSLS     R0,R4,#+8
   \   00000096   0xF050 0x00FF      ORRS     R0,R0,#0xFF
   \   0000009A   0x8130             STRH     R0,[R6, #+8]
    236              pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x6070             STR      R0,[R6, #+4]
    237          #if OS_EVENT_NAME_EN > 0u
    238              pevent->OSEventName = (INT8U *)(void *)"?";
   \   000000A0   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   000000A2   0x6170             STR      R0,[R6, #+20]
    239          #endif
    240              OS_EventWaitListInit(pevent);
   \   000000A4   0x0030             MOVS     R0,R6
   \   000000A6   0x.... 0x....      BL       OS_EventWaitListInit
    241             *perr = OS_ERR_NONE;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7028             STRB     R0,[R5, #+0]
    242              return (pevent);
   \   000000AE   0x0030             MOVS     R0,R6
   \                     ??OSMutexCreate_1:
   \   000000B0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    243          }
    244          
    245          /*$PAGE*/
    246          /*
    247          *********************************************************************************************************
    248          *                                           DELETE A MUTEX
    249          *
    250          * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
    251          *
    252          * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
    253          *
    254          *              opt           determines delete options as follows:
    255          *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
    256          *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
    257          *                                                    In this case, all the tasks pending will be readied.
    258          *
    259          *              perr          is a pointer to an error code that can contain one of the following values:
    260          *                            OS_ERR_NONE             The call was successful and the mutex was deleted
    261          *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
    262          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    263          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
    264          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    265          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    266          *
    267          * Returns    : pevent        upon error
    268          *              (OS_EVENT *)0 if the mutex was successfully deleted.
    269          *
    270          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    271          *                 the mutex MUST check the return code of OSMutexPend().
    272          *
    273          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    274          *                 time is directly proportional to the number of tasks waiting on the mutex.
    275          *
    276          *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
    277          *                 resource(s) will no longer be guarded by the mutex.
    278          *
    279          *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
    280          *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
    281          *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
    282          *                            that task will be made ready-to-run at its original priority.
    283          *********************************************************************************************************
    284          */
    285          
    286          #if OS_MUTEX_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    287          OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
    288                                 INT8U      opt,
    289                                 INT8U     *perr)
    290          {
   \                     OSMutexDel:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    291              BOOLEAN    tasks_waiting;
    292              OS_EVENT  *pevent_return;
    293              INT8U      pcp;                                        /* Priority ceiling priority                */
    294              INT8U      prio;
    295              OS_TCB    *ptcb;
    296          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    297              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    298          #endif
    299          
    300          
    301          
    302          #ifdef OS_SAFETY_CRITICAL
    303              if (perr == (INT8U *)0) {
    304                  OS_SAFETY_CRITICAL_EXCEPTION();
    305                  return ((OS_EVENT *)0);
    306              }
    307          #endif
    308          
    309          #if OS_ARG_CHK_EN > 0u
    310              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    311                  *perr = OS_ERR_PEVENT_NULL;
    312                  return (pevent);
    313              }
    314          #endif
    315              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   0000000E   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD003             BEQ.N    ??OSMutexDel_0
    316                  *perr = OS_ERR_EVENT_TYPE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    317                  return (pevent);
   \   0000001A   0x4658             MOV      R0,R11
   \   0000001C   0xE0B0             B.N      ??OSMutexDel_1
    318              }
    319              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMutexDel_0:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??OSMutexDel_2
    320                  *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
   \   00000028   0x200F             MOVS     R0,#+15
   \   0000002A   0x7028             STRB     R0,[R5, #+0]
    321                  return (pevent);
   \   0000002C   0x4658             MOV      R0,R11
   \   0000002E   0xE0A7             B.N      ??OSMutexDel_1
    322              }
    323              OS_ENTER_CRITICAL();
   \                     ??OSMutexDel_2:
   \   00000030   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000034   0x4682             MOV      R10,R0
    324              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
   \   00000036   0xF89B 0x000A      LDRB     R0,[R11, #+10]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??OSMutexDel_3
    325                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE001             B.N      ??OSMutexDel_4
    326              } else {
    327                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSMutexDel_3:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0006             MOVS     R6,R0
    328              }
    329              switch (opt) {
   \                     ??OSMutexDel_4:
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD002             BEQ.N    ??OSMutexDel_5
   \   0000004E   0x2C01             CMP      R4,#+1
   \   00000050   0xD035             BEQ.N    ??OSMutexDel_6
   \   00000052   0xE08E             B.N      ??OSMutexDel_7
    330                  case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
    331                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMutexDel_5:
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD12A             BNE.N    ??OSMutexDel_8
    332          #if OS_EVENT_NAME_EN > 0u
    333                           pevent->OSEventName   = (INT8U *)(void *)"?";
   \   0000005A   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   0000005C   0xF8CB 0x0014      STR      R0,[R11, #+20]
    334          #endif
    335                           pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
   \   00000060   0xF8BB 0x0008      LDRH     R0,[R11, #+8]
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x0A00             LSRS     R0,R0,#+8
   \   00000068   0x4680             MOV      R8,R0
    336                           if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
   \   0000006A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000072   0xD006             BEQ.N    ??OSMutexDel_9
    337                               OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0xF840 0x1028      STR      R1,[R0, R8, LSL #+2]
    338                           }
    339                           pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
   \                     ??OSMutexDel_9:
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF88B 0x0000      STRB     R0,[R11, #+0]
    340                           pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF8CB 0x0004      STR      R0,[R11, #+4]
    341                           pevent->OSEventCnt    = 0u;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF8AB 0x0008      STRH     R0,[R11, #+8]
    342                           OSEventFreeList       = pevent;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000009C   0xF8C0 0xB000      STR      R11,[R0, #+0]
    343                           OS_EXIT_CRITICAL();
   \   000000A0   0x4650             MOV      R0,R10
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    344                           *perr                 = OS_ERR_NONE;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7028             STRB     R0,[R5, #+0]
    345                           pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x0007             MOVS     R7,R0
   \   000000AE   0xE005             B.N      ??OSMutexDel_10
    346                       } else {
    347                           OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_8:
   \   000000B0   0x4650             MOV      R0,R10
   \   000000B2   0x.... 0x....      BL       OS_CPU_SR_Restore
    348                           *perr                 = OS_ERR_TASK_WAITING;
   \   000000B6   0x2049             MOVS     R0,#+73
   \   000000B8   0x7028             STRB     R0,[R5, #+0]
    349                           pevent_return         = pevent;
   \   000000BA   0x465F             MOV      R7,R11
    350                       }
    351                       break;
   \                     ??OSMutexDel_10:
   \   000000BC   0xE05F             B.N      ??OSMutexDel_11
    352          
    353                  case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
    354                       pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
   \                     ??OSMutexDel_6:
   \   000000BE   0xF8BB 0x0008      LDRH     R0,[R11, #+8]
   \   000000C2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C4   0x0A00             LSRS     R0,R0,#+8
   \   000000C6   0x4680             MOV      R8,R0
    355                       if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
   \   000000C8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CC   0xF1B8 0x0FFF      CMP      R8,#+255
   \   000000D0   0xD014             BEQ.N    ??OSMutexDel_12
    356                           prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
   \   000000D2   0xF8BB 0x0008      LDRH     R0,[R11, #+8]
   \   000000D6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    357                           ptcb = (OS_TCB *)pevent->OSEventPtr;
   \   000000DA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000DE   0x4681             MOV      R9,R0
    358                           if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
   \   000000E0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E4   0xD00A             BEQ.N    ??OSMutexDel_12
    359                               if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
   \   000000E6   0xF899 0x0036      LDRB     R0,[R9, #+54]
   \   000000EA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000EE   0x4540             CMP      R0,R8
   \   000000F0   0xD104             BNE.N    ??OSMutexDel_12
    360                                   OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
   \   000000F2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000F6   0x4648             MOV      R0,R9
   \   000000F8   0x.... 0x....      BL       OSMutex_RdyAtPrio
    361                               }
    362                           }
    363                       }
    364                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
   \                     ??OSMutexDel_12:
   \   000000FC   0xF89B 0x000A      LDRB     R0,[R11, #+10]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD006             BEQ.N    ??OSMutexDel_13
    365                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
   \   00000104   0x2302             MOVS     R3,#+2
   \   00000106   0x2210             MOVS     R2,#+16
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x4658             MOV      R0,R11
   \   0000010C   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000110   0xE7F4             B.N      ??OSMutexDel_12
    366                       }
    367          #if OS_EVENT_NAME_EN > 0u
    368                       pevent->OSEventName   = (INT8U *)(void *)"?";
   \                     ??OSMutexDel_13:
   \   00000112   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   00000114   0xF8CB 0x0014      STR      R0,[R11, #+20]
    369          #endif
    370                       pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
   \   00000118   0xF8BB 0x0008      LDRH     R0,[R11, #+8]
   \   0000011C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000011E   0x0A00             LSRS     R0,R0,#+8
   \   00000120   0x4680             MOV      R8,R0
    371                       if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
   \   00000122   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000126   0xF1B8 0x0FFF      CMP      R8,#+255
   \   0000012A   0xD006             BEQ.N    ??OSMutexDel_14
    372                           OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
   \   0000012C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0xF840 0x1028      STR      R1,[R0, R8, LSL #+2]
    373                       }
    374                       pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
   \                     ??OSMutexDel_14:
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF88B 0x0000      STRB     R0,[R11, #+0]
    375                       pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0xF8CB 0x0004      STR      R0,[R11, #+4]
    376                       pevent->OSEventCnt    = 0u;
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF8AB 0x0008      STRH     R0,[R11, #+8]
    377                       OSEventFreeList       = pevent;               /* Get next free event control block        */
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000154   0xF8C0 0xB000      STR      R11,[R0, #+0]
    378                       OS_EXIT_CRITICAL();
   \   00000158   0x4650             MOV      R0,R10
   \   0000015A   0x.... 0x....      BL       OS_CPU_SR_Restore
    379                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   0000015E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000160   0x2E01             CMP      R6,#+1
   \   00000162   0xD101             BNE.N    ??OSMutexDel_15
    380                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00000164   0x.... 0x....      BL       OS_Sched
    381                       }
    382                       *perr         = OS_ERR_NONE;
   \                     ??OSMutexDel_15:
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x7028             STRB     R0,[R5, #+0]
    383                       pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x0007             MOVS     R7,R0
    384                       break;
   \   00000170   0xE005             B.N      ??OSMutexDel_11
    385          
    386                  default:
    387                       OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_7:
   \   00000172   0x4650             MOV      R0,R10
   \   00000174   0x.... 0x....      BL       OS_CPU_SR_Restore
    388                       *perr         = OS_ERR_INVALID_OPT;
   \   00000178   0x2007             MOVS     R0,#+7
   \   0000017A   0x7028             STRB     R0,[R5, #+0]
    389                       pevent_return = pevent;
   \   0000017C   0x465F             MOV      R7,R11
    390                       break;
    391              }
    392              return (pevent_return);
   \                     ??OSMutexDel_11:
   \   0000017E   0x0038             MOVS     R0,R7
   \                     ??OSMutexDel_1:
   \   00000180   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    393          }
    394          #endif
    395          
    396          /*$PAGE*/
    397          /*
    398          *********************************************************************************************************
    399          *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
    400          *
    401          * Description: This function waits for a mutual exclusion semaphore.
    402          *
    403          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    404          *                            mutex.
    405          *
    406          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    407          *                            wait for the resource up to the amount of time specified by this argument.
    408          *                            If you specify 0, however, your task will wait forever at the specified
    409          *                            mutex or, until the resource becomes available.
    410          *
    411          *              perr          is a pointer to where an error message will be deposited.  Possible error
    412          *                            messages are:
    413          *                               OS_ERR_NONE        The call was successful and your task owns the mutex
    414          *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
    415          *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
    416          *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
    417          *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
    418          *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
    419          *                                                  would lead to a suspension.
    420          *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
    421          *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
    422          *                                                  indicates that you did not set the PCP higher (lower
    423          *                                                  number) than ALL the tasks that compete for the Mutex.
    424          *                                                  Unfortunately, this is something that could not be
    425          *                                                  detected when the Mutex is created because we don't know
    426          *                                                  what tasks will be using the Mutex.
    427          *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
    428          *
    429          * Returns    : none
    430          *
    431          * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
    432          *
    433          *              2) You MUST NOT change the priority of the task that owns the mutex
    434          *********************************************************************************************************
    435          */
    436          

   \                                 In section .text, align 2, keep-with-next
    437          void  OSMutexPend (OS_EVENT  *pevent,
    438                             INT32U     timeout,
    439                             INT8U     *perr)
    440          {
   \                     OSMutexPend:
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
    441              INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
    442              INT8U      mprio;                                      /* Mutex owner priority                     */
    443              BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    444              OS_TCB    *ptcb;
    445              OS_EVENT  *pevent2;
    446              INT8U      y;
    447          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    448              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    449          #endif
    450          
    451          
    452          
    453          #ifdef OS_SAFETY_CRITICAL
    454              if (perr == (INT8U *)0) {
    455                  OS_SAFETY_CRITICAL_EXCEPTION();
    456                  return;
    457              }
    458          #endif
    459          
    460          #if OS_ARG_CHK_EN > 0u
    461              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    462                  *perr = OS_ERR_PEVENT_NULL;
    463                  return;
    464              }
    465          #endif
    466              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD002             BEQ.N    ??OSMutexPend_0
    467                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7028             STRB     R0,[R5, #+0]
    468                  return;
   \   00000018   0xE146             B.N      ??OSMutexPend_1
    469              }
    470              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSMutexPend_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??OSMutexPend_2
    471                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7028             STRB     R0,[R5, #+0]
    472                  return;
   \   00000028   0xE13E             B.N      ??OSMutexPend_1
    473              }
    474              if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
   \                     ??OSMutexPend_2:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??OSMutexPend_3
    475                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   00000034   0x200D             MOVS     R0,#+13
   \   00000036   0x7028             STRB     R0,[R5, #+0]
    476                  return;
   \   00000038   0xE136             B.N      ??OSMutexPend_1
    477              }
    478          /*$PAGE*/
    479              OS_ENTER_CRITICAL();
   \                     ??OSMutexPend_3:
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000003E   0x4683             MOV      R11,R0
    480              pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
   \   00000040   0x8920             LDRH     R0,[R4, #+8]
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x0A00             LSRS     R0,R0,#+8
   \   00000046   0x0006             MOVS     R6,R0
    481                                                                     /* Is Mutex available?                      */
    482              if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   00000048   0x7A20             LDRB     R0,[R4, #+8]
   \   0000004A   0x28FF             CMP      R0,#+255
   \   0000004C   0xD126             BNE.N    ??OSMutexPend_4
    483                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
   \   0000004E   0x8920             LDRH     R0,[R4, #+8]
   \   00000050   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000054   0x8120             STRH     R0,[R4, #+8]
    484                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
   \   00000056   0x8920             LDRH     R0,[R4, #+8]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x8120             STRH     R0,[R4, #+8]
    485                  pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6060             STR      R0,[R4, #+4]
    486                  if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
    487                      (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2EFF             CMP      R6,#+255
   \   00000072   0xD00D             BEQ.N    ??OSMutexPend_5
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x4286             CMP      R6,R0
   \   00000082   0xD305             BCC.N    ??OSMutexPend_5
    488                       OS_EXIT_CRITICAL();                           /*      ... than current task!              */
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       OS_CPU_SR_Restore
    489                      *perr = OS_ERR_PCP_LOWER;
   \   0000008A   0x2078             MOVS     R0,#+120
   \   0000008C   0x7028             STRB     R0,[R5, #+0]
   \   0000008E   0xE004             B.N      ??OSMutexPend_6
    490                  } else {
    491                       OS_EXIT_CRITICAL();
   \                     ??OSMutexPend_5:
   \   00000090   0x4658             MOV      R0,R11
   \   00000092   0x.... 0x....      BL       OS_CPU_SR_Restore
    492                      *perr = OS_ERR_NONE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x7028             STRB     R0,[R5, #+0]
    493                  }
    494                  return;
   \                     ??OSMutexPend_6:
   \   0000009A   0xE105             B.N      ??OSMutexPend_1
    495              }
    496              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
   \                     ??OSMutexPend_4:
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x2EFF             CMP      R6,#+255
   \   000000A0   0xF000 0x80B9      BEQ.W    ??OSMutexPend_7
    497                  mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
   \   000000A4   0x8920             LDRH     R0,[R4, #+8]
   \   000000A6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    498                  ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0x4680             MOV      R8,R0
    499                  if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
   \   000000AE   0xF898 0x0036      LDRB     R0,[R8, #+54]
   \   000000B2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B4   0x4286             CMP      R6,R0
   \   000000B6   0xF080 0x80AE      BCS.W    ??OSMutexPend_7
    500                      if (mprio > OSTCBCur->OSTCBPrio) {
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   000000C4   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xF080 0x80A4      BCS.W    ??OSMutexPend_7
    501                          y = ptcb->OSTCBY;
   \   000000CE   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   000000D2   0x4682             MOV      R10,R0
    502                          if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
   \   000000D4   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000DC   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   000000E0   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   000000E4   0x4208             TST      R0,R1
   \   000000E6   0xD022             BEQ.N    ??OSMutexPend_8
    503                              OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
   \   000000E8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000F0   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   000000F4   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   000000F8   0x4388             BICS     R0,R0,R1
   \   000000FA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000102   0xF80A 0x0001      STRB     R0,[R10, R1]
    504                              if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
   \   00000106   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   0000010E   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD108             BNE.N    ??OSMutexPend_9
    505                                  OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   00000120   0x4388             BICS     R0,R0,R1
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \   00000126   0x7008             STRB     R0,[R1, #+0]
    506                              }
    507                              rdy = OS_TRUE;
   \                     ??OSMutexPend_9:
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0x0007             MOVS     R7,R0
   \   0000012C   0xE025             B.N      ??OSMutexPend_10
    508                          } else {
    509                              pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_8:
   \   0000012E   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000132   0x4681             MOV      R9,R0
    510                              if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
   \   00000134   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000138   0xD01D             BEQ.N    ??OSMutexPend_11
    511                                  y = ptcb->OSTCBY;
   \   0000013A   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   0000013E   0x4682             MOV      R10,R0
    512                                  pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
   \   00000140   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000144   0xEB1A 0x0009      ADDS     R0,R10,R9
   \   00000148   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000014A   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   0000014E   0x4388             BICS     R0,R0,R1
   \   00000150   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000154   0xEB1A 0x0109      ADDS     R1,R10,R9
   \   00000158   0x72C8             STRB     R0,[R1, #+11]
    513                                  if (pevent2->OSEventTbl[y] == 0u) {
   \   0000015A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015E   0xEB1A 0x0009      ADDS     R0,R10,R9
   \   00000162   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD106             BNE.N    ??OSMutexPend_11
    514                                      pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000168   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   0000016C   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   00000170   0x4388             BICS     R0,R0,R1
   \   00000172   0xF889 0x000A      STRB     R0,[R9, #+10]
    515                                  }
    516                              }
    517                              rdy = OS_FALSE;                        /* No                                       */
   \                     ??OSMutexPend_11:
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x0007             MOVS     R7,R0
    518                          }
    519                          ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
   \                     ??OSMutexPend_10:
   \   0000017A   0xF888 0x6036      STRB     R6,[R8, #+54]
    520          #if OS_LOWEST_PRIO <= 63u
    521                          ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
   \   0000017E   0xF898 0x0036      LDRB     R0,[R8, #+54]
   \   00000182   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000184   0x08C0             LSRS     R0,R0,#+3
   \   00000186   0xF888 0x0038      STRB     R0,[R8, #+56]
    522                          ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
   \   0000018A   0xF898 0x0036      LDRB     R0,[R8, #+54]
   \   0000018E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000192   0xF888 0x0037      STRB     R0,[R8, #+55]
    523          #else
    524                          ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
    525                          ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
    526          #endif
    527                          ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0xF898 0x1038      LDRB     R1,[R8, #+56]
   \   0000019C   0x4088             LSLS     R0,R0,R1
   \   0000019E   0xF888 0x003A      STRB     R0,[R8, #+58]
    528                          ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0xF898 0x1037      LDRB     R1,[R8, #+55]
   \   000001A8   0x4088             LSLS     R0,R0,R1
   \   000001AA   0xF888 0x0039      STRB     R0,[R8, #+57]
    529          
    530                          if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
   \   000001AE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001B0   0x2F01             CMP      R7,#+1
   \   000001B2   0xD112             BNE.N    ??OSMutexPend_12
    531                              OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
   \   000001B4   0x....             LDR.N    R0,??DataTable6_6
   \   000001B6   0x7800             LDRB     R0,[R0, #+0]
   \   000001B8   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   000001BC   0x4308             ORRS     R0,R1,R0
   \   000001BE   0x....             LDR.N    R1,??DataTable6_6
   \   000001C0   0x7008             STRB     R0,[R1, #+0]
    532                              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000001C2   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   000001C6   0x....             LDR.N    R1,??DataTable6_5
   \   000001C8   0x5C40             LDRB     R0,[R0, R1]
   \   000001CA   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   000001CE   0x4308             ORRS     R0,R1,R0
   \   000001D0   0xF898 0x1038      LDRB     R1,[R8, #+56]
   \   000001D4   0x....             LDR.N    R2,??DataTable6_5
   \   000001D6   0x5488             STRB     R0,[R1, R2]
   \   000001D8   0xE019             B.N      ??OSMutexPend_13
    533                          } else {
    534                              pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_12:
   \   000001DA   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   000001DE   0x4681             MOV      R9,R0
    535                              if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
   \   000001E0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001E4   0xD013             BEQ.N    ??OSMutexPend_13
    536                                  pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
   \   000001E6   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   000001EA   0xF898 0x103A      LDRB     R1,[R8, #+58]
   \   000001EE   0x4308             ORRS     R0,R1,R0
   \   000001F0   0xF889 0x000A      STRB     R0,[R9, #+10]
    537                                  pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   000001F4   0xF898 0x0038      LDRB     R0,[R8, #+56]
   \   000001F8   0xEB10 0x0009      ADDS     R0,R0,R9
   \   000001FC   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001FE   0xF898 0x1039      LDRB     R1,[R8, #+57]
   \   00000202   0x4308             ORRS     R0,R1,R0
   \   00000204   0xF898 0x1038      LDRB     R1,[R8, #+56]
   \   00000208   0xEB11 0x0109      ADDS     R1,R1,R9
   \   0000020C   0x72C8             STRB     R0,[R1, #+11]
    538                              }
    539                          }
    540                          OSTCBPrioTbl[pcp] = ptcb;
   \                     ??OSMutexPend_13:
   \   0000020E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000210   0x....             LDR.N    R0,??DataTable6_2
   \   00000212   0xF840 0x8026      STR      R8,[R0, R6, LSL #+2]
    541                      }
    542                  }
    543              }
    544              OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
   \                     ??OSMutexPend_7:
   \   00000216   0x....             LDR.N    R0,??DataTable6_1
   \   00000218   0x6800             LDR      R0,[R0, #+0]
   \   0000021A   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   0000021E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000222   0x....             LDR.N    R1,??DataTable6_1
   \   00000224   0x6809             LDR      R1,[R1, #+0]
   \   00000226   0xF881 0x0034      STRB     R0,[R1, #+52]
    545              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000022A   0x....             LDR.N    R0,??DataTable6_1
   \   0000022C   0x6800             LDR      R0,[R0, #+0]
   \   0000022E   0x2100             MOVS     R1,#+0
   \   00000230   0xF880 0x1035      STRB     R1,[R0, #+53]
    546              OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
   \   00000234   0x....             LDR.N    R0,??DataTable6_1
   \   00000236   0x6800             LDR      R0,[R0, #+0]
   \   00000238   0x9902             LDR      R1,[SP, #+8]
   \   0000023A   0x6301             STR      R1,[R0, #+48]
    547              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   0000023C   0x0020             MOVS     R0,R4
   \   0000023E   0x.... 0x....      BL       OS_EventTaskWait
    548              OS_EXIT_CRITICAL();
   \   00000242   0x4658             MOV      R0,R11
   \   00000244   0x.... 0x....      BL       OS_CPU_SR_Restore
    549              OS_Sched();                                       /* Find next highest priority task ready         */
   \   00000248   0x.... 0x....      BL       OS_Sched
    550              OS_ENTER_CRITICAL();
   \   0000024C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000250   0x4683             MOV      R11,R0
    551              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   00000252   0x....             LDR.N    R0,??DataTable6_1
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   0000025A   0x2800             CMP      R0,#+0
   \   0000025C   0xD002             BEQ.N    ??OSMutexPend_14
   \   0000025E   0x2802             CMP      R0,#+2
   \   00000260   0xD003             BEQ.N    ??OSMutexPend_15
   \   00000262   0xE005             B.N      ??OSMutexPend_16
    552                  case OS_STAT_PEND_OK:
    553                       *perr = OS_ERR_NONE;
   \                     ??OSMutexPend_14:
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0x7028             STRB     R0,[R5, #+0]
    554                       break;
   \   00000268   0xE009             B.N      ??OSMutexPend_17
    555          
    556                  case OS_STAT_PEND_ABORT:
    557                       *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
   \                     ??OSMutexPend_15:
   \   0000026A   0x200E             MOVS     R0,#+14
   \   0000026C   0x7028             STRB     R0,[R5, #+0]
    558                       break;
   \   0000026E   0xE006             B.N      ??OSMutexPend_17
    559          
    560                  case OS_STAT_PEND_TO:
    561                  default:
    562                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSMutexPend_16:
   \   00000270   0x0021             MOVS     R1,R4
   \   00000272   0x....             LDR.N    R0,??DataTable6_1
   \   00000274   0x6800             LDR      R0,[R0, #+0]
   \   00000276   0x.... 0x....      BL       OS_EventTaskRemove
    563                       *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
   \   0000027A   0x200A             MOVS     R0,#+10
   \   0000027C   0x7028             STRB     R0,[R5, #+0]
    564                       break;
    565              }
    566              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSMutexPend_17:
   \   0000027E   0x....             LDR.N    R0,??DataTable6_1
   \   00000280   0x6800             LDR      R0,[R0, #+0]
   \   00000282   0x2100             MOVS     R1,#+0
   \   00000284   0xF880 0x1034      STRB     R1,[R0, #+52]
    567              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   00000288   0x....             LDR.N    R0,??DataTable6_1
   \   0000028A   0x6800             LDR      R0,[R0, #+0]
   \   0000028C   0x2100             MOVS     R1,#+0
   \   0000028E   0xF880 0x1035      STRB     R1,[R0, #+53]
    568              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   00000292   0x....             LDR.N    R0,??DataTable6_1
   \   00000294   0x6800             LDR      R0,[R0, #+0]
   \   00000296   0x2100             MOVS     R1,#+0
   \   00000298   0x61C1             STR      R1,[R0, #+28]
    569          #if (OS_EVENT_MULTI_EN > 0u)
    570              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   0000029A   0x....             LDR.N    R0,??DataTable6_1
   \   0000029C   0x6800             LDR      R0,[R0, #+0]
   \   0000029E   0x2100             MOVS     R1,#+0
   \   000002A0   0x6201             STR      R1,[R0, #+32]
    571          #endif
    572              OS_EXIT_CRITICAL();
   \   000002A2   0x4658             MOV      R0,R11
   \   000002A4   0x.... 0x....      BL       OS_CPU_SR_Restore
    573          }
   \                     ??OSMutexPend_1:
   \   000002A8   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    574          /*$PAGE*/
    575          /*
    576          *********************************************************************************************************
    577          *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
    578          *
    579          * Description: This function signals a mutual exclusion semaphore
    580          *
    581          * Arguments  : pevent              is a pointer to the event control block associated with the desired
    582          *                                  mutex.
    583          *
    584          * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
    585          *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    586          *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
    587          *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
    588          *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
    589          *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
    590          *                                      HIGHER (i.e. a lower number) than the PCP.  This error
    591          *                                      indicates that you did not set the PCP higher (lower
    592          *                                      number) than ALL the tasks that compete for the Mutex.
    593          *                                      Unfortunately, this is something that could not be
    594          *                                      detected when the Mutex is created because we don't know
    595          *                                      what tasks will be using the Mutex.
    596          *********************************************************************************************************
    597          */
    598          

   \                                 In section .text, align 2, keep-with-next
    599          INT8U  OSMutexPost (OS_EVENT *pevent)
    600          {
   \                     OSMutexPost:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    601              INT8U      pcp;                                   /* Priority ceiling priority                     */
    602              INT8U      prio;
    603          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    604              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2700             MOVS     R7,#+0
    605          #endif
    606          
    607          
    608          
    609              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
   \   00000006   0x....             LDR.N    R0,??DataTable6
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??OSMutexPost_0
    610                  return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0xE062             B.N      ??OSMutexPost_1
    611              }
    612          #if OS_ARG_CHK_EN > 0u
    613              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    614                  return (OS_ERR_PEVENT_NULL);
    615              }
    616          #endif
    617              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
   \                     ??OSMutexPost_0:
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD001             BEQ.N    ??OSMutexPost_2
    618                  return (OS_ERR_EVENT_TYPE);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE05D             B.N      ??OSMutexPost_1
    619              }
    620              OS_ENTER_CRITICAL();
   \                     ??OSMutexPost_2:
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x0007             MOVS     R7,R0
    621              pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
   \   00000022   0x8920             LDRH     R0,[R4, #+8]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x0A00             LSRS     R0,R0,#+8
   \   00000028   0x0005             MOVS     R5,R0
    622              prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
   \   0000002A   0x8920             LDRH     R0,[R4, #+8]
   \   0000002C   0x0006             MOVS     R6,R0
    623              if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
   \   0000002E   0x....             LDR.N    R0,??DataTable6_1
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6861             LDR      R1,[R4, #+4]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD004             BEQ.N    ??OSMutexPost_3
    624                  OS_EXIT_CRITICAL();
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    625                  return (OS_ERR_NOT_MUTEX_OWNER);
   \   0000003E   0x2064             MOVS     R0,#+100
   \   00000040   0xE04A             B.N      ??OSMutexPost_1
    626              }
    627              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
   \                     ??OSMutexPost_3:
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2DFF             CMP      R5,#+255
   \   00000046   0xD011             BEQ.N    ??OSMutexPost_4
    628                  if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
   \   00000048   0x....             LDR.N    R0,??DataTable6_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x42A8             CMP      R0,R5
   \   00000054   0xD105             BNE.N    ??OSMutexPost_5
    629                      OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x....             LDR.N    R0,??DataTable6_1
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       OSMutex_RdyAtPrio
    630                  }
    631                  OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
   \                     ??OSMutexPost_5:
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x....             LDR.N    R0,??DataTable6_2
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xF840 0x1025      STR      R1,[R0, R5, LSL #+2]
    632              }
    633              if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
   \                     ??OSMutexPost_4:
   \   0000006C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD028             BEQ.N    ??OSMutexPost_6
    634                                                                /* Yes, Make HPT waiting for mutex ready         */
    635                  prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
   \   00000072   0x2300             MOVS     R3,#+0
   \   00000074   0x2210             MOVS     R2,#+16
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000007E   0x0006             MOVS     R6,R0
    636                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
   \   00000080   0x8920             LDRH     R0,[R4, #+8]
   \   00000082   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000086   0x8120             STRH     R0,[R4, #+8]
    637                  pevent->OSEventCnt |= prio;
   \   00000088   0x8920             LDRH     R0,[R4, #+8]
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0x4330             ORRS     R0,R6,R0
   \   0000008E   0x8120             STRH     R0,[R4, #+8]
    638                  pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x....             LDR.N    R0,??DataTable6_2
   \   00000094   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000098   0x6060             STR      R0,[R4, #+4]
    639                  if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
    640                      (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2DFF             CMP      R5,#+255
   \   0000009E   0xD00A             BEQ.N    ??OSMutexPost_7
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x42B5             CMP      R5,R6
   \   000000A6   0xD306             BCC.N    ??OSMutexPost_7
    641                      OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0x.... 0x....      BL       OS_CPU_SR_Restore
    642                      OS_Sched();                               /*      Find highest priority task ready to run  */
   \   000000AE   0x.... 0x....      BL       OS_Sched
    643                      return (OS_ERR_PCP_LOWER);
   \   000000B2   0x2078             MOVS     R0,#+120
   \   000000B4   0xE010             B.N      ??OSMutexPost_1
    644                  } else {
    645                      OS_EXIT_CRITICAL();
   \                     ??OSMutexPost_7:
   \   000000B6   0x0038             MOVS     R0,R7
   \   000000B8   0x.... 0x....      BL       OS_CPU_SR_Restore
    646                      OS_Sched();                               /*      Find highest priority task ready to run  */
   \   000000BC   0x.... 0x....      BL       OS_Sched
    647                      return (OS_ERR_NONE);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE009             B.N      ??OSMutexPost_1
    648                  }
    649              }
    650              pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
   \                     ??OSMutexPost_6:
   \   000000C4   0x8920             LDRH     R0,[R4, #+8]
   \   000000C6   0xF050 0x00FF      ORRS     R0,R0,#0xFF
   \   000000CA   0x8120             STRH     R0,[R4, #+8]
    651              pevent->OSEventPtr  = (void *)0;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x6060             STR      R0,[R4, #+4]
    652              OS_EXIT_CRITICAL();
   \   000000D0   0x0038             MOVS     R0,R7
   \   000000D2   0x.... 0x....      BL       OS_CPU_SR_Restore
    653              return (OS_ERR_NONE);
   \   000000D6   0x2000             MOVS     R0,#+0
   \                     ??OSMutexPost_1:
   \   000000D8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    654          }
    655          /*$PAGE*/
    656          /*
    657          *********************************************************************************************************
    658          *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
    659          *
    660          * Description: This function obtains information about a mutex
    661          *
    662          * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
    663          *
    664          *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
    665          *
    666          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    667          *              OS_ERR_QUERY_ISR     If you called this function from an ISR
    668          *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
    669          *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
    670          *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
    671          *********************************************************************************************************
    672          */
    673          
    674          #if OS_MUTEX_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    675          INT8U  OSMutexQuery (OS_EVENT       *pevent,
    676                               OS_MUTEX_DATA  *p_mutex_data)
    677          {
   \                     OSMutexQuery:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    678              INT8U       i;
    679              OS_PRIO    *psrc;
    680              OS_PRIO    *pdest;
    681          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    682              OS_CPU_SR   cpu_sr = 0u;
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    683          #endif
    684          
    685          
    686          
    687              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??OSMutexQuery_0
    688                  return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016   0xE02C             B.N      ??OSMutexQuery_1
    689              }
    690          #if OS_ARG_CHK_EN > 0u
    691              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    692                  return (OS_ERR_PEVENT_NULL);
    693              }
    694              if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
    695                  return (OS_ERR_PDATA_NULL);
    696              }
    697          #endif
    698              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \                     ??OSMutexQuery_0:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD001             BEQ.N    ??OSMutexQuery_2
    699                  return (OS_ERR_EVENT_TYPE);
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE027             B.N      ??OSMutexQuery_1
    700              }
    701              OS_ENTER_CRITICAL();
   \                     ??OSMutexQuery_2:
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000026   0x4681             MOV      R9,R0
    702              p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
   \   00000028   0x8920             LDRH     R0,[R4, #+8]
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x0A00             LSRS     R0,R0,#+8
   \   0000002E   0x72E8             STRB     R0,[R5, #+11]
    703              p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
   \   00000030   0x8920             LDRH     R0,[R4, #+8]
   \   00000032   0x72A8             STRB     R0,[R5, #+10]
    704              if (p_mutex_data->OSOwnerPrio == 0xFFu) {
   \   00000034   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0xD102             BNE.N    ??OSMutexQuery_3
    705                  p_mutex_data->OSValue = OS_TRUE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7268             STRB     R0,[R5, #+9]
   \   0000003E   0xE001             B.N      ??OSMutexQuery_4
    706              } else {
    707                  p_mutex_data->OSValue = OS_FALSE;
   \                     ??OSMutexQuery_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7268             STRB     R0,[R5, #+9]
    708              }
    709              p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
   \                     ??OSMutexQuery_4:
   \   00000044   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000046   0x7228             STRB     R0,[R5, #+8]
    710              psrc                      = &pevent->OSEventTbl[0];
   \   00000048   0xF204 0x000B      ADDW     R0,R4,#+11
   \   0000004C   0x0007             MOVS     R7,R0
    711              pdest                     = &p_mutex_data->OSEventTbl[0];
   \   0000004E   0x46A8             MOV      R8,R5
    712              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0006             MOVS     R6,R0
   \                     ??OSMutexQuery_5:
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x2E08             CMP      R6,#+8
   \   00000058   0xD207             BCS.N    ??OSMutexQuery_6
    713                  *pdest++ = *psrc++;
   \   0000005A   0x7838             LDRB     R0,[R7, #+0]
   \   0000005C   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000060   0x1C7F             ADDS     R7,R7,#+1
   \   00000062   0xF118 0x0801      ADDS     R8,R8,#+1
    714              }
   \   00000066   0x1C76             ADDS     R6,R6,#+1
   \   00000068   0xE7F4             B.N      ??OSMutexQuery_5
    715              OS_EXIT_CRITICAL();
   \                     ??OSMutexQuery_6:
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0x.... 0x....      BL       OS_CPU_SR_Restore
    716              return (OS_ERR_NONE);
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??OSMutexQuery_1:
   \   00000072   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    717          }
    718          #endif                                                     /* OS_MUTEX_QUERY_EN                        */
    719          
    720          /*$PAGE*/
    721          /*
    722          *********************************************************************************************************
    723          *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
    724          *
    725          * Description: This function makes a task ready at the specified priority
    726          *
    727          * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
    728          *
    729          *              prio            is the desired priority
    730          *
    731          * Returns    : none
    732          *********************************************************************************************************
    733          */
    734          

   \                                 In section .text, align 2, keep-with-next
    735          static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
    736                                           INT8U    prio)
    737          {
   \                     OSMutex_RdyAtPrio:
   \   00000000   0xB430             PUSH     {R4,R5}
    738              INT8U  y;
    739          
    740          
    741              y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
   \   00000002   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000006   0x001A             MOVS     R2,R3
    742              OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x....             LDR.N    R3,??DataTable6_5
   \   0000000C   0x5CD3             LDRB     R3,[R2, R3]
   \   0000000E   0xF890 0x4039      LDRB     R4,[R0, #+57]
   \   00000012   0x43A3             BICS     R3,R3,R4
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x....             LDR.N    R4,??DataTable6_5
   \   00000018   0x5513             STRB     R3,[R2, R4]
    743              if (OSRdyTbl[y] == 0u) {
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x....             LDR.N    R3,??DataTable6_5
   \   0000001E   0x5CD3             LDRB     R3,[R2, R3]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD106             BNE.N    ??OSMutex_RdyAtPrio_0
    744                  OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000024   0x....             LDR.N    R3,??DataTable6_6
   \   00000026   0x781B             LDRB     R3,[R3, #+0]
   \   00000028   0xF890 0x403A      LDRB     R4,[R0, #+58]
   \   0000002C   0x43A3             BICS     R3,R3,R4
   \   0000002E   0x....             LDR.N    R4,??DataTable6_6
   \   00000030   0x7023             STRB     R3,[R4, #+0]
    745              }
    746              ptcb->OSTCBPrio         = prio;
   \                     ??OSMutex_RdyAtPrio_0:
   \   00000032   0xF880 0x1036      STRB     R1,[R0, #+54]
    747              OSPrioCur               = prio;                        /* The current task is now at this priority */
   \   00000036   0x....             LDR.N    R3,??DataTable6_7
   \   00000038   0x7019             STRB     R1,[R3, #+0]
    748          #if OS_LOWEST_PRIO <= 63u
    749              ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
   \   0000003A   0xF3C1 0x03C2      UBFX     R3,R1,#+3,#+3
   \   0000003E   0xF880 0x3038      STRB     R3,[R0, #+56]
    750              ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
   \   00000042   0xF011 0x0307      ANDS     R3,R1,#0x7
   \   00000046   0xF880 0x3037      STRB     R3,[R0, #+55]
    751          #else
    752              ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
    753              ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
    754          #endif
    755              ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0xF890 0x4038      LDRB     R4,[R0, #+56]
   \   00000050   0x40A3             LSLS     R3,R3,R4
   \   00000052   0xF880 0x303A      STRB     R3,[R0, #+58]
    756              ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
   \   00000056   0x2301             MOVS     R3,#+1
   \   00000058   0xF890 0x4037      LDRB     R4,[R0, #+55]
   \   0000005C   0x40A3             LSLS     R3,R3,R4
   \   0000005E   0xF880 0x3039      STRB     R3,[R0, #+57]
    757              OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
   \   00000062   0x....             LDR.N    R3,??DataTable6_6
   \   00000064   0x781B             LDRB     R3,[R3, #+0]
   \   00000066   0xF890 0x403A      LDRB     R4,[R0, #+58]
   \   0000006A   0x4323             ORRS     R3,R4,R3
   \   0000006C   0x....             LDR.N    R4,??DataTable6_6
   \   0000006E   0x7023             STRB     R3,[R4, #+0]
    758              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000070   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000074   0x....             LDR.N    R4,??DataTable6_5
   \   00000076   0x5D1B             LDRB     R3,[R3, R4]
   \   00000078   0xF890 0x4039      LDRB     R4,[R0, #+57]
   \   0000007C   0x4323             ORRS     R3,R4,R3
   \   0000007E   0xF890 0x4038      LDRB     R4,[R0, #+56]
   \   00000082   0x....             LDR.N    R5,??DataTable6_5
   \   00000084   0x5563             STRB     R3,[R4, R5]
    759              OSTCBPrioTbl[prio]      = ptcb;
   \   00000086   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000088   0x....             LDR.N    R3,??DataTable6_2
   \   0000008A   0xF843 0x0021      STR      R0,[R3, R1, LSL #+2]
    760          }
   \   0000008E   0xBC30             POP      {R4,R5}
   \   00000090   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
    761          
    762          
    763          #endif                                                     /* OS_MUTEX_EN                              */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMutexAccept
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      24   OSMutexCreate
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventWaitListInit
      40   OSMutexDel
        40   -> OSMutex_RdyAtPrio
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_EventTaskRdy
        40   -> OS_Sched
      48   OSMutexPend
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_EventTaskRemove
        48   -> OS_EventTaskWait
        48   -> OS_Sched
      24   OSMutexPost
        24   -> OSMutex_RdyAtPrio
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      32   OSMutexQuery
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
       8   OSMutex_RdyAtPrio


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
     156  OSMutexAccept
     178  OSMutexCreate
     388  OSMutexDel
     684  OSMutexPend
     218  OSMutexPost
     118  OSMutexQuery
     146  OSMutex_RdyAtPrio

 
     2 bytes in section .rodata
 1 924 bytes in section .text
 
 1 924 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none

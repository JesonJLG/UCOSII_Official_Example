###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:18 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp_i2c.c                                       #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp_i2c.c" -D USE_STDPERIPH_DRIVER -lCN         #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\" -o                         #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\bsp_i2c.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\bsp_i2c.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp_i2c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICRIUM BOARD SUPPORT SUPPORT
      4          *
      5          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     MICIUM BOARD SUPPORT PACKAGE
     18          *                                        I2C DRIVER (MASTER ONLY)
     19          *                                                                         
     20          *
     21          * Filename      : bsp_i2c.c
     22          * Version       : V1.00
     23          * Programmer(s) : FT
     24          *********************************************************************************************************
     25          * Note(s)       :
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                             INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #define  BSP_I2C_MODULE
     36          #include <bsp.h>
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                              LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45                                                                          /* ------------- I2C BASE ADDRESS DEFINES ------------ */
     46          #define  BSP_I2C_REG_I2C1_BASE_ADDR       (CPU_INT32U)(0x40005400)
     47          #define  BSP_I2C_REG_I2C2_BASE_ADDR       (CPU_INT32U)(0x40005800)
     48          
     49                                                                          /* -------- I2C CONTROL REGISTER 1 BIT DEFINES  ------- */
     50          #define  BSP_I2C_REG_CR1_PE               DEF_BIT_00            /* Peripheral Enable                                    */
     51          #define  BSP_I2C_REG_CR1_SMBUS            DEF_BIT_01            /* SMBUS Mode                                           */
     52          #define  BSP_I2C_REG_CR1_SMBTYPE          DEF_BIT_03            /* SMBUS Type                                           */
     53          #define  BSP_I2C_REG_CR1_ENARP            DEF_BIT_04            /* ARP Enable                                           */
     54          #define  BSP_I2C_REG_CR1_ENPEC            DEF_BIT_05            /* PEC Enable                                           */
     55          #define  BSP_I2C_REG_CR1_ENGC             DEF_BIT_06            /* ENGC General Call enable                             */
     56          #define  BSP_I2C_REG_CR1_NOSTRETCH        DEF_BIT_07            /* Clock stretching enable                              */
     57          #define  BSP_I2C_REG_CR1_START            DEF_BIT_08            /* Start Generation                                     */
     58          #define  BSP_I2C_REG_CR1_STOP             DEF_BIT_09            /* Stop  Generation                                     */
     59          #define  BSP_I2C_REG_CR1_ACK              DEF_BIT_10            /* Acknowledge Enable                                   */
     60          #define  BSP_I2C_REG_CR1_POS              DEF_BIT_11            /* Acknowledge/PEC position (for data reception)        */
     61          #define  BSP_I2C_REG_CR1_PEC              DEF_BIT_12            /* Packet Error Checking                                */
     62          #define  BSP_I2C_REG_CR1_ALERT            DEF_BIT_13            /* SMBUS Aler                                           */
     63          #define  BSP_I2C_REG_CR1_SWRST            DEF_BIT_15            /* Software Reset                                       */
     64          
     65                                                                          /* -------- I2C CONTROL REGISTER 2 BIT DEFINES  ------- */
     66          #define  BSP_I2C_REG_CR2_LAST             DEF_BIT_12            /* Last DMA transfer                                    */
     67          #define  BSP_I2C_REG_CR2_DMAEN            DEF_BIT_11            /* DMA Request enable                                   */
     68          #define  BSP_I2C_REG_CR2_ITBUFEN          DEF_BIT_10            /* Buffer interrupt enable                              */
     69          #define  BSP_I2C_REG_CR2_ITEVTEN          DEF_BIT_09            /* Event  interrupt enable                              */
     70          #define  BSP_I2C_REG_CR2_ITERREN          DEF_BIT_08            /* Error Interrupt enable                               */
     71          #define  BSP_I2C_REG_CR2_FREQ_MASK        DEF_BIT_FIELD(6, 0)   /* Peripheral Clock Frequency Mask                      */
     72          
     73          #define  BSP_I2C_REG_DR_MASK              DEF_BIT_FIELD(8, 0)   /* 8-bit Data register mask                             */
     74          
     75                                                                          /* --------- I2C STATUS REGISTER 1 BIT DEFINES -------- */
     76          #define  BSP_I2C_REG_SR1_ALERT            DEF_BIT_15            /* SMBUS Alert                                          */
     77          #define  BSP_I2C_REG_SR1_TIMEOUT          DEF_BIT_14            /* Timeout error                                        */
     78          #define  BSP_I2C_REG_SR1_PECERR           DEF_BIT_12            /* PEC error in reception                               */
     79          #define  BSP_I2C_REG_SR1_OVR              DEF_BIT_11            /* Overrun/Underrun                                     */
     80          #define  BSP_I2C_REG_SR1_AF               DEF_BIT_10            /* Aknowledge failure                                   */
     81          #define  BSP_I2C_REG_SR1_ARLO             DEF_BIT_09            /* Arbitration Lost                                     */
     82          #define  BSP_I2C_REG_SR1_BERR             DEF_BIT_08            /* Bus Error                                            */
     83          #define  BSP_I2C_REG_SR1_TXE              DEF_BIT_07            /* Data Register empty (Transmitters)                   */
     84          #define  BSP_I2C_REG_SR1_RXNE             DEF_BIT_06            /* Data register not empty                              */
     85          #define  BSP_I2C_REG_SR1_STOPF            DEF_BIT_04            /* Stop detection                                       */
     86          #define  BSP_I2C_REG_SR1_ADD10            DEF_BIT_03            /* 10-bit header sent (Master Mode)                     */
     87          #define  BSP_I2C_REG_SR1_BTF              DEF_BIT_02            /* Byte Transfer finished                               */
     88          #define  BSP_I2C_REG_SR1_ADDR             DEF_BIT_01            /* Address Sent                                         */
     89          #define  BSP_I2C_REG_SR1_SB               DEF_BIT_00            /* Start bit (Mode)                                     */
     90          
     91                                                                          /* Event Mask                                           */
     92          #define  BSP_I2C_REG_SR1_EVENT_MASK      (BSP_I2C_REG_SR1_SB      | \
     93                                                    BSP_I2C_REG_SR1_ADDR    | \
     94                                                    BSP_I2C_REG_SR1_BTF     | \
     95                                                    BSP_I2C_REG_SR1_ADDR    | \
     96                                                    BSP_I2C_REG_SR1_RXNE    | \
     97                                                    BSP_I2C_REG_SR1_TXE )
     98          
     99                                                                          /* Error Mask                                           */
    100          #define  BSP_I2C_REG_SR1_ERR_MASK        (BSP_I2C_REG_SR1_BERR    | \
    101                                                    BSP_I2C_REG_SR1_ARLO    | \
    102                                                    BSP_I2C_REG_SR1_AF      | \
    103                                                    BSP_I2C_REG_SR1_OVR     | \
    104                                                    BSP_I2C_REG_SR1_PECERR  | \
    105                                                    BSP_I2C_REG_SR1_ALERT)
    106          
    107                                                                          /* --------- I2C STATUS REGISTER 2 BIT DEFINES -------- */
    108          #define  BSP_I2C_REG_SR2_PEC_MASK         DEF_BIT_FIELD(8, 8)   /* Packet error cheking register mask                   */
    109          #define  BSP_I2C_REG_SR2_DUALF            DEF_BIT_07            /* Dual Flag (Slave mode)                               */
    110          #define  BSP_I2C_REG_SR2_SMBHOST          DEF_BIT_06            /* SMBus Host header (Slave Mode)                       */
    111          #define  BSP_I2C_REG_SR2_SMBDEFAULT       DEF_BIT_05            /* SMBus Device default Address                         */
    112          #define  BSP_I2C_REG_SR2_GENCALL          DEF_BIT_04            /* General Call Address (Slave Mode)                    */
    113          #define  BSP_I2C_REG_SR2_TRA              DEF_BIT_02            /* Trnasmitter/Receiver bit                             */
    114          #define  BSP_I2C_REG_SR2_BUSY             DEF_BIT_01            /* Bus Busy                                             */
    115          #define  BSP_I2C_REG_SR2_MSL              DEF_BIT_00            /* Master/Slave bit                                     */
    116          
    117                                                                          /* ------ I2C CLOCK CONTROL REGISTER BIT DEFINES ------ */
    118          #define  BSP_I2C_REG_CCR_FS               DEF_BIT_15            /* I2C Master Mode Selection (Standard/Fast)            */
    119          #define  BSP_I2C_REG_CCR_DUTY             DEF_BIT_14            /* Fast Mode Duty Cycle                                 */
    120          #define  BSP_I2C_REG_CCR_MASK             DEF_BIT_FIELD(12, 0)  /* Clock Divider                                        */
    121          
    122          
    123                                                                          /* --------------- I2C DRIVER STATES DEFINES ---------- */
    124          #define  BSP_I2C_STATE_IDLE                        0
    125          #define  BSP_I2C_STATE_START                       1
    126          #define  BSP_I2C_STATE_ADDR                        2
    127          #define  BSP_I2C_STATE_DATA                        3
    128          #define  BSP_I2C_STATE_STOP                        4
    129          
    130                                                                          /* -------------- I2C ACCESS TYPE DEFINES ------------- */
    131          #define  BSP_I2C_ACCESS_TYPE_NONE                  0
    132          #define  BSP_I2C_ACCESS_TYPE_RD                    1
    133          #define  BSP_I2C_ACCESS_TYPE_WR                    2
    134          #define  BSP_I2C_ACCESS_TYPE_WR_RD                 3
    135          
    136          
    137          /*
    138          *********************************************************************************************************
    139          *                                           LOCAL CONSTANTS
    140          *********************************************************************************************************
    141          */
    142          
    143          
    144          
    145          /*
    146          *********************************************************************************************************
    147          *                                          LOCAL DATA TYPES
    148          *
    149          * Note(s) :  (1) The 'BSP_I2C_DEV_STATUS' structure defines the status of the current transfer
    150          *
    151          *            (2) The 'BSP_I2C_REG' defines the register set for the I2C1/I2C2 peripherals.
    152          *********************************************************************************************************
    153          */
    154          
    155          typedef  struct bsp_i2c_dev_status {
    156              CPU_INT08U   AccessType;                                    /* Transfer Access Type RD/WR/WR_RD                     */
    157              CPU_INT08U   Addr;                                          /* I2C slave address                                    */
    158              CPU_INT08U   State;                                         /* Current transfer state                               */
    159              CPU_INT08U  *BufPtr;                                        /* Pointer to the transfer data area                    */
    160              CPU_INT16U   BufLen;                                        /* Trnasfer length                                      */
    161              BSP_OS_SEM   SemLock;                                       /* I2C Exclusive access sempahore                       */
    162              BSP_OS_SEM   SemWait;                                       /* Transfer Complete signal                             */
    163          } BSP_I2C_DEV_STATUS;
    164          
    165          
    166          typedef  struct  bsp_i2c_reg {
    167              CPU_REG32   I2C_CR1;
    168              CPU_REG32   I2C_CR2;    
    169              CPU_REG32   I2C_OAR1;
    170              CPU_REG32   I2C_OAR2;
    171              CPU_REG32   I2C_DR;
    172              CPU_REG32   I2C_SR1;
    173              CPU_REG32   I2C_SR2;
    174              CPU_REG32   I2C_CCR;
    175              CPU_REG32   I2C_TRISE;
    176          } BSP_I2C_REG;
    177          
    178          
    179          /*
    180          *********************************************************************************************************
    181          *                                            LOCAL TABLES
    182          *********************************************************************************************************
    183          */
    184          
    185          
    186          /*
    187          *********************************************************************************************************
    188          *                                       LOCAL GLOBAL VARIABLES
    189          *********************************************************************************************************
    190          */
    191          

   \                                 In section .bss, align 4
    192          static  BSP_I2C_DEV_STATUS     BSP_I2C_DevTbl[BSP_I2C_NBR_MAX];
   \                     BSP_I2C_DevTbl:
   \   00000000                      DS8 40
    193          
    194          /*
    195          *********************************************************************************************************
    196          *                                      LOCAL FUNCTION PROTOTYPES
    197          *********************************************************************************************************
    198          */
    199          
    200          static  void        BSP_I2C1_EventISR_Handler  (void);
    201          static  void        BSP_I2C2_EventISR_Handler  (void);
    202          static  void        BSP_I2Cx_EventISR_Handler  (CPU_INT08U  i2c_nbr);
    203          
    204          static  void        BSP_I2C1_ErrISR_Handler    (void);
    205          static  void        BSP_I2C2_ErrISR_Handler    (void);
    206          static  void        BSP_I2Cx_ErrISR_Handler    (CPU_INT08U  i2c_nbr);
    207          
    208          static CPU_BOOLEAN  BSP_I2C_StartXfer          (CPU_INT08U   i2c_nbr,
    209                                                          CPU_INT08U   i2c_addr,
    210                                                          CPU_INT08U   i2c_access_type,
    211                                                          CPU_INT08U  *p_buf,
    212                                                          CPU_INT08U   nbr_bytes);
    213          /*
    214          *********************************************************************************************************
    215          *                                     LOCAL CONFIGURATION ERRORS
    216          *********************************************************************************************************
    217          */
    218          
    219          
    220          /*
    221          *********************************************************************************************************
    222          *********************************************************************************************************
    223          **                                         GLOBAL FUNCTIONS
    224          *********************************************************************************************************
    225          *********************************************************************************************************
    226          */
    227          
    228          
    229          /*
    230          *********************************************************************************************************
    231          *                                        BSP_I2C_Init()
    232          *
    233          * Description : Initialize the I2C.
    234          *
    235          * Argument(s) : i2c_id     I2C peripheral ID
    236          *                              BSP_I2C_ID_I2C1
    237          *                              BSP_I2C_ID_I2C2
    238          *
    239          *               freq       I2C clock speed. It must be set to a value lower than 100 kHz (Standard Mode) or
    240          *                          400 Khz (Fast mode)
    241          *
    242          * Return(s)   : DEF_OK     If the I2C peripheral was initialized
    243          *               DEF_FAIL   If the I2C peripheral could not be initialized.
    244          *
    245          * Caller(s)   : Application
    246          *
    247          * Note(s)     : none.
    248          *********************************************************************************************************
    249          */
    250          
    251          

   \                                 In section .text, align 2, keep-with-next
    252          CPU_BOOLEAN  BSP_I2C_Init (CPU_INT08U  i2c_id,
    253                                     CPU_INT08U  i2c_mode,
    254                                     CPU_INT32U  clk_freq)
    255                              
    256          {
   \                     BSP_I2C_Init:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    257              CPU_BOOLEAN          err;  
    258              GPIO_InitTypeDef     gpio_init_cfg;
    259              RCC_ClocksTypeDef    rcc_clocks;
    260              CPU_INT32U           pclk_freq;
    261              CPU_INT32U           reg_val;
    262              BSP_I2C_REG         *p_i2c_reg;
    263              BSP_I2C_DEV_STATUS  *p_i2c_dev_status;
    264          
    265              
    266                                                                          /* ------------- ARGUMENTS CHECKING ----------------- */
    267              switch (i2c_id) {
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD002             BEQ.N    ??BSP_I2C_Init_0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD01B             BEQ.N    ??BSP_I2C_Init_1
   \   00000018   0xE036             B.N      ??BSP_I2C_Init_2
    268                  case BSP_I2C_ID_I2C1:
    269                       p_i2c_reg        = (BSP_I2C_REG        *)BSP_I2C_REG_I2C1_BASE_ADDR;
   \                     ??BSP_I2C_Init_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0x40005400
   \   0000001E   0x4682             MOV      R10,R0
    270                       p_i2c_dev_status = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[0];
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000024   0x4683             MOV      R11,R0
    271                       
    272                                                                          /* Configure the I2C1 GPIO                            */
    273                       BSP_PeriphEn(BSP_PERIPH_ID_IOPB);             
   \   00000026   0x2023             MOVS     R0,#+35
   \   00000028   0x.... 0x....      BL       BSP_PeriphEn
    274                       gpio_init_cfg.GPIO_Pin   = GPIO_Pin_6 | GPIO_Pin_7;
   \   0000002C   0x20C0             MOVS     R0,#+192
   \   0000002E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    275                       gpio_init_cfg.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xF88D 0x0002      STRB     R0,[SP, #+2]
    276                       gpio_init_cfg.GPIO_Mode  = GPIO_Mode_AF_OD;
   \   00000038   0x201C             MOVS     R0,#+28
   \   0000003A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    277                       GPIO_Init(GPIOB, &gpio_init_cfg);
   \   0000003E   0xA900             ADD      R1,SP,#+0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable3_2  ;; 0x40010c00
   \   00000044   0x.... 0x....      BL       GPIO_Init
    278           
    279                       BSP_PeriphEn(BSP_PERIPH_ID_I2C1);                  /* Enable the I2C1 peripheral clock                   */
   \   00000048   0x2055             MOVS     R0,#+85
   \   0000004A   0x.... 0x....      BL       BSP_PeriphEn
    280                       
    281                       break;
   \   0000004E   0xE01D             B.N      ??BSP_I2C_Init_3
    282          
    283                  case BSP_I2C_ID_I2C2:
    284                       p_i2c_reg        = (BSP_I2C_REG        *)BSP_I2C_REG_I2C2_BASE_ADDR;
   \                     ??BSP_I2C_Init_1:
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable3_3  ;; 0x40005800
   \   00000054   0x4682             MOV      R10,R0
    285                       p_i2c_dev_status = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[1];
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   0000005A   0x4683             MOV      R11,R0
    286          
    287                                                                          /* Configure the I2C2 GPIO                            */
    288                       BSP_PeriphEn(BSP_PERIPH_ID_IOPB);             
   \   0000005C   0x2023             MOVS     R0,#+35
   \   0000005E   0x.... 0x....      BL       BSP_PeriphEn
    289                       gpio_init_cfg.GPIO_Pin   = GPIO_Pin_10 | GPIO_Pin_11;
   \   00000062   0xF44F 0x6040      MOV      R0,#+3072
   \   00000066   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    290                       gpio_init_cfg.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    291                       gpio_init_cfg.GPIO_Mode  = GPIO_Mode_AF_OD;
   \   00000070   0x201C             MOVS     R0,#+28
   \   00000072   0xF88D 0x0003      STRB     R0,[SP, #+3]
    292                       GPIO_Init(GPIOB, &gpio_init_cfg);
   \   00000076   0xA900             ADD      R1,SP,#+0
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable3_2  ;; 0x40010c00
   \   0000007C   0x.... 0x....      BL       GPIO_Init
    293                       
    294                       BSP_PeriphEn(BSP_PERIPH_ID_I2C2);                  /* Enable the I2C1 peripheral clock                   */             
   \   00000080   0x2056             MOVS     R0,#+86
   \   00000082   0x.... 0x....      BL       BSP_PeriphEn
    295                       break;
   \   00000086   0xE001             B.N      ??BSP_I2C_Init_3
    296                  
    297                  default:
    298                      return (DEF_FAIL);
   \                     ??BSP_I2C_Init_2:
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE0B0             B.N      ??BSP_I2C_Init_4
    299              }
    300                  
    301                                                                          /* -------------- CREATE OS SEMAPHORES  ------------- */
    302              err = BSP_OS_SemCreate((BSP_OS_SEM    *)&(p_i2c_dev_status->SemWait),
    303                                     (BSP_OS_SEM_VAL ) 0, 
    304                                     (CPU_CHAR      *) "I2C Wait");          
   \                     ??BSP_I2C_Init_3:
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable3_5
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0xF11B 0x0010      ADDS     R0,R11,#+16
   \   00000096   0x.... 0x....      BL       BSP_OS_SemCreate
   \   0000009A   0x0007             MOVS     R7,R0
    305               
    306              if (err == DEF_FAIL) {
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD101             BNE.N    ??BSP_I2C_Init_5
    307                  return (DEF_FAIL);
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xE0A3             B.N      ??BSP_I2C_Init_4
    308              }
    309          
    310              err = BSP_OS_SemCreate((BSP_OS_SEM    *)&(p_i2c_dev_status->SemLock),
    311                                     (BSP_OS_SEM_VAL ) 1, 
    312                                     (CPU_CHAR      *)"I2C Lock");        
   \                     ??BSP_I2C_Init_5:
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable3_6
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0xF11B 0x000C      ADDS     R0,R11,#+12
   \   000000B0   0x.... 0x....      BL       BSP_OS_SemCreate
   \   000000B4   0x0007             MOVS     R7,R0
    313          
    314              if (err == DEF_FAIL) {
   \   000000B6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B8   0x2F00             CMP      R7,#+0
   \   000000BA   0xD101             BNE.N    ??BSP_I2C_Init_6
    315                  return (DEF_FAIL);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE096             B.N      ??BSP_I2C_Init_4
    316              }
    317                  
    318                                                                         /* ----------------- I2C INITIALIZATION -------------- */
    319              RCC_GetClocksFreq(&rcc_clocks);
   \                     ??BSP_I2C_Init_6:
   \   000000C0   0xA801             ADD      R0,SP,#+4
   \   000000C2   0x.... 0x....      BL       RCC_GetClocksFreq
    320              pclk_freq = rcc_clocks.PCLK1_Frequency;
   \   000000C6   0x9803             LDR      R0,[SP, #+12]
   \   000000C8   0x4680             MOV      R8,R0
    321              
    322              if (pclk_freq > BSP_I2C_PER_CLK_MAX_FREQ_HZ) {
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable3_7  ;; 0x2255101
   \   000000CE   0x4580             CMP      R8,R0
   \   000000D0   0xD301             BCC.N    ??BSP_I2C_Init_7
    323                 return (DEF_FAIL);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE08B             B.N      ??BSP_I2C_Init_4
    324              }
    325          
    326              p_i2c_reg->I2C_CR1 = BSP_I2C_REG_CR1_SWRST;                /* Perform a software reset                            */
   \                     ??BSP_I2C_Init_7:
   \   000000D6   0xF44F 0x4000      MOV      R0,#+32768
   \   000000DA   0xF8CA 0x0000      STR      R0,[R10, #+0]
    327              p_i2c_reg->I2C_CR1 = DEF_BIT_NONE;          
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF8CA 0x0000      STR      R0,[R10, #+0]
    328              
    329                                                                         /* Set the frequency range                             */
    330              p_i2c_reg->I2C_CR2 = (pclk_freq / DEF_TIME_NBR_uS_PER_SEC)
    331                                 & BSP_I2C_REG_CR2_FREQ_MASK;          
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable3_8  ;; 0xf4240
   \   000000E8   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \   000000EC   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000F0   0xF8CA 0x0004      STR      R0,[R10, #+4]
    332              
    333                                                                         /* Calculate the clock divider                         */
    334              switch (i2c_mode) {
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD003             BEQ.N    ??BSP_I2C_Init_8
   \   000000FA   0x2D02             CMP      R5,#+2
   \   000000FC   0xD024             BEQ.N    ??BSP_I2C_Init_9
   \   000000FE   0xD30F             BCC.N    ??BSP_I2C_Init_10
   \   00000100   0xE037             B.N      ??BSP_I2C_Init_11
    335                  case BSP_I2C_MODE_STANDARD:
    336                       if (clk_freq > BSP_I2C_MODE_STANDARD_MAX_FREQ_HZ) {
   \                     ??BSP_I2C_Init_8:
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable3_9  ;; 0x186a1
   \   00000106   0x4286             CMP      R6,R0
   \   00000108   0xD301             BCC.N    ??BSP_I2C_Init_12
    337                           return (DEF_FAIL);
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xE06F             B.N      ??BSP_I2C_Init_4
    338                       }
    339                       
    340                       reg_val = (((2 * pclk_freq  + clk_freq)/ (2 * clk_freq))  / 2)
    341                               & BSP_I2C_REG_CCR_MASK;
   \                     ??BSP_I2C_Init_12:
   \   0000010E   0xEB16 0x0048      ADDS     R0,R6,R8, LSL #+1
   \   00000112   0x0071             LSLS     R1,R6,#+1
   \   00000114   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000118   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+20
   \   0000011A   0x0D00             LSRS     R0,R0,#+20
   \   0000011C   0x4681             MOV      R9,R0
    342                       break;
   \   0000011E   0xE028             B.N      ??BSP_I2C_Init_11
    343                       
    344                  case BSP_I2C_MODE_FAST_1_2:             
    345                       if (clk_freq > BSP_I2C_MODE_FAST_MAX_FREQ_HZ) {
   \                     ??BSP_I2C_Init_10:
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable3_10  ;; 0x61a81
   \   00000124   0x4286             CMP      R6,R0
   \   00000126   0xD301             BCC.N    ??BSP_I2C_Init_13
    346                           return (DEF_FAIL);
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xE060             B.N      ??BSP_I2C_Init_4
    347                       }  
    348                       DEF_BIT_SET(reg_val, BSP_I2C_REG_CCR_FS);
   \                     ??BSP_I2C_Init_13:
   \   0000012C   0xF459 0x4900      ORRS     R9,R9,#0x8000
    349                       reg_val = (((2 * pclk_freq  + clk_freq)/ (2 * clk_freq))  / 3)
    350                               & BSP_I2C_REG_CCR_MASK;
   \   00000130   0xEB16 0x0048      ADDS     R0,R6,R8, LSL #+1
   \   00000134   0x0071             LSLS     R1,R6,#+1
   \   00000136   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000013A   0x2103             MOVS     R1,#+3
   \   0000013C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000140   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   00000142   0x0D00             LSRS     R0,R0,#+20
   \   00000144   0x4681             MOV      R9,R0
    351                       break;
   \   00000146   0xE014             B.N      ??BSP_I2C_Init_11
    352                  
    353                  
    354                  case BSP_I2C_MODE_FAST_16_9:
    355                       if (clk_freq > BSP_I2C_MODE_FAST_MAX_FREQ_HZ) {
   \                     ??BSP_I2C_Init_9:
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable3_10  ;; 0x61a81
   \   0000014C   0x4286             CMP      R6,R0
   \   0000014E   0xD301             BCC.N    ??BSP_I2C_Init_14
    356                           return (DEF_FAIL);
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xE04C             B.N      ??BSP_I2C_Init_4
    357                       }  
    358                       reg_val = (((2 * pclk_freq) + (25 * clk_freq)) / (50 * clk_freq))
    359                               & BSP_I2C_REG_CCR_MASK; 
   \                     ??BSP_I2C_Init_14:
   \   00000154   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   00000158   0x2119             MOVS     R1,#+25
   \   0000015A   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000015E   0x2132             MOVS     R1,#+50
   \   00000160   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000164   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000168   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   0000016A   0x0D00             LSRS     R0,R0,#+20
   \   0000016C   0x4681             MOV      R9,R0
    360                       DEF_BIT_SET(reg_val, BSP_I2C_REG_CCR_DUTY | BSP_I2C_REG_CCR_FS);
   \   0000016E   0xF459 0x4940      ORRS     R9,R9,#0xC000
    361                       break;                          
    362              }    
    363              
    364              p_i2c_reg->I2C_CCR = reg_val;
   \                     ??BSP_I2C_Init_11:
   \   00000172   0xF8CA 0x901C      STR      R9,[R10, #+28]
    365              
    366                                                                          /* Enable interrupts in the interrupt controller      */
    367              switch (i2c_id) {
   \   00000176   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   0x0020             MOVS     R0,R4
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xD002             BEQ.N    ??BSP_I2C_Init_15
   \   0000017E   0x2802             CMP      R0,#+2
   \   00000180   0xD011             BEQ.N    ??BSP_I2C_Init_16
   \   00000182   0xE021             B.N      ??BSP_I2C_Init_17
    368                  case BSP_I2C_ID_I2C1:
    369                       BSP_IntVectSet(BSP_INT_ID_I2C1_EV, BSP_I2C1_EventISR_Handler);
   \                     ??BSP_I2C_Init_15:
   \   00000184   0x.... 0x....      ADR.W    R1,BSP_I2C1_EventISR_Handler
   \   00000188   0x201F             MOVS     R0,#+31
   \   0000018A   0x.... 0x....      BL       BSP_IntVectSet
    370                       BSP_IntEn(BSP_INT_ID_I2C1_EV);
   \   0000018E   0x201F             MOVS     R0,#+31
   \   00000190   0x.... 0x....      BL       BSP_IntEn
    371          
    372                       BSP_IntVectSet(BSP_INT_ID_I2C1_ER, BSP_I2C1_ErrISR_Handler);
   \   00000194   0x.... 0x....      ADR.W    R1,BSP_I2C1_ErrISR_Handler
   \   00000198   0x2020             MOVS     R0,#+32
   \   0000019A   0x.... 0x....      BL       BSP_IntVectSet
    373                       BSP_IntEn(BSP_INT_ID_I2C1_ER);
   \   0000019E   0x2020             MOVS     R0,#+32
   \   000001A0   0x.... 0x....      BL       BSP_IntEn
    374                       
    375                       break;
   \   000001A4   0xE010             B.N      ??BSP_I2C_Init_18
    376          
    377                  case BSP_I2C_ID_I2C2:
    378                       BSP_IntVectSet(BSP_INT_ID_I2C2_EV, BSP_I2C2_EventISR_Handler);
   \                     ??BSP_I2C_Init_16:
   \   000001A6   0x.... 0x....      ADR.W    R1,BSP_I2C2_EventISR_Handler
   \   000001AA   0x2021             MOVS     R0,#+33
   \   000001AC   0x.... 0x....      BL       BSP_IntVectSet
    379                       BSP_IntEn(BSP_INT_ID_I2C2_EV);
   \   000001B0   0x2021             MOVS     R0,#+33
   \   000001B2   0x.... 0x....      BL       BSP_IntEn
    380          
    381                       BSP_IntVectSet(BSP_INT_ID_I2C2_ER, BSP_I2C2_ErrISR_Handler);
   \   000001B6   0x.... 0x....      ADR.W    R1,BSP_I2C2_ErrISR_Handler
   \   000001BA   0x2022             MOVS     R0,#+34
   \   000001BC   0x.... 0x....      BL       BSP_IntVectSet
    382                       BSP_IntEn(BSP_INT_ID_I2C1_ER);
   \   000001C0   0x2020             MOVS     R0,#+32
   \   000001C2   0x.... 0x....      BL       BSP_IntEn
    383                       break;
   \   000001C6   0xE7FF             B.N      ??BSP_I2C_Init_18
    384                  
    385                  default:
    386                       break;
    387              }
    388          
    389                                                                           /* Initialize the device status                      */
    390              p_i2c_dev_status->Addr       = DEF_BIT_NONE;
   \                     ??BSP_I2C_Init_17:
   \                     ??BSP_I2C_Init_18:
   \   000001C8   0x2000             MOVS     R0,#+0
   \   000001CA   0xF88B 0x0001      STRB     R0,[R11, #+1]
    391              p_i2c_dev_status->AccessType = BSP_I2C_ACCESS_TYPE_NONE;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xF88B 0x0000      STRB     R0,[R11, #+0]
    392              p_i2c_dev_status->State      = BSP_I2C_STATE_IDLE;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0xF88B 0x0002      STRB     R0,[R11, #+2]
    393              p_i2c_dev_status->BufPtr     = (CPU_INT08U *)0;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0xF8CB 0x0004      STR      R0,[R11, #+4]
    394              p_i2c_dev_status->BufLen     = 0;   
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0xF8AB 0x0008      STRH     R0,[R11, #+8]
    395          
    396              p_i2c_reg->I2C_CR1           = BSP_I2C_REG_CR1_PE;            /* Enable the I2C peripheral                        */
   \   000001E6   0x2001             MOVS     R0,#+1
   \   000001E8   0xF8CA 0x0000      STR      R0,[R10, #+0]
    397              
    398              return (DEF_OK);
   \   000001EC   0x2001             MOVS     R0,#+1
   \                     ??BSP_I2C_Init_4:
   \   000001EE   0xB007             ADD      SP,SP,#+28
   \   000001F0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    399              
    400          }
    401          
    402          
    403          /*
    404          *********************************************************************************************************
    405          *                                       BSP_I2C_StartXfer()
    406          *
    407          * Description : Initialize and Start a new transfer in the I2C bus.
    408          *
    409          * Argument(s) : i2c_id            I2C peripheral ID
    410          *                                    BSP_I2C_ID_I2C1
    411          *                                    BSP_I2C_ID_I2C2
    412          *
    413          *               i2c_addr           The I2C device address
    414          *
    415          *               i2c_acess_type     I2C Access Type
    416          *                                      BSP_I2C_ACCESS_TYPE_RD
    417          *                                      BSP_I2C_ACCESS_TYPE_WR
    418          *                                      BSP_I2C_ACCESS_TYPE_WR_RD
    419          *                               
    420          *               p_buf              Pointer to the buffer into which the bytes will be stored.
    421          *
    422          *               nbr_bytes          Number of bytes to read.
    423          *
    424          * Return(s)   : DEF_OK            If the transfer could be initialized and started 
    425          *               DEF_FAIL          If the transfer could no bet initialized and started
    426          *
    427          * Caller(s)   : BSP_I2C_Rd()
    428          *               BSP_I2C_Wr()
    429          *               BSP_I2C_WrRd()
    430          *
    431          * Note(s)     : none.
    432          *********************************************************************************************************
    433          */
    434          

   \                                 In section .text, align 2, keep-with-next
    435          static  CPU_BOOLEAN  BSP_I2C_StartXfer (CPU_INT08U   i2c_id,
    436                                                  CPU_INT08U   i2c_addr,
    437                                                  CPU_INT08U   i2c_access_type,
    438                                                  CPU_INT08U  *p_buf,                    
    439                                                  CPU_INT08U   nbr_bytes)
    440          {   
   \                     BSP_I2C_StartXfer:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
    441              CPU_BOOLEAN          err;
    442              BSP_I2C_DEV_STATUS  *p_i2c_dev_status;
    443              BSP_I2C_REG         *p_i2c_reg;
    444             
    445          
    446              err = DEF_OK;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4681             MOV      R9,R0
    447              
    448              switch (i2c_id) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD002             BEQ.N    ??BSP_I2C_StartXfer_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD007             BEQ.N    ??BSP_I2C_StartXfer_1
   \   0000001E   0xE00D             B.N      ??BSP_I2C_StartXfer_2
    449                  case BSP_I2C_ID_I2C1:
    450                       p_i2c_reg        = (BSP_I2C_REG        *)BSP_I2C_REG_I2C1_BASE_ADDR;
   \                     ??BSP_I2C_StartXfer_0:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0x40005400
   \   00000024   0x4683             MOV      R11,R0
    451                       p_i2c_dev_status = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[0];
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000002A   0x4682             MOV      R10,R0
    452                       break;
   \   0000002C   0xE008             B.N      ??BSP_I2C_StartXfer_3
    453          
    454                  case BSP_I2C_ID_I2C2:
    455                       p_i2c_reg        = (BSP_I2C_REG        *)BSP_I2C_REG_I2C2_BASE_ADDR;
   \                     ??BSP_I2C_StartXfer_1:
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable3_3  ;; 0x40005800
   \   00000032   0x4683             MOV      R11,R0
    456                       p_i2c_dev_status = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[1];
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   00000038   0x4682             MOV      R10,R0
    457                       break;
   \   0000003A   0xE001             B.N      ??BSP_I2C_StartXfer_3
    458                  
    459                  default:
    460                      return (DEF_FAIL);
   \                     ??BSP_I2C_StartXfer_2:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE037             B.N      ??BSP_I2C_StartXfer_4
    461              }
    462                
    463              err = BSP_OS_SemWait(&(p_i2c_dev_status->SemLock),          /* Lock the I2C peripheral                              */
    464                                   0);    
   \                     ??BSP_I2C_StartXfer_3:
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF11A 0x000C      ADDS     R0,R10,#+12
   \   00000046   0x.... 0x....      BL       BSP_OS_SemWait
   \   0000004A   0x4681             MOV      R9,R0
    465          
    466              if (err == DEF_FAIL) {
   \   0000004C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD101             BNE.N    ??BSP_I2C_StartXfer_5
    467                  return (DEF_FAIL);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE02A             B.N      ??BSP_I2C_StartXfer_4
    468              }
    469          
    470                                                                          /* Initialize the device structure                      */
    471              p_i2c_dev_status->Addr       = (i2c_addr);                  /* I2C Slave  address                                   */    
   \                     ??BSP_I2C_StartXfer_5:
   \   0000005A   0xF88A 0x6001      STRB     R6,[R10, #+1]
    472              p_i2c_dev_status->AccessType = i2c_access_type;             /* Set the access type                                  */
   \   0000005E   0xF88A 0x7000      STRB     R7,[R10, #+0]
    473              p_i2c_dev_status->State      = BSP_I2C_STATE_START;         /* Set the START state                                  */
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF88A 0x0002      STRB     R0,[R10, #+2]
    474              p_i2c_dev_status->BufPtr     = p_buf;                       /* Set the buffer information                           */
   \   00000068   0xF8CA 0x8004      STR      R8,[R10, #+4]
    475              p_i2c_dev_status->BufLen     = nbr_bytes;  
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0xF8AA 0x4008      STRH     R4,[R10, #+8]
    476              
    477              DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_START);     /* Generate the start condition                         */
   \   00000072   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000076   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000007A   0xF8CB 0x0000      STR      R0,[R11, #+0]
    478          
    479              DEF_BIT_SET(p_i2c_reg->I2C_CR2, BSP_I2C_REG_CR2_ITEVTEN |   /* Enable Bus Errors and bus Events interrupts          */
    480                                              BSP_I2C_REG_CR2_ITERREN);
   \   0000007E   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000082   0xF450 0x7040      ORRS     R0,R0,#0x300
   \   00000086   0xF8CB 0x0004      STR      R0,[R11, #+4]
    481              
    482                                                                          /* Wait until the transfer completes                    */
    483              err = BSP_OS_SemWait(&(p_i2c_dev_status->SemWait),
    484                                   500);  
   \   0000008A   0xF44F 0x71FA      MOV      R1,#+500
   \   0000008E   0xF11A 0x0010      ADDS     R0,R10,#+16
   \   00000092   0x.... 0x....      BL       BSP_OS_SemWait
   \   00000096   0x4681             MOV      R9,R0
    485                  
    486              BSP_OS_SemPost(&(p_i2c_dev_status->SemLock));               /* Release the I2C Peripheral                           */
   \   00000098   0xF11A 0x000C      ADDS     R0,R10,#+12
   \   0000009C   0x.... 0x....      BL       BSP_OS_SemPost
    487                  
    488          
    489              if (p_i2c_dev_status->BufLen != 0) {                        /* If the transfer is incomplete ...                    */
   \   000000A0   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD001             BEQ.N    ??BSP_I2C_StartXfer_6
    490                  err  = DEF_FAIL;                                        /* ... return an errror                                 */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x4681             MOV      R9,R0
    491              }
    492              
    493              return (err);
   \                     ??BSP_I2C_StartXfer_6:
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_I2C_StartXfer_4:
   \   000000B0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    494          }
    495           
    496          
    497          /*
    498          *********************************************************************************************************
    499          *                                        BSP_I2C_Rd()
    500          *
    501          * Description : Read 'n' bytes from the I2C bus.
    502          *
    503          * Argument(s) : i2c_nbr      I2C peripheral number
    504          *                                BSP_I2C_ID_I2C1
    505          *                                BSP_I2C_ID_I2C2
    506          *
    507          *               i2c_addr     The I2C device address
    508          *
    509          *               p_buf        Pointer to the buffer into which the bytes will be stored.
    510          *
    511          *               nbr_bytes    Number of bytes to be read.
    512          *
    513          * Return(s)   : DEF_OK       If all bytes were read.
    514          *               DEF_FAIL     If all bytes could not be read.
    515          *
    516          * Caller(s)   : Application
    517          *
    518          * Note(s)     : none.
    519          *********************************************************************************************************
    520          */
    521          

   \                                 In section .text, align 2, keep-with-next
    522          CPU_BOOLEAN  BSP_I2C_Rd (CPU_INT08U   i2c_id,
    523                                   CPU_INT08U   i2c_addr,
    524                                   CPU_INT08U  *p_buf,
    525                                   CPU_INT08U   nbr_bytes)
    526          {
   \                     BSP_I2C_Rd:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    527              CPU_BOOLEAN  err;
    528              
    529              
    530              if (p_buf == (CPU_INT08U *)0) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??BSP_I2C_Rd_0
    531                  return (DEF_FAIL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE011             B.N      ??BSP_I2C_Rd_1
    532              }
    533              
    534              if (nbr_bytes < 1) {
   \                     ??BSP_I2C_Rd_0:
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD101             BNE.N    ??BSP_I2C_Rd_2
    535                  return (DEF_FAIL);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00C             B.N      ??BSP_I2C_Rd_1
    536              }
    537              
    538              err = BSP_I2C_StartXfer(i2c_id,
    539                                      i2c_addr,
    540                                      BSP_I2C_ACCESS_TYPE_RD,
    541                                      p_buf,
    542                                      nbr_bytes);
   \                     ??BSP_I2C_Rd_2:
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x9700             STR      R7,[SP, #+0]
   \   00000024   0x0033             MOVS     R3,R6
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       BSP_I2C_StartXfer
   \   00000034   0x4680             MOV      R8,R0
    543              
    544              return (err);
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_I2C_Rd_1:
   \   0000003A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    545          }
    546          
    547          
    548          /*
    549          *********************************************************************************************************
    550          *                                        BSP_I2C_Wr()
    551          *
    552          * Description : Write 'n' bytes tothe I2C bus.
    553          *
    554          * Argument(s) : i2c_nbr      I2C peripheral number
    555          *                                BSP_I2C_ID_I2C1
    556          *                                BSP_I2C_ID_I2C2
    557          *
    558          *               i2c_addr     The I2C device address
    559          *
    560          *               p_buf        Pointer to the buffer where the bytes will be transfered.
    561          *
    562          *               nbr_bytes    Number of bytes to be read.
    563          *
    564          * Return(s)   : DEF_OK       If all bytes were written
    565          *               DEF_FAIL     If all bytes could not be written.
    566          *
    567          * Caller(s)   : Application
    568          *
    569          * Note(s)     : none.
    570          *********************************************************************************************************
    571          */
    572          
    573          

   \                                 In section .text, align 2, keep-with-next
    574          CPU_BOOLEAN  BSP_I2C_Wr (CPU_INT08U   i2c_id,
    575                                   CPU_INT08U   i2c_addr,
    576                                   CPU_INT08U  *p_buf,
    577                                   CPU_INT08U   nbr_bytes)
    578          {
   \                     BSP_I2C_Wr:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    579              CPU_BOOLEAN  err;
    580              
    581              
    582              if (p_buf == (CPU_INT08U *)0) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??BSP_I2C_Wr_0
    583                  return (DEF_FAIL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE011             B.N      ??BSP_I2C_Wr_1
    584              }
    585              
    586              if (nbr_bytes < 1) {
   \                     ??BSP_I2C_Wr_0:
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD101             BNE.N    ??BSP_I2C_Wr_2
    587                  return (DEF_FAIL);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00C             B.N      ??BSP_I2C_Wr_1
    588              }
    589          
    590               
    591              err = BSP_I2C_StartXfer(i2c_id,
    592                                      i2c_addr,
    593                                      BSP_I2C_ACCESS_TYPE_WR,
    594                                      p_buf,
    595                                      nbr_bytes);
   \                     ??BSP_I2C_Wr_2:
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x9700             STR      R7,[SP, #+0]
   \   00000024   0x0033             MOVS     R3,R6
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       BSP_I2C_StartXfer
   \   00000034   0x4680             MOV      R8,R0
    596              
    597              return (err);               
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_I2C_Wr_1:
   \   0000003A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    598          }
    599          
    600          
    601          /*
    602          *********************************************************************************************************
    603          *                                        BSP_I2C_WrRd()
    604          *
    605          * Description : Perform a write followed by multiples/single read(s)
    606          *
    607          * Argument(s) : i2c_nbr      I2C peripheral number
    608          *                                BSP_I2C_ID_I2C1
    609          *                                BSP_I2C_ID_I2C2
    610          *
    611          *               i2c_addr     The I2C device address
    612          *
    613          *               p_buf        Pointer to the buffer where the bytes will be transfered/received.
    614          *
    615          *               nbr_bytes    Number of bytes to be read.
    616          *
    617          * Return(s)   : DEF_OK       If all bytes were read
    618          *               DEF_FAIL     If all bytes could not be read.
    619          *
    620          * Caller(s)   : Application
    621          *
    622          * Note(s)     : none.
    623          *********************************************************************************************************
    624          */
    625          

   \                                 In section .text, align 2, keep-with-next
    626          CPU_BOOLEAN  BSP_I2C_WrRd (CPU_INT08U   i2c_id,
    627                                     CPU_INT08U   i2c_addr,
    628                                     CPU_INT08U  *p_buf,
    629                                     CPU_INT08U   nbr_bytes)
    630          {
   \                     BSP_I2C_WrRd:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    631              CPU_BOOLEAN  err;
    632              
    633              
    634              if (p_buf == (CPU_INT08U *)0) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??BSP_I2C_WrRd_0
    635                  return (DEF_FAIL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE011             B.N      ??BSP_I2C_WrRd_1
    636              }
    637              
    638              if (nbr_bytes < 2) {
   \                     ??BSP_I2C_WrRd_0:
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F02             CMP      R7,#+2
   \   0000001A   0xDA01             BGE.N    ??BSP_I2C_WrRd_2
    639                  return (DEF_FAIL);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00C             B.N      ??BSP_I2C_WrRd_1
    640              }
    641               
    642              
    643              err = BSP_I2C_StartXfer(i2c_id,
    644                                      i2c_addr,
    645                                      BSP_I2C_ACCESS_TYPE_WR_RD,
    646                                      p_buf,
    647                                      nbr_bytes);
   \                     ??BSP_I2C_WrRd_2:
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0x9700             STR      R7,[SP, #+0]
   \   00000024   0x0033             MOVS     R3,R6
   \   00000026   0x2203             MOVS     R2,#+3
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       BSP_I2C_StartXfer
   \   00000034   0x4680             MOV      R8,R0
    648              
    649              return (err);               
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BSP_I2C_WrRd_1:
   \   0000003A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    650          }
    651          
    652          
    653          /*
    654          *********************************************************************************************************
    655          *                                        BSP_I2C1_EventISR_Handle()
    656          *                                        BSP_I2C2_EventISR_Handle
    657          *
    658          * Description : I2C1/I2C2 ISR handlers
    659          *
    660          * Argument(s) : none.
    661          *
    662          * Return(s)   : none.
    663          *
    664          * Caller(s)   : This is an ISR.
    665          *
    666          * Note(s)     : none.
    667          *********************************************************************************************************
    668          */
    669          
    670          

   \                                 In section .text, align 4, keep-with-next
    671          static  void  BSP_I2C1_EventISR_Handler (void)
    672          {
   \                     BSP_I2C1_EventISR_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    673              BSP_I2Cx_EventISR_Handler(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       BSP_I2Cx_EventISR_Handler
    674          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    675          

   \                                 In section .text, align 4, keep-with-next
    676          static  void  BSP_I2C2_EventISR_Handler (void) 
    677          {
   \                     BSP_I2C2_EventISR_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    678              BSP_I2Cx_EventISR_Handler(1);    
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       BSP_I2Cx_EventISR_Handler
    679          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    680          
    681          
    682          /*
    683          *********************************************************************************************************
    684          *                                        BSP_I2Cx_EventISR_Handler()
    685          *
    686          * Description : Generic ISR events handler
    687          *
    688          * Argument(s) : i2c_nbr           I2C peripheral number.
    689          *                                     0  I2C1 peripheral
    690          *                                     1  I2C2 peripheral
    691          *
    692          * Return(s)   : none.
    693          *
    694          * Caller(s)   : BSP_I2C1_EventISR_Handler()
    695          *               BSP_I2C2_EventISR_Handler()
    696          *
    697          * Note(s)     : none.
    698          *********************************************************************************************************
    699          */
    700          

   \                                 In section .text, align 2, keep-with-next
    701          void  BSP_I2Cx_EventISR_Handler (CPU_INT08U  i2c_nbr)
    702          {
   \                     BSP_I2Cx_EventISR_Handler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    703              BSP_I2C_DEV_STATUS  *p_i2c_dev_status;
    704              BSP_I2C_REG         *p_i2c_reg;
    705              CPU_INT32U           int_stat1;
    706              CPU_INT32U           int_stat2;
    707          
    708              
    709               switch (i2c_nbr) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??BSP_I2Cx_EventISR_Handler_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD003             BEQ.N    ??BSP_I2Cx_EventISR_Handler_1
   \   0000000E   0xE005             B.N      ??BSP_I2Cx_EventISR_Handler_2
    710                  case 0:
    711                       p_i2c_reg = (BSP_I2C_REG *)BSP_I2C_REG_I2C1_BASE_ADDR;
   \                     ??BSP_I2Cx_EventISR_Handler_0:
   \   00000010   0x....             LDR.N    R0,??DataTable3  ;; 0x40005400
   \   00000012   0x0006             MOVS     R6,R0
    712                       break;
   \   00000014   0xE002             B.N      ??BSP_I2Cx_EventISR_Handler_3
    713          
    714                  case 1:
    715                       p_i2c_reg = (BSP_I2C_REG *)BSP_I2C_REG_I2C2_BASE_ADDR;
   \                     ??BSP_I2Cx_EventISR_Handler_1:
   \   00000016   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40005800
   \   00000018   0x0006             MOVS     R6,R0
    716                       break;
   \   0000001A   0xE7FF             B.N      ??BSP_I2Cx_EventISR_Handler_3
    717                  
    718                  default:
    719                       break;
    720              }
    721          
    722          
    723              p_i2c_dev_status  = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[i2c_nbr];
   \                     ??BSP_I2Cx_EventISR_Handler_2:
   \                     ??BSP_I2Cx_EventISR_Handler_3:
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2014             MOVS     R0,#+20
   \   00000020   0x....             LDR.N    R1,??DataTable3_1
   \   00000022   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000026   0x0005             MOVS     R5,R0
    724              int_stat1         =  p_i2c_reg->I2C_SR1;
   \   00000028   0x6970             LDR      R0,[R6, #+20]
   \   0000002A   0x0007             MOVS     R7,R0
    725              int_stat1        &=  BSP_I2C_REG_SR1_EVENT_MASK;
   \   0000002C   0xF017 0x07C7      ANDS     R7,R7,#0xC7
    726          
    727              switch (p_i2c_dev_status->State) {
   \   00000030   0x78A8             LDRB     R0,[R5, #+2]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD008             BEQ.N    ??BSP_I2Cx_EventISR_Handler_4
   \   00000036   0xF0C0 0x80D9      BCC.W    ??BSP_I2Cx_EventISR_Handler_5
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD060             BEQ.N    ??BSP_I2Cx_EventISR_Handler_6
   \   0000003E   0xD31A             BCC.N    ??BSP_I2Cx_EventISR_Handler_7
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xF000 0x80A3      BEQ.W    ??BSP_I2Cx_EventISR_Handler_8
   \   00000046   0xE0D1             B.N      ??BSP_I2Cx_EventISR_Handler_5
    728                  case BSP_I2C_STATE_START:                               /* --------------- I2C START STATE ------------------ */
    729                                                                          /* If the start bit flag has been generated ...       */
    730                       if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_SB)) {     
   \                     ??BSP_I2Cx_EventISR_Handler_4:
   \   00000048   0x07F8             LSLS     R0,R7,#+31
   \   0000004A   0xD513             BPL.N    ??BSP_I2Cx_EventISR_Handler_9
    731                                                                          /* Send the Address with the correct direction        */
    732                           if (p_i2c_dev_status->AccessType == BSP_I2C_ACCESS_TYPE_RD) {
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD109             BNE.N    ??BSP_I2Cx_EventISR_Handler_10
    733                               DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_ACK);
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000058   0x6030             STR      R0,[R6, #+0]
    734                               p_i2c_reg->I2C_DR = (p_i2c_dev_status->Addr << 1)
    735                                                 | DEF_BIT_00;
   \   0000005A   0x7868             LDRB     R0,[R5, #+1]
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000062   0x6130             STR      R0,[R6, #+16]
   \   00000064   0xE004             B.N      ??BSP_I2Cx_EventISR_Handler_11
    736                           } else {                 
    737                               p_i2c_reg->I2C_DR = (p_i2c_dev_status->Addr << 1) & DEF_BIT_FIELD(7, 1);
   \                     ??BSP_I2Cx_EventISR_Handler_10:
   \   00000066   0x7868             LDRB     R0,[R5, #+1]
   \   00000068   0x0040             LSLS     R0,R0,#+1
   \   0000006A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000006E   0x6130             STR      R0,[R6, #+16]
    738                           }
    739                           
    740                           p_i2c_dev_status->State = BSP_I2C_STATE_ADDR;
   \                     ??BSP_I2Cx_EventISR_Handler_11:
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x70A8             STRB     R0,[R5, #+2]
    741                       }
    742                       break;
   \                     ??BSP_I2Cx_EventISR_Handler_9:
   \   00000074   0xE0BA             B.N      ??BSP_I2Cx_EventISR_Handler_12
    743                       
    744                  case BSP_I2C_STATE_ADDR:                                /* --------------- I2C ADRESS STATE ----------------- */
    745                                                                          /* If the address was sent ...                        */
    746                       if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_ADDR)) { 
   \                     ??BSP_I2Cx_EventISR_Handler_7:
   \   00000076   0xF017 0x0002      ANDS     R0,R7,#0x2
   \   0000007A   0x0840             LSRS     R0,R0,#+1
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD02E             BEQ.N    ??BSP_I2Cx_EventISR_Handler_13
    747                           int_stat2 = p_i2c_reg->I2C_SR2;
   \   00000080   0x69B0             LDR      R0,[R6, #+24]
   \   00000082   0x9000             STR      R0,[SP, #+0]
    748                        
    749                           (void)&int_stat2;
   \   00000084   0xA800             ADD      R0,SP,#+0
    750          
    751                           switch (p_i2c_dev_status->AccessType) {
   \   00000086   0x7828             LDRB     R0,[R5, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0xD003             BEQ.N    ??BSP_I2Cx_EventISR_Handler_14
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD90D             BLS.N    ??BSP_I2Cx_EventISR_Handler_15
   \   00000092   0xE023             B.N      ??BSP_I2Cx_EventISR_Handler_16
    752                               case BSP_I2C_ACCESS_TYPE_RD:
    753                                    if (p_i2c_dev_status->BufLen == 1) {
   \                     ??BSP_I2Cx_EventISR_Handler_14:
   \   00000094   0x8928             LDRH     R0,[R5, #+8]
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD106             BNE.N    ??BSP_I2Cx_EventISR_Handler_17
    754                                        p_i2c_dev_status->State = BSP_I2C_STATE_STOP;                               
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0x70A8             STRB     R0,[R5, #+2]
    755                                        DEF_BIT_CLR(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_ACK);
   \   0000009E   0x6830             LDR      R0,[R6, #+0]
   \   000000A0   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000A4   0x6030             STR      R0,[R6, #+0]
   \   000000A6   0xE001             B.N      ??BSP_I2Cx_EventISR_Handler_18
    756                                    } else {                              
    757                                        p_i2c_dev_status->State = BSP_I2C_STATE_DATA;
   \                     ??BSP_I2Cx_EventISR_Handler_17:
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0x70A8             STRB     R0,[R5, #+2]
    758                                    }
    759                                    break;                 
   \                     ??BSP_I2Cx_EventISR_Handler_18:
   \   000000AC   0xE027             B.N      ??BSP_I2Cx_EventISR_Handler_19
    760          
    761                               case BSP_I2C_ACCESS_TYPE_WR:
    762                               case BSP_I2C_ACCESS_TYPE_WR_RD:
    763                                    if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_TXE)) {                     
   \                     ??BSP_I2Cx_EventISR_Handler_15:
   \   000000AE   0xF017 0x0080      ANDS     R0,R7,#0x80
   \   000000B2   0x09C0             LSRS     R0,R0,#+7
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD010             BEQ.N    ??BSP_I2Cx_EventISR_Handler_20
    764                                        p_i2c_reg->I2C_DR = (CPU_INT32U)(*(p_i2c_dev_status->BufPtr));
   \   000000B8   0x6868             LDR      R0,[R5, #+4]
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x6130             STR      R0,[R6, #+16]
    765                                        p_i2c_dev_status->BufPtr++;
   \   000000BE   0x6868             LDR      R0,[R5, #+4]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x6068             STR      R0,[R5, #+4]
    766                                        p_i2c_dev_status->BufLen--;
   \   000000C4   0x8928             LDRH     R0,[R5, #+8]
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
   \   000000C8   0x8128             STRH     R0,[R5, #+8]
    767                                        if (p_i2c_dev_status->BufLen == 0) {                               
   \   000000CA   0x8928             LDRH     R0,[R5, #+8]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD102             BNE.N    ??BSP_I2Cx_EventISR_Handler_21
    768                                            p_i2c_dev_status->State = BSP_I2C_STATE_STOP;                               
   \   000000D0   0x2004             MOVS     R0,#+4
   \   000000D2   0x70A8             STRB     R0,[R5, #+2]
   \   000000D4   0xE001             B.N      ??BSP_I2Cx_EventISR_Handler_20
    769                                        } else {
    770                                            p_i2c_dev_status->State = BSP_I2C_STATE_DATA;
   \                     ??BSP_I2Cx_EventISR_Handler_21:
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0x70A8             STRB     R0,[R5, #+2]
    771                                        }
    772                                    }
    773                                    break;  
   \                     ??BSP_I2Cx_EventISR_Handler_20:
   \   000000DA   0xE010             B.N      ??BSP_I2Cx_EventISR_Handler_19
    774          
    775                               default:
    776                                    break;
   \                     ??BSP_I2Cx_EventISR_Handler_16:
   \   000000DC   0xE00F             B.N      ??BSP_I2Cx_EventISR_Handler_19
    777                           }             
    778                       } else {
    779                           p_i2c_dev_status->State      = BSP_I2C_STATE_IDLE;
   \                     ??BSP_I2Cx_EventISR_Handler_13:
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x70A8             STRB     R0,[R5, #+2]
    780                           p_i2c_dev_status->AccessType = BSP_I2C_ACCESS_TYPE_NONE;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x7028             STRB     R0,[R5, #+0]
    781          
    782                           DEF_BIT_CLR(p_i2c_reg->I2C_CR2, BSP_I2C_REG_CR2_ITEVTEN |
    783                                                           BSP_I2C_REG_CR2_ITERREN);
   \   000000E6   0x6870             LDR      R0,[R6, #+4]
   \   000000E8   0xF430 0x7040      BICS     R0,R0,#0x300
   \   000000EC   0x6070             STR      R0,[R6, #+4]
    784                           DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_STOP);                              
   \   000000EE   0x6830             LDR      R0,[R6, #+0]
   \   000000F0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000F4   0x6030             STR      R0,[R6, #+0]
    785          
    786                           BSP_OS_SemPost(&(p_i2c_dev_status->SemWait));
   \   000000F6   0xF115 0x0010      ADDS     R0,R5,#+16
   \   000000FA   0x.... 0x....      BL       BSP_OS_SemPost
    787                       }
    788                       break;
   \                     ??BSP_I2Cx_EventISR_Handler_19:
   \   000000FE   0xE075             B.N      ??BSP_I2Cx_EventISR_Handler_12
    789                           
    790                   case BSP_I2C_STATE_DATA:                               /* ---------------- I2C DATA STATE ------------------ */
    791                        switch (p_i2c_dev_status->AccessType) {
   \                     ??BSP_I2Cx_EventISR_Handler_6:
   \   00000100   0x7828             LDRB     R0,[R5, #+0]
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xD012             BEQ.N    ??BSP_I2Cx_EventISR_Handler_22
   \   00000106   0xD340             BCC.N    ??BSP_I2Cx_EventISR_Handler_23
   \   00000108   0x2803             CMP      R0,#+3
   \   0000010A   0xD001             BEQ.N    ??BSP_I2Cx_EventISR_Handler_24
   \   0000010C   0xD32A             BCC.N    ??BSP_I2Cx_EventISR_Handler_25
   \   0000010E   0xE03C             B.N      ??BSP_I2Cx_EventISR_Handler_23
    792                                                                          /* If the I2C is receiving ...                        */
    793                            case BSP_I2C_ACCESS_TYPE_WR_RD:  
    794                                 if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_TXE)) {
   \                     ??BSP_I2Cx_EventISR_Handler_24:
   \   00000110   0xF017 0x0080      ANDS     R0,R7,#0x80
   \   00000114   0x09C0             LSRS     R0,R0,#+7
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD007             BEQ.N    ??BSP_I2Cx_EventISR_Handler_26
    795                                                                          /* Initialize the Transfer as read access             */
    796                                     DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_START);
   \   0000011A   0x6830             LDR      R0,[R6, #+0]
   \   0000011C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000120   0x6030             STR      R0,[R6, #+0]
    797                                     p_i2c_dev_status->State      = BSP_I2C_STATE_START;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x70A8             STRB     R0,[R5, #+2]
    798                                     p_i2c_dev_status->AccessType = BSP_I2C_ACCESS_TYPE_RD;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0x7028             STRB     R0,[R5, #+0]
    799                                 }
    800                                 break;
   \                     ??BSP_I2Cx_EventISR_Handler_26:
   \   0000012A   0xE02E             B.N      ??BSP_I2Cx_EventISR_Handler_23
    801          
    802                            case BSP_I2C_ACCESS_TYPE_RD:  
    803                                                                          /* If the receive register is not empty               */
    804                                 if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_RXNE)) {
   \                     ??BSP_I2Cx_EventISR_Handler_22:
   \   0000012C   0xF017 0x0040      ANDS     R0,R7,#0x40
   \   00000130   0x0980             LSRS     R0,R0,#+6
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD015             BEQ.N    ??BSP_I2Cx_EventISR_Handler_27
    805                                     *(p_i2c_dev_status->BufPtr) = (CPU_INT08U)(p_i2c_reg->I2C_DR & BSP_I2C_REG_DR_MASK);
   \   00000136   0x6868             LDR      R0,[R5, #+4]
   \   00000138   0x6931             LDR      R1,[R6, #+16]
   \   0000013A   0x7001             STRB     R1,[R0, #+0]
    806                                       p_i2c_dev_status->BufPtr++;
   \   0000013C   0x6868             LDR      R0,[R5, #+4]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0x6068             STR      R0,[R5, #+4]
    807                                       p_i2c_dev_status->BufLen--;
   \   00000142   0x8928             LDRH     R0,[R5, #+8]
   \   00000144   0x1E40             SUBS     R0,R0,#+1
   \   00000146   0x8128             STRH     R0,[R5, #+8]
    808                                                                         /*  If it is the last byte                             */
    809                                     if (p_i2c_dev_status->BufLen == 1) {                               
   \   00000148   0x8928             LDRH     R0,[R5, #+8]
   \   0000014A   0x2801             CMP      R0,#+1
   \   0000014C   0xD109             BNE.N    ??BSP_I2Cx_EventISR_Handler_27
    810                                                                         /*  NOT Acknowledge, Generate STOP condition           */
    811                                         DEF_BIT_CLR(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_ACK);
   \   0000014E   0x6830             LDR      R0,[R6, #+0]
   \   00000150   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000154   0x6030             STR      R0,[R6, #+0]
    812                                         DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_STOP);                              
   \   00000156   0x6830             LDR      R0,[R6, #+0]
   \   00000158   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000015C   0x6030             STR      R0,[R6, #+0]
    813                                         p_i2c_dev_status->State = BSP_I2C_STATE_STOP;                               
   \   0000015E   0x2004             MOVS     R0,#+4
   \   00000160   0x70A8             STRB     R0,[R5, #+2]
    814                                     }
    815                                 }                        
    816                                 break;                 
   \                     ??BSP_I2Cx_EventISR_Handler_27:
   \   00000162   0xE012             B.N      ??BSP_I2Cx_EventISR_Handler_23
    817                            
    818                            case BSP_I2C_ACCESS_TYPE_WR:
    819                                 if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_TXE)) {
   \                     ??BSP_I2Cx_EventISR_Handler_25:
   \   00000164   0xF017 0x0080      ANDS     R0,R7,#0x80
   \   00000168   0x09C0             LSRS     R0,R0,#+7
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD00D             BEQ.N    ??BSP_I2Cx_EventISR_Handler_28
    820                                     p_i2c_reg->I2C_DR = (CPU_INT32U)(*(p_i2c_dev_status->BufPtr));
   \   0000016E   0x6868             LDR      R0,[R5, #+4]
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x6130             STR      R0,[R6, #+16]
    821                                     p_i2c_dev_status->BufPtr++;
   \   00000174   0x6868             LDR      R0,[R5, #+4]
   \   00000176   0x1C40             ADDS     R0,R0,#+1
   \   00000178   0x6068             STR      R0,[R5, #+4]
    822                                     p_i2c_dev_status->BufLen--;
   \   0000017A   0x8928             LDRH     R0,[R5, #+8]
   \   0000017C   0x1E40             SUBS     R0,R0,#+1
   \   0000017E   0x8128             STRH     R0,[R5, #+8]
    823                                     if (p_i2c_dev_status->BufLen == 0) {                               
   \   00000180   0x8928             LDRH     R0,[R5, #+8]
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD101             BNE.N    ??BSP_I2Cx_EventISR_Handler_28
    824                                         p_i2c_dev_status->State = BSP_I2C_STATE_STOP;                               
   \   00000186   0x2004             MOVS     R0,#+4
   \   00000188   0x70A8             STRB     R0,[R5, #+2]
    825                                     }
    826                                 }
    827                                 break;       
    828                        }
    829                        break;
   \                     ??BSP_I2Cx_EventISR_Handler_28:
   \                     ??BSP_I2Cx_EventISR_Handler_23:
   \   0000018A   0xE02F             B.N      ??BSP_I2Cx_EventISR_Handler_12
    830                  
    831                  case BSP_I2C_STATE_STOP:                                /* ---------------- I2C STOP STATE ------------------ */
    832                       if (DEF_BIT_IS_SET(int_stat1, BSP_I2C_REG_SR1_BTF)) {     
   \                     ??BSP_I2Cx_EventISR_Handler_8:
   \   0000018C   0xF017 0x0004      ANDS     R0,R7,#0x4
   \   00000190   0x0880             LSRS     R0,R0,#+2
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD029             BEQ.N    ??BSP_I2Cx_EventISR_Handler_29
    833                           switch (p_i2c_dev_status->AccessType) {
   \   00000196   0x7828             LDRB     R0,[R5, #+0]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD004             BEQ.N    ??BSP_I2Cx_EventISR_Handler_30
   \   0000019C   0xD319             BCC.N    ??BSP_I2Cx_EventISR_Handler_31
   \   0000019E   0x2803             CMP      R0,#+3
   \   000001A0   0xD001             BEQ.N    ??BSP_I2Cx_EventISR_Handler_30
   \   000001A2   0xD30E             BCC.N    ??BSP_I2Cx_EventISR_Handler_32
   \   000001A4   0xE015             B.N      ??BSP_I2Cx_EventISR_Handler_31
    834                               case BSP_I2C_ACCESS_TYPE_WR_RD:
    835                               case BSP_I2C_ACCESS_TYPE_RD:  
    836                                    DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_STOP);                                   
   \                     ??BSP_I2Cx_EventISR_Handler_30:
   \   000001A6   0x6830             LDR      R0,[R6, #+0]
   \   000001A8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001AC   0x6030             STR      R0,[R6, #+0]
    837                                    *(p_i2c_dev_status->BufPtr) = (CPU_INT08U)(p_i2c_reg->I2C_DR & BSP_I2C_REG_DR_MASK);;
   \   000001AE   0x6868             LDR      R0,[R5, #+4]
   \   000001B0   0x6931             LDR      R1,[R6, #+16]
   \   000001B2   0x7001             STRB     R1,[R0, #+0]
    838                                      p_i2c_dev_status->BufPtr++;
   \   000001B4   0x6868             LDR      R0,[R5, #+4]
   \   000001B6   0x1C40             ADDS     R0,R0,#+1
   \   000001B8   0x6068             STR      R0,[R5, #+4]
    839                                      p_i2c_dev_status->BufLen--;
   \   000001BA   0x8928             LDRH     R0,[R5, #+8]
   \   000001BC   0x1E40             SUBS     R0,R0,#+1
   \   000001BE   0x8128             STRH     R0,[R5, #+8]
    840                                    break;
   \   000001C0   0xE007             B.N      ??BSP_I2Cx_EventISR_Handler_31
    841                              
    842                               case BSP_I2C_ACCESS_TYPE_WR:
    843                                    DEF_BIT_CLR(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_ACK);
   \                     ??BSP_I2Cx_EventISR_Handler_32:
   \   000001C2   0x6830             LDR      R0,[R6, #+0]
   \   000001C4   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000001C8   0x6030             STR      R0,[R6, #+0]
    844                                    DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_STOP);                              
   \   000001CA   0x6830             LDR      R0,[R6, #+0]
   \   000001CC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001D0   0x6030             STR      R0,[R6, #+0]
    845                                    break;
    846                           }
    847                           p_i2c_dev_status->State      = BSP_I2C_STATE_IDLE;
   \                     ??BSP_I2Cx_EventISR_Handler_31:
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0x70A8             STRB     R0,[R5, #+2]
    848                           p_i2c_dev_status->AccessType = BSP_I2C_ACCESS_TYPE_NONE;
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0x7028             STRB     R0,[R5, #+0]
    849          
    850                           DEF_BIT_CLR(p_i2c_reg->I2C_CR2, BSP_I2C_REG_CR2_ITEVTEN |
    851                                                           BSP_I2C_REG_CR2_ITERREN);
   \   000001DA   0x6870             LDR      R0,[R6, #+4]
   \   000001DC   0xF430 0x7040      BICS     R0,R0,#0x300
   \   000001E0   0x6070             STR      R0,[R6, #+4]
    852                           
    853                           BSP_OS_SemPost(&(p_i2c_dev_status->SemWait));
   \   000001E2   0xF115 0x0010      ADDS     R0,R5,#+16
   \   000001E6   0x.... 0x....      BL       BSP_OS_SemPost
    854                       }
    855                       break;
   \                     ??BSP_I2Cx_EventISR_Handler_29:
   \   000001EA   0xE7FF             B.N      ??BSP_I2Cx_EventISR_Handler_12
    856          
    857                  case BSP_I2C_STATE_IDLE:
    858                  default:
    859                       break;
    860              }
    861          
    862          }
   \                     ??BSP_I2Cx_EventISR_Handler_5:
   \                     ??BSP_I2Cx_EventISR_Handler_12:
   \   000001EC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    863          
    864          
    865          /*
    866          *********************************************************************************************************
    867          *                                        BSP_I2Cx_EventISR_Handler()
    868          *
    869          * Description : Generic ISR events handler
    870          *
    871          * Argument(s) : i2c_nbr           I2C peripheral number.
    872          *                                     0  I2C1 peripheral
    873          *                                     1  I2C2 peripheral
    874          *
    875          * Return(s)   : none.
    876          *
    877          * Caller(s)   : BSP_I2C1_EventISR_Handler()
    878          *               BSP_I2C2_EventISR_Handler()
    879          *
    880          * Note(s)     : none.
    881          *********************************************************************************************************
    882          */
    883          

   \                                 In section .text, align 4, keep-with-next
    884          static  void  BSP_I2C1_ErrISR_Handler    (void) 
    885          {
   \                     BSP_I2C1_ErrISR_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    886              BSP_I2Cx_ErrISR_Handler(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       BSP_I2Cx_ErrISR_Handler
    887          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    888          
    889          

   \                                 In section .text, align 4, keep-with-next
    890          static  void  BSP_I2C2_ErrISR_Handler    (void)
    891          {
   \                     BSP_I2C2_ErrISR_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    892              BSP_I2Cx_ErrISR_Handler(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       BSP_I2Cx_ErrISR_Handler
    893          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    894          
    895          
    896          /*
    897          *********************************************************************************************************
    898          *                                        BSP_I2Cx_ErrISR_Handler()
    899          *
    900          * Description : Generic ISR errors handler
    901          *
    902          * Argument(s) : i2c_nbr           I2C peripheral number.
    903          *                                     0  I2C1 peripheral
    904          *                                     1  I2C2 peripheral
    905          *
    906          * Return(s)   : none.
    907          *
    908          * Caller(s)   : BSP_I2C1_ErrISR_Handler()
    909          *               BSP_I2C2_ErrISR_Handler()
    910          *
    911          * Note(s)     : none
    912          *********************************************************************************************************
    913          */
    914          

   \                                 In section .text, align 2, keep-with-next
    915          static  void  BSP_I2Cx_ErrISR_Handler (CPU_INT08U  i2c_nbr)
    916          {
   \                     BSP_I2Cx_ErrISR_Handler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    917              BSP_I2C_DEV_STATUS  *p_i2c_dev_status;
    918              BSP_I2C_REG         *p_i2c_reg;
    919              CPU_INT32U           int_stat1;
    920          
    921              
    922               switch (i2c_nbr) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??BSP_I2Cx_ErrISR_Handler_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD003             BEQ.N    ??BSP_I2Cx_ErrISR_Handler_1
   \   0000000E   0xE005             B.N      ??BSP_I2Cx_ErrISR_Handler_2
    923                  case 0:
    924                       p_i2c_reg = (BSP_I2C_REG *)BSP_I2C_REG_I2C1_BASE_ADDR;
   \                     ??BSP_I2Cx_ErrISR_Handler_0:
   \   00000010   0x....             LDR.N    R0,??DataTable3  ;; 0x40005400
   \   00000012   0x0006             MOVS     R6,R0
    925                       break;
   \   00000014   0xE002             B.N      ??BSP_I2Cx_ErrISR_Handler_3
    926          
    927                  case 1:
    928                       p_i2c_reg = (BSP_I2C_REG *)BSP_I2C_REG_I2C2_BASE_ADDR;
   \                     ??BSP_I2Cx_ErrISR_Handler_1:
   \   00000016   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40005800
   \   00000018   0x0006             MOVS     R6,R0
    929                       break;
   \   0000001A   0xE7FF             B.N      ??BSP_I2Cx_ErrISR_Handler_3
    930                  
    931                  default:
    932                       break;
    933              }
    934          
    935              p_i2c_dev_status  = (BSP_I2C_DEV_STATUS *)&BSP_I2C_DevTbl[i2c_nbr];
   \                     ??BSP_I2Cx_ErrISR_Handler_2:
   \                     ??BSP_I2Cx_ErrISR_Handler_3:
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2014             MOVS     R0,#+20
   \   00000020   0x....             LDR.N    R1,??DataTable3_1
   \   00000022   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000026   0x0005             MOVS     R5,R0
    936              int_stat1         =  p_i2c_reg->I2C_SR1;
   \   00000028   0x6970             LDR      R0,[R6, #+20]
   \   0000002A   0x0007             MOVS     R7,R0
    937              int_stat1        &=  BSP_I2C_REG_SR1_ERR_MASK;
   \   0000002C   0xF417 0x471F      ANDS     R7,R7,#0x9F00
    938              
    939              DEF_BIT_CLR(p_i2c_reg->I2C_SR1, int_stat1);
   \   00000030   0x6970             LDR      R0,[R6, #+20]
   \   00000032   0x43B8             BICS     R0,R0,R7
   \   00000034   0x6170             STR      R0,[R6, #+20]
    940              
    941              if (p_i2c_dev_status->State != BSP_I2C_STATE_IDLE) {
   \   00000036   0x78A8             LDRB     R0,[R5, #+2]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD00F             BEQ.N    ??BSP_I2Cx_ErrISR_Handler_4
    942                  p_i2c_dev_status->State      = BSP_I2C_STATE_IDLE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x70A8             STRB     R0,[R5, #+2]
    943                  p_i2c_dev_status->AccessType = BSP_I2C_ACCESS_TYPE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7028             STRB     R0,[R5, #+0]
    944                  DEF_BIT_SET(p_i2c_reg->I2C_CR1, BSP_I2C_REG_CR1_STOP);                              
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000004A   0x6030             STR      R0,[R6, #+0]
    945          
    946                  DEF_BIT_CLR(p_i2c_reg->I2C_CR2, (BSP_I2C_REG_CR2_ITEVTEN |
    947                                                   BSP_I2C_REG_CR2_ITERREN));
   \   0000004C   0x6870             LDR      R0,[R6, #+4]
   \   0000004E   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000052   0x6070             STR      R0,[R6, #+4]
    948                           
    949                  BSP_OS_SemPost(&(p_i2c_dev_status->SemWait));
   \   00000054   0xF115 0x0010      ADDS     R0,R5,#+16
   \   00000058   0x.... 0x....      BL       BSP_OS_SemPost
    950              }
    951          }
   \                     ??BSP_I2Cx_ErrISR_Handler_4:
   \   0000005C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     BSP_I2C_DevTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     BSP_I2C_DevTbl+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     `?<Constant "I2C Wait">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     `?<Constant "I2C Lock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x02255101         DC32     0x2255101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x00061A81         DC32     0x61a81

   \                                 In section .rodata, align 4
   \                     `?<Constant "I2C Wait">`:
   \   00000000   0x49 0x32          DC8 "I2C Wait"
   \              0x43 0x20    
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "I2C Lock">`:
   \   00000000   0x49 0x32          DC8 "I2C Lock"
   \              0x43 0x20    
   \              0x4C 0x6F    
   \              0x63 0x6B    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_I2C1_ErrISR_Handler
         8   -> BSP_I2Cx_ErrISR_Handler
       8   BSP_I2C1_EventISR_Handler
         8   -> BSP_I2Cx_EventISR_Handler
       8   BSP_I2C2_ErrISR_Handler
         8   -> BSP_I2Cx_ErrISR_Handler
       8   BSP_I2C2_EventISR_Handler
         8   -> BSP_I2Cx_EventISR_Handler
      64   BSP_I2C_Init
        64   -> BSP_IntEn
        64   -> BSP_IntVectSet
        64   -> BSP_OS_SemCreate
        64   -> BSP_PeriphEn
        64   -> GPIO_Init
        64   -> RCC_GetClocksFreq
      32   BSP_I2C_Rd
        32   -> BSP_I2C_StartXfer
      40   BSP_I2C_StartXfer
        40   -> BSP_OS_SemPost
        40   -> BSP_OS_SemWait
      32   BSP_I2C_Wr
        32   -> BSP_I2C_StartXfer
      32   BSP_I2C_WrRd
        32   -> BSP_I2C_StartXfer
      24   BSP_I2Cx_ErrISR_Handler
        24   -> BSP_OS_SemPost
      24   BSP_I2Cx_EventISR_Handler
        24   -> BSP_OS_SemPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "I2C Lock">
      12  ?<Constant "I2C Wait">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      10  BSP_I2C1_ErrISR_Handler
      10  BSP_I2C1_EventISR_Handler
      10  BSP_I2C2_ErrISR_Handler
      10  BSP_I2C2_EventISR_Handler
      40  BSP_I2C_DevTbl
     500  BSP_I2C_Init
      62  BSP_I2C_Rd
     180  BSP_I2C_StartXfer
      62  BSP_I2C_Wr
      62  BSP_I2C_WrRd
      94  BSP_I2Cx_ErrISR_Handler
     494  BSP_I2Cx_EventISR_Handler

 
    40 bytes in section .bss
    24 bytes in section .rodata
 1 538 bytes in section .text
 
 1 538 bytes of CODE  memory
    24 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none

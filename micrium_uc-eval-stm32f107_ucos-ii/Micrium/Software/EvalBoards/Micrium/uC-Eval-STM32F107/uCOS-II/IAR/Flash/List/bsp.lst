###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:18 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp.c                                           #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\bsp.c" -D USE_STDPERIPH_DRIVER -lCN             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\" -o                         #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\bsp.lst                      #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\bsp.o                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                             (c) Copyright 2013; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        BOARD SUPPORT PACKAGE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              on the
     21          *
     22          *                                     Micrium uC-Eval-STM32F107
     23          *                                        Evaluation Board
     24          *
     25          * Filename      : bsp.c
     26          * Version       : V1.00
     27          * Programmer(s) : EHS
     28          *********************************************************************************************************
     29          */
     30          
     31          /*
     32          *********************************************************************************************************
     33          *                                             INCLUDE FILES
     34          *********************************************************************************************************
     35          */
     36          
     37          #define  BSP_MODULE
     38          #include <bsp.h>
     39          
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            LOCAL DEFINES
     44          *********************************************************************************************************
     45          */
     46          
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                           LOCAL CONSTANTS
     51          *********************************************************************************************************
     52          */
     53          
     54          #define  BSP_LED_START_BIT  (13 - 1)                            /* LEDs[3:1] are sequentially connected to PTD[15:13].  */
     55          
     56          
     57          /*
     58          *********************************************************************************************************
     59          *                                          LOCAL DATA TYPES
     60          *********************************************************************************************************
     61          */
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL TABLES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                       LOCAL GLOBAL VARIABLES
     74          *********************************************************************************************************
     75          */
     76          

   \                                 In section .bss, align 4
     77          CPU_INT32U  BSP_CPU_ClkFreq_MHz;
   \                     BSP_CPU_ClkFreq_MHz:
   \   00000000                      DS8 4
     78          
     79          
     80          /*
     81          *********************************************************************************************************
     82          *                                      LOCAL FUNCTION PROTOTYPES
     83          *********************************************************************************************************
     84          */
     85          
     86          static  void  BSP_LED_Init   (void);
     87          static  void  BSP_StatusInit (void);
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                             REGISTERS
     92          *********************************************************************************************************
     93          */
     94          
     95          #define  DWT_CR      *(CPU_REG32 *)0xE0001000
     96          #define  DWT_CYCCNT  *(CPU_REG32 *)0xE0001004
     97          #define  DEM_CR      *(CPU_REG32 *)0xE000EDFC
     98          #define  DBGMCU_CR   *(CPU_REG32 *)0xE0042004
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                            REGISTER BITS
    104          *********************************************************************************************************
    105          */
    106          
    107          #define  DBGMCU_CR_TRACE_IOEN_MASK       0x10
    108          #define  DBGMCU_CR_TRACE_MODE_ASYNC      0x00
    109          #define  DBGMCU_CR_TRACE_MODE_SYNC_01    0x40
    110          #define  DBGMCU_CR_TRACE_MODE_SYNC_02    0x80
    111          #define  DBGMCU_CR_TRACE_MODE_SYNC_04    0xC0
    112          #define  DBGMCU_CR_TRACE_MODE_MASK       0xC0
    113          
    114          #define  DEM_CR_TRCENA                   (1 << 24)
    115          
    116          #define  DWT_CR_CYCCNTENA                (1 <<  0)
    117          
    118          
    119          /*
    120          *********************************************************************************************************
    121          *                                     LOCAL CONFIGURATION ERRORS
    122          *********************************************************************************************************
    123          */
    124          /*
    125          #if ((CPU_CFG_TS_TMR_EN          != DEF_ENABLED) && \
    126               (APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    127               (OS_PROBE_HOOKS_EN          >  0u))
    128          #error  "CPU_CFG_TS_EN                  illegally #define'd in 'cpu.h'"
    129          #error  "                              [MUST be  DEF_ENABLED] when    "
    130          #error  "                               using uC/Probe COM modules    "
    131          #endif
    132          
    133          */
    134          /*
    135          *********************************************************************************************************
    136          *                                               BSP_Init()
    137          *
    138          * Description : Initialize the Board Support Package (BSP).
    139          *
    140          * Argument(s) : none.
    141          *
    142          * Return(s)   : none.
    143          *
    144          * Caller(s)   : Application.
    145          *
    146          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    147          *
    148          *               (2) CPU instruction / data tracing requires the use of the following pins :
    149          *                   (a) (1) Aysynchronous     :  PB[3]
    150          *                       (2) Synchronous 1-bit :  PE[3:2]
    151          *                       (3) Synchronous 2-bit :  PE[4:2]
    152          *                       (4) Synchronous 4-bit :  PE[6:2]
    153          *
    154          *                   (b) The uC-Eval board MAY utilize the following pins depending on the application :
    155          *                       (1) PE[5], MII_INT
    156          *                       (1) PE[6], SDCard_Detection
    157          *
    158          *                   (c) The application may wish to adjust the trace bus width depending on I/O
    159          *                       requirements.
    160          *********************************************************************************************************
    161          */
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void  BSP_Init (void)
    164          {
   \                     BSP_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    165              BSP_IntInit();
   \   00000002   0x.... 0x....      BL       BSP_IntInit
    166          
    167              RCC_DeInit();
   \   00000006   0x.... 0x....      BL       RCC_DeInit
    168              RCC_HSEConfig(RCC_HSE_ON);                                  /* HSE = 25MHz ext. crystal.                            */
   \   0000000A   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000000E   0x.... 0x....      BL       RCC_HSEConfig
    169              RCC_WaitForHSEStartUp();
   \   00000012   0x.... 0x....      BL       RCC_WaitForHSEStartUp
    170          
    171          
    172              RCC_PREDIV2Config(RCC_PREDIV2_Div5);                        /* Fprediv2 = HSE      /  5 =  5MHz.                    */
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x.... 0x....      BL       RCC_PREDIV2Config
    173              RCC_PLL2Config(RCC_PLL2Mul_8);                              /* PLL2     = Fprediv2 *  8 = 40MHz.                    */
   \   0000001C   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000020   0x.... 0x....      BL       RCC_PLL2Config
    174              RCC_PLL2Cmd(ENABLE);
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       RCC_PLL2Cmd
    175              RCC_PLL3Config(RCC_PLL3Mul_10);                             /* PLL3     = Fprediv2 * 10 = 50MHz.                    */
   \   0000002A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000002E   0x.... 0x....      BL       RCC_PLL3Config
    176              RCC_PLL3Cmd(ENABLE);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       RCC_PLL3Cmd
    177          
    178          
    179              RCC_HCLKConfig(RCC_SYSCLK_Div1);                            /* HCLK    = AHBCLK  = PLL1 / AHBPRES(1) = 72MHz.       */
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       RCC_HCLKConfig
    180              RCC_PCLK2Config(RCC_HCLK_Div1);                             /* APB2CLK = AHBCLK  / APB2DIV(1)  = 72MHz.             */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       RCC_PCLK2Config
    181              RCC_PCLK1Config(RCC_HCLK_Div2);                             /* APB1CLK = AHBCLK  / APB1DIV(2)  = 36MHz (max).       */
   \   00000044   0xF44F 0x6080      MOV      R0,#+1024
   \   00000048   0x.... 0x....      BL       RCC_PCLK1Config
    182              RCC_ADCCLKConfig(RCC_PCLK2_Div6);                           /* ADCCLK  = AHBCLK  / APB2DIV / 6 = 12MHz.             */
   \   0000004C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000050   0x.... 0x....      BL       RCC_ADCCLKConfig
    183              RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLL1VCO_Div3);        /* OTGCLK  = PLL1VCO / USBPRES(3)  = 144MHz / 3 = 48MHz */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       RCC_OTGFSCLKConfig
    184          
    185              FLASH_SetLatency(FLASH_Latency_2);                          /* 2 Flash wait states when HCLK > 48MHz.               */
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x.... 0x....      BL       FLASH_SetLatency
    186              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       FLASH_PrefetchBufferCmd
    187          
    188              while (RCC_GetFlagStatus(RCC_FLAG_PLL2RDY) == RESET) {      /* Wait for PLL2 to lock.                               */
   \                     ??BSP_Init_0:
   \   00000066   0x203B             MOVS     R0,#+59
   \   00000068   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD0FA             BEQ.N    ??BSP_Init_0
    189                  ;
    190              }
    191          
    192              while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {      /* Wait for PLL3 to lock.                               */
   \                     ??BSP_Init_1:
   \   00000070   0x203D             MOVS     R0,#+61
   \   00000072   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD0FA             BEQ.N    ??BSP_Init_1
    193                  ;
    194              }
    195          
    196                                                                          /* Fprediv1 = PLL2 / 5 =  8MHz.                         */
    197              RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
   \   0000007A   0x2104             MOVS     R1,#+4
   \   0000007C   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000080   0x.... 0x....      BL       RCC_PREDIV1Config
    198              RCC_PLL1Config(RCC_PLL1Source_PREDIV1, RCC_PLL1Mul_9);      /* PLL1 = Fprediv1 * 9 = 72Mhz.                         */
   \   00000084   0xF45F 0x11E0      MOVS     R1,#+1835008
   \   00000088   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000008C   0x.... 0x....      BL       RCC_PLL1Config
    199              RCC_PLL1Cmd(ENABLE);
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x.... 0x....      BL       RCC_PLL1Cmd
    200              while (RCC_GetFlagStatus(RCC_FLAG_PLL1RDY) == RESET) {      /* Wait for PLL1 to lock.                               */
   \                     ??BSP_Init_2:
   \   00000096   0x2039             MOVS     R0,#+57
   \   00000098   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD0FA             BEQ.N    ??BSP_Init_2
    201                  ;
    202              }
    203          
    204          
    205              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLL1CLK);                 /* HCLK = SYSCLK = PLL1 = 72MHz.                        */
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x.... 0x....      BL       RCC_SYSCLKConfig
    206              while (RCC_GetSYSCLKSource() != 0x08) {
   \                     ??BSP_Init_3:
   \   000000A6   0x.... 0x....      BL       RCC_GetSYSCLKSource
   \   000000AA   0x2808             CMP      R0,#+8
   \   000000AC   0xD1FB             BNE.N    ??BSP_Init_3
    207                  ;
    208              }
    209          
    210              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq() / (CPU_INT32U)1000000;
   \   000000AE   0x.... 0x....      BL       BSP_CPU_ClkFreq
   \   000000B2   0x....             LDR.N    R1,??DataTable6  ;; 0xf4240
   \   000000B4   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B8   0x....             LDR.N    R1,??DataTable6_1
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    211          
    212              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq_MHz;                  /* Surpress compiler warning BSP_CPU_ClkFreq_MHz    ... */
   \   000000BC   0x....             LDR.N    R0,??DataTable6_1
   \   000000BE   0x....             LDR.N    R1,??DataTable6_1
   \   000000C0   0x6809             LDR      R1,[R1, #+0]
   \   000000C2   0x6001             STR      R1,[R0, #+0]
    213                                                                          /* ... set and not used.                                */
    214          
    215              BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
   \   000000C4   0x.... 0x....      BL       BSP_LED_Init
    216          
    217              BSP_StatusInit();                                           /* Initialize the status input(s)                       */
   \   000000C8   0x.... 0x....      BL       BSP_StatusInit
    218          
    219          #ifdef TRACE_EN                                                 /* See project / compiler preprocessor options.         */
    220              DBGMCU_CR |=  DBGMCU_CR_TRACE_IOEN_MASK;                    /* Enable tracing (see Note #2).                        */
    221              DBGMCU_CR &= ~DBGMCU_CR_TRACE_MODE_MASK;                    /* Clr trace mode sel bits.                             */
    222              DBGMCU_CR |=  DBGMCU_CR_TRACE_MODE_SYNC_04;                 /* Cfg trace mode to synch 4-bit.                       */
    223          #endif
    224          }
   \   000000CC   0xBD01             POP      {R0,PC}          ;; return
    225          
    226          
    227          /*
    228          *********************************************************************************************************
    229          *                                            BSP_CPU_ClkFreq()
    230          *
    231          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    232          *
    233          * Argument(s) : none.
    234          *
    235          * Return(s)   : The CPU clock frequency, in Hz.
    236          *
    237          * Caller(s)   : Application.
    238          *
    239          * Note(s)     : none.
    240          *********************************************************************************************************
    241          */
    242          

   \                                 In section .text, align 2, keep-with-next
    243          CPU_INT32U  BSP_CPU_ClkFreq (void)
    244          {
   \                     BSP_CPU_ClkFreq:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    245              RCC_ClocksTypeDef  rcc_clocks;
    246          
    247          
    248              RCC_GetClocksFreq(&rcc_clocks);
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      BL       RCC_GetClocksFreq
    249          
    250              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xB005             ADD      SP,SP,#+20
   \   0000000E   0xBD00             POP      {PC}             ;; return
    251          }
    252          
    253          
    254          /*
    255          *********************************************************************************************************
    256          *********************************************************************************************************
    257          *                                              LED FUNCTIONS
    258          *********************************************************************************************************
    259          *********************************************************************************************************
    260          */
    261          
    262          /*
    263          *********************************************************************************************************
    264          *                                             BSP_LED_Init()
    265          *
    266          * Description : Initialize the I/O for the LEDs
    267          *
    268          * Argument(s) : none.
    269          *
    270          * Return(s)   : none.
    271          *
    272          * Caller(s)   : BSP_Init().
    273          *
    274          * Note(s)     : none.
    275          *********************************************************************************************************
    276          */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static  void  BSP_LED_Init (void)
    279          {
   \                     BSP_LED_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    280              GPIO_InitTypeDef  gpio_init;
    281          
    282          
    283              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    284          
    285              gpio_init.GPIO_Pin   = BSP_GPIOD_LEDS;
   \   0000000A   0xF44F 0x4060      MOV      R0,#+57344
   \   0000000E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    286              gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
    287              gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
   \   00000018   0x2010             MOVS     R0,#+16
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    288          
    289              GPIO_Init(GPIOD, &gpio_init);
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000022   0x.... 0x....      BL       GPIO_Init
    290          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    291          
    292          
    293          /*
    294          *********************************************************************************************************
    295          *                                             BSP_LED_On()
    296          *
    297          * Description : Turn ON any or all the LEDs on the board.
    298          *
    299          * Argument(s) : led     The ID of the LED to control:
    300          *
    301          *                       0    turns ON ALL the LEDs
    302          *                       1    turns ON user LED1  on the board
    303          *                       2    turns ON user LED2  on the board
    304          *                       3    turns ON user LED3  on the board
    305          *
    306          * Return(s)   : none.
    307          *
    308          * Caller(s)   : Application.
    309          *
    310          * Note(s)     : none.
    311          *********************************************************************************************************
    312          */
    313          

   \                                 In section .text, align 2, keep-with-next
    314          void  BSP_LED_On (CPU_INT08U led)
    315          {
   \                     BSP_LED_On:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    316              switch (led) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD005             BEQ.N    ??BSP_LED_On_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00F             BEQ.N    ??BSP_LED_On_1
   \   0000000E   0xD308             BCC.N    ??BSP_LED_On_2
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD012             BEQ.N    ??BSP_LED_On_3
   \   00000014   0xE017             B.N      ??BSP_LED_On_4
    317                  case 0:
    318                       GPIO_SetBits(GPIOD, BSP_GPIOD_LEDS);
   \                     ??BSP_LED_On_0:
   \   00000016   0xF44F 0x4160      MOV      R1,#+57344
   \   0000001A   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   0000001C   0x.... 0x....      BL       GPIO_SetBits
    319                       break;
   \   00000020   0xE011             B.N      ??BSP_LED_On_5
    320          
    321                  case 1:
    322                       GPIO_SetBits(GPIOD, BSP_GPIOD_LED1);
   \                     ??BSP_LED_On_2:
   \   00000022   0xF44F 0x5100      MOV      R1,#+8192
   \   00000026   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_SetBits
    323                       break;
   \   0000002C   0xE00B             B.N      ??BSP_LED_On_5
    324          
    325                  case 2:
    326                       GPIO_SetBits(GPIOD, BSP_GPIOD_LED2);
   \                     ??BSP_LED_On_1:
   \   0000002E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000032   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000034   0x.... 0x....      BL       GPIO_SetBits
    327                       break;
   \   00000038   0xE005             B.N      ??BSP_LED_On_5
    328          
    329                  case 3:
    330                       GPIO_SetBits(GPIOD, BSP_GPIOD_LED3);
   \                     ??BSP_LED_On_3:
   \   0000003A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003E   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000040   0x.... 0x....      BL       GPIO_SetBits
    331                       break;
   \   00000044   0xE7FF             B.N      ??BSP_LED_On_5
    332          
    333                  default:
    334                       break;
    335              }
    336          }
   \                     ??BSP_LED_On_4:
   \                     ??BSP_LED_On_5:
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    337          
    338          
    339          /*
    340          *********************************************************************************************************
    341          *                                              BSP_LED_Off()
    342          *
    343          * Description : Turn OFF any or all the LEDs on the board.
    344          *
    345          * Argument(s) : led     The ID of the LED to control:
    346          *
    347          *                       0    turns OFF ALL the LEDs
    348          *                       1    turns OFF user LED1  on the board
    349          *                       2    turns OFF user LED2  on the board
    350          *                       3    turns OFF user LED3  on the board
    351          *
    352          * Return(s)   : none.
    353          *
    354          * Caller(s)   : Application.
    355          *
    356          * Note(s)     : none.
    357          *********************************************************************************************************
    358          */
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void  BSP_LED_Off (CPU_INT08U led)
    361          {
   \                     BSP_LED_Off:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    362              switch (led) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD005             BEQ.N    ??BSP_LED_Off_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00F             BEQ.N    ??BSP_LED_Off_1
   \   0000000E   0xD308             BCC.N    ??BSP_LED_Off_2
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD012             BEQ.N    ??BSP_LED_Off_3
   \   00000014   0xE017             B.N      ??BSP_LED_Off_4
    363                  case 0:
    364                       GPIO_ResetBits(GPIOD, BSP_GPIOD_LEDS);
   \                     ??BSP_LED_Off_0:
   \   00000016   0xF44F 0x4160      MOV      R1,#+57344
   \   0000001A   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   0000001C   0x.... 0x....      BL       GPIO_ResetBits
    365                       break;
   \   00000020   0xE011             B.N      ??BSP_LED_Off_5
    366          
    367                  case 1:
    368                       GPIO_ResetBits(GPIOD, BSP_GPIOD_LED1);
   \                     ??BSP_LED_Off_2:
   \   00000022   0xF44F 0x5100      MOV      R1,#+8192
   \   00000026   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    369                       break;
   \   0000002C   0xE00B             B.N      ??BSP_LED_Off_5
    370          
    371                  case 2:
    372                       GPIO_ResetBits(GPIOD, BSP_GPIOD_LED2);
   \                     ??BSP_LED_Off_1:
   \   0000002E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000032   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000034   0x.... 0x....      BL       GPIO_ResetBits
    373                       break;
   \   00000038   0xE005             B.N      ??BSP_LED_Off_5
    374          
    375                  case 3:
    376                       GPIO_ResetBits(GPIOD, BSP_GPIOD_LED3);
   \                     ??BSP_LED_Off_3:
   \   0000003A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003E   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000040   0x.... 0x....      BL       GPIO_ResetBits
    377                       break;
   \   00000044   0xE7FF             B.N      ??BSP_LED_Off_5
    378          
    379                  default:
    380                       break;
    381              }
    382          }
   \                     ??BSP_LED_Off_4:
   \                     ??BSP_LED_Off_5:
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    383          
    384          
    385          /*
    386          *********************************************************************************************************
    387          *                                            BSP_LED_Toggle()
    388          *
    389          * Description : TOGGLE any or all the LEDs on the board.
    390          *
    391          * Argument(s) : led     The ID of the LED to control:
    392          *
    393          *                       0    TOGGLE ALL the LEDs
    394          *                       1    TOGGLE user LED1  on the board
    395          *                       2    TOGGLE user LED2  on the board
    396          *                       3    TOGGLE user LED3  on the board
    397          *
    398          * Return(s)   : none.
    399          *
    400          * Caller(s)   : Application.
    401          *
    402          * Note(s)     : none.
    403          *********************************************************************************************************
    404          */
    405          

   \                                 In section .text, align 2, keep-with-next
    406          void  BSP_LED_Toggle (CPU_INT08U led)
    407          {
   \                     BSP_LED_Toggle:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408              CPU_INT32U  pins;
    409          
    410          
    411              switch (led) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??BSP_LED_Toggle_0
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD912             BLS.N    ??BSP_LED_Toggle_1
   \   00000012   0xE02F             B.N      ??BSP_LED_Toggle_2
    412                  case 0:
    413                       pins =  GPIO_ReadOutputData(GPIOD);
   \                     ??BSP_LED_Toggle_0:
   \   00000014   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ReadOutputData
   \   0000001A   0x0005             MOVS     R5,R0
    414                       pins ^= BSP_GPIOD_LEDS;
   \   0000001C   0xF495 0x4560      EORS     R5,R5,#0xE000
    415                       GPIO_SetBits(  GPIOD,   pins  & BSP_GPIOD_LEDS);
   \   00000020   0xF415 0x4160      ANDS     R1,R5,#0xE000
   \   00000024   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000026   0x.... 0x....      BL       GPIO_SetBits
    416                       GPIO_ResetBits(GPIOD, (~pins) & BSP_GPIOD_LEDS);
   \   0000002A   0x43E8             MVNS     R0,R5
   \   0000002C   0xF410 0x4160      ANDS     R1,R0,#0xE000
   \   00000030   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    417                       break;
   \   00000036   0xE01D             B.N      ??BSP_LED_Toggle_3
    418          
    419                  case 1:
    420                  case 2:
    421                  case 3:
    422                      pins = GPIO_ReadOutputData(GPIOD);
   \                     ??BSP_LED_Toggle_1:
   \   00000038   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   0000003A   0x.... 0x....      BL       GPIO_ReadOutputData
   \   0000003E   0x0005             MOVS     R5,R0
    423                      if ((pins & (1 << (led + BSP_LED_START_BIT))) == 0) {
   \   00000040   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000044   0xFA35 0xF000      LSRS     R0,R5,R0
   \   00000048   0x07C0             LSLS     R0,R0,#+31
   \   0000004A   0xD409             BMI.N    ??BSP_LED_Toggle_4
    424                           GPIO_SetBits(  GPIOD, (1 << (led + BSP_LED_START_BIT)));
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF114 0x010C      ADDS     R1,R4,#+12
   \   00000052   0xFA10 0xF101      LSLS     R1,R0,R1
   \   00000056   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000058   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   0000005A   0x.... 0x....      BL       GPIO_SetBits
   \   0000005E   0xE008             B.N      ??BSP_LED_Toggle_5
    425                       } else {
    426                           GPIO_ResetBits(GPIOD, (1 << (led + BSP_LED_START_BIT)));
   \                     ??BSP_LED_Toggle_4:
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF114 0x010C      ADDS     R1,R4,#+12
   \   00000066   0xFA10 0xF101      LSLS     R1,R0,R1
   \   0000006A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000006C   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40011400
   \   0000006E   0x.... 0x....      BL       GPIO_ResetBits
    427                       }
    428                      break;
   \                     ??BSP_LED_Toggle_5:
   \   00000072   0xE7FF             B.N      ??BSP_LED_Toggle_3
    429          
    430                  default:
    431                       break;
    432              }
    433          }
   \                     ??BSP_LED_Toggle_2:
   \                     ??BSP_LED_Toggle_3:
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    434          
    435          
    436          /*
    437          *********************************************************************************************************
    438          *                                            BSP_StatusInit()
    439          *
    440          * Description : Initialize the status port(s)
    441          *
    442          * Argument(s) : none.
    443          *
    444          * Return(s)   : none.
    445          *
    446          * Caller(s)   : BSP_Init()
    447          *
    448          * Note(s)     : none.
    449          *********************************************************************************************************
    450          */
    451          

   \                                 In section .text, align 2, keep-with-next
    452          static  void  BSP_StatusInit (void)
    453          {
   \                     BSP_StatusInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    454              GPIO_InitTypeDef  GPIO_InitStructure;
    455          
    456          
    457              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;             /* PB5 is used to read the status of the LM75 */
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    458              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    459              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    460              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40010c00
   \   00000018   0x.... 0x....      BL       GPIO_Init
    461          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    462          
    463          
    464          /*
    465          *********************************************************************************************************
    466          *                                            BSP_StatusRd()
    467          *
    468          * Description : Get the current status of a status input
    469          *
    470          * Argument(s) : id    is the status you want to get.
    471          *
    472          * Return(s)   : DEF_ON    if the status is asserted
    473          *               DEF_OFF   if the status is negated
    474          *
    475          * Caller(s)   : application
    476          *
    477          * Note(s)     : none.
    478          *********************************************************************************************************
    479          */
    480          

   \                                 In section .text, align 2, keep-with-next
    481          CPU_BOOLEAN  BSP_StatusRd (CPU_INT08U  id)
    482          {
   \                     BSP_StatusRd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    483              CPU_BOOLEAN  bit_val;
    484          
    485          
    486              switch (id) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD107             BNE.N    ??BSP_StatusRd_0
    487                  case 1:
    488                       bit_val = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_5);
   \   0000000A   0x2120             MOVS     R1,#+32
   \   0000000C   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40010c00
   \   0000000E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000012   0x0005             MOVS     R5,R0
    489                       return (bit_val);
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xE000             B.N      ??BSP_StatusRd_1
    490          
    491                  default:
    492                       return ((CPU_BOOLEAN)DEF_OFF);
   \                     ??BSP_StatusRd_0:
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??BSP_StatusRd_1:
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    493              }
    494          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     BSP_CPU_ClkFreq_MHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40010C00         DC32     0x40010c00
    495          
    496          
    497          /*
    498          *********************************************************************************************************
    499          *********************************************************************************************************
    500          *                                           OS PROBE FUNCTIONS
    501          *********************************************************************************************************
    502          *********************************************************************************************************
    503          */
    504          
    505          /*
    506          *********************************************************************************************************
    507          *                                           OSProbe_TmrInit()
    508          *
    509          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
    510          *
    511          * Argument(s) : none.
    512          *
    513          * Return(s)   : none.
    514          *
    515          * Caller(s)   : OSProbe_Init().
    516          *
    517          * Note(s)     : none.
    518          *********************************************************************************************************
    519          */
    520          
    521          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    522               (OS_PROBE_HOOKS_EN          == 1))
    523          void  OSProbe_TmrInit (void)
    524          {
    525          }
    526          #endif
    527          
    528          
    529          /*
    530          *********************************************************************************************************
    531          *                                            OSProbe_TmrRd()
    532          *
    533          * Description : Read the current counts of a free running timer.
    534          *
    535          * Argument(s) : none.
    536          *
    537          * Return(s)   : The 32-bit timer counts.
    538          *
    539          * Caller(s)   : OSProbe_TimeGetCycles().
    540          *
    541          * Note(s)     : none.
    542          *********************************************************************************************************
    543          */
    544          
    545          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    546               (OS_PROBE_HOOKS_EN          == 1))
    547          CPU_INT32U  OSProbe_TmrRd (void)
    548          {
    549              return ((CPU_INT32U)DWT_CYCCNT);
    550          }
    551          #endif
    552          
    553          
    554          /*$PAGE*/
    555          /*
    556          *********************************************************************************************************
    557          *                                          CPU_TS_TmrInit()
    558          *
    559          * Description : Initialize & start CPU timestamp timer.
    560          *
    561          * Argument(s) : none.
    562          *
    563          * Return(s)   : none.
    564          *
    565          * Caller(s)   : CPU_TS_Init().
    566          *
    567          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    568          *               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
    569          *
    570          * Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer
    571          *                   if either of the following CPU features is enabled :
    572          *
    573          *                   (a) CPU timestamps
    574          *                   (b) CPU interrupts disabled time measurements
    575          *
    576          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    577          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    578          *
    579          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    580          *                       data type.
    581          *
    582          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    583          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    584          *
    585          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    586          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    587          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    588          *
    589          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    590          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    591          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    592          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    593          *
    594          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    595          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    596          *
    597          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    598          *
    599          *                   (c) When applicable, timer period SHOULD be less than the typical measured time
    600          *                       but MUST be less than the maximum measured time; otherwise, timer resolution
    601          *                       inadequate to measure desired times.
    602          *
    603          *                   See also 'CPU_TS_TmrRd()  Note #2'.
    604          *********************************************************************************************************
    605          */
    606          
    607          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    608          void  CPU_TS_TmrInit (void)
    609          {
    610              CPU_INT32U  cpu_clk_freq_hz;
    611          
    612          
    613              DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    614              DWT_CYCCNT      = (CPU_INT32U)0u;
    615              DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
    616          
    617              cpu_clk_freq_hz = BSP_CPU_ClkFreq();
    618              CPU_TS_TmrFreqSet(cpu_clk_freq_hz);
    619          }
    620          #endif
    621          
    622          
    623          /*$PAGE*/
    624          /*
    625          *********************************************************************************************************
    626          *                                           CPU_TS_TmrRd()
    627          *
    628          * Description : Get current CPU timestamp timer count value.
    629          *
    630          * Argument(s) : none.
    631          *
    632          * Return(s)   : Timestamp timer count (see Notes #2a & #2b).
    633          *
    634          * Caller(s)   : CPU_TS_Init(),
    635          *               CPU_TS_Get32(),
    636          *               CPU_TS_Get64(),
    637          *               CPU_IntDisMeasStart(),
    638          *               CPU_IntDisMeasStop().
    639          *
    640          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    641          *               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
    642          *
    643          * Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer
    644          *                   if either of the following CPU features is enabled :
    645          *
    646          *                   (a) CPU timestamps
    647          *                   (b) CPU interrupts disabled time measurements
    648          *
    649          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    650          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    651          *
    652          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    653          *                       data type.
    654          *
    655          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    656          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    657          *
    658          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    659          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    660          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    661          *
    662          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    663          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    664          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    665          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    666          *
    667          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    668          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    669          *
    670          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    671          *
    672          *                       (1) If timer is a 'down' counter whose values decrease with each time count,
    673          *                           then the returned timer value MUST be ones-complemented.
    674          *
    675          *                   (c) (1) When applicable, the amount of time measured by CPU timestamps is
    676          *                           calculated by either of the following equations :
    677          *
    678          *                           (A) Time measured  =  Number timer counts  *  Timer period
    679          *
    680          *                                   where
    681          *
    682          *                                       Number timer counts     Number of timer counts measured
    683          *                                       Timer period            Timer's period in some units of
    684          *                                                                   (fractional) seconds
    685          *                                       Time measured           Amount of time measured, in same
    686          *                                                                   units of (fractional) seconds
    687          *                                                                   as the Timer period
    688          *
    689          *                                                  Number timer counts
    690          *                           (B) Time measured  =  ---------------------
    691          *                                                    Timer frequency
    692          *
    693          *                                   where
    694          *
    695          *                                       Number timer counts     Number of timer counts measured
    696          *                                       Timer frequency         Timer's frequency in some units
    697          *                                                                   of counts per second
    698          *                                       Time measured           Amount of time measured, in seconds
    699          *
    700          *                       (2) Timer period SHOULD be less than the typical measured time but MUST be less
    701          *                           than the maximum measured time; otherwise, timer resolution inadequate to
    702          *                           measure desired times.
    703          *********************************************************************************************************
    704          */
    705          
    706          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    707          CPU_TS_TMR  CPU_TS_TmrRd (void)
    708          {
    709              return ((CPU_TS_TMR)DWT_CYCCNT);
    710          }
    711          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   BSP_CPU_ClkFreq
        24   -> RCC_GetClocksFreq
       8   BSP_Init
         8   -> BSP_CPU_ClkFreq
         8   -> BSP_IntInit
         8   -> BSP_LED_Init
         8   -> BSP_StatusInit
         8   -> FLASH_PrefetchBufferCmd
         8   -> FLASH_SetLatency
         8   -> RCC_ADCCLKConfig
         8   -> RCC_DeInit
         8   -> RCC_GetFlagStatus
         8   -> RCC_GetSYSCLKSource
         8   -> RCC_HCLKConfig
         8   -> RCC_HSEConfig
         8   -> RCC_OTGFSCLKConfig
         8   -> RCC_PCLK1Config
         8   -> RCC_PCLK2Config
         8   -> RCC_PLL1Cmd
         8   -> RCC_PLL1Config
         8   -> RCC_PLL2Cmd
         8   -> RCC_PLL2Config
         8   -> RCC_PLL3Cmd
         8   -> RCC_PLL3Config
         8   -> RCC_PREDIV1Config
         8   -> RCC_PREDIV2Config
         8   -> RCC_SYSCLKConfig
         8   -> RCC_WaitForHSEStartUp
       8   BSP_LED_Init
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
       8   BSP_LED_Off
         8   -> GPIO_ResetBits
       8   BSP_LED_On
         8   -> GPIO_SetBits
      16   BSP_LED_Toggle
        16   -> GPIO_ReadOutputData
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       8   BSP_StatusInit
         8   -> GPIO_Init
      16   BSP_StatusRd
        16   -> GPIO_ReadInputDataBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      16  BSP_CPU_ClkFreq
       4  BSP_CPU_ClkFreq_MHz
     206  BSP_Init
      40  BSP_LED_Init
      72  BSP_LED_Off
      72  BSP_LED_On
     118  BSP_LED_Toggle
      30  BSP_StatusInit
      30  BSP_StatusRd

 
   4 bytes in section .bss
 600 bytes in section .text
 
 600 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none

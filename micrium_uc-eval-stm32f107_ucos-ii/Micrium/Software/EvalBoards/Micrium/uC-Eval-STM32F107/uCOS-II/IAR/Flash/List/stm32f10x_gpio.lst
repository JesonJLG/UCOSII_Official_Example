###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:23 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_gpio.c                   #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_gpio.c" -D               #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_gpio.lst           #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_gpio.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_gpio.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_gpio.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the GPIO firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_gpio.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ------------ RCC registers bit address in the alias region ----------- */
     23          #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
     24          
     25          /* --- EVENTCR Register ---*/
     26          /* Alias word address of EVOE bit */
     27          #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
     28          #define EVOE_BitNumber              ((u8)0x07)
     29          #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
     30          
     31          /* ---  MAPR Register ---*/ 
     32          /* Alias word address of MII_RMII_SEL bit */ 
     33          #define MAPR_OFFSET                 (AFIO_OFFSET + 0x04) 
     34          #define MII_RMII_SEL_BitNumber      ((u8)0x17) 
     35          #define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4)) 
     36          
     37          #define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
     38          #define LSB_MASK                    ((u16)0xFFFF)
     39          #define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
     40          #define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
     41          #define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
     42          #define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
     43          
     44          /* Private macro -------------------------------------------------------------*/
     45          /* Private variables ---------------------------------------------------------*/
     46          /* Private function prototypes -----------------------------------------------*/
     47          /* Private functions ---------------------------------------------------------*/
     48          
     49          /*******************************************************************************
     50          * Function Name  : GPIO_DeInit
     51          * Description    : Deinitializes the GPIOx peripheral registers to their default
     52          *                  reset values.
     53          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
     54          * Output         : None
     55          * Return         : None
     56          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     57          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     58          {
   \                     GPIO_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     59            /* Check the parameters */
     60            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
     61            
     62            switch (*(u32*)&GPIOx)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x40010800
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD016             BEQ.N    ??GPIO_DeInit_0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40010c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD01B             BEQ.N    ??GPIO_DeInit_1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x40011000
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD020             BEQ.N    ??GPIO_DeInit_2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable5_3  ;; 0x40011400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD025             BEQ.N    ??GPIO_DeInit_3
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable5_4  ;; 0x40011800
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD02A             BEQ.N    ??GPIO_DeInit_4
   \   0000002E   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40011c00
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD030             BEQ.N    ??GPIO_DeInit_5
   \   00000034   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40012000
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD036             BEQ.N    ??GPIO_DeInit_6
   \   0000003A   0xE040             B.N      ??GPIO_DeInit_7
     63            {
     64              case GPIOA_BASE:
     65                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \                     ??GPIO_DeInit_0:
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     66                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     67                break;
   \   0000004C   0xE037             B.N      ??GPIO_DeInit_8
     68          
     69              case GPIOB_BASE:
     70                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \                     ??GPIO_DeInit_1:
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2008             MOVS     R0,#+8
   \   00000052   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     71                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x2008             MOVS     R0,#+8
   \   0000005A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     72                break;
   \   0000005E   0xE02E             B.N      ??GPIO_DeInit_8
     73          
     74              case GPIOC_BASE:
     75                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \                     ??GPIO_DeInit_2:
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     76                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x2010             MOVS     R0,#+16
   \   0000006C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     77                break;
   \   00000070   0xE025             B.N      ??GPIO_DeInit_8
     78          
     79              case GPIOD_BASE:
     80                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \                     ??GPIO_DeInit_3:
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x2020             MOVS     R0,#+32
   \   00000076   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     81                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x2020             MOVS     R0,#+32
   \   0000007E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     82                break;
   \   00000082   0xE01C             B.N      ??GPIO_DeInit_8
     83                
     84              case GPIOE_BASE:
     85                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
   \                     ??GPIO_DeInit_4:
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x2040             MOVS     R0,#+64
   \   00000088   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     86                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2040             MOVS     R0,#+64
   \   00000090   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     87                break; 
   \   00000094   0xE013             B.N      ??GPIO_DeInit_8
     88          
     89              case GPIOF_BASE:
     90                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
   \                     ??GPIO_DeInit_5:
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x2080             MOVS     R0,#+128
   \   0000009A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     91                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x2080             MOVS     R0,#+128
   \   000000A2   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     92                break;
   \   000000A6   0xE00A             B.N      ??GPIO_DeInit_8
     93          
     94              case GPIOG_BASE:
     95                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
   \                     ??GPIO_DeInit_6:
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0xF44F 0x7080      MOV      R0,#+256
   \   000000AE   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     96                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0xF44F 0x7080      MOV      R0,#+256
   \   000000B8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     97                break;                       
   \   000000BC   0xE7FF             B.N      ??GPIO_DeInit_8
     98          
     99              default:
    100                break;
    101            }
    102          }
   \                     ??GPIO_DeInit_7:
   \                     ??GPIO_DeInit_8:
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
    103          
    104          /*******************************************************************************
    105          * Function Name  : GPIO_AFIODeInit
    106          * Description    : Deinitializes the Alternate Functions (remap, event control
    107          *                  and EXTI configuration) registers to their default reset
    108          *                  values.
    109          * Input          : None
    110          * Output         : None
    111          * Return         : None
    112          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    113          void GPIO_AFIODeInit(void)
    114          {
   \                     GPIO_AFIODeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    115            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    116            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    117          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    118          
    119          /*******************************************************************************
    120          * Function Name  : GPIO_Init
    121          * Description    : Initializes the GPIOx peripheral according to the specified
    122          *                  parameters in the GPIO_InitStruct.
    123          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    124          *                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
    125          *                    contains the configuration information for the specified GPIO
    126          *                    peripheral.
    127          * Output         : None
    128          * Return         : None
    129          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    130          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    131          {
   \                     GPIO_Init:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    132            u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
   \   00000002   0x2700             MOVS     R7,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
    133            u32 tmpreg = 0x00, pinmask = 0x00;
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x2600             MOVS     R6,#+0
    134          
    135            /* Check the parameters */
    136            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    137            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    138            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
    139            
    140          /*---------------------------- GPIO Mode Configuration -----------------------*/
    141            currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
   \   0000000E   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   00000012   0xF01C 0x0C0F      ANDS     R12,R12,#0xF
   \   00000016   0x4667             MOV      R7,R12
    142          
    143            if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
   \   00000018   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   0000001C   0xEA5F 0x6CCC      LSLS     R12,R12,#+27
   \   00000020   0xD503             BPL.N    ??GPIO_Init_0
    144            { 
    145              /* Check the parameters */
    146              assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    147              /* Output mode */
    148              currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
   \   00000022   0xF891 0xC002      LDRB     R12,[R1, #+2]
   \   00000026   0xEA5C 0x0707      ORRS     R7,R12,R7
    149            }
    150          
    151          /*---------------------------- GPIO CRL Configuration ------------------------*/
    152            /* Configure the eight low port pins */
    153            if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
   \                     ??GPIO_Init_0:
   \   0000002A   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   0000002E   0xEA5F 0x6C0C      LSLS     R12,R12,#+24
   \   00000032   0xD03A             BEQ.N    ??GPIO_Init_1
    154            {
    155              tmpreg = GPIOx->CRL;
   \   00000034   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \   00000038   0x4665             MOV      R5,R12
    156          
    157              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000003A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000003E   0x4663             MOV      R3,R12
   \                     ??GPIO_Init_2:
   \   00000040   0x2B08             CMP      R3,#+8
   \   00000042   0xD231             BCS.N    ??GPIO_Init_3
    158              {
    159                pos = ((u32)0x01) << pinpos;
   \   00000044   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000048   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \   0000004C   0x4664             MOV      R4,R12
    160                /* Get the port pins position */
    161                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
   \   0000004E   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \   00000052   0xEA14 0x0C0C      ANDS     R12,R4,R12
   \   00000056   0x4662             MOV      R2,R12
    162          
    163                if (currentpin == pos)
   \   00000058   0x42A2             CMP      R2,R4
   \   0000005A   0xD123             BNE.N    ??GPIO_Init_4
    164                {
    165                  pos = pinpos << 2;
   \   0000005C   0xEA5F 0x0C83      LSLS     R12,R3,#+2
   \   00000060   0x4664             MOV      R4,R12
    166                  /* Clear the corresponding low control register bits */
    167                  pinmask = ((u32)0x0F) << pos;
   \   00000062   0xF05F 0x0C0F      MOVS     R12,#+15
   \   00000066   0xFA1C 0xFC04      LSLS     R12,R12,R4
   \   0000006A   0x4666             MOV      R6,R12
    168                  tmpreg &= ~pinmask;
   \   0000006C   0x43B5             BICS     R5,R5,R6
    169          
    170                  /* Write the mode configuration in the corresponding bits */
    171                  tmpreg |= (currentmode << pos);
   \   0000006E   0xFA17 0xFC04      LSLS     R12,R7,R4
   \   00000072   0xEA5C 0x0505      ORRS     R5,R12,R5
    172          
    173                  /* Reset the corresponding ODR bit */
    174                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   00000076   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   0000007A   0xF1BC 0x0F28      CMP      R12,#+40
   \   0000007E   0xD106             BNE.N    ??GPIO_Init_5
    175                  {
    176                    GPIOx->BRR = (((u32)0x01) << pinpos);
   \   00000080   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000084   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \   00000088   0xF8C0 0xC014      STR      R12,[R0, #+20]
   \   0000008C   0xE00A             B.N      ??GPIO_Init_4
    177                  }
    178                  else
    179                  {
    180                    /* Set the corresponding ODR bit */
    181                    if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_5:
   \   0000008E   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   00000092   0xF1BC 0x0F48      CMP      R12,#+72
   \   00000096   0xD105             BNE.N    ??GPIO_Init_4
    182                    {
    183                      GPIOx->BSRR = (((u32)0x01) << pinpos);
   \   00000098   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000009C   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \   000000A0   0xF8C0 0xC010      STR      R12,[R0, #+16]
    184                    }
    185                  }
    186                }
    187              }
   \                     ??GPIO_Init_4:
   \   000000A4   0x1C5B             ADDS     R3,R3,#+1
   \   000000A6   0xE7CB             B.N      ??GPIO_Init_2
    188              GPIOx->CRL = tmpreg;
   \                     ??GPIO_Init_3:
   \   000000A8   0x6005             STR      R5,[R0, #+0]
    189            }
    190          
    191          /*---------------------------- GPIO CRH Configuration ------------------------*/
    192            /* Configure the eight high port pins */
    193            if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
   \                     ??GPIO_Init_1:
   \   000000AA   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \   000000AE   0xF1BC 0x0FFF      CMP      R12,#+255
   \   000000B2   0xDD3F             BLE.N    ??GPIO_Init_6
    194            {
    195              tmpreg = GPIOx->CRH;
   \   000000B4   0xF8D0 0xC004      LDR      R12,[R0, #+4]
   \   000000B8   0x4665             MOV      R5,R12
    196              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   000000BA   0xF05F 0x0C00      MOVS     R12,#+0
   \   000000BE   0x4663             MOV      R3,R12
   \                     ??GPIO_Init_7:
   \   000000C0   0x2B08             CMP      R3,#+8
   \   000000C2   0xD236             BCS.N    ??GPIO_Init_8
    197              {
    198                pos = (((u32)0x01) << (pinpos + 0x08));
   \   000000C4   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000C8   0xF113 0x0E08      ADDS     LR,R3,#+8
   \   000000CC   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   000000D0   0x4664             MOV      R4,R12
    199                /* Get the port pins position */
    200                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
   \   000000D2   0xF8B1 0xC000      LDRH     R12,[R1, #+0]
   \   000000D6   0xEA14 0x0C0C      ANDS     R12,R4,R12
   \   000000DA   0x4662             MOV      R2,R12
    201                if (currentpin == pos)
   \   000000DC   0x42A2             CMP      R2,R4
   \   000000DE   0xD126             BNE.N    ??GPIO_Init_9
    202                {
    203                  pos = pinpos << 2;
   \   000000E0   0xEA5F 0x0C83      LSLS     R12,R3,#+2
   \   000000E4   0x4664             MOV      R4,R12
    204                  /* Clear the corresponding high control register bits */
    205                  pinmask = ((u32)0x0F) << pos;
   \   000000E6   0xF05F 0x0C0F      MOVS     R12,#+15
   \   000000EA   0xFA1C 0xFC04      LSLS     R12,R12,R4
   \   000000EE   0x4666             MOV      R6,R12
    206                  tmpreg &= ~pinmask;
   \   000000F0   0x43B5             BICS     R5,R5,R6
    207          
    208                  /* Write the mode configuration in the corresponding bits */
    209                  tmpreg |= (currentmode << pos);
   \   000000F2   0xFA17 0xFC04      LSLS     R12,R7,R4
   \   000000F6   0xEA5C 0x0505      ORRS     R5,R12,R5
    210          
    211                  /* Reset the corresponding ODR bit */
    212                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   000000FA   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   000000FE   0xF1BC 0x0F28      CMP      R12,#+40
   \   00000102   0xD107             BNE.N    ??GPIO_Init_10
    213                  {
    214                    GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
   \   00000104   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000108   0xF113 0x0E08      ADDS     LR,R3,#+8
   \   0000010C   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   00000110   0xF8C0 0xC014      STR      R12,[R0, #+20]
    215                  }
    216                  /* Set the corresponding ODR bit */
    217                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_10:
   \   00000114   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   00000118   0xF1BC 0x0F48      CMP      R12,#+72
   \   0000011C   0xD107             BNE.N    ??GPIO_Init_9
    218                  {
    219                    GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
   \   0000011E   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000122   0xF113 0x0E08      ADDS     LR,R3,#+8
   \   00000126   0xFA1C 0xFC0E      LSLS     R12,R12,LR
   \   0000012A   0xF8C0 0xC010      STR      R12,[R0, #+16]
    220                  }
    221                }
    222              }
   \                     ??GPIO_Init_9:
   \   0000012E   0x1C5B             ADDS     R3,R3,#+1
   \   00000130   0xE7C6             B.N      ??GPIO_Init_7
    223              GPIOx->CRH = tmpreg;
   \                     ??GPIO_Init_8:
   \   00000132   0x6045             STR      R5,[R0, #+4]
    224            }
    225          }
   \                     ??GPIO_Init_6:
   \   00000134   0xBDF0             POP      {R4-R7,PC}       ;; return
    226          
    227          /*******************************************************************************
    228          * Function Name  : GPIO_StructInit
    229          * Description    : Fills each GPIO_InitStruct member with its default value.
    230          * Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
    231          *                    which will be initialized.
    232          * Output         : None
    233          * Return         : None
    234          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    236          {
    237            /* Reset GPIO init structure parameters values */
    238            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    239            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x7081             STRB     R1,[R0, #+2]
    240            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
    241          }
   \   0000000E   0x4770             BX       LR               ;; return
    242          
    243          /*******************************************************************************
    244          * Function Name  : GPIO_ReadInputDataBit
    245          * Description    : Reads the specified input port pin.
    246          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    247          *                : - GPIO_Pin:  specifies the port bit to read.
    248          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    249          * Output         : None
    250          * Return         : The input port pin value.
    251          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    252          u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    253          {
   \                     GPIO_ReadInputDataBit:
   \   00000000   0x0002             MOVS     R2,R0
    254            u8 bitstatus = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
    255            
    256            /* Check the parameters */
    257            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    258            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    259            
    260            if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000004   0x6893             LDR      R3,[R2, #+8]
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x420B             TST      R3,R1
   \   0000000A   0xD002             BEQ.N    ??GPIO_ReadInputDataBit_0
    261            {
    262              bitstatus = (u8)Bit_SET;
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE001             B.N      ??GPIO_ReadInputDataBit_1
    263            }
    264            else
    265            {
    266              bitstatus = (u8)Bit_RESET;
   \                     ??GPIO_ReadInputDataBit_0:
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x0018             MOVS     R0,R3
    267            }
    268            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_1:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    269          }
    270          
    271          /*******************************************************************************
    272          * Function Name  : GPIO_ReadInputData
    273          * Description    : Reads the specified GPIO input data port.
    274          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    275          * Output         : None
    276          * Return         : GPIO input data port value.
    277          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    279          {
    280            /* Check the parameters */
    281            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    282            
    283            return ((u16)GPIOx->IDR);
   \                     GPIO_ReadInputData:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    284          }
    285          
    286          /*******************************************************************************
    287          * Function Name  : GPIO_ReadOutputDataBit
    288          * Description    : Reads the specified output data port bit.
    289          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    290          *                : - GPIO_Pin:  specifies the port bit to read.
    291          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    292          * Output         : None
    293          * Return         : The output port pin value.
    294          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    296          {
   \                     GPIO_ReadOutputDataBit:
   \   00000000   0x0002             MOVS     R2,R0
    297            u8 bitstatus = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
    298          
    299            /* Check the parameters */
    300            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    301            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    302            
    303            if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x420B             TST      R3,R1
   \   0000000A   0xD002             BEQ.N    ??GPIO_ReadOutputDataBit_0
    304            {
    305              bitstatus = (u8)Bit_SET;
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE001             B.N      ??GPIO_ReadOutputDataBit_1
    306            }
    307            else
    308            {
    309              bitstatus = (u8)Bit_RESET;
   \                     ??GPIO_ReadOutputDataBit_0:
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x0018             MOVS     R0,R3
    310            }
    311            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_1:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    312          }
    313          
    314          /*******************************************************************************
    315          * Function Name  : GPIO_ReadOutputData
    316          * Description    : Reads the specified GPIO output data port.
    317          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    318          * Output         : None
    319          * Return         : GPIO output data port value.
    320          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    321          u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    322          {
    323            /* Check the parameters */
    324            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    325              
    326            return ((u16)GPIOx->ODR);
   \                     GPIO_ReadOutputData:
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    327          }
    328          
    329          /*******************************************************************************
    330          * Function Name  : GPIO_SetBits
    331          * Description    : Sets the selected data port bits.
    332          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    333          *                  - GPIO_Pin: specifies the port bits to be written.
    334          *                    This parameter can be any combination of GPIO_Pin_x where 
    335          *                    x can be (0..15).
    336          * Output         : None
    337          * Return         : None
    338          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    339          void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    340          {
    341            /* Check the parameters */
    342            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    343            assert_param(IS_GPIO_PIN(GPIO_Pin));
    344            
    345            GPIOx->BSRR = GPIO_Pin;
   \                     GPIO_SetBits:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6101             STR      R1,[R0, #+16]
    346          }
   \   00000004   0x4770             BX       LR               ;; return
    347          
    348          /*******************************************************************************
    349          * Function Name  : GPIO_ResetBits
    350          * Description    : Clears the selected data port bits.
    351          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    352          *                  - GPIO_Pin: specifies the port bits to be written.
    353          *                    This parameter can be any combination of GPIO_Pin_x where 
    354          *                    x can be (0..15).
    355          * Output         : None
    356          * Return         : None
    357          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    358          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    359          {
    360            /* Check the parameters */
    361            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    362            assert_param(IS_GPIO_PIN(GPIO_Pin));
    363            
    364            GPIOx->BRR = GPIO_Pin;
   \                     GPIO_ResetBits:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6141             STR      R1,[R0, #+20]
    365          }
   \   00000004   0x4770             BX       LR               ;; return
    366          
    367          /*******************************************************************************
    368          * Function Name  : GPIO_WriteBit
    369          * Description    : Sets or clears the selected data port bit.
    370          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    371          *                  - GPIO_Pin: specifies the port bit to be written.
    372          *                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
    373          *                  - BitVal: specifies the value to be written to the selected bit.
    374          *                    This parameter can be one of the BitAction enum values:
    375          *                       - Bit_RESET: to clear the port pin
    376          *                       - Bit_SET: to set the port pin
    377          * Output         : None
    378          * Return         : None
    379          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    384            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    385            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    386            
    387            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??GPIO_WriteBit_0
    388            {
    389              GPIOx->BSRR = GPIO_Pin;
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x6101             STR      R1,[R0, #+16]
   \   0000000A   0xE001             B.N      ??GPIO_WriteBit_1
    390            }
    391            else
    392            {
    393              GPIOx->BRR = GPIO_Pin;
   \                     ??GPIO_WriteBit_0:
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    394            }
    395          }
   \                     ??GPIO_WriteBit_1:
   \   00000010   0x4770             BX       LR               ;; return
    396          
    397          /*******************************************************************************
    398          * Function Name  : GPIO_Write
    399          * Description    : Writes data to the specified GPIO data port.
    400          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    401          *                  - PortVal: specifies the value to be written to the port output
    402          *                    data register.
    403          * Output         : None
    404          * Return         : None
    405          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
    407          {
    408            /* Check the parameters */
    409            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    410            
    411            GPIOx->ODR = PortVal;
   \                     GPIO_Write:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x60C1             STR      R1,[R0, #+12]
    412          }
   \   00000004   0x4770             BX       LR               ;; return
    413          
    414          /*******************************************************************************
    415          * Function Name  : GPIO_PinLockConfig
    416          * Description    : Locks GPIO Pins configuration registers.
    417          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    418          *                  - GPIO_Pin: specifies the port bit to be written.
    419          *                    This parameter can be any combination of GPIO_Pin_x where 
    420          *                    x can be (0..15).
    421          * Output         : None
    422          * Return         : None
    423          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    424          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    425          {
    426            u32 tmp = 0x00010000;
   \                     GPIO_PinLockConfig:
   \   00000000   0xF45F 0x3280      MOVS     R2,#+65536
    427            
    428            /* Check the parameters */
    429            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    430            assert_param(IS_GPIO_PIN(GPIO_Pin));
    431            
    432            tmp |= GPIO_Pin;
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x430A             ORRS     R2,R1,R2
    433            /* Set LCKK bit */
    434            GPIOx->LCKR = tmp;
   \   00000008   0x6182             STR      R2,[R0, #+24]
    435            /* Reset LCKK bit */
    436            GPIOx->LCKR =  GPIO_Pin;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x6181             STR      R1,[R0, #+24]
    437            /* Set LCKK bit */
    438            GPIOx->LCKR = tmp;
   \   0000000E   0x6182             STR      R2,[R0, #+24]
    439            /* Read LCKK bit*/
    440            tmp = GPIOx->LCKR;
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   \   00000012   0x001A             MOVS     R2,R3
    441            /* Read LCKK bit*/
    442            tmp = GPIOx->LCKR;
   \   00000014   0x6983             LDR      R3,[R0, #+24]
   \   00000016   0x001A             MOVS     R2,R3
    443          }
   \   00000018   0x4770             BX       LR               ;; return
    444          
    445          /*******************************************************************************
    446          * Function Name  : GPIO_EventOutputConfig
    447          * Description    : Selects the GPIO pin used as Event output.
    448          * Input          : - GPIO_PortSource: selects the GPIO port to be used as source
    449          *                    for Event output.
    450          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    451          *                    (A..E).
    452          *                  - GPIO_PinSource: specifies the pin for the Event output.
    453          *                    This parameter can be GPIO_PinSourcex where x can be (0..15).
    454          * Output         : None
    455          * Return         : None
    456          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    457          void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    458          {
    459            u32 tmpreg = 0x00;
   \                     GPIO_EventOutputConfig:
   \   00000000   0x2200             MOVS     R2,#+0
    460          
    461            /* Check the parameters */
    462            assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
    463            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    464              
    465            tmpreg = AFIO->EVCR;
   \   00000002   0x....             LDR.N    R3,??DataTable5_7  ;; 0x40010000
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x001A             MOVS     R2,R3
    466            /* Clear the PORT[6:4] and PIN[3:0] bits */
    467            tmpreg &= EVCR_PORTPINCONFIG_MASK;
   \   00000008   0xF64F 0x7380      MOVW     R3,#+65408
   \   0000000C   0x401A             ANDS     R2,R3,R2
    468            tmpreg |= (u32)GPIO_PortSource << 0x04;
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xEA52 0x1200      ORRS     R2,R2,R0, LSL #+4
    469            tmpreg |= GPIO_PinSource;
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x430A             ORRS     R2,R1,R2
    470          
    471            AFIO->EVCR = tmpreg;
   \   00000018   0x....             LDR.N    R3,??DataTable5_7  ;; 0x40010000
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    472          }
   \   0000001C   0x4770             BX       LR               ;; return
    473          
    474          /*******************************************************************************
    475          * Function Name  : GPIO_EventOutputCmd
    476          * Description    : Enables or disables the Event Output.
    477          * Input          : - NewState: new state of the Event output.
    478          *                    This parameter can be: ENABLE or DISABLE.
    479          * Output         : None
    480          * Return         : None
    481          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    482          void GPIO_EventOutputCmd(FunctionalState NewState)
    483          {
    484            /* Check the parameters */
    485            assert_param(IS_FUNCTIONAL_STATE(NewState));
    486            
    487            *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
   \                     GPIO_EventOutputCmd:
   \   00000000   0x....             LDR.N    R1,??DataTable5_8  ;; 0x4220001c
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x6008             STR      R0,[R1, #+0]
    488          }
   \   00000006   0x4770             BX       LR               ;; return
    489          
    490          /*******************************************************************************
    491          * Function Name  : GPIO_PinRemapConfig
    492          * Description    : Changes the mapping of the specified pin.
    493          * Input          : - GPIO_Remap: selects the pin to remap.
    494          *                    This parameter can be one of the following values:
    495          *                       - GPIO_Remap_SPI1
    496          *                       - GPIO_Remap_I2C1
    497          *                       - GPIO_Remap_USART1
    498          *                       - GPIO_Remap_USART2
    499          *                       - GPIO_PartialRemap_USART3
    500          *                       - GPIO_FullRemap_USART3
    501          *                       - GPIO_PartialRemap_TIM1
    502          *                       - GPIO_FullRemap_TIM1
    503          *                       - GPIO_PartialRemap1_TIM2
    504          *                       - GPIO_PartialRemap2_TIM2
    505          *                       - GPIO_FullRemap_TIM2
    506          *                       - GPIO_PartialRemap_TIM3
    507          *                       - GPIO_FullRemap_TIM3
    508          *                       - GPIO_Remap_TIM4
    509          *                       - GPIO_Remap1_CAN
    510          *                       - GPIO_Remap2_CAN
    511          *                       - GPIO_Remap_PD01
    512          *                       - GPIO_Remap_TIM5CH4_LSI
    513          *                       - GPIO_Remap_ADC1_ETRGINJ
    514          *                       - GPIO_Remap_ADC1_ETRGREG
    515          *                       - GPIO_Remap_ADC2_ETRGINJ
    516          *                       - GPIO_Remap_ADC2_ETRGREG
    517          *                       - GPIO_Remap_ETH
    518          *                       - GPIO_Remap_CAN2
    519          *                       - GPIO_Remap_SWJ_NoJTRST
    520          *                       - GPIO_Remap_SWJ_JTAGDisable
    521          *                       - GPIO_Remap_SWJ_Disable
    522          *                       - GPIO_Remap_SPI3
    523          *                       - GPIO_Remap_TIM2ITR1_PTP_SOF
    524          *                       Note: If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the
    525          *                       TIM2 ITR1 is connected to Ethernet PTP output. When Reset 
    526          *                       TIM2 ITR1 is connected to USB OTG SOF output. 
    527          *                       - GPIO_Remap_PTP_PPS
    528          *                  - NewState: new state of the port pin remapping.
    529          *                    This parameter can be: ENABLE or DISABLE.
    530          * Output         : None
    531          * Return         : None
    532          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    533          void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
    534          {
   \                     GPIO_PinRemapConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    535            u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2400             MOVS     R4,#+0
    536          
    537            /* Check the parameters */
    538            assert_param(IS_GPIO_REMAP(GPIO_Remap));
    539            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    540            
    541            tmpreg = AFIO->MAPR;
   \   0000000A   0x....             LDR.N    R6,??DataTable5_9  ;; 0x40010004
   \   0000000C   0x6836             LDR      R6,[R6, #+0]
   \   0000000E   0x0035             MOVS     R5,R6
    542          
    543            tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
   \   00000010   0xF3C0 0x4603      UBFX     R6,R0,#+16,#+4
   \   00000014   0x0034             MOVS     R4,R6
    544            tmp = GPIO_Remap & LSB_MASK;
   \   00000016   0xB286             UXTH     R6,R0            ;; ZeroExt  R6,R0,#+16,#+16
   \   00000018   0x0032             MOVS     R2,R6
    545          
    546            if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
   \   0000001A   0xF410 0x1640      ANDS     R6,R0,#0x300000
   \   0000001E   0xF5B6 0x1F40      CMP      R6,#+3145728
   \   00000022   0xD108             BNE.N    ??GPIO_PinRemapConfig_0
    547            {
    548              tmpreg &= DBGAFR_SWJCFG_MASK;
   \   00000024   0xF035 0x6570      BICS     R5,R5,#0xF000000
    549              AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
   \   00000028   0x....             LDR.N    R6,??DataTable5_9  ;; 0x40010004
   \   0000002A   0x6836             LDR      R6,[R6, #+0]
   \   0000002C   0xF036 0x6670      BICS     R6,R6,#0xF000000
   \   00000030   0x....             LDR.N    R7,??DataTable5_9  ;; 0x40010004
   \   00000032   0x603E             STR      R6,[R7, #+0]
   \   00000034   0xE010             B.N      ??GPIO_PinRemapConfig_1
    550            }
    551            else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
   \                     ??GPIO_PinRemapConfig_0:
   \   00000036   0x02C6             LSLS     R6,R0,#+11
   \   00000038   0xD506             BPL.N    ??GPIO_PinRemapConfig_2
    552            {
    553              tmp1 = ((u32)0x03) << tmpmask;
   \   0000003A   0x2603             MOVS     R6,#+3
   \   0000003C   0x40A6             LSLS     R6,R6,R4
   \   0000003E   0x0033             MOVS     R3,R6
    554              tmpreg &= ~tmp1;
   \   00000040   0x439D             BICS     R5,R5,R3
    555              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000042   0xF055 0x6570      ORRS     R5,R5,#0xF000000
   \   00000046   0xE007             B.N      ??GPIO_PinRemapConfig_1
    556            }
    557            else
    558            {
    559              tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
   \                     ??GPIO_PinRemapConfig_2:
   \   00000048   0x0D46             LSRS     R6,R0,#+21
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x0136             LSLS     R6,R6,#+4
   \   0000004E   0xFA12 0xF606      LSLS     R6,R2,R6
   \   00000052   0x43B5             BICS     R5,R5,R6
    560              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000054   0xF055 0x6570      ORRS     R5,R5,#0xF000000
    561            }
    562          
    563            if (NewState != DISABLE)
   \                     ??GPIO_PinRemapConfig_1:
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD005             BEQ.N    ??GPIO_PinRemapConfig_3
    564            {
    565              tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
   \   0000005E   0x0D46             LSRS     R6,R0,#+21
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x0136             LSLS     R6,R6,#+4
   \   00000064   0xFA12 0xF606      LSLS     R6,R2,R6
   \   00000068   0x4335             ORRS     R5,R6,R5
    566            }
    567          
    568            AFIO->MAPR = tmpreg;
   \                     ??GPIO_PinRemapConfig_3:
   \   0000006A   0x....             LDR.N    R6,??DataTable5_9  ;; 0x40010004
   \   0000006C   0x6035             STR      R5,[R6, #+0]
    569          }
   \   0000006E   0xBCF0             POP      {R4-R7}
   \   00000070   0x4770             BX       LR               ;; return
    570          
    571          /*******************************************************************************
    572          * Function Name  : GPIO_EXTILineConfig
    573          * Description    : Selects the GPIO pin used as EXTI Line.
    574          * Input          : - GPIO_PortSource: selects the GPIO port to be used as
    575          *                    source for EXTI lines.
    576          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    577          *                    (A..G).
    578          *                  - GPIO_PinSource: specifies the EXTI line to be configured.
    579          *                   This parameter can be GPIO_PinSourcex where x can be (0..15).
    580          * Output         : None
    581          * Return         : None
    582          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    583          void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    584          {
   \                     GPIO_EXTILineConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
    585            u32 tmp = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    586          
    587            /* Check the parameters */
    588            assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
    589            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    590            
    591            tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0xF011 0x0403      ANDS     R4,R1,#0x3
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x00A4             LSLS     R4,R4,#+2
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0x001A             MOVS     R2,R3
    592          
    593            AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x108B             ASRS     R3,R1,#+2
   \   00000016   0x....             LDR.N    R4,??DataTable5_10  ;; 0x40010008
   \   00000018   0xF854 0x3023      LDR      R3,[R4, R3, LSL #+2]
   \   0000001C   0x4393             BICS     R3,R3,R2
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x108C             ASRS     R4,R1,#+2
   \   00000022   0x....             LDR.N    R5,??DataTable5_10  ;; 0x40010008
   \   00000024   0xF845 0x3024      STR      R3,[R5, R4, LSL #+2]
    594            AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x108B             ASRS     R3,R1,#+2
   \   0000002C   0x....             LDR.N    R4,??DataTable5_10  ;; 0x40010008
   \   0000002E   0xF854 0x3023      LDR      R3,[R4, R3, LSL #+2]
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xF011 0x0403      ANDS     R4,R1,#0x3
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x00A4             LSLS     R4,R4,#+2
   \   0000003C   0xFA10 0xF404      LSLS     R4,R0,R4
   \   00000040   0x4323             ORRS     R3,R4,R3
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x108C             ASRS     R4,R1,#+2
   \   00000046   0x....             LDR.N    R5,??DataTable5_10  ;; 0x40010008
   \   00000048   0xF845 0x3024      STR      R3,[R5, R4, LSL #+2]
    595          }
   \   0000004C   0xBC30             POP      {R4,R5}
   \   0000004E   0x4770             BX       LR               ;; return
    596          
    597          /******************************************************************************* 
    598          * Function Name  : GPIO_ETH_MediaInterfaceConfig 
    599          * Desciption     : Selects the ETHERNET media interface 
    600          * Input          : - GPIO_ETH_MediaInterface: specifies the Media Interface mode. 
    601          *                    This parameter can be one of the following values: 
    602          *                       - GPIO_ETH_MediaInterface_MII: MII mode 
    603          *                       - GPIO_ETH_MediaInterface_RMII: RMII mode 
    604          * Output         : None 
    605          * Return         : None 
    606          *******************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    607          void GPIO_ETH_MediaInterfaceConfig(u32 GPIO_ETH_MediaInterface) 
    608          { 
    609            assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 
    610          
    611            /* Configure MII_RMII selection bit */ 
    612            *(vu32 *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
   \                     GPIO_ETH_MediaInterfaceConfig:
   \   00000000   0x....             LDR.N    R1,??DataTable5_11  ;; 0x422000dc
   \   00000002   0x6008             STR      R0,[R1, #+0]
    613          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40011C00         DC32     0x40011c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4220001C         DC32     0x4220001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x40010008         DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x422000DC         DC32     0x422000dc
    614          
    615          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_AFIODeInit
         8   -> RCC_APB2PeriphResetCmd
       8   GPIO_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   GPIO_ETH_MediaInterfaceConfig
       8   GPIO_EXTILineConfig
       0   GPIO_EventOutputCmd
       0   GPIO_EventOutputConfig
      20   GPIO_Init
       0   GPIO_PinLockConfig
      16   GPIO_PinRemapConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      20  GPIO_AFIODeInit
     192  GPIO_DeInit
       6  GPIO_ETH_MediaInterfaceConfig
      80  GPIO_EXTILineConfig
       8  GPIO_EventOutputCmd
      30  GPIO_EventOutputConfig
     310  GPIO_Init
      26  GPIO_PinLockConfig
     114  GPIO_PinRemapConfig
       6  GPIO_ReadInputData
      26  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      26  GPIO_ReadOutputDataBit
       6  GPIO_ResetBits
       6  GPIO_SetBits
      16  GPIO_StructInit
       6  GPIO_Write
      18  GPIO_WriteBit

 
 950 bytes in section .text
 
 950 bytes of CODE memory

Errors: none
Warnings: none

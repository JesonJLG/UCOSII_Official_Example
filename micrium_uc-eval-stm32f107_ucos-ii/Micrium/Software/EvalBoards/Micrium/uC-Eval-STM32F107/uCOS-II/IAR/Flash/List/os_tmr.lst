###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:22 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_tmr.c          #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_tmr.c" -D      #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_tmr.lst                   #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_tmr.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_tmr.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TIMER MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          *
     11          * File    : OS_TMR.C
     12          * By      : Jean J. Labrosse
     13          * Version : V2.92.07
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     18          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     19          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     20          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     21          * licensing fee.
     22          *********************************************************************************************************
     23          */
     24          
     25          #define  MICRIUM_SOURCE
     26          
     27          #ifndef  OS_MASTER_FILE
     28          #include <ucos_ii.h>
     29          #endif
     30          
     31          /*
     32          *********************************************************************************************************
     33          *                                                        NOTES
     34          *
     35          * 1) Your application MUST define the following #define constants:
     36          *
     37          *    OS_TASK_TMR_PRIO          The priority of the Timer management task
     38          *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
     39          *
     40          * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
     41          *********************************************************************************************************
     42          */
     43          
     44          /*
     45          *********************************************************************************************************
     46          *                                              CONSTANTS
     47          *********************************************************************************************************
     48          */
     49          
     50          #define  OS_TMR_LINK_DLY       0u
     51          #define  OS_TMR_LINK_PERIODIC  1u
     52          
     53          /*
     54          *********************************************************************************************************
     55          *                                          LOCAL PROTOTYPES
     56          *********************************************************************************************************
     57          */
     58          
     59          #if OS_TMR_EN > 0u
     60          static  OS_TMR  *OSTmr_Alloc         (void);
     61          static  void     OSTmr_Free          (OS_TMR *ptmr);
     62          static  void     OSTmr_InitTask      (void);
     63          static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
     64          static  void     OSTmr_Unlink        (OS_TMR *ptmr);
     65          static  void     OSTmr_Task          (void   *p_arg);
     66          #endif
     67          
     68          /*$PAGE*/
     69          /*
     70          *********************************************************************************************************
     71          *                                           CREATE A TIMER
     72          *
     73          * Description: This function is called by your application code to create a timer.
     74          *
     75          * Arguments  : dly           Initial delay.
     76          *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
     77          *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
     78          *                               wait for before the timer starts entering periodic mode.
     79          *
     80          *              period        The 'period' being repeated for the timer.
     81          *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
     82          *                               expires, it will automatically restart with the same period.
     83          *
     84          *              opt           Specifies either:
     85          *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
     86          *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
     87          *
     88          *              callback      Is a pointer to a callback function that will be called when the timer expires. 
     89          *                               The callback function must be declared as follows:
     90          *
     91          *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
     92          *
     93          *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
     94          *
     95          *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
     96          *                               useful for debugging.
     97          *
     98          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
     99          *                               OS_ERR_NONE
    100          *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
    101          *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
    102          *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
    103          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
    104          *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
    105          *
    106          * Returns    : A pointer to an OS_TMR data structure.
    107          *              This is the 'handle' that your application will use to reference the timer created.
    108          *********************************************************************************************************
    109          */
    110          
    111          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    112          OS_TMR  *OSTmrCreate (INT32U           dly,
    113                                INT32U           period,
    114                                INT8U            opt,
    115                                OS_TMR_CALLBACK  callback,
    116                                void            *callback_arg,
    117                                INT8U           *pname,
    118                                INT8U           *perr)
    119          {
   \                     OSTmrCreate:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000010   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \   00000014   0xF8DD 0xA030      LDR      R10,[SP, #+48]
    120              OS_TMR   *ptmr;
    121          
    122          
    123          #ifdef OS_SAFETY_CRITICAL
    124              if (perr == (INT8U *)0) {
    125                  OS_SAFETY_CRITICAL_EXCEPTION();
    126                  return ((OS_TMR *)0);
    127              }
    128          #endif
    129          
    130          #ifdef OS_SAFETY_CRITICAL_IEC61508
    131              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    132                  OS_SAFETY_CRITICAL_EXCEPTION();
    133                  return ((OS_TMR *)0);
    134              }
    135          #endif
    136          
    137          #if OS_ARG_CHK_EN > 0u
    138              switch (opt) {                                          /* Validate arguments                                     */
    139                  case OS_TMR_OPT_PERIODIC:
    140                       if (period == 0u) {
    141                           *perr = OS_ERR_TMR_INVALID_PERIOD;
    142                           return ((OS_TMR *)0);
    143                       }
    144                       break;
    145          
    146                  case OS_TMR_OPT_ONE_SHOT:
    147                       if (dly == 0u) {
    148                           *perr = OS_ERR_TMR_INVALID_DLY;
    149                           return ((OS_TMR *)0);
    150                       }
    151                       break;
    152          
    153                  default:
    154                       *perr = OS_ERR_TMR_INVALID_OPT;
    155                       return ((OS_TMR *)0);
    156              }
    157          #endif
    158              if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??OSTmrCreate_0
    159                  *perr  = OS_ERR_TMR_ISR;
   \   00000022   0x208B             MOVS     R0,#+139
   \   00000024   0xF88A 0x0000      STRB     R0,[R10, #+0]
    160                  return ((OS_TMR *)0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE02A             B.N      ??OSTmrCreate_1
    161              }
    162              OSSchedLock();
   \                     ??OSTmrCreate_0:
   \   0000002C   0x.... 0x....      BL       OSSchedLock
    163              ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
   \   00000030   0x.... 0x....      BL       OSTmr_Alloc
   \   00000034   0x4683             MOV      R11,R0
    164              if (ptmr == (OS_TMR *)0) {
   \   00000036   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000003A   0xD106             BNE.N    ??OSTmrCreate_2
    165                  OSSchedUnlock();
   \   0000003C   0x.... 0x....      BL       OSSchedUnlock
    166                  *perr = OS_ERR_TMR_NON_AVAIL;
   \   00000040   0x2086             MOVS     R0,#+134
   \   00000042   0xF88A 0x0000      STRB     R0,[R10, #+0]
    167                  return ((OS_TMR *)0);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE01B             B.N      ??OSTmrCreate_1
    168              }
    169              ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
   \                     ??OSTmrCreate_2:
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF88B 0x0025      STRB     R0,[R11, #+37]
    170              ptmr->OSTmrDly         = dly;
   \   00000050   0xF8CB 0x4018      STR      R4,[R11, #+24]
    171              ptmr->OSTmrPeriod      = period;
   \   00000054   0xF8CB 0x501C      STR      R5,[R11, #+28]
    172              ptmr->OSTmrOpt         = opt;
   \   00000058   0xF88B 0x6024      STRB     R6,[R11, #+36]
    173              ptmr->OSTmrCallback    = callback;
   \   0000005C   0xF8CB 0x7004      STR      R7,[R11, #+4]
    174              ptmr->OSTmrCallbackArg = callback_arg;
   \   00000060   0xF8CB 0x8008      STR      R8,[R11, #+8]
    175          #if OS_TMR_CFG_NAME_EN > 0u
    176              if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
   \   00000064   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000068   0xD103             BNE.N    ??OSTmrCreate_3
    177                  ptmr->OSTmrName    = (INT8U *)(void *)"?";
   \   0000006A   0x....             ADR.N    R0,??DataTable5  ;; "\?"
   \   0000006C   0xF8CB 0x0020      STR      R0,[R11, #+32]
   \   00000070   0xE001             B.N      ??OSTmrCreate_4
    178              } else {
    179                  ptmr->OSTmrName    = pname;
   \                     ??OSTmrCreate_3:
   \   00000072   0xF8CB 0x9020      STR      R9,[R11, #+32]
    180              }
    181          #endif
    182              OSSchedUnlock();
   \                     ??OSTmrCreate_4:
   \   00000076   0x.... 0x....      BL       OSSchedUnlock
    183              *perr = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF88A 0x0000      STRB     R0,[R10, #+0]
    184              return (ptmr);
   \   00000080   0x4658             MOV      R0,R11
   \                     ??OSTmrCreate_1:
   \   00000082   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    185          }
    186          #endif
    187          
    188          /*$PAGE*/
    189          /*
    190          *********************************************************************************************************
    191          *                                           DELETE A TIMER
    192          *
    193          * Description: This function is called by your application code to delete a timer.
    194          *
    195          * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
    196          *
    197          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    198          *                               OS_ERR_NONE
    199          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
    200          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    201          *                               OS_ERR_TMR_ISR            if the function was called from an ISR
    202          *                               OS_ERR_TMR_INACTIVE       if the timer was not created
    203          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    204          *
    205          * Returns    : OS_TRUE       If the call was successful
    206          *              OS_FALSE      If not
    207          *********************************************************************************************************
    208          */
    209          
    210          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    211          BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
    212                             INT8U   *perr)
    213          {
   \                     OSTmrDel:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    214          #ifdef OS_SAFETY_CRITICAL
    215              if (perr == (INT8U *)0) {
    216                  OS_SAFETY_CRITICAL_EXCEPTION();
    217                  return (OS_FALSE);
    218              }
    219          #endif
    220          
    221          #if OS_ARG_CHK_EN > 0u
    222              if (ptmr == (OS_TMR *)0) {
    223                  *perr = OS_ERR_TMR_INVALID;
    224                  return (OS_FALSE);
    225              }
    226          #endif
    227              if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrDel_0
    228                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    229                  return (OS_FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE033             B.N      ??OSTmrDel_1
    230              }
    231              if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
   \                     ??OSTmrDel_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrDel_2
    232                  *perr  = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    233                  return (OS_FALSE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE02A             B.N      ??OSTmrDel_1
    234              }
    235              OSSchedLock();
   \                     ??OSTmrDel_2:
   \   00000026   0x.... 0x....      BL       OSSchedLock
    236              switch (ptmr->OSTmrState) {
   \   0000002A   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD019             BEQ.N    ??OSTmrDel_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD00E             BEQ.N    ??OSTmrDel_4
   \   00000036   0xD30D             BCC.N    ??OSTmrDel_4
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD11A             BNE.N    ??OSTmrDel_5
    237                  case OS_TMR_STATE_RUNNING:
    238                       OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
   \                     ??OSTmrDel_6:
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       OSTmr_Unlink
    239                       OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       OSTmr_Free
    240                       OSSchedUnlock();
   \   00000048   0x.... 0x....      BL       OSSchedUnlock
    241                       *perr = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
    242                       return (OS_TRUE);
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE013             B.N      ??OSTmrDel_1
    243          
    244                  case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
    245                  case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
    246                       OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
   \                     ??OSTmrDel_4:
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OSTmr_Free
    247                       OSSchedUnlock();
   \   0000005A   0x.... 0x....      BL       OSSchedUnlock
    248                       *perr = OS_ERR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7028             STRB     R0,[R5, #+0]
    249                       return (OS_TRUE);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE00A             B.N      ??OSTmrDel_1
    250          
    251                  case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
    252                       OSSchedUnlock();
   \                     ??OSTmrDel_3:
   \   00000066   0x.... 0x....      BL       OSSchedUnlock
    253                       *perr = OS_ERR_TMR_INACTIVE;
   \   0000006A   0x2087             MOVS     R0,#+135
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
    254                       return (OS_FALSE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE004             B.N      ??OSTmrDel_1
    255          
    256                  default:
    257                       OSSchedUnlock();
   \                     ??OSTmrDel_5:
   \   00000072   0x.... 0x....      BL       OSSchedUnlock
    258                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   00000076   0x208D             MOVS     R0,#+141
   \   00000078   0x7028             STRB     R0,[R5, #+0]
    259                       return (OS_FALSE);
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??OSTmrDel_1:
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    260              }
    261          }
    262          #endif
    263          
    264          /*$PAGE*/
    265          /*
    266          *********************************************************************************************************
    267          *                                       GET THE NAME OF A TIMER
    268          *
    269          * Description: This function is called to obtain the name of a timer.
    270          *
    271          * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
    272          *
    273          *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
    274          *
    275          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    276          *                               OS_ERR_NONE               The call was successful
    277          *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
    278          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
    279          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    280          *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
    281          *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
    282          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    283          *
    284          * Returns    : The length of the string or 0 if the timer does not exist.
    285          *********************************************************************************************************
    286          */
    287          
    288          #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    289          INT8U  OSTmrNameGet (OS_TMR   *ptmr,
    290                               INT8U   **pdest,
    291                               INT8U    *perr)
    292          {
   \                     OSTmrNameGet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    293              INT8U  len;
    294          
    295          
    296          #ifdef OS_SAFETY_CRITICAL
    297              if (perr == (INT8U *)0) {
    298                  OS_SAFETY_CRITICAL_EXCEPTION();
    299                  return (0u);
    300              }
    301          #endif
    302          
    303          #if OS_ARG_CHK_EN > 0u
    304              if (pdest == (INT8U **)0) {
    305                  *perr = OS_ERR_TMR_INVALID_DEST;
    306                  return (0u);
    307              }
    308              if (ptmr == (OS_TMR *)0) {
    309                  *perr = OS_ERR_TMR_INVALID;
    310                  return (0u);
    311              }
    312          #endif
    313              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2864             CMP      R0,#+100
   \   0000000C   0xD003             BEQ.N    ??OSTmrNameGet_0
    314                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000E   0x2089             MOVS     R0,#+137
   \   00000010   0x7030             STRB     R0,[R6, #+0]
    315                  return (0u);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE029             B.N      ??OSTmrNameGet_1
    316              }
    317              if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
   \                     ??OSTmrNameGet_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD003             BEQ.N    ??OSTmrNameGet_2
    318                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000020   0x2011             MOVS     R0,#+17
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    319                  return (0u);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE020             B.N      ??OSTmrNameGet_1
    320              }
    321              OSSchedLock();
   \                     ??OSTmrNameGet_2:
   \   00000028   0x.... 0x....      BL       OSSchedLock
    322              switch (ptmr->OSTmrState) {
   \   0000002C   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00F             BEQ.N    ??OSTmrNameGet_3
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD812             BHI.N    ??OSTmrNameGet_4
    323                  case OS_TMR_STATE_RUNNING:
    324                  case OS_TMR_STATE_STOPPED:
    325                  case OS_TMR_STATE_COMPLETED:
    326                       *pdest = ptmr->OSTmrName;
   \                     ??OSTmrNameGet_5:
   \   0000003A   0x6A20             LDR      R0,[R4, #+32]
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    327                       len    = OS_StrLen(*pdest);
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      BL       OS_StrLen
   \   00000044   0x0007             MOVS     R7,R0
    328                       OSSchedUnlock();
   \   00000046   0x.... 0x....      BL       OSSchedUnlock
    329                       *perr = OS_ERR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
    330                       return (len);
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xE00A             B.N      ??OSTmrNameGet_1
    331          
    332                  case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
    333                       OSSchedUnlock();
   \                     ??OSTmrNameGet_3:
   \   00000054   0x.... 0x....      BL       OSSchedUnlock
    334                       *perr = OS_ERR_TMR_INACTIVE;
   \   00000058   0x2087             MOVS     R0,#+135
   \   0000005A   0x7030             STRB     R0,[R6, #+0]
    335                       return (0u);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE004             B.N      ??OSTmrNameGet_1
    336          
    337                  default:
    338                       OSSchedUnlock();
   \                     ??OSTmrNameGet_4:
   \   00000060   0x.... 0x....      BL       OSSchedUnlock
    339                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   00000064   0x208D             MOVS     R0,#+141
   \   00000066   0x7030             STRB     R0,[R6, #+0]
    340                       return (0u);
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??OSTmrNameGet_1:
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    341              }
    342          }
    343          #endif
    344          
    345          /*$PAGE*/
    346          /*
    347          *********************************************************************************************************
    348          *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
    349          *
    350          * Description: This function is called to get the number of ticks before a timer times out.
    351          *
    352          * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
    353          *
    354          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    355          *                               OS_ERR_NONE
    356          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
    357          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    358          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
    359          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
    360          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    361          *
    362          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
    363          *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
    364          *              value represents the number of 1/10 of a second remaining before the timer expires.
    365          *********************************************************************************************************
    366          */
    367          
    368          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    369          INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
    370                                  INT8U   *perr)
    371          {
   \                     OSTmrRemainGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    372              INT32U  remain;
    373          
    374          
    375          #ifdef OS_SAFETY_CRITICAL
    376              if (perr == (INT8U *)0) {
    377                  OS_SAFETY_CRITICAL_EXCEPTION();
    378                  return (0u);
    379              }
    380          #endif
    381          
    382          #if OS_ARG_CHK_EN > 0u
    383              if (ptmr == (OS_TMR *)0) {
    384                  *perr = OS_ERR_TMR_INVALID;
    385                  return (0u);
    386              }
    387          #endif
    388              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrRemainGet_0
    389                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    390                  return (0u);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE049             B.N      ??OSTmrRemainGet_1
    391              }
    392              if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
   \                     ??OSTmrRemainGet_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrRemainGet_2
    393                  *perr = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    394                  return (0u);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE040             B.N      ??OSTmrRemainGet_1
    395              }
    396              OSSchedLock();
   \                     ??OSTmrRemainGet_2:
   \   00000026   0x.... 0x....      BL       OSSchedLock
    397              switch (ptmr->OSTmrState) {
   \   0000002A   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD02F             BEQ.N    ??OSTmrRemainGet_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD027             BEQ.N    ??OSTmrRemainGet_4
   \   00000036   0xD30D             BCC.N    ??OSTmrRemainGet_5
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD130             BNE.N    ??OSTmrRemainGet_6
    398                  case OS_TMR_STATE_RUNNING:
    399                       remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
   \                     ??OSTmrRemainGet_7:
   \   0000003C   0x6960             LDR      R0,[R4, #+20]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x0006             MOVS     R6,R0
    400                       OSSchedUnlock();
   \   00000048   0x.... 0x....      BL       OSSchedUnlock
    401                       *perr  = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
    402                       return (remain);
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xE029             B.N      ??OSTmrRemainGet_1
    403          
    404                  case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
    405                       switch (ptmr->OSTmrOpt) {
   \                     ??OSTmrRemainGet_5:
   \   00000054   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD10C             BNE.N    ??OSTmrRemainGet_8
    406                           case OS_TMR_OPT_PERIODIC:
    407                                if (ptmr->OSTmrDly == 0u) {
   \   0000005C   0x69A0             LDR      R0,[R4, #+24]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD102             BNE.N    ??OSTmrRemainGet_9
    408                                    remain = ptmr->OSTmrPeriod;
   \   00000062   0x69E0             LDR      R0,[R4, #+28]
   \   00000064   0x0006             MOVS     R6,R0
   \   00000066   0xE001             B.N      ??OSTmrRemainGet_10
    409                                } else {
    410                                    remain = ptmr->OSTmrDly;
   \                     ??OSTmrRemainGet_9:
   \   00000068   0x69A0             LDR      R0,[R4, #+24]
   \   0000006A   0x0006             MOVS     R6,R0
    411                                }
    412                                OSSchedUnlock();
   \                     ??OSTmrRemainGet_10:
   \   0000006C   0x.... 0x....      BL       OSSchedUnlock
    413                                *perr  = OS_ERR_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7028             STRB     R0,[R5, #+0]
    414                                break;
   \   00000074   0xE005             B.N      ??OSTmrRemainGet_11
    415          
    416                           case OS_TMR_OPT_ONE_SHOT:
    417                           default:
    418                                remain = ptmr->OSTmrDly;
   \                     ??OSTmrRemainGet_8:
   \   00000076   0x69A0             LDR      R0,[R4, #+24]
   \   00000078   0x0006             MOVS     R6,R0
    419                                OSSchedUnlock();
   \   0000007A   0x.... 0x....      BL       OSSchedUnlock
    420                                *perr  = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7028             STRB     R0,[R5, #+0]
    421                                break;
    422                       }
    423                       return (remain);
   \                     ??OSTmrRemainGet_11:
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0xE010             B.N      ??OSTmrRemainGet_1
    424          
    425                  case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
    426                       OSSchedUnlock();
   \                     ??OSTmrRemainGet_4:
   \   00000086   0x.... 0x....      BL       OSSchedUnlock
    427                       *perr = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x7028             STRB     R0,[R5, #+0]
    428                       return (0u);
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE00A             B.N      ??OSTmrRemainGet_1
    429          
    430                  case OS_TMR_STATE_UNUSED:
    431                       OSSchedUnlock();
   \                     ??OSTmrRemainGet_3:
   \   00000092   0x.... 0x....      BL       OSSchedUnlock
    432                       *perr = OS_ERR_TMR_INACTIVE;
   \   00000096   0x2087             MOVS     R0,#+135
   \   00000098   0x7028             STRB     R0,[R5, #+0]
    433                       return (0u);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE004             B.N      ??OSTmrRemainGet_1
    434          
    435                  default:
    436                       OSSchedUnlock();
   \                     ??OSTmrRemainGet_6:
   \   0000009E   0x.... 0x....      BL       OSSchedUnlock
    437                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   000000A2   0x208D             MOVS     R0,#+141
   \   000000A4   0x7028             STRB     R0,[R5, #+0]
    438                       return (0u);
   \   000000A6   0x2000             MOVS     R0,#+0
   \                     ??OSTmrRemainGet_1:
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
    439              }
    440          }
    441          #endif
    442          
    443          /*$PAGE*/
    444          /*
    445          *********************************************************************************************************
    446          *                                  FIND OUT WHAT STATE A TIMER IS IN
    447          *
    448          * Description: This function is called to determine what state the timer is in:
    449          *
    450          *                  OS_TMR_STATE_UNUSED     the timer has not been created
    451          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
    452          *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
    453          *                  OS_TMR_STATE_RUNNING    the timer is currently running
    454          *
    455          * Arguments  : ptmr          Is a pointer to the desired timer
    456          *
    457          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    458          *                               OS_ERR_NONE
    459          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
    460          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
    461          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
    462          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
    463          *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
    464          *
    465          * Returns    : The current state of the timer (see description).
    466          *********************************************************************************************************
    467          */
    468          
    469          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    470          INT8U  OSTmrStateGet (OS_TMR  *ptmr,
    471                                INT8U   *perr)
    472          {
   \                     OSTmrStateGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    473              INT8U  state;
    474          
    475          
    476          #ifdef OS_SAFETY_CRITICAL
    477              if (perr == (INT8U *)0) {
    478                  OS_SAFETY_CRITICAL_EXCEPTION();
    479                  return (0u);
    480              }
    481          #endif
    482          
    483          #if OS_ARG_CHK_EN > 0u
    484              if (ptmr == (OS_TMR *)0) {
    485                  *perr = OS_ERR_TMR_INVALID;
    486                  return (0u);
    487              }
    488          #endif
    489              if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrStateGet_0
    490                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    491                  return (0u);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01B             B.N      ??OSTmrStateGet_1
    492              }
    493              if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
   \                     ??OSTmrStateGet_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrStateGet_2
    494                  *perr = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    495                  return (0u);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE012             B.N      ??OSTmrStateGet_1
    496              }
    497              OSSchedLock();
   \                     ??OSTmrStateGet_2:
   \   00000026   0x.... 0x....      BL       OSSchedLock
    498              state = ptmr->OSTmrState;
   \   0000002A   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   0000002E   0x0006             MOVS     R6,R0
    499              switch (state) {
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xD802             BHI.N    ??OSTmrStateGet_3
    500                  case OS_TMR_STATE_UNUSED:
    501                  case OS_TMR_STATE_STOPPED:
    502                  case OS_TMR_STATE_COMPLETED:
    503                  case OS_TMR_STATE_RUNNING:
    504                       *perr = OS_ERR_NONE;
   \                     ??OSTmrStateGet_4:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7028             STRB     R0,[R5, #+0]
    505                       break;
   \   0000003E   0xE001             B.N      ??OSTmrStateGet_5
    506          
    507                  default:
    508                       *perr = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStateGet_3:
   \   00000040   0x208D             MOVS     R0,#+141
   \   00000042   0x7028             STRB     R0,[R5, #+0]
    509                       break;
    510              }
    511              OSSchedUnlock();
   \                     ??OSTmrStateGet_5:
   \   00000044   0x.... 0x....      BL       OSSchedUnlock
    512              return (state);
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStateGet_1:
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    513          }
    514          #endif
    515          
    516          /*$PAGE*/
    517          /*
    518          *********************************************************************************************************
    519          *                                            START A TIMER
    520          *
    521          * Description: This function is called by your application code to start a timer.
    522          *
    523          * Arguments  : ptmr          Is a pointer to an OS_TMR
    524          *
    525          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    526          *                               OS_ERR_NONE
    527          *                               OS_ERR_TMR_INVALID
    528          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
    529          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
    530          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
    531          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    532          *
    533          * Returns    : OS_TRUE    if the timer was started
    534          *              OS_FALSE   if an error was detected
    535          *********************************************************************************************************
    536          */
    537          
    538          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    539          BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
    540                               INT8U    *perr)
    541          {
   \                     OSTmrStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    542          #ifdef OS_SAFETY_CRITICAL
    543              if (perr == (INT8U *)0) {
    544                  OS_SAFETY_CRITICAL_EXCEPTION();
    545                  return (OS_FALSE);
    546              }
    547          #endif
    548          
    549          #if OS_ARG_CHK_EN > 0u
    550              if (ptmr == (OS_TMR *)0) {
    551                  *perr = OS_ERR_TMR_INVALID;
    552                  return (OS_FALSE);
    553              }
    554          #endif
    555              if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2864             CMP      R0,#+100
   \   0000000A   0xD003             BEQ.N    ??OSTmrStart_0
    556                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   0000000C   0x2089             MOVS     R0,#+137
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    557                  return (OS_FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE035             B.N      ??OSTmrStart_1
    558              }
    559              if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
   \                     ??OSTmrStart_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??OSTmrStart_2
    560                  *perr  = OS_ERR_TMR_ISR;
   \   0000001E   0x208B             MOVS     R0,#+139
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    561                  return (OS_FALSE);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE02C             B.N      ??OSTmrStart_1
    562              }
    563              OSSchedLock();
   \                     ??OSTmrStart_2:
   \   00000026   0x.... 0x....      BL       OSSchedLock
    564              switch (ptmr->OSTmrState) {
   \   0000002A   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD01B             BEQ.N    ??OSTmrStart_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD00F             BEQ.N    ??OSTmrStart_4
   \   00000036   0xD30E             BCC.N    ??OSTmrStart_4
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD11C             BNE.N    ??OSTmrStart_5
    565                  case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
    566                       OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
   \                     ??OSTmrStart_6:
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       OSTmr_Unlink
    567                       OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       OSTmr_Link
    568                       OSSchedUnlock();
   \   0000004A   0x.... 0x....      BL       OSSchedUnlock
    569                       *perr = OS_ERR_NONE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7028             STRB     R0,[R5, #+0]
    570                       return (OS_TRUE);
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE014             B.N      ??OSTmrStart_1
    571          
    572                  case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
    573                  case OS_TMR_STATE_COMPLETED:
    574                       OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
   \                     ??OSTmrStart_4:
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       OSTmr_Link
    575                       OSSchedUnlock();
   \   0000005E   0x.... 0x....      BL       OSSchedUnlock
    576                       *perr = OS_ERR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7028             STRB     R0,[R5, #+0]
    577                       return (OS_TRUE);
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE00A             B.N      ??OSTmrStart_1
    578          
    579                  case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
    580                       OSSchedUnlock();
   \                     ??OSTmrStart_3:
   \   0000006A   0x.... 0x....      BL       OSSchedUnlock
    581                       *perr = OS_ERR_TMR_INACTIVE;
   \   0000006E   0x2087             MOVS     R0,#+135
   \   00000070   0x7028             STRB     R0,[R5, #+0]
    582                       return (OS_FALSE);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE004             B.N      ??OSTmrStart_1
    583          
    584                  default:
    585                       OSSchedUnlock();
   \                     ??OSTmrStart_5:
   \   00000076   0x.... 0x....      BL       OSSchedUnlock
    586                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   0000007A   0x208D             MOVS     R0,#+141
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
    587                       return (OS_FALSE);
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??OSTmrStart_1:
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    588              }
    589          }
    590          #endif
    591          
    592          /*$PAGE*/
    593          /*
    594          *********************************************************************************************************
    595          *                                            STOP A TIMER
    596          *
    597          * Description: This function is called by your application code to stop a timer.
    598          *
    599          * Arguments  : ptmr          Is a pointer to the timer to stop.
    600          *
    601          *              opt           Allows you to specify an option to this functions which can be:
    602          *
    603          *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
    604          *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
    605          *                                                        callback argument specified when the timer 
    606          *                                                        was created.
    607          *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
    608          *                                                        callback argument specified in THIS function call.
    609          *
    610          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
    611          *                            function instead of the timer's callback argument.  In other words, use 
    612          *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
    613          *
    614          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
    615          *                               OS_ERR_NONE
    616          *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
    617          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
    618          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
    619          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
    620          *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
    621          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
    622          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    623          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
    624          *
    625          * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
    626          *              OS_FALSE      If not
    627          *********************************************************************************************************
    628          */
    629          
    630          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    631          BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
    632                              INT8U    opt,
    633                              void    *callback_arg,
    634                              INT8U   *perr)
    635          {
   \                     OSTmrStop:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    636              OS_TMR_CALLBACK  pfnct;
    637          
    638          
    639          #ifdef OS_SAFETY_CRITICAL
    640              if (perr == (INT8U *)0) {
    641                  OS_SAFETY_CRITICAL_EXCEPTION();
    642                  return (OS_FALSE);
    643              }
    644          #endif
    645          
    646          #if OS_ARG_CHK_EN > 0u
    647              if (ptmr == (OS_TMR *)0) {
    648                  *perr = OS_ERR_TMR_INVALID;
    649                  return (OS_FALSE);
    650              }
    651          #endif
    652              if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2864             CMP      R0,#+100
   \   00000010   0xD003             BEQ.N    ??OSTmrStop_0
    653                  *perr = OS_ERR_TMR_INVALID_TYPE;
   \   00000012   0x2089             MOVS     R0,#+137
   \   00000014   0x7038             STRB     R0,[R7, #+0]
    654                  return (OS_FALSE);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE051             B.N      ??OSTmrStop_1
    655              }
    656              if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
   \                     ??OSTmrStop_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??OSTmrStop_2
    657                  *perr  = OS_ERR_TMR_ISR;
   \   00000024   0x208B             MOVS     R0,#+139
   \   00000026   0x7038             STRB     R0,[R7, #+0]
    658                  return (OS_FALSE);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE048             B.N      ??OSTmrStop_1
    659              }
    660              OSSchedLock();
   \                     ??OSTmrStop_2:
   \   0000002C   0x.... 0x....      BL       OSSchedLock
    661              switch (ptmr->OSTmrState) {
   \   00000030   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD037             BEQ.N    ??OSTmrStop_3
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD02F             BEQ.N    ??OSTmrStop_4
   \   0000003C   0xD32E             BCC.N    ??OSTmrStop_4
   \   0000003E   0x2803             CMP      R0,#+3
   \   00000040   0xD138             BNE.N    ??OSTmrStop_5
    662                  case OS_TMR_STATE_RUNNING:
    663                       OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
   \                     ??OSTmrStop_6:
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       OSTmr_Unlink
    664                       *perr = OS_ERR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7038             STRB     R0,[R7, #+0]
    665                       switch (opt) {
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD01C             BEQ.N    ??OSTmrStop_7
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD002             BEQ.N    ??OSTmrStop_8
   \   00000058   0x2804             CMP      R0,#+4
   \   0000005A   0xD00C             BEQ.N    ??OSTmrStop_9
   \   0000005C   0xE018             B.N      ??OSTmrStop_10
    666                           case OS_TMR_OPT_CALLBACK:
    667                                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
   \                     ??OSTmrStop_8:
   \   0000005E   0x6860             LDR      R0,[R4, #+4]
   \   00000060   0x4680             MOV      R8,R0
    668                                if (pfnct != (OS_TMR_CALLBACK)0) {
   \   00000062   0x4640             MOV      R0,R8
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD003             BEQ.N    ??OSTmrStop_11
    669                                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
   \   00000068   0x68A1             LDR      R1,[R4, #+8]
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x47C0             BLX      R8
   \   0000006E   0xE001             B.N      ??OSTmrStop_12
    670                                } else {
    671                                    *perr = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_11:
   \   00000070   0x208F             MOVS     R0,#+143
   \   00000072   0x7038             STRB     R0,[R7, #+0]
    672                                }
    673                                break;
   \                     ??OSTmrStop_12:
   \   00000074   0xE00E             B.N      ??OSTmrStop_13
    674          
    675                           case OS_TMR_OPT_CALLBACK_ARG:
    676                                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
   \                     ??OSTmrStop_9:
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0x4680             MOV      R8,R0
    677                                if (pfnct != (OS_TMR_CALLBACK)0) {
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD003             BEQ.N    ??OSTmrStop_14
    678                                    (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x47C0             BLX      R8
   \   00000086   0xE001             B.N      ??OSTmrStop_15
    679                                } else {
    680                                    *perr = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_14:
   \   00000088   0x208F             MOVS     R0,#+143
   \   0000008A   0x7038             STRB     R0,[R7, #+0]
    681                                }
    682                                break;
   \                     ??OSTmrStop_15:
   \   0000008C   0xE002             B.N      ??OSTmrStop_13
    683          
    684                           case OS_TMR_OPT_NONE:
    685                                break;
   \                     ??OSTmrStop_7:
   \   0000008E   0xE001             B.N      ??OSTmrStop_13
    686          
    687                           default:
    688                               *perr = OS_ERR_TMR_INVALID_OPT;
   \                     ??OSTmrStop_10:
   \   00000090   0x2084             MOVS     R0,#+132
   \   00000092   0x7038             STRB     R0,[R7, #+0]
    689                               break;
    690                       }
    691                       OSSchedUnlock();
   \                     ??OSTmrStop_13:
   \   00000094   0x.... 0x....      BL       OSSchedUnlock
    692                       return (OS_TRUE);
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE010             B.N      ??OSTmrStop_1
    693          
    694                  case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
    695                  case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
    696                       OSSchedUnlock();
   \                     ??OSTmrStop_4:
   \   0000009C   0x.... 0x....      BL       OSSchedUnlock
    697                       *perr = OS_ERR_TMR_STOPPED;
   \   000000A0   0x208E             MOVS     R0,#+142
   \   000000A2   0x7038             STRB     R0,[R7, #+0]
    698                       return (OS_TRUE);
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE00A             B.N      ??OSTmrStop_1
    699          
    700                  case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
    701                       OSSchedUnlock();
   \                     ??OSTmrStop_3:
   \   000000A8   0x.... 0x....      BL       OSSchedUnlock
    702                       *perr = OS_ERR_TMR_INACTIVE;
   \   000000AC   0x2087             MOVS     R0,#+135
   \   000000AE   0x7038             STRB     R0,[R7, #+0]
    703                       return (OS_FALSE);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE004             B.N      ??OSTmrStop_1
    704          
    705                  default:
    706                       OSSchedUnlock();
   \                     ??OSTmrStop_5:
   \   000000B4   0x.... 0x....      BL       OSSchedUnlock
    707                       *perr = OS_ERR_TMR_INVALID_STATE;
   \   000000B8   0x208D             MOVS     R0,#+141
   \   000000BA   0x7038             STRB     R0,[R7, #+0]
    708                       return (OS_FALSE);
   \   000000BC   0x2000             MOVS     R0,#+0
   \                     ??OSTmrStop_1:
   \   000000BE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    709              }
    710          }
    711          #endif
    712          
    713          /*$PAGE*/
    714          /*
    715          *********************************************************************************************************
    716          *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
    717          *
    718          * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
    719          *              used to signal to OSTmr_Task() that it's time to update the timers.
    720          *
    721          * Arguments  : none
    722          *
    723          * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
    724          *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
    725          *                                  the timers. This would indicate that your system is heavily loaded.
    726          *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
    727          *                                  signaling is created by uC/OS-II.
    728          *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
    729          *                                  used for signaling is created by uC/OS-II.
    730          *********************************************************************************************************
    731          */
    732          
    733          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    734          INT8U  OSTmrSignal (void)
    735          {
   \                     OSTmrSignal:
   \   00000000   0xB510             PUSH     {R4,LR}
    736              INT8U  err;
    737          
    738          
    739              err = OSSemPost(OSTmrSemSignal);
   \   00000002   0x....             LDR.N    R0,??DataTable14_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSSemPost
   \   0000000A   0x0004             MOVS     R4,R0
    740              return (err);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    741          }
    742          #endif
    743          
    744          /*$PAGE*/
    745          /*
    746          *********************************************************************************************************
    747          *                                      ALLOCATE AND FREE A TIMER
    748          *
    749          * Description: This function is called to allocate a timer.
    750          *
    751          * Arguments  : none
    752          *
    753          * Returns    : a pointer to a timer if one is available
    754          *********************************************************************************************************
    755          */
    756          
    757          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    758          static  OS_TMR  *OSTmr_Alloc (void)
    759          {
    760              OS_TMR *ptmr;
    761          
    762          
    763              if (OSTmrFreeList == (OS_TMR *)0) {
   \                     OSTmr_Alloc:
   \   00000000   0x....             LDR.N    R0,??DataTable14_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE.N    ??OSTmr_Alloc_0
    764                  return ((OS_TMR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE014             B.N      ??OSTmr_Alloc_1
    765              }
    766              ptmr            = (OS_TMR *)OSTmrFreeList;
   \                     ??OSTmr_Alloc_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable14_4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0001             MOVS     R1,R0
    767              OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
   \   00000012   0x68C8             LDR      R0,[R1, #+12]
   \   00000014   0x....             LDR.N    R2,??DataTable14_4
   \   00000016   0x6010             STR      R0,[R2, #+0]
    768              ptmr->OSTmrNext = (OS_TCB *)0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x60C8             STR      R0,[R1, #+12]
    769              ptmr->OSTmrPrev = (OS_TCB *)0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6108             STR      R0,[R1, #+16]
    770              OSTmrUsed++;
   \   00000020   0x....             LDR.N    R0,??DataTable14_5
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R2,??DataTable14_5
   \   00000028   0x8010             STRH     R0,[R2, #+0]
    771              OSTmrFree--;
   \   0000002A   0x....             LDR.N    R0,??DataTable14_6
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x....             LDR.N    R2,??DataTable14_6
   \   00000032   0x8010             STRH     R0,[R2, #+0]
    772              return (ptmr);
   \   00000034   0x0008             MOVS     R0,R1
   \                     ??OSTmr_Alloc_1:
   \   00000036   0x4770             BX       LR               ;; return
    773          }
    774          #endif
    775          
    776          
    777          /*
    778          *********************************************************************************************************
    779          *                                   RETURN A TIMER TO THE FREE LIST
    780          *
    781          * Description: This function is called to return a timer object to the free list of timers.
    782          *
    783          * Arguments  : ptmr     is a pointer to the timer to free
    784          *
    785          * Returns    : none
    786          *********************************************************************************************************
    787          */
    788          
    789          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    790          static  void  OSTmr_Free (OS_TMR *ptmr)
    791          {
    792              ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
   \                     OSTmr_Free:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1025      STRB     R1,[R0, #+37]
    793              ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF880 0x1024      STRB     R1,[R0, #+36]
    794              ptmr->OSTmrPeriod      = 0u;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
    795              ptmr->OSTmrMatch       = 0u;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6141             STR      R1,[R0, #+20]
    796              ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6041             STR      R1,[R0, #+4]
    797              ptmr->OSTmrCallbackArg = (void *)0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
    798          #if OS_TMR_CFG_NAME_EN > 0u
    799              ptmr->OSTmrName        = (INT8U *)(void *)"?";
   \   0000001C   0x....             ADR.N    R1,??DataTable14  ;; "\?"
   \   0000001E   0x6201             STR      R1,[R0, #+32]
    800          #endif
    801          
    802              ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6101             STR      R1,[R0, #+16]
    803              ptmr->OSTmrNext        = OSTmrFreeList;
   \   00000024   0x....             LDR.N    R1,??DataTable14_4
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x60C1             STR      R1,[R0, #+12]
    804              OSTmrFreeList          = ptmr;
   \   0000002A   0x....             LDR.N    R1,??DataTable14_4
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    805          
    806              OSTmrUsed--;                                       /* Update timer object statistics                              */
   \   0000002E   0x....             LDR.N    R1,??DataTable14_5
   \   00000030   0x8809             LDRH     R1,[R1, #+0]
   \   00000032   0x1E49             SUBS     R1,R1,#+1
   \   00000034   0x....             LDR.N    R2,??DataTable14_5
   \   00000036   0x8011             STRH     R1,[R2, #+0]
    807              OSTmrFree++;
   \   00000038   0x....             LDR.N    R1,??DataTable14_6
   \   0000003A   0x8809             LDRH     R1,[R1, #+0]
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x....             LDR.N    R2,??DataTable14_6
   \   00000040   0x8011             STRH     R1,[R2, #+0]
    808          }
   \   00000042   0x4770             BX       LR               ;; return
    809          #endif
    810          
    811          /*$PAGE*/
    812          /*
    813          *********************************************************************************************************
    814          *                                                    INITIALIZATION
    815          *                                          INITIALIZE THE FREE LIST OF TIMERS
    816          *
    817          * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
    818          *
    819          * Arguments  : none
    820          *
    821          * Returns    : none
    822          *********************************************************************************************************
    823          */
    824          
    825          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    826          void  OSTmr_Init (void)
    827          {
   \                     OSTmr_Init:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    828          #if OS_EVENT_NAME_EN > 0u
    829              INT8U    err;
    830          #endif
    831              INT16U   ix;
    832              INT16U   ix_next;
    833              OS_TMR  *ptmr1;
    834              OS_TMR  *ptmr2;
    835          
    836          
    837              OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
   \   00000002   0xF44F 0x7120      MOV      R1,#+640
   \   00000006   0x....             LDR.N    R0,??DataTable14_7
   \   00000008   0x.... 0x....      BL       OS_MemClr
    838              OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
   \   0000000C   0x2140             MOVS     R1,#+64
   \   0000000E   0x....             LDR.N    R0,??DataTable14_8
   \   00000010   0x.... 0x....      BL       OS_MemClr
    839          
    840              for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0004             MOVS     R4,R0
   \                     ??OSTmr_Init_0:
   \   00000018   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001A   0x2C0F             CMP      R4,#+15
   \   0000001C   0xD217             BCS.N    ??OSTmr_Init_1
    841                  ix_next = ix + 1u;
   \   0000001E   0x1C60             ADDS     R0,R4,#+1
   \   00000020   0x0005             MOVS     R5,R0
    842                  ptmr1 = &OSTmrTbl[ix];
   \   00000022   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000024   0x2028             MOVS     R0,#+40
   \   00000026   0x....             LDR.N    R1,??DataTable14_7
   \   00000028   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002C   0x0006             MOVS     R6,R0
    843                  ptmr2 = &OSTmrTbl[ix_next];
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2028             MOVS     R0,#+40
   \   00000032   0x....             LDR.N    R1,??DataTable14_7
   \   00000034   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000038   0x0007             MOVS     R7,R0
    844                  ptmr1->OSTmrType    = OS_TMR_TYPE;
   \   0000003A   0x2064             MOVS     R0,#+100
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
    845                  ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF886 0x0025      STRB     R0,[R6, #+37]
    846                  ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
   \   00000044   0x60F7             STR      R7,[R6, #+12]
    847          #if OS_TMR_CFG_NAME_EN > 0u
    848                  ptmr1->OSTmrName    = (INT8U *)(void *)"?";
   \   00000046   0x....             ADR.N    R0,??DataTable14  ;; "\?"
   \   00000048   0x6230             STR      R0,[R6, #+32]
    849          #endif
    850              }
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0xE7E4             B.N      ??OSTmr_Init_0
    851              ptmr1               = &OSTmrTbl[ix];
   \                     ??OSTmr_Init_1:
   \   0000004E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000050   0x2028             MOVS     R0,#+40
   \   00000052   0x....             LDR.N    R1,??DataTable14_7
   \   00000054   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000058   0x0006             MOVS     R6,R0
    852              ptmr1->OSTmrType    = OS_TMR_TYPE;
   \   0000005A   0x2064             MOVS     R0,#+100
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
    853              ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF886 0x0025      STRB     R0,[R6, #+37]
    854              ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x60F0             STR      R0,[R6, #+12]
    855          #if OS_TMR_CFG_NAME_EN > 0u
    856              ptmr1->OSTmrName    = (INT8U *)(void *)"?";
   \   00000068   0x....             ADR.N    R0,??DataTable14  ;; "\?"
   \   0000006A   0x6230             STR      R0,[R6, #+32]
    857          #endif
    858              OSTmrTime           = 0u;
   \   0000006C   0x....             LDR.N    R0,??DataTable14_2
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x6001             STR      R1,[R0, #+0]
    859              OSTmrUsed           = 0u;
   \   00000072   0x....             LDR.N    R0,??DataTable14_5
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x8001             STRH     R1,[R0, #+0]
    860              OSTmrFree           = OS_TMR_CFG_MAX;
   \   00000078   0x....             LDR.N    R0,??DataTable14_6
   \   0000007A   0x2110             MOVS     R1,#+16
   \   0000007C   0x8001             STRH     R1,[R0, #+0]
    861              OSTmrFreeList       = &OSTmrTbl[0];
   \   0000007E   0x....             LDR.N    R0,??DataTable14_4
   \   00000080   0x....             LDR.N    R1,??DataTable14_7
   \   00000082   0x6001             STR      R1,[R0, #+0]
    862              OSTmrSem            = OSSemCreate(1u);
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       OSSemCreate
   \   0000008A   0x....             LDR.N    R1,??DataTable14_9
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    863              OSTmrSemSignal      = OSSemCreate(0u);
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       OSSemCreate
   \   00000094   0x....             LDR.N    R1,??DataTable14_3
   \   00000096   0x6008             STR      R0,[R1, #+0]
    864          
    865          #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
    866              OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
   \   00000098   0xAA00             ADD      R2,SP,#+0
   \   0000009A   0x....             LDR.N    R1,??DataTable14_10
   \   0000009C   0x....             LDR.N    R0,??DataTable14_9
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       OSEventNameSet
    867              OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
   \   000000A4   0xAA00             ADD      R2,SP,#+0
   \   000000A6   0x....             LDR.N    R1,??DataTable14_11
   \   000000A8   0x....             LDR.N    R0,??DataTable14_3
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x.... 0x....      BL       OSEventNameSet
    868          #endif
    869          
    870              OSTmr_InitTask();
   \   000000B0   0x.... 0x....      BL       OSTmr_InitTask
    871          }
   \   000000B4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    872          #endif
    873          
    874          /*$PAGE*/
    875          /*
    876          *********************************************************************************************************
    877          *                                INITIALIZE THE TIMER MANAGEMENT TASK
    878          *
    879          * Description: This function is called by OSTmrInit() to create the timer management task.
    880          *                               * Arguments  : none
    881          *
    882          * Returns    : none
    883          *********************************************************************************************************
    884          */
    885          
    886          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    887          static  void  OSTmr_InitTask (void)
    888          {
   \                     OSTmr_InitTask:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    889          #if OS_TASK_NAME_EN > 0u
    890              INT8U  err;
    891          #endif
    892          
    893          
    894          #if OS_TASK_CREATE_EXT_EN > 0u
    895              #if OS_STK_GROWTH == 1u
    896              (void)OSTaskCreateExt(OSTmr_Task,
    897                                    (void *)0,                                       /* No arguments passed to OSTmrTask()      */
    898                                    &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
    899                                    OS_TASK_TMR_PRIO,
    900                                    OS_TASK_TMR_ID,
    901                                    &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
    902                                    OS_TASK_TMR_STK_SIZE,
    903                                    (void *)0,                                       /* No TCB extension                        */
    904                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x9004             STR      R0,[SP, #+16]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x....             LDR.N    R0,??DataTable14_12
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x233D             MOVS     R3,#+61
   \   0000001C   0x....             LDR.N    R2,??DataTable14_13
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      ADR.W    R0,OSTmr_Task
   \   00000024   0x.... 0x....      BL       OSTaskCreateExt
   \   00000028   0x0004             MOVS     R4,R0
    905              #else
    906              (void)OSTaskCreateExt(OSTmr_Task,
    907                                    (void *)0,                                       /* No arguments passed to OSTmrTask()      */
    908                                    &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
    909                                    OS_TASK_TMR_PRIO,
    910                                    OS_TASK_TMR_ID,
    911                                    &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
    912                                    OS_TASK_TMR_STK_SIZE,
    913                                    (void *)0,                                       /* No TCB extension                        */
    914                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
    915              #endif
    916          #else
    917              #if OS_STK_GROWTH == 1u
    918              (void)OSTaskCreate(OSTmr_Task,
    919                                 (void *)0,
    920                                 &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
    921                                 OS_TASK_TMR_PRIO);
    922              #else
    923              (void)OSTaskCreate(OSTmr_Task,
    924                                 (void *)0,
    925                                 &OSTmrTaskStk[0],
    926                                 OS_TASK_TMR_PRIO);
    927              #endif
    928          #endif
    929          
    930          #if OS_TASK_NAME_EN > 0u
    931              OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
   \   0000002A   0xAA05             ADD      R2,SP,#+20
   \   0000002C   0x....             LDR.N    R1,??DataTable14_14
   \   0000002E   0x203D             MOVS     R0,#+61
   \   00000030   0x.... 0x....      BL       OSTaskNameSet
    932          #endif
    933          }
   \   00000034   0xB006             ADD      SP,SP,#+24
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    934          #endif
    935          
    936          /*$PAGE*/
    937          /*
    938          *********************************************************************************************************
    939          *                                 INSERT A TIMER INTO THE TIMER WHEEL
    940          *
    941          * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
    942          *              inserted at the beginning of the list.
    943          *
    944          * Arguments  : ptmr          Is a pointer to the timer to insert.
    945          *
    946          *              type          Is either:
    947          *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
    948          *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
    949          *
    950          * Returns    : none
    951          *********************************************************************************************************
    952          */
    953          
    954          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    955          static  void  OSTmr_Link (OS_TMR  *ptmr,
    956                                    INT8U    type)
    957          {
   \                     OSTmr_Link:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    958              OS_TMR       *ptmr1;
    959              OS_TMR_WHEEL *pspoke;
    960              INT16U        spoke;
    961          
    962          
    963              ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
   \   00000002   0x2503             MOVS     R5,#+3
   \   00000004   0xF880 0x5025      STRB     R5,[R0, #+37]
    964              if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD105             BNE.N    ??OSTmr_Link_0
    965                  ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
   \   0000000E   0x69C5             LDR      R5,[R0, #+28]
   \   00000010   0x....             LDR.N    R6,??DataTable14_2
   \   00000012   0x6836             LDR      R6,[R6, #+0]
   \   00000014   0x1975             ADDS     R5,R6,R5
   \   00000016   0x6145             STR      R5,[R0, #+20]
   \   00000018   0xE00D             B.N      ??OSTmr_Link_1
    966              } else {
    967                  if (ptmr->OSTmrDly == 0u) {
   \                     ??OSTmr_Link_0:
   \   0000001A   0x6985             LDR      R5,[R0, #+24]
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD105             BNE.N    ??OSTmr_Link_2
    968                      ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
   \   00000020   0x69C5             LDR      R5,[R0, #+28]
   \   00000022   0x....             LDR.N    R6,??DataTable14_2
   \   00000024   0x6836             LDR      R6,[R6, #+0]
   \   00000026   0x1975             ADDS     R5,R6,R5
   \   00000028   0x6145             STR      R5,[R0, #+20]
   \   0000002A   0xE004             B.N      ??OSTmr_Link_1
    969                  } else {
    970                      ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
   \                     ??OSTmr_Link_2:
   \   0000002C   0x6985             LDR      R5,[R0, #+24]
   \   0000002E   0x....             LDR.N    R6,??DataTable14_2
   \   00000030   0x6836             LDR      R6,[R6, #+0]
   \   00000032   0x1975             ADDS     R5,R6,R5
   \   00000034   0x6145             STR      R5,[R0, #+20]
    971                  }
    972              }
    973              spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
   \                     ??OSTmr_Link_1:
   \   00000036   0x6945             LDR      R5,[R0, #+20]
   \   00000038   0x2608             MOVS     R6,#+8
   \   0000003A   0xFBB5 0xF7F6      UDIV     R7,R5,R6
   \   0000003E   0xFB07 0x5716      MLS      R7,R7,R6,R5
   \   00000042   0x003C             MOVS     R4,R7
    974              pspoke = &OSTmrWheelTbl[spoke];
   \   00000044   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000046   0x....             LDR.N    R5,??DataTable14_8
   \   00000048   0xEB15 0x05C4      ADDS     R5,R5,R4, LSL #+3
   \   0000004C   0x002B             MOVS     R3,R5
    975          
    976              if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
   \   0000004E   0x681D             LDR      R5,[R3, #+0]
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD105             BNE.N    ??OSTmr_Link_3
    977                  pspoke->OSTmrFirst   = ptmr;
   \   00000054   0x6018             STR      R0,[R3, #+0]
    978                  ptmr->OSTmrNext      = (OS_TMR *)0;
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0x60C5             STR      R5,[R0, #+12]
    979                  pspoke->OSTmrEntries = 1u;
   \   0000005A   0x2501             MOVS     R5,#+1
   \   0000005C   0x809D             STRH     R5,[R3, #+4]
   \   0000005E   0xE007             B.N      ??OSTmr_Link_4
    980              } else {
    981                  ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
   \                     ??OSTmr_Link_3:
   \   00000060   0x681D             LDR      R5,[R3, #+0]
   \   00000062   0x002A             MOVS     R2,R5
    982                  pspoke->OSTmrFirst   = ptmr;
   \   00000064   0x6018             STR      R0,[R3, #+0]
    983                  ptmr->OSTmrNext      = (void *)ptmr1;
   \   00000066   0x60C2             STR      R2,[R0, #+12]
    984                  ptmr1->OSTmrPrev     = (void *)ptmr;
   \   00000068   0x6110             STR      R0,[R2, #+16]
    985                  pspoke->OSTmrEntries++;
   \   0000006A   0x889D             LDRH     R5,[R3, #+4]
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \   0000006E   0x809D             STRH     R5,[R3, #+4]
    986              }
    987              ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
   \                     ??OSTmr_Link_4:
   \   00000070   0x2500             MOVS     R5,#+0
   \   00000072   0x6105             STR      R5,[R0, #+16]
    988          }
   \   00000074   0xBCF0             POP      {R4-R7}
   \   00000076   0x4770             BX       LR               ;; return
    989          #endif
    990          
    991          /*$PAGE*/
    992          /*
    993          *********************************************************************************************************
    994          *                                 REMOVE A TIMER FROM THE TIMER WHEEL
    995          *
    996          * Description: This function is called to remove the timer from the timer wheel.
    997          *
    998          * Arguments  : ptmr          Is a pointer to the timer to remove.
    999          *
   1000          * Returns    : none
   1001          *********************************************************************************************************
   1002          */
   1003          
   1004          #if OS_TMR_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1005          static  void  OSTmr_Unlink (OS_TMR *ptmr)
   1006          {
   \                     OSTmr_Unlink:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1007              OS_TMR        *ptmr1;
   1008              OS_TMR        *ptmr2;
   1009              OS_TMR_WHEEL  *pspoke;
   1010              INT16U         spoke;
   1011          
   1012          
   1013              spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
   \   00000002   0x6945             LDR      R5,[R0, #+20]
   \   00000004   0x2608             MOVS     R6,#+8
   \   00000006   0xFBB5 0xF7F6      UDIV     R7,R5,R6
   \   0000000A   0xFB07 0x5716      MLS      R7,R7,R6,R5
   \   0000000E   0x003C             MOVS     R4,R7
   1014              pspoke = &OSTmrWheelTbl[spoke];
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x....             LDR.N    R5,??DataTable14_8
   \   00000014   0xEB15 0x05C4      ADDS     R5,R5,R4, LSL #+3
   \   00000018   0x002B             MOVS     R3,R5
   1015          
   1016              if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
   \   0000001A   0x681D             LDR      R5,[R3, #+0]
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD107             BNE.N    ??OSTmr_Unlink_0
   1017                  ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
   \   00000020   0x68C5             LDR      R5,[R0, #+12]
   \   00000022   0x0029             MOVS     R1,R5
   1018                  pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
   \   00000024   0x6019             STR      R1,[R3, #+0]
   1019                  if (ptmr1 != (OS_TMR *)0) {
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD00A             BEQ.N    ??OSTmr_Unlink_1
   1020                      ptmr1->OSTmrPrev = (void *)0;
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x610D             STR      R5,[R1, #+16]
   \   0000002E   0xE007             B.N      ??OSTmr_Unlink_1
   1021                  }
   1022              } else {
   1023                  ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
   \                     ??OSTmr_Unlink_0:
   \   00000030   0x6905             LDR      R5,[R0, #+16]
   \   00000032   0x0029             MOVS     R1,R5
   1024                  ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
   \   00000034   0x68C5             LDR      R5,[R0, #+12]
   \   00000036   0x002A             MOVS     R2,R5
   1025                  ptmr1->OSTmrNext = ptmr2;
   \   00000038   0x60CA             STR      R2,[R1, #+12]
   1026                  if (ptmr2 != (OS_TMR *)0) {
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD000             BEQ.N    ??OSTmr_Unlink_1
   1027                      ptmr2->OSTmrPrev = (void *)ptmr1;
   \   0000003E   0x6111             STR      R1,[R2, #+16]
   1028                  }
   1029              }
   1030              ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
   \                     ??OSTmr_Unlink_1:
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xF880 0x5025      STRB     R5,[R0, #+37]
   1031              ptmr->OSTmrNext  = (void *)0;
   \   00000046   0x2500             MOVS     R5,#+0
   \   00000048   0x60C5             STR      R5,[R0, #+12]
   1032              ptmr->OSTmrPrev  = (void *)0;
   \   0000004A   0x2500             MOVS     R5,#+0
   \   0000004C   0x6105             STR      R5,[R0, #+16]
   1033              pspoke->OSTmrEntries--;
   \   0000004E   0x889D             LDRH     R5,[R3, #+4]
   \   00000050   0x1E6D             SUBS     R5,R5,#+1
   \   00000052   0x809D             STRH     R5,[R3, #+4]
   1034          }
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
   1035          #endif
   1036          
   1037          /*$PAGE*/
   1038          /*
   1039          *********************************************************************************************************
   1040          *                                        TIMER MANAGEMENT TASK
   1041          *
   1042          * Description: This task is created by OSTmrInit().
   1043          *
   1044          * Arguments  : none
   1045          *
   1046          * Returns    : none
   1047          *********************************************************************************************************
   1048          */
   1049          
   1050          #if OS_TMR_EN > 0u

   \                                 In section .text, align 4, keep-with-next
   1051          static  void  OSTmr_Task (void *p_arg)
   1052          {
   \                     OSTmr_Task:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   1053              INT8U            err;
   1054              OS_TMR          *ptmr;
   1055              OS_TMR          *ptmr_next;
   1056              OS_TMR_CALLBACK  pfnct;
   1057              OS_TMR_WHEEL    *pspoke;
   1058              INT16U           spoke;
   1059          
   1060          
   1061              p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
   1062              for (;;) {
   1063                  OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
   \                     ??OSTmr_Task_0:
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable14_3
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       OSSemPend
   1064                  OSSchedLock();
   \   00000012   0x.... 0x....      BL       OSSchedLock
   1065                  OSTmrTime++;                                             /* Increment the current time                        */
   \   00000016   0x....             LDR.N    R0,??DataTable14_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable14_2
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1066                  spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
   \   00000020   0x....             LDR.N    R0,??DataTable14_2
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000002A   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000002E   0x4690             MOV      R8,R2
   1067                  pspoke = &OSTmrWheelTbl[spoke];
   \   00000030   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000034   0x....             LDR.N    R0,??DataTable14_8
   \   00000036   0xEB10 0x00C8      ADDS     R0,R0,R8, LSL #+3
   \   0000003A   0x0007             MOVS     R7,R0
   1068                  ptmr   = pspoke->OSTmrFirst;
   \   0000003C   0x6838             LDR      R0,[R7, #+0]
   \   0000003E   0x0004             MOVS     R4,R0
   1069                  while (ptmr != (OS_TMR *)0) {
   \                     ??OSTmr_Task_1:
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD01F             BEQ.N    ??OSTmr_Task_2
   1070                      ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0x0005             MOVS     R5,R0
   1071                                                                           /* ... timer could get unlinked from the wheel.      */
   1072                      if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
   \   00000048   0x....             LDR.N    R0,??DataTable14_2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6961             LDR      R1,[R4, #+20]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD116             BNE.N    ??OSTmr_Task_3
   1073                          OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OSTmr_Unlink
   1074                          if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
   \   00000058   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD104             BNE.N    ??OSTmr_Task_4
   1075                              OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       OSTmr_Link
   \   00000068   0xE002             B.N      ??OSTmr_Task_5
   1076                          } else {
   1077                              ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
   \                     ??OSTmr_Task_4:
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0xF884 0x0025      STRB     R0,[R4, #+37]
   1078                          }
   1079                          pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
   \                     ??OSTmr_Task_5:
   \   00000070   0x6860             LDR      R0,[R4, #+4]
   \   00000072   0x0006             MOVS     R6,R0
   1080                          if (pfnct != (OS_TMR_CALLBACK)0) {
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ.N    ??OSTmr_Task_3
   1081                              (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
   \   0000007A   0x68A1             LDR      R1,[R4, #+8]
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x47B0             BLX      R6
   1082                          }
   1083                      }
   1084                      ptmr = ptmr_next;
   \                     ??OSTmr_Task_3:
   \   00000080   0x002C             MOVS     R4,R5
   \   00000082   0xE7DD             B.N      ??OSTmr_Task_1
   1085                  }
   1086                  OSSchedUnlock();
   \                     ??OSTmr_Task_2:
   \   00000084   0x.... 0x....      BL       OSSchedUnlock
   \   00000088   0xE7BD             B.N      ??OSTmr_Task_0
   1087              }
   1088          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     OSTmrTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     OSTmrSemSignal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     OSTmrFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     OSTmrUsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     OSTmrFree

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     OSTmrTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     OSTmrWheelTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     OSTmrSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II TmrLock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II TmrSignal">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     OSTmrTaskStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     OSTmrTaskStk+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     `?<Constant "uC/OS-II Tmr">`

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II TmrLock">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II TmrLock"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x54    
   \              0x6D 0x72    
   \              0x4C 0x6F    
   \              0x63 0x6B    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II TmrSignal">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II TmrSignal"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x54    
   \              0x6D 0x72    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "uC/OS-II Tmr">`:
   \   00000000   0x75 0x43          DC8 "uC/OS-II Tmr"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x20 0x54    
   \              0x6D 0x72    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1089          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSTmrCreate
        40   -> OSSchedLock
        40   -> OSSchedUnlock
        40   -> OSTmr_Alloc
      16   OSTmrDel
        16   -> OSSchedLock
        16   -> OSSchedUnlock
        16   -> OSTmr_Free
        16   -> OSTmr_Unlink
      24   OSTmrNameGet
        24   -> OSSchedLock
        24   -> OSSchedUnlock
        24   -> OS_StrLen
      16   OSTmrRemainGet
        16   -> OSSchedLock
        16   -> OSSchedUnlock
       8   OSTmrSignal
         8   -> OSSemPost
      16   OSTmrStart
        16   -> OSSchedLock
        16   -> OSSchedUnlock
        16   -> OSTmr_Link
        16   -> OSTmr_Unlink
      16   OSTmrStateGet
        16   -> OSSchedLock
        16   -> OSSchedUnlock
      24   OSTmrStop
        24   -- Indirect call
        24   -> OSSchedLock
        24   -> OSSchedUnlock
        24   -> OSTmr_Unlink
       0   OSTmr_Alloc
       0   OSTmr_Free
      24   OSTmr_Init
        24   -> OSEventNameSet
        24   -> OSSemCreate
        24   -> OSTmr_InitTask
        24   -> OS_MemClr
      32   OSTmr_InitTask
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet
      16   OSTmr_Link
      32   OSTmr_Task
        32   -- Indirect call
        32   -> OSSchedLock
        32   -> OSSchedUnlock
        32   -> OSSemPend
        32   -> OSTmr_Link
        32   -> OSTmr_Unlink
      16   OSTmr_Unlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
      16  ?<Constant "uC/OS-II Tmr">
      20  ?<Constant "uC/OS-II TmrLock">
      20  ?<Constant "uC/OS-II TmrSignal">
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable5
     134  OSTmrCreate
     126  OSTmrDel
     108  OSTmrNameGet
     170  OSTmrRemainGet
      18  OSTmrSignal
     130  OSTmrStart
      78  OSTmrStateGet
     194  OSTmrStop
      56  OSTmr_Alloc
      68  OSTmr_Free
     182  OSTmr_Init
      56  OSTmr_InitTask
     120  OSTmr_Link
     138  OSTmr_Task
      88  OSTmr_Unlink

 
    58 bytes in section .rodata
 1 730 bytes in section .text
 
 1 730 bytes of CODE  memory
    58 bytes of CONST memory

Errors: none
Warnings: none

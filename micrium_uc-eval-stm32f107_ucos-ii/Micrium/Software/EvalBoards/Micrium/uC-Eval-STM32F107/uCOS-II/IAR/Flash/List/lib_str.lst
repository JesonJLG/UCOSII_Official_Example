###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:20 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uC-LIB\lib_str.c                 #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uC-LIB\lib_str.c" -D             #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\lib_str.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\lib_str.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uC-LIB\lib_str.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is 
     11          *               illegal to distribute this source code to any third party unless you receive 
     12          *               written permission by an authorized Micrium representative.  Knowledge of 
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest 
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                       ASCII STRING MANAGEMENT
     26          *
     27          * Filename      : lib_str.c
     28          * Version       : V1.37.01
     29          * Programmer(s) : ITJ
     30          *                 BAN
     31          *                 JDH
     32          *********************************************************************************************************
     33          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     34          *
     35          *                     (a) ALL standard library functions are implemented in the custom library modules :
     36          *
     37          *                         (1) \<Custom Library Directory>\lib_*.*
     38          *
     39          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     40          *
     41          *                               where
     42          *                                       <Custom Library Directory>      directory path for custom library software
     43          *                                       <cpu>                           directory name for specific processor (CPU)
     44          *                                       <compiler>                      directory name for specific compiler
     45          *
     46          *                     (b) Product-specific library functions are implemented in individual products.
     47          *
     48          *********************************************************************************************************
     49          * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
     50          *                     us permission to reprint portions of their documentation.  Portions of this text are
     51          *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
     52          *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
     53          *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
     54          *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
     55          *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
     56          *                     the original IEEE and The Open Group Standard is the referee document.  The original
     57          *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
     58          *********************************************************************************************************
     59          */
     60          
     61          
     62          /*
     63          *********************************************************************************************************
     64          *                                            INCLUDE FILES
     65          *********************************************************************************************************
     66          */
     67          
     68          #define    MICRIUM_SOURCE
     69          #define    LIB_STR_MODULE
     70          #include  <lib_str.h>
     71          
     72          
     73          /*$PAGE*/
     74          /*
     75          *********************************************************************************************************
     76          *                                            LOCAL DEFINES
     77          *********************************************************************************************************
     78          */
     79          
     80          
     81          /*
     82          *********************************************************************************************************
     83          *                                           LOCAL CONSTANTS
     84          *********************************************************************************************************
     85          */
     86          
     87          
     88          /*
     89          *********************************************************************************************************
     90          *                                          LOCAL DATA TYPES
     91          *********************************************************************************************************
     92          */
     93          
     94          
     95          /*
     96          *********************************************************************************************************
     97          *                                            LOCAL TABLES
     98          *********************************************************************************************************
     99          */
    100          

   \                                 In section .rodata, align 4
    101          static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
   \                     Str_MultOvfThTbl_Int32U:
   \   00000000   0xFFFFFFFF         DC32 4294967295, 4294967295, 2147483647, 1431655765, 1073741823
   \              0xFFFFFFFF   
   \              0x7FFFFFFF   
   \              0x55555555   
   \              0x3FFFFFFF   
   \   00000014   0x33333333         DC32 858993459, 715827882, 613566756, 536870911, 477218588, 429496729
   \              0x2AAAAAAA   
   \              0x24924924   
   \              0x1FFFFFFF   
   \              0x1C71C71C   
   \              0x19999999   
   \   0000002C   0x1745D174         DC32 390451572, 357913941, 330382099, 306783378, 286331153, 268435455
   \              0x15555555   
   \              0x13B13B13   
   \              0x12492492   
   \              0x11111111   
   \              0x0FFFFFFF   
   \   00000044   0x0F0F0F0F         DC32 252645135, 238609294, 226050910, 214748364, 204522252, 195225786
   \              0x0E38E38E   
   \              0x0D79435E   
   \              0x0CCCCCCC   
   \              0x0C30C30C   
   \              0x0BA2E8BA   
   \   0000005C   0x0B21642C         DC32 186737708, 178956970, 171798691, 165191049, 159072862, 153391689
   \              0x0AAAAAAA   
   \              0x0A3D70A3   
   \              0x09D89D89   
   \              0x097B425E   
   \              0x09249249   
   \   00000074   0x08D3DCB0         DC32 148102320, 143165576, 138547332, 134217727, 130150524, 126322567
   \              0x08888888   
   \              0x08421084   
   \              0x07FFFFFF   
   \              0x07C1F07C   
   \              0x07878787   
   \   0000008C   0x07507507         DC32 122713351, 119304647
   \              0x071C71C7   
    102             (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
    103             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
    104             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
    105             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
    106             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
    107             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
    108             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
    109             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
    110             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
    111             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
    112             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
    113             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
    114             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
    115             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
    116             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
    117             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
    118             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
    119             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
    120             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
    121             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
    122             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
    123             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
    124             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
    125             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
    126             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
    127             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
    128             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
    129             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
    130             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
    131             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
    132             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
    133             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
    134             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
    135             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
    136             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
    137             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
    138             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
    139          };
    140          
    141          
    142          /*
    143          *********************************************************************************************************
    144          *                                       LOCAL GLOBAL VARIABLES
    145          *********************************************************************************************************
    146          */
    147          
    148          
    149          /*$PAGE*/
    150          /*
    151          *********************************************************************************************************
    152          *                                      LOCAL FUNCTION PROTOTYPES
    153          *********************************************************************************************************
    154          */
    155          
    156          static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
    157                                                         CPU_INT08U     nbr_dig,
    158                                                         CPU_INT08U     nbr_base,
    159                                                         CPU_BOOLEAN    nbr_neg,
    160                                                         CPU_CHAR       lead_char,
    161                                                         CPU_BOOLEAN    lower_case,
    162                                                         CPU_BOOLEAN    nul,
    163                                                         CPU_CHAR      *pstr);
    164          
    165          static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
    166                                                         CPU_CHAR     **pstr_next,
    167                                                         CPU_INT08U     nbr_base,
    168                                                         CPU_BOOLEAN    nbr_signed,
    169                                                         CPU_BOOLEAN   *pnbr_neg);
    170          
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                     LOCAL CONFIGURATION ERRORS
    175          *********************************************************************************************************
    176          */
    177          
    178          
    179          /*$PAGE*/
    180          /*
    181          *********************************************************************************************************
    182          *                                              Str_Len()
    183          *
    184          * Description : Calculate length of a string.
    185          *
    186          * Argument(s) : pstr        Pointer to string (see Note #1).
    187          *
    188          * Return(s)   : Length of string; number of characters in string before terminating NULL character 
    189          *                   (see Note #2b1).
    190          *
    191          * Caller(s)   : Application.
    192          *
    193          * Note(s)     : (1) String buffer NOT modified.
    194          *
    195          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    196          *
    197          *                       (1) "The strlen() function shall compute the number of bytes in the string to 
    198          *                            which 's' ('pstr') points," ...
    199          *                       (2) "not including the terminating null byte."
    200          *
    201          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    202          *
    203          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    204          *                       (2) "no return value shall be reserved to indicate an error."
    205          *
    206          *               (3) String length calculation terminates when :
    207          *
    208          *                   (a) String pointer points to NULL.
    209          *                       (1) String buffer overlaps with NULL address.
    210          *                       (2) String length calculated for string up to but NOT beyond or including
    211          *                           the NULL address.
    212          *
    213          *                   (b) Terminating NULL character found.
    214          *                       (1) String length calculated for string up to but NOT           including
    215          *                           the NULL character (see Note #2a2).
    216          *********************************************************************************************************
    217          */
    218          

   \                                 In section .text, align 2, keep-with-next
    219          CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
    220          {
   \                     Str_Len:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    221              CPU_SIZE_T  len;
    222          
    223          
    224              len = Str_Len_N(pstr,
    225                              DEF_INT_CPU_U_MAX_VAL);
   \   00000004   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Str_Len_N
   \   0000000E   0x0005             MOVS     R5,R0
    226          
    227              return (len);
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    228          }
    229          
    230          
    231          /*$PAGE*/
    232          /*
    233          *********************************************************************************************************
    234          *                                             Str_Len_N()
    235          *
    236          * Description : Calculate length of a string, up to a maximum number of characters.
    237          *
    238          * Argument(s) : pstr        Pointer to string (see Note #1).
    239          *
    240          *               len_max     Maximum number of characters to search (see Note #3c).
    241          *
    242          * Return(s)   : Length of string; number of characters in string before terminating NULL character, 
    243          *                   if terminating NULL character     found (see Note #2b1).
    244          *
    245          *               Requested maximum number of characters to search, 
    246          *                   if terminating NULL character NOT found (see Note #3c).
    247          *
    248          * Caller(s)   : Application.
    249          *
    250          * Note(s)     : (1) String buffer NOT modified.
    251          *
    252          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    253          *
    254          *                       (1) "The strlen() function shall compute the number of bytes in the string to 
    255          *                            which 's' ('pstr') points," ...
    256          *                       (2) "not including the terminating null byte."
    257          *
    258          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    259          *
    260          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    261          *                       (2) "no return value shall be reserved to indicate an error."
    262          *
    263          *               (3) String length calculation terminates when :
    264          *
    265          *                   (a) String pointer points to NULL.
    266          *                       (1) String buffer overlaps with NULL address.
    267          *                       (2) String length calculated for string up to but NOT beyond or including
    268          *                           the NULL address.
    269          *
    270          *                   (b) Terminating NULL character found.
    271          *                       (1) String length calculated for string up to but NOT           including
    272          *                           the NULL character (see Note #2a2).
    273          *
    274          *                   (c) 'len_max' number of characters searched.
    275          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    276          *********************************************************************************************************
    277          */
    278          

   \                                 In section .text, align 2, keep-with-next
    279          CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
    280                                        CPU_SIZE_T   len_max)
    281          {
   \                     Str_Len_N:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    282              const  CPU_CHAR    *pstr_len;
    283                     CPU_SIZE_T   len;
    284          
    285          
    286              pstr_len = pstr;
   \   00000004   0x0013             MOVS     R3,R2
    287              len      = 0u;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0020             MOVS     R0,R4
    288              while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
    289                     (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
    290                     ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
   \                     ??Str_Len_N_0:
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD007             BEQ.N    ??Str_Len_N_1
   \   0000000E   0x781C             LDRB     R4,[R3, #+0]
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??Str_Len_N_1
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD202             BCS.N    ??Str_Len_N_1
    291                  pstr_len++;
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
    292                  len++;
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7F5             B.N      ??Str_Len_N_0
    293              }
    294          
    295              return (len);                                               /* Rtn str len (see Note #3b1).                         */
   \                     ??Str_Len_N_1:
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    296          }
    297          
    298          
    299          /*$PAGE*/
    300          /*
    301          *********************************************************************************************************
    302          *                                             Str_Copy()
    303          *
    304          * Description : Copy source string to destination string buffer.
    305          *
    306          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    307          *
    308          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    309          *
    310          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    311          *
    312          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    313          *
    314          * Caller(s)   : Application.
    315          *
    316          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    317          *
    318          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    319          *                           string size including the terminating NULL character.
    320          *
    321          *                   (b) Source buffer NOT modified.
    322          *
    323          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
    324          *
    325          *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src') 
    326          *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
    327          *                       (2) "(including the terminating null byte)."
    328          *
    329          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
    330          *
    331          *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
    332          *                       (2) "no return value is reserved to indicate an error."
    333          *                           (A) #### This requirement is intentionally NOT implemented in order to return 
    334          *                               NULL for any error(s).
    335          *
    336          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
    337          *                       copying takes place between objects that overlap, the behavior is undefined".
    338          *
    339          *               (3) String copy terminates when :
    340          *
    341          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    342          *                       (1) No string copy performed; NULL pointer returned.
    343          *
    344          *                   (b) Destination/Source string pointer(s) point to NULL.
    345          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    346          *
    347          *                   (c) Source string's terminating NULL character found.
    348          *                       (1) Entire source string copied into destination string buffer (see Note #2a).
    349          *********************************************************************************************************
    350          */
    351          

   \                                 In section .text, align 2, keep-with-next
    352          CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
    353                               const  CPU_CHAR  *pstr_src)
    354          {
   \                     Str_Copy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    355              CPU_CHAR  *pstr_rtn;
    356          
    357          
    358              pstr_rtn = Str_Copy_N(pstr_dest,
    359                                    pstr_src,
    360                                    DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Copy_N
   \   00000012   0x0006             MOVS     R6,R0
    361          
    362              return (pstr_rtn);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    363          }
    364          
    365          
    366          /*$PAGE*/
    367          /*
    368          *********************************************************************************************************
    369          *                                            Str_Copy_N()
    370          *
    371          * Description : Copy source string to destination string buffer, up to a maximum number of characters.
    372          *
    373          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    374          *
    375          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    376          *
    377          *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
    378          *
    379          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    380          *
    381          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    382          *
    383          * Caller(s)   : Application.
    384          *
    385          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    386          *
    387          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    388          *                           string size including the terminating NULL character.
    389          *
    390          *                   (b) Source string buffer NOT modified.
    391          *
    392          *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    393          *
    394          *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2' 
    395          *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
    396          *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
    397          *                           (C)  &   "(bytes that follow a null byte are not copied)".
    398          *
    399          *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that 
    400          *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter 
    401          *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in 
    402          *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes 
    403          *                               in all are written."
    404          *
    405          *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy 
    406          *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters, 
    407          *                                   this requirement is intentionally NOT implemented to avoid appending 
    408          *                                   a potentially large number of unnecessary terminating NULL characters.
    409          *
    410          *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also  
    411          *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of 
    412          *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
    413          *
    414          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
    415          *
    416          *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
    417          *                       (2) "no return value is reserved to indicate an error."
    418          *                           (A) #### This requirement is intentionally ignored in order to return NULL 
    419          *                               for any error(s).
    420          *
    421          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
    422          *                       copying takes place between objects that overlap, the behavior is undefined".
    423          *
    424          *               (3) String copy terminates when :
    425          *
    426          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    427          *                       (1) No string copy performed; NULL pointer returned.
    428          *
    429          *                   (b) Destination/Source string pointer(s) point to NULL.
    430          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    431          *
    432          *                   (c) Source string's terminating NULL character found.
    433          *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
    434          *
    435          *                   (d) 'len_max' number of characters copied.
    436          *                       (1) 'len_max' number of characters MAY include the terminating NULL character 
    437          *                           (see Note #2a1C).
    438          *                       (2) Null copies allowed (i.e. zero-length copies).
    439          *                           (A) No string copy performed; destination string returned  (see Note #2b1).
    440          *********************************************************************************************************
    441          */
    442          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    443          CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
    444                                 const  CPU_CHAR    *pstr_src,
    445                                        CPU_SIZE_T   len_max)
    446          {
   \                     Str_Copy_N:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    447                     CPU_CHAR    *pstr_copy_dest;
    448              const  CPU_CHAR    *pstr_copy_src;
    449                     CPU_SIZE_T   len_copy;
    450          
    451                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    452              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Copy_N_0
    453                  return ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE021             B.N      ??Str_Copy_N_1
    454              }
    455              if (pstr_src  == (const CPU_CHAR *)0) {
   \                     ??Str_Copy_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Copy_N_2
    456                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01D             B.N      ??Str_Copy_N_1
    457              }
    458          
    459          
    460              pstr_copy_dest = pstr_dest;
   \                     ??Str_Copy_N_2:
   \   00000014   0x001C             MOVS     R4,R3
    461              pstr_copy_src  = pstr_src;
   \   00000016   0x000D             MOVS     R5,R1
    462              len_copy       = 0u;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0006             MOVS     R6,R0
    463          
    464              while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
    465                     ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
    466                     (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
    467                     ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
   \                     ??Str_Copy_N_3:
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD00C             BEQ.N    ??Str_Copy_N_4
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD00A             BEQ.N    ??Str_Copy_N_4
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ.N    ??Str_Copy_N_4
   \   0000002A   0x4296             CMP      R6,R2
   \   0000002C   0xD205             BCS.N    ??Str_Copy_N_4
    468                 *pstr_copy_dest = *pstr_copy_src;
   \   0000002E   0x7828             LDRB     R0,[R5, #+0]
   \   00000030   0x7020             STRB     R0,[R4, #+0]
    469                  pstr_copy_dest++;
   \   00000032   0x1C64             ADDS     R4,R4,#+1
    470                  pstr_copy_src++;
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    471                  len_copy++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \   00000038   0xE7F0             B.N      ??Str_Copy_N_3
    472              }
    473                                                                          /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
    474              if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
    475                  (pstr_copy_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Copy_N_4:
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD001             BEQ.N    ??Str_Copy_N_5
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD101             BNE.N    ??Str_Copy_N_6
    476                   return ((CPU_CHAR *)0);
   \                     ??Str_Copy_N_5:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE004             B.N      ??Str_Copy_N_1
    477              }
    478          
    479              if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
   \                     ??Str_Copy_N_6:
   \   00000046   0x4296             CMP      R6,R2
   \   00000048   0xD201             BCS.N    ??Str_Copy_N_7
    480                 *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    481              }
    482          
    483          
    484              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \                     ??Str_Copy_N_7:
   \   0000004E   0x0018             MOVS     R0,R3
   \                     ??Str_Copy_N_1:
   \   00000050   0xBC70             POP      {R4-R6}
   \   00000052   0x4770             BX       LR               ;; return
    485          }
    486          
    487          
    488          /*$PAGE*/
    489          /*
    490          *********************************************************************************************************
    491          *                                              Str_Cat()
    492          *
    493          * Description : Append concatenation string to destination string.
    494          *
    495          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    496          *
    497          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    498          *
    499          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    500          *
    501          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    502          *
    503          * Caller(s)   : Application.
    504          *
    505          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    506          *
    507          *                       (1) Destination buffer size MUST be large enough to accommodate the entire 
    508          *                           concatenated string size including the terminating NULL character.
    509          *
    510          *                   (b) Concatenation string buffer NOT modified.
    511          *
    512          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
    513          *
    514          *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2' 
    515          *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
    516          *
    517          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
    518          *                                end of 's1' ('pstr_dest')."
    519          *                           (B)  A "terminating null byte" is appended at the end of the concatenated 
    520          *                                destination strings.
    521          *
    522          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
    523          *
    524          *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
    525          *                       (2) "no return value shall be reserved to indicate an error."
    526          *                           (A) #### This requirement is intentionally NOT implemented in order to return 
    527          *                               NULL for any error(s).
    528          *
    529          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
    530          *                       copying takes place between objects that overlap, the behavior is undefined."
    531          *
    532          *               (3) String concatenation terminates when :
    533          *
    534          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    535          *                       (1) No string concatenation performed; NULL pointer returned.
    536          *
    537          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    538          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    539          *
    540          *                   (c) Concatenation string's terminating NULL character found.
    541          *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
    542          *********************************************************************************************************
    543          */
    544          

   \                                 In section .text, align 2, keep-with-next
    545          CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
    546                              const  CPU_CHAR  *pstr_cat)
    547          {
   \                     Str_Cat:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    548              CPU_CHAR  *pstr_rtn;
    549          
    550          
    551              pstr_rtn = Str_Cat_N(pstr_dest,
    552                                   pstr_cat,
    553                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Cat_N
   \   00000012   0x0006             MOVS     R6,R0
    554          
    555              return (pstr_rtn);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    556          }
    557          
    558          
    559          /*$PAGE*/
    560          /*
    561          *********************************************************************************************************
    562          *                                             Str_Cat_N()
    563          *
    564          * Description : Append concatenation string to destination string, up to a maximum number of characters.
    565          *
    566          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    567          *
    568          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    569          *
    570          *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
    571          *
    572          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    573          *
    574          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    575          *
    576          * Caller(s)   : Application.
    577          *
    578          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    579          *
    580          *                       (1) Destination buffer size MUST be large enough to accommodate the entire 
    581          *                           concatenated string size including the terminating NULL character.
    582          *
    583          *                   (b) Concatenation string buffer NOT modified.
    584          *
    585          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
    586          *
    587          *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2' 
    588          *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
    589          *                           (B)  but "not more than 'n' ('len_max') bytes".
    590          *
    591          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
    592          *                                end of 's1' ('pstr_dest')."
    593          *                           (B) "(a null byte and bytes that follow it are not appended)."
    594          *                           (C) "A terminating null byte is always appended to the result."
    595          *
    596          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
    597          *
    598          *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
    599          *                       (2) "no return value shall be reserved to indicate an error."
    600          *                           (A) #### This requirement is intentionally NOT implemented in order to return 
    601          *                               NULL for any error(s).
    602          *
    603          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
    604          *                       copying takes place between objects that overlap, the behavior is undefined."
    605          *
    606          *               (3) String concatenation terminates when :
    607          *
    608          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    609          *                       (1) No string concatenation performed; NULL pointer returned.
    610          *
    611          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    612          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    613          *
    614          *                   (c) Concatenation string's terminating NULL character found.
    615          *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
    616          *
    617          *                   (d) 'len_max' number of characters concatenated.
    618          *
    619          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character 
    620          *                           (see Note #2a2).
    621          *
    622          *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
    623          *                           (A) No string concatenation performed; destination string returned 
    624          *                               (see Note #2b1).
    625          *********************************************************************************************************
    626          */
    627          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    628          CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
    629                                const  CPU_CHAR    *pstr_cat,
    630                                       CPU_SIZE_T   len_max)
    631          {
   \                     Str_Cat_N:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    632                     CPU_CHAR    *pstr_cat_dest;
    633              const  CPU_CHAR    *pstr_cat_src;
    634                     CPU_SIZE_T   len_cat;
    635          
    636                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    637              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Cat_N_0
    638                  return ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE02E             B.N      ??Str_Cat_N_1
    639              }
    640              if (pstr_cat  == (const CPU_CHAR *)0) {
   \                     ??Str_Cat_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Cat_N_2
    641                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE02A             B.N      ??Str_Cat_N_1
    642              }
    643          
    644              if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
   \                     ??Str_Cat_N_2:
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??Str_Cat_N_3
    645                  return ((CPU_CHAR *)pstr_dest);
   \   00000018   0x0018             MOVS     R0,R3
   \   0000001A   0xE026             B.N      ??Str_Cat_N_1
    646              }
    647          
    648          
    649              pstr_cat_dest = pstr_dest;
   \                     ??Str_Cat_N_3:
   \   0000001C   0x001C             MOVS     R4,R3
    650              while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
    651                     (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
   \                     ??Str_Cat_N_4:
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD004             BEQ.N    ??Str_Cat_N_5
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??Str_Cat_N_5
    652                  pstr_cat_dest++;
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0xE7F8             B.N      ??Str_Cat_N_4
    653              }
    654              if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
   \                     ??Str_Cat_N_5:
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD101             BNE.N    ??Str_Cat_N_6
    655                  return ((CPU_CHAR *)0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE01A             B.N      ??Str_Cat_N_1
    656              }
    657          
    658              pstr_cat_src = pstr_cat;
   \                     ??Str_Cat_N_6:
   \   00000034   0x000D             MOVS     R5,R1
    659              len_cat      = 0u;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0006             MOVS     R6,R0
    660          
    661              while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
    662                     ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
    663                     (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
    664                     ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
   \                     ??Str_Cat_N_7:
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD00C             BEQ.N    ??Str_Cat_N_8
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD00A             BEQ.N    ??Str_Cat_N_8
   \   00000042   0x7828             LDRB     R0,[R5, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD007             BEQ.N    ??Str_Cat_N_8
   \   00000048   0x4296             CMP      R6,R2
   \   0000004A   0xD205             BCS.N    ??Str_Cat_N_8
    665                 *pstr_cat_dest = *pstr_cat_src;
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
    666                  pstr_cat_dest++;
   \   00000050   0x1C64             ADDS     R4,R4,#+1
    667                  pstr_cat_src++;
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
    668                  len_cat++;
   \   00000054   0x1C76             ADDS     R6,R6,#+1
   \   00000056   0xE7F0             B.N      ??Str_Cat_N_7
    669              }
    670                                                                          /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    671              if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
    672                  (pstr_cat_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Cat_N_8:
   \   00000058   0x2C00             CMP      R4,#+0
   \   0000005A   0xD001             BEQ.N    ??Str_Cat_N_9
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD101             BNE.N    ??Str_Cat_N_10
    673                   return ((CPU_CHAR *)0);
   \                     ??Str_Cat_N_9:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE002             B.N      ??Str_Cat_N_1
    674              }
    675          
    676             *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
   \                     ??Str_Cat_N_10:
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    677          
    678          
    679              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \   00000068   0x0018             MOVS     R0,R3
   \                     ??Str_Cat_N_1:
   \   0000006A   0xBC70             POP      {R4-R6}
   \   0000006C   0x4770             BX       LR               ;; return
    680          }
    681          
    682          
    683          /*$PAGE*/
    684          /*
    685          *********************************************************************************************************
    686          *                                              Str_Cmp()
    687          *
    688          * Description : Determine if two strings are identical.
    689          *
    690          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    691          *
    692          *               p2_str      Pointer to second string (see Note #1).
    693          *
    694          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    695          *
    696          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    697          *
    698          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    699          *
    700          *               See also Note #2b.
    701          *
    702          * Caller(s)   : Application.
    703          *
    704          * Note(s)     : (1) String buffers NOT modified.
    705          *
    706          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
    707          *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the 
    708          *                       string pointed to by 's2' ('p2_str)".
    709          *
    710          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
    711          *                          "upon successful completion, strcmp() shall return an integer greater than,
    712          *                           equal to, or less than 0".
    713          *
    714          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    715          *                           sign of a non-zero return value shall be determined by the sign of the difference
    716          *                           between the values of the first pair of bytes ... that differ in the strings
    717          *                           being compared".
    718          *
    719          *               (3) String comparison terminates when :
    720          *
    721          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    722          *                               (1) NULL strings identical; 0 returned.
    723          *
    724          *                           (B) (1) 'p1_str' passed a NULL pointer.
    725          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    726          *
    727          *                               (2) 'p2_str' passed a NULL pointer.
    728          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    729          *
    730          *                       (2) (A) BOTH strings point to NULL.
    731          *                               (1) Strings overlap with NULL address.
    732          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    733          *                                   0 returned.
    734          *
    735          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    736          *                                   (a) 'p1_str' overlaps with NULL address.
    737          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    738          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    739          *
    740          *                               (2) 'p2_str_cmp_next' points to NULL.
    741          *                                   (a) 'p2_str' overlaps with NULL address.
    742          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    743          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    744          *
    745          *                   (b) Terminating NULL character found in both strings.
    746          *                       (1) Strings identical; 0 returned.
    747          *                       (2) Only one NULL character test required in conditional since previous condition
    748          *                           tested character equality.
    749          *
    750          *                   (c) Non-matching characters found.
    751          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    752          *                           from the character pointed to by 'p1_str'.
    753          *
    754          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    755          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    756          *********************************************************************************************************
    757          */
    758          

   \                                 In section .text, align 2, keep-with-next
    759          CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
    760                               const  CPU_CHAR  *p2_str)
    761          {
   \                     Str_Cmp:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    762              CPU_INT16S  cmp_val;
    763          
    764          
    765              cmp_val = Str_Cmp_N(p1_str,
    766                                  p2_str,
    767                                  DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Cmp_N
   \   00000012   0x0006             MOVS     R6,R0
    768          
    769              return (cmp_val);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    770          }
    771          
    772          
    773          /*$PAGE*/
    774          /*
    775          *********************************************************************************************************
    776          *                                             Str_Cmp_N()
    777          *
    778          * Description : Determine if two strings are identical for up to a maximum number of characters.
    779          *
    780          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    781          *
    782          *               p2_str      Pointer to second string (see Note #1).
    783          *
    784          *               len_max     Maximum number of characters to compare  (see Note  #3d).
    785          *
    786          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    787          *
    788          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    789          *
    790          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    791          *
    792          *               See also Note #2b.
    793          *
    794          * Caller(s)   : Application.
    795          *
    796          * Note(s)     : (1) String buffers NOT modified.
    797          *
    798          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
    799          *
    800          *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str') 
    801          *                            to the array pointed to by 's2' ('p2_str)" ...
    802          *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
    803          *
    804          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
    805          *                          "upon successful completion, strncmp() shall return an integer greater than,
    806          *                           equal to, or less than 0".
    807          *
    808          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
    809          *                          "the sign of a non-zero return value is determined by the sign of the difference
    810          *                           between the values of the first pair of bytes ... that differ in the strings
    811          *                           being compared".
    812          *
    813          *               (3) String comparison terminates when :
    814          *
    815          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    816          *                               (1) NULL strings identical; 0 returned.
    817          *
    818          *                           (B) (1) 'p1_str' passed a NULL pointer.
    819          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    820          *
    821          *                               (2) 'p2_str' passed a NULL pointer.
    822          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    823          *
    824          *                       (2) (A) BOTH strings point to NULL.
    825          *                               (1) Strings overlap with NULL address.
    826          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    827          *                                   0 returned.
    828          *
    829          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    830          *                                   (a) 'p1_str' overlaps with NULL address.
    831          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    832          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    833          *
    834          *                               (2) 'p2_str_cmp_next' points to NULL.
    835          *                                   (a) 'p2_str' overlaps with NULL address.
    836          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    837          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    838          *
    839          *                   (b) Terminating NULL character found in both strings.
    840          *                       (1) Strings identical; 0 returned.
    841          *                       (2) Only one NULL character test required in conditional since previous condition
    842          *                           tested character equality.
    843          *
    844          *                   (c) Non-matching characters found.
    845          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    846          *                           from the character pointed to by 'p1_str'.
    847          *
    848          *                   (d) (1) 'len_max' passed a zero length.
    849          *                           (A) Zero-length strings identical; 0 returned.
    850          *
    851          *                       (2) First 'len_max' number of characters identical.
    852          *                           (A) Strings identical; 0 returned.
    853          *
    854          *                       See also Note #2a2.
    855          *
    856          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    857          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    858          *********************************************************************************************************
    859          */
    860          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    861          CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
    862                                 const  CPU_CHAR    *p2_str,
    863                                        CPU_SIZE_T   len_max)
    864          {
   \                     Str_Cmp_N:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0003             MOVS     R3,R0
    865              const  CPU_CHAR    *p1_str_cmp;
    866              const  CPU_CHAR    *p2_str_cmp;
    867              const  CPU_CHAR    *p1_str_cmp_next;
    868              const  CPU_CHAR    *p2_str_cmp_next;
    869                     CPU_INT16S   cmp_val;
    870                     CPU_SIZE_T   cmp_len;
    871          
    872          
    873              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??Str_Cmp_N_0
    874                  return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE05D             B.N      ??Str_Cmp_N_1
    875              }
    876          
    877              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_0:
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD109             BNE.N    ??Str_Cmp_N_2
    878                  if (p2_str == (const CPU_CHAR *)0) {
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD101             BNE.N    ??Str_Cmp_N_3
    879                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE057             B.N      ??Str_Cmp_N_1
    880                  }
    881                  cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
   \                     ??Str_Cmp_N_3:
   \   0000001A   0x7808             LDRB     R0,[R1, #+0]
   \   0000001C   0x4240             RSBS     R0,R0,#+0
   \   0000001E   0x0007             MOVS     R7,R0
    882                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000024   0xE051             B.N      ??Str_Cmp_N_1
    883              }
    884              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_2:
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD104             BNE.N    ??Str_Cmp_N_4
    885                  cmp_val = (CPU_INT16S)(*p1_str);
   \   0000002A   0x7818             LDRB     R0,[R3, #+0]
   \   0000002C   0x0007             MOVS     R7,R0
    886                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000032   0xE04A             B.N      ??Str_Cmp_N_1
    887              }
    888          
    889          
    890              p1_str_cmp      = p1_str;
   \                     ??Str_Cmp_N_4:
   \   00000034   0x001C             MOVS     R4,R3
    891              p2_str_cmp      = p2_str;
   \   00000036   0x000D             MOVS     R5,R1
    892              p1_str_cmp_next = p1_str_cmp;
   \   00000038   0x46A4             MOV      R12,R4
    893              p2_str_cmp_next = p2_str_cmp;
   \   0000003A   0x46AE             MOV      LR,R5
    894              p1_str_cmp_next++;
   \   0000003C   0xF11C 0x0C01      ADDS     R12,R12,#+1
    895              p2_str_cmp_next++;
   \   00000040   0xF11E 0x0E01      ADDS     LR,LR,#+1
    896              cmp_len         = 0u;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0006             MOVS     R6,R0
    897          
    898              while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
    899                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
    900                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
    901                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
    902                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   \                     ??Str_Cmp_N_5:
   \   00000048   0x7820             LDRB     R0,[R4, #+0]
   \   0000004A   0xF895 0x8000      LDRB     R8,[R5, #+0]
   \   0000004E   0x4540             CMP      R0,R8
   \   00000050   0xD112             BNE.N    ??Str_Cmp_N_6
   \   00000052   0x7820             LDRB     R0,[R4, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD00F             BEQ.N    ??Str_Cmp_N_6
   \   00000058   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000005C   0xD00C             BEQ.N    ??Str_Cmp_N_6
   \   0000005E   0xF1BE 0x0F00      CMP      LR,#+0
   \   00000062   0xD009             BEQ.N    ??Str_Cmp_N_6
   \   00000064   0x4296             CMP      R6,R2
   \   00000066   0xD207             BCS.N    ??Str_Cmp_N_6
    903                  p1_str_cmp++;
   \   00000068   0x1C64             ADDS     R4,R4,#+1
    904                  p2_str_cmp++;
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
    905                  p1_str_cmp_next++;
   \   0000006C   0xF11C 0x0C01      ADDS     R12,R12,#+1
    906                  p2_str_cmp_next++;
   \   00000070   0xF11E 0x0E01      ADDS     LR,LR,#+1
    907                  cmp_len++;
   \   00000074   0x1C76             ADDS     R6,R6,#+1
   \   00000076   0xE7E7             B.N      ??Str_Cmp_N_5
    908              }
    909          
    910          
    911              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_Cmp_N_6:
   \   00000078   0x4296             CMP      R6,R2
   \   0000007A   0xD101             BNE.N    ??Str_Cmp_N_7
    912                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE024             B.N      ??Str_Cmp_N_1
    913              }
    914          
    915              if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
   \                     ??Str_Cmp_N_7:
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0xF895 0x8000      LDRB     R8,[R5, #+0]
   \   00000086   0x4540             CMP      R0,R8
   \   00000088   0xD006             BEQ.N    ??Str_Cmp_N_8
    916                                                                          /* ... calc & rtn char diff  (see Note #3c1).           */
    917                   cmp_val = (CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp);
   \   0000008A   0x7820             LDRB     R0,[R4, #+0]
   \   0000008C   0xF895 0x8000      LDRB     R8,[R5, #+0]
   \   00000090   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000094   0x0007             MOVS     R7,R0
   \   00000096   0xE016             B.N      ??Str_Cmp_N_9
    918          
    919              } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
   \                     ??Str_Cmp_N_8:
   \   00000098   0x7820             LDRB     R0,[R4, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD102             BNE.N    ??Str_Cmp_N_10
    920                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0007             MOVS     R7,R0
   \   000000A2   0xE010             B.N      ??Str_Cmp_N_9
    921          
    922              } else {
    923                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_10:
   \   000000A4   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000A8   0xD10A             BNE.N    ??Str_Cmp_N_11
    924                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   000000AA   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000AE   0xD102             BNE.N    ??Str_Cmp_N_12
    925                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x0007             MOVS     R7,R0
   \   000000B4   0xE007             B.N      ??Str_Cmp_N_9
    926                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
    927                                                                          /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
    928                          cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
   \                     ??Str_Cmp_N_12:
   \   000000B6   0xF89E 0x0000      LDRB     R0,[LR, #+0]
   \   000000BA   0x4240             RSBS     R0,R0,#+0
   \   000000BC   0x0007             MOVS     R7,R0
   \   000000BE   0xE002             B.N      ??Str_Cmp_N_9
    929                      }
    930                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
    931                      cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \                     ??Str_Cmp_N_11:
   \   000000C0   0xF89C 0x0000      LDRB     R0,[R12, #+0]
   \   000000C4   0x0007             MOVS     R7,R0
    932                  }
    933              }
    934          
    935          
    936              return (cmp_val);
   \                     ??Str_Cmp_N_9:
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_Cmp_N_1:
   \   000000CA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    937          }
    938          
    939          
    940          /*$PAGE*/
    941          /*
    942          *********************************************************************************************************
    943          *                                         Str_CmpIgnoreCase()
    944          *
    945          * Description : Determine if two strings are identical, ignoring case.
    946          *
    947          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    948          *
    949          *               p2_str      Pointer to second string (see Note #1).
    950          *
    951          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    952          *
    953          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    954          *
    955          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    956          *
    957          *               See also Note #2b.
    958          *
    959          * Caller(s)   : Application.
    960          *
    961          * Note(s)     : (1) String buffers NOT modified.
    962          *
    963          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
    964          *
    965          *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1' 
    966          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
    967          *                           (B) "ignoring differences in case".
    968          *
    969          *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
    970          *                            and then a byte comparison performed."
    971          *
    972          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
    973          *                          "upon successful completion, strcasecmp() shall return an integer greater than,
    974          *                           equal to, or less than 0".
    975          *
    976          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    977          *                           sign of a non-zero return value shall be determined by the sign of the difference
    978          *                           between the values of the first pair of bytes ... that differ in the strings
    979          *                           being compared".
    980          *
    981          *               (3) String comparison terminates when :
    982          *
    983          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    984          *                               (1) NULL strings identical; 0 returned.
    985          *
    986          *                           (B) (1) 'p1_str' passed a NULL pointer.
    987          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
    988          *                                       to lower case (see Note #2a2).
    989          *
    990          *                               (2) 'p2_str' passed a NULL pointer.
    991          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
    992          *                                       to lower case (see Note #2a2).
    993          *
    994          *                       (2) (A) BOTH strings point to NULL.
    995          *                               (1) Strings overlap with NULL address.
    996          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    997          *                                   0 returned.
    998          *
    999          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
   1000          *                                   (a) 'p1_str' overlaps with NULL address.
   1001          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1002          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
   1003          *                                       converted to lower case (see Note #2a2).
   1004          *
   1005          *                               (2) 'p2_str_cmp_next' points to NULL.
   1006          *                                   (a) 'p2_str' overlaps with NULL address.
   1007          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1008          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
   1009          *                                       converted to lower case (see Note #2a2).
   1010          *
   1011          *                   (b) Terminating NULL character found in both strings.
   1012          *                       (1) Strings identical; 0 returned.
   1013          *                       (2) Only one NULL character test required in conditional since previous condition
   1014          *                           tested character equality.
   1015          *
   1016          *                   (c) Non-matching characters found.
   1017          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1018          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1019          *                           to lower case.
   1020          *
   1021          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1022          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1023          *********************************************************************************************************
   1024          */
   1025          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   1026          CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
   1027                                         const  CPU_CHAR  *p2_str)
   1028          {
   \                     Str_CmpIgnoreCase:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1029              CPU_INT16S  cmp_val;
   1030          
   1031          
   1032              cmp_val = Str_CmpIgnoreCase_N(p1_str,
   1033                                            p2_str,
   1034                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_CmpIgnoreCase_N
   \   00000012   0x0006             MOVS     R6,R0
   1035          
   1036              return (cmp_val);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   1037          }
   1038          
   1039          
   1040          /*$PAGE*/
   1041          /*
   1042          *********************************************************************************************************
   1043          *                                        Str_CmpIgnoreCase_N()
   1044          *
   1045          * Description : Determine if two strings are identical for up to a maximum number of characters,
   1046          *                   ignoring case.
   1047          *
   1048          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
   1049          *
   1050          *               p2_str      Pointer to second string (see Note #1).
   1051          *
   1052          *               len_max     Maximum number of characters to compare  (see Note  #3d).
   1053          *
   1054          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
   1055          *
   1056          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
   1057          *
   1058          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
   1059          *
   1060          *               See also Note #2b.
   1061          *
   1062          * Caller(s)   : Application.
   1063          *
   1064          * Note(s)     : (1) String buffers NOT modified.
   1065          *
   1066          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
   1067          *
   1068          *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1' 
   1069          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
   1070          *                           (B) "ignoring differences in case"                           ...
   1071          *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
   1072          *
   1073          *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
   1074          *                            and then a byte comparison performed."
   1075          *
   1076          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
   1077          *                          "upon successful completion, strncasecmp() shall return an integer greater than,
   1078          *                           equal to, or less than 0".
   1079          *
   1080          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
   1081          *                           sign of a non-zero return value shall be determined by the sign of the difference
   1082          *                           between the values of the first pair of bytes ... that differ in the strings
   1083          *                           being compared".
   1084          *
   1085          *               (3) String comparison terminates when :
   1086          *
   1087          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
   1088          *                               (1) NULL strings identical; 0 returned.
   1089          *
   1090          *                           (B) (1) 'p1_str' passed a NULL pointer.
   1091          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
   1092          *                                       to lower case (see Note #2a2).
   1093          *
   1094          *                               (2) 'p2_str' passed a NULL pointer.
   1095          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
   1096          *                                       to lower case (see Note #2a2).
   1097          *
   1098          *                       (2) (A) BOTH strings point to NULL.
   1099          *                               (1) Strings overlap with NULL address.
   1100          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
   1101          *                                   0 returned.
   1102          *
   1103          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
   1104          *                                   (a) 'p1_str' overlaps with NULL address.
   1105          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1106          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
   1107          *                                       converted to lower case (see Note #2a2).
   1108          *
   1109          *                               (2) 'p2_str_cmp_next' points to NULL.
   1110          *                                   (a) 'p2_str' overlaps with NULL address.
   1111          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1112          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
   1113          *                                       converted to lower case (see Note #2a2).
   1114          *
   1115          *                   (b) Terminating NULL character found in both strings.
   1116          *                       (1) Strings identical; 0 returned.
   1117          *                       (2) Only one NULL character test required in conditional since previous condition
   1118          *                           tested character equality.
   1119          *
   1120          *                   (c) Non-matching characters found.
   1121          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1122          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1123          *                           to lower case.
   1124          *
   1125          *                   (d) (1) 'len_max' passed a zero length.
   1126          *                           (A) Zero-length strings identical; 0 returned.
   1127          *
   1128          *                       (2) First 'len_max' number of characters identical.
   1129          *                           (A) Strings identical; 0 returned.
   1130          *
   1131          *                       See also Note #2a1C.
   1132          *$PAGE*
   1133          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1134          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1135          *********************************************************************************************************
   1136          */
   1137          

   \                                 In section .text, align 2, keep-with-next
   1138          CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
   1139                                           const  CPU_CHAR    *p2_str,
   1140                                                  CPU_SIZE_T   len_max)
   1141          {
   \                     Str_CmpIgnoreCase_N:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   1142              const  CPU_CHAR    *p1_str_cmp;
   1143              const  CPU_CHAR    *p2_str_cmp;
   1144              const  CPU_CHAR    *p1_str_cmp_next;
   1145              const  CPU_CHAR    *p2_str_cmp_next;
   1146                     CPU_CHAR     char_1;
   1147                     CPU_CHAR     char_2;
   1148                     CPU_INT16S   cmp_val;
   1149                     CPU_SIZE_T   cmp_len;
   1150          
   1151          
   1152              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   00000004   0x9802             LDR      R0,[SP, #+8]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_0
   1153                  return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE088             B.N      ??Str_CmpIgnoreCase_N_1
   1154              }
   1155          
   1156              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_0:
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD111             BNE.N    ??Str_CmpIgnoreCase_N_2
   1157                  if (p2_str == (const CPU_CHAR *)0) {
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_3
   1158                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE080             B.N      ??Str_CmpIgnoreCase_N_1
   1159                  }
   1160                  char_2  =  ASCII_ToLower(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_3:
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x.... 0x....      BL       ASCII_ToLower
   \   00000026   0x4681             MOV      R9,R0
   1161                  cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
   \   00000028   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002C   0xF1D9 0x0000      RSBS     R0,R9,#+0
   \   00000030   0x4682             MOV      R10,R0
   1162                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   00000032   0x4650             MOV      R0,R10
   \   00000034   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000036   0xE073             B.N      ??Str_CmpIgnoreCase_N_1
   1163              }
   1164              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_2:
   \   00000038   0x9801             LDR      R0,[SP, #+4]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD10A             BNE.N    ??Str_CmpIgnoreCase_N_4
   1165                  char_1  =  ASCII_ToLower(*p1_str);
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x.... 0x....      BL       ASCII_ToLower
   \   00000046   0x4680             MOV      R8,R0
   1166                  cmp_val = (CPU_INT16S)char_1;
   \   00000048   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004C   0x46C2             MOV      R10,R8
   1167                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   0000004E   0x4650             MOV      R0,R10
   \   00000050   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000052   0xE065             B.N      ??Str_CmpIgnoreCase_N_1
   1168              }
   1169          
   1170          
   1171              p1_str_cmp      = p1_str;
   \                     ??Str_CmpIgnoreCase_N_4:
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x0004             MOVS     R4,R0
   1172              p2_str_cmp      = p2_str;
   \   00000058   0x9801             LDR      R0,[SP, #+4]
   \   0000005A   0x0005             MOVS     R5,R0
   1173              p1_str_cmp_next = p1_str_cmp;
   \   0000005C   0x0026             MOVS     R6,R4
   1174              p2_str_cmp_next = p2_str_cmp;
   \   0000005E   0x002F             MOVS     R7,R5
   1175              p1_str_cmp_next++;
   \   00000060   0x1C76             ADDS     R6,R6,#+1
   1176              p2_str_cmp_next++;
   \   00000062   0x1C7F             ADDS     R7,R7,#+1
   1177              char_1          = ASCII_ToLower(*p1_str_cmp);
   \   00000064   0x7820             LDRB     R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       ASCII_ToLower
   \   0000006A   0x4680             MOV      R8,R0
   1178              char_2          = ASCII_ToLower(*p2_str_cmp);
   \   0000006C   0x7828             LDRB     R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       ASCII_ToLower
   \   00000072   0x4681             MOV      R9,R0
   1179              cmp_len         = 0u;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x4683             MOV      R11,R0
   1180          
   1181              while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
   1182                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
   1183                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
   1184                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
   1185                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   \                     ??Str_CmpIgnoreCase_N_5:
   \   00000078   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000080   0x45C8             CMP      R8,R9
   \   00000082   0xD118             BNE.N    ??Str_CmpIgnoreCase_N_6
   \   00000084   0x7820             LDRB     R0,[R4, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD015             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD013             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD011             BEQ.N    ??Str_CmpIgnoreCase_N_6
   \   00000092   0x9802             LDR      R0,[SP, #+8]
   \   00000094   0x4583             CMP      R11,R0
   \   00000096   0xD20E             BCS.N    ??Str_CmpIgnoreCase_N_6
   1186                  p1_str_cmp++;
   \   00000098   0x1C64             ADDS     R4,R4,#+1
   1187                  p2_str_cmp++;
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
   1188                  p1_str_cmp_next++;
   \   0000009C   0x1C76             ADDS     R6,R6,#+1
   1189                  p2_str_cmp_next++;
   \   0000009E   0x1C7F             ADDS     R7,R7,#+1
   1190                  cmp_len++;
   \   000000A0   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1191                  char_1 = ASCII_ToLower(*p1_str_cmp);
   \   000000A4   0x7820             LDRB     R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       ASCII_ToLower
   \   000000AA   0x4680             MOV      R8,R0
   1192                  char_2 = ASCII_ToLower(*p2_str_cmp);
   \   000000AC   0x7828             LDRB     R0,[R5, #+0]
   \   000000AE   0x.... 0x....      BL       ASCII_ToLower
   \   000000B2   0x4681             MOV      R9,R0
   \   000000B4   0xE7E0             B.N      ??Str_CmpIgnoreCase_N_5
   1193              }
   1194          
   1195          
   1196              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_CmpIgnoreCase_N_6:
   \   000000B6   0x9802             LDR      R0,[SP, #+8]
   \   000000B8   0x4583             CMP      R11,R0
   \   000000BA   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_7
   1197                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE02F             B.N      ??Str_CmpIgnoreCase_N_1
   1198              }
   1199          
   1200              if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
   \                     ??Str_CmpIgnoreCase_N_7:
   \   000000C0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C8   0x45C8             CMP      R8,R9
   \   000000CA   0xD007             BEQ.N    ??Str_CmpIgnoreCase_N_8
   1201                   cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */
   \   000000CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D4   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   000000D8   0x4682             MOV      R10,R0
   \   000000DA   0xE01F             B.N      ??Str_CmpIgnoreCase_N_9
   1202          
   1203              } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
   \                     ??Str_CmpIgnoreCase_N_8:
   \   000000DC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000E4   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_10
   1204                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x4682             MOV      R10,R0
   \   000000EA   0xE017             B.N      ??Str_CmpIgnoreCase_N_9
   1205          
   1206              } else {
   1207                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_10:
   \   000000EC   0x2E00             CMP      R6,#+0
   \   000000EE   0xD10E             BNE.N    ??Str_CmpIgnoreCase_N_11
   1208                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   000000F0   0x2F00             CMP      R7,#+0
   \   000000F2   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_12
   1209                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x4682             MOV      R10,R0
   \   000000F8   0xE010             B.N      ??Str_CmpIgnoreCase_N_9
   1210                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
   1211                          char_2  =  ASCII_ToLower(*p2_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_12:
   \   000000FA   0x7838             LDRB     R0,[R7, #+0]
   \   000000FC   0x.... 0x....      BL       ASCII_ToLower
   \   00000100   0x4681             MOV      R9,R0
   1212                          cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
   \   00000102   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000106   0xF1D9 0x0000      RSBS     R0,R9,#+0
   \   0000010A   0x4682             MOV      R10,R0
   \   0000010C   0xE006             B.N      ??Str_CmpIgnoreCase_N_9
   1213                      }
   1214                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
   1215                      char_1  =  ASCII_ToLower(*p1_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_11:
   \   0000010E   0x7830             LDRB     R0,[R6, #+0]
   \   00000110   0x.... 0x....      BL       ASCII_ToLower
   \   00000114   0x4680             MOV      R8,R0
   1216                      cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \   00000116   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000011A   0x46C2             MOV      R10,R8
   1217                  }
   1218              }
   1219          
   1220          
   1221              return (cmp_val);
   \                     ??Str_CmpIgnoreCase_N_9:
   \   0000011C   0x4650             MOV      R0,R10
   \   0000011E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_CmpIgnoreCase_N_1:
   \   00000120   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1222          }
   1223          
   1224          
   1225          /*$PAGE*/
   1226          /*
   1227          *********************************************************************************************************
   1228          *                                             Str_Char()
   1229          *
   1230          * Description : Search string for first occurrence of specific character.
   1231          *
   1232          * Argument(s) : pstr            Pointer to string (see Note #1).
   1233          *
   1234          *               srch_char       Search character.
   1235          *
   1236          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1237          *
   1238          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1239          *
   1240          * Caller(s)   : Application.
   1241          *
   1242          * Note(s)     : (1) String buffer NOT modified.
   1243          *
   1244          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1245          *
   1246          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
   1247          *                            ... in the string pointed to by 's' ('pstr')."
   1248          *                       (2) "The terminating null byte is considered to be part of the string."
   1249          *
   1250          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
   1251          *                       "upon completion, strchr() shall return" :
   1252          *
   1253          *                       (1) "a pointer to the byte," ...
   1254          *                       (2) "or a null pointer if the byte was not found."
   1255          *                           (A) #### Although NO strchr() specification states to return NULL for 
   1256          *                               any other reason(s), NULL is also returned for any error(s).
   1257          *
   1258          *               (3) String search terminates when :
   1259          *
   1260          *                   (a) String pointer passed a NULL pointer.
   1261          *                       (1) No string search performed; NULL pointer returned.
   1262          *
   1263          *                   (b) String pointer points to NULL.
   1264          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1265          *
   1266          *                   (c) String's terminating NULL character found.
   1267          *                       (1) Search character NOT found in search string; NULL pointer returned 
   1268          *                           (see Note #2b2).
   1269          *                       (2) Applicable even if search character is the terminating NULL character 
   1270          *                           (see Note #2a2).
   1271          *
   1272          *                   (d) Search character found.
   1273          *                       (1) Return pointer to first occurrence of search character in search string
   1274          *                           (see Note #2a1).
   1275          *********************************************************************************************************
   1276          */
   1277          

   \                                 In section .text, align 2, keep-with-next
   1278          CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
   1279                                      CPU_CHAR   srch_char)
   1280          {
   \                     Str_Char:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1281              CPU_CHAR  *pstr_rtn;
   1282          
   1283          
   1284              pstr_rtn = Str_Char_N(pstr,
   1285                                    DEF_INT_CPU_U_MAX_VAL,
   1286                                    srch_char);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Str_Char_N
   \   00000014   0x0006             MOVS     R6,R0
   1287          
   1288              return (pstr_rtn);
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   1289          }
   1290          
   1291          
   1292          /*$PAGE*/
   1293          /*
   1294          *********************************************************************************************************
   1295          *                                            Str_Char_N()
   1296          *
   1297          * Description : Search string for first occurrence of specific character, up to a maximum number 
   1298          *                   of characters.
   1299          *
   1300          * Argument(s) : pstr            Pointer to string (see Note #1).
   1301          *
   1302          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1303          *
   1304          *               srch_char       Search character.
   1305          *
   1306          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1307          *
   1308          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1309          *
   1310          * Caller(s)   : Application.
   1311          *
   1312          * Note(s)     : (1) String buffer NOT modified.
   1313          *
   1314          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1315          *
   1316          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
   1317          *                            ... in the string pointed to by 's' ('pstr')."
   1318          *                       (2) "The terminating null byte is considered to be part of the string."
   1319          *
   1320          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
   1321          *                       "upon completion, strchr() shall return" :
   1322          *
   1323          *                       (1) "a pointer to the byte," ...
   1324          *                       (2) "or a null pointer if the byte was not found."
   1325          *                           (A) #### Although NO strchr() specification states to return NULL for 
   1326          *                               any other reason(s), NULL is also returned for any error(s).
   1327          *
   1328          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1329          *                       argument list for consistency with all other custom string library functions.
   1330          *                       However, the 'len_max' argument is sequentially ordered as the second argument 
   1331          *                       to comply with most standard library's strnchr() argument list.
   1332          *
   1333          *               (3) String search terminates when :
   1334          *
   1335          *                   (a) String pointer passed a NULL pointer.
   1336          *                       (1) No string search performed; NULL pointer returned.
   1337          *
   1338          *                   (b) String pointer points to NULL.
   1339          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1340          *
   1341          *                   (c) String's terminating NULL character found.
   1342          *                       (1) Search character NOT found in search string; NULL pointer returned 
   1343          *                           (see Note #2b2).
   1344          *                       (2) Applicable even if search character is the terminating NULL character 
   1345          *                           (see Note #2a2).
   1346          *
   1347          *                   (d) Search character found.
   1348          *                       (1) Return pointer to first occurrence of search character in search string
   1349          *                           (see Note #2a1).
   1350          *
   1351          *                   (e) 'len_max' number of characters searched.
   1352          *                       (1) Search character NOT found in search string within first 'len_max' number 
   1353          *                           of characters; NULL pointer returned.
   1354          *                       (2) 'len_max' number of characters MAY include terminating NULL character 
   1355          *                           (see Note #2a2).
   1356          *********************************************************************************************************
   1357          */
   1358          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   1359          CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
   1360                                        CPU_SIZE_T   len_max,
   1361                                        CPU_CHAR     srch_char)
   1362          {
   \                     Str_Char_N:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
   1363              const  CPU_CHAR    *pstr_char;
   1364                     CPU_SIZE_T   len_srch;
   1365          
   1366          
   1367              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??Str_Char_N_0
   1368                  return ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE023             B.N      ??Str_Char_N_1
   1369              }
   1370          
   1371              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_N_0:
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Char_N_2
   1372                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01F             B.N      ??Str_Char_N_1
   1373              }
   1374          
   1375          
   1376              pstr_char = pstr;
   \                     ??Str_Char_N_2:
   \   00000014   0x001C             MOVS     R4,R3
   1377              len_srch  = 0u;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
   1378          
   1379              while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
   1380                     (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
   1381                     (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
   1382                     ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
   \                     ??Str_Char_N_3:
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD00B             BEQ.N    ??Str_Char_N_4
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD008             BEQ.N    ??Str_Char_N_4
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x4290             CMP      R0,R2
   \   0000002A   0xD004             BEQ.N    ??Str_Char_N_4
   \   0000002C   0x428D             CMP      R5,R1
   \   0000002E   0xD202             BCS.N    ??Str_Char_N_4
   1383                  pstr_char++;
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   1384                  len_srch++;
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F1             B.N      ??Str_Char_N_3
   1385              }
   1386          
   1387          
   1388              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
   \                     ??Str_Char_N_4:
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD101             BNE.N    ??Str_Char_N_5
   1389                  return ((CPU_CHAR *)0);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE00A             B.N      ??Str_Char_N_1
   1390              }
   1391          
   1392              if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
   \                     ??Str_Char_N_5:
   \   0000003E   0x428D             CMP      R5,R1
   \   00000040   0xD301             BCC.N    ??Str_Char_N_6
   1393                  return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE006             B.N      ??Str_Char_N_1
   1394              }
   1395          
   1396              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
   \                     ??Str_Char_N_6:
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x4290             CMP      R0,R2
   \   0000004C   0xD001             BEQ.N    ??Str_Char_N_7
   1397                   return ((CPU_CHAR *)0);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??Str_Char_N_1
   1398              }
   1399          
   1400          
   1401              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
   \                     ??Str_Char_N_7:
   \   00000052   0x0020             MOVS     R0,R4
   \                     ??Str_Char_N_1:
   \   00000054   0xBC30             POP      {R4,R5}
   \   00000056   0x4770             BX       LR               ;; return
   1402          }
   1403          
   1404          
   1405          /*$PAGE*/
   1406          /*
   1407          *********************************************************************************************************
   1408          *                                           Str_Char_Last()
   1409          *
   1410          * Description : Search string for last occurrence of specific character.
   1411          *
   1412          * Argument(s) : pstr            Pointer to string (see Note #1).
   1413          *
   1414          *               srch_char       Search character.
   1415          *
   1416          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1417          *
   1418          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1419          *
   1420          * Caller(s)   : Application.
   1421          *
   1422          * Note(s)     : (1) String buffer NOT modified.
   1423          *
   1424          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1425          *
   1426          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
   1427          *                            ... in the string pointed to by 's' ('pstr')."
   1428          *                       (2) "The terminating null byte is considered to be part of the string."
   1429          *
   1430          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
   1431          *                       "upon successful completion, strrchr() shall return" :
   1432          *
   1433          *                       (1) "a pointer to the byte" ...
   1434          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1435          *                           (A) #### Although NO strrchr() specification states to return NULL for 
   1436          *                               any other reason(s), NULL is also returned for any error(s).
   1437          *
   1438          *               (3) String search terminates when :
   1439          *
   1440          *                   (a) String pointer passed a NULL pointer.
   1441          *                       (1) No string search performed; NULL pointer returned.
   1442          *
   1443          *                   (b) String pointer points to NULL.
   1444          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1445          *
   1446          *                   (c) String searched from end to beginning.
   1447          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1448          *                       (2) Applicable even if search character is the terminating NULL character 
   1449          *                           (see Note #2a2).
   1450          *
   1451          *                   (d) Search character found.
   1452          *                       (1) Return pointer to last occurrence of search character in search string 
   1453          *                           (see Note #2a1).
   1454          *********************************************************************************************************
   1455          */
   1456          

   \                                 In section .text, align 2, keep-with-next
   1457          CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
   1458                                           CPU_CHAR   srch_char)
   1459          {
   \                     Str_Char_Last:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1460              CPU_CHAR  *pstr_rtn;
   1461          
   1462          
   1463              pstr_rtn = Str_Char_Last_N(pstr,
   1464                                         DEF_INT_CPU_U_MAX_VAL,
   1465                                         srch_char);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Str_Char_Last_N
   \   00000014   0x0006             MOVS     R6,R0
   1466          
   1467              return (pstr_rtn);
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   1468          }
   1469          
   1470          
   1471          /*$PAGE*/
   1472          /*
   1473          *********************************************************************************************************
   1474          *                                          Str_Char_Last_N()
   1475          *
   1476          * Description : Search string for last occurrence of specific character, up to a maximum number 
   1477          *                   of characters.
   1478          *
   1479          * Argument(s) : pstr            Pointer to string (see Note #1).
   1480          *
   1481          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1482          *
   1483          *               srch_char       Search character.
   1484          *
   1485          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1486          *
   1487          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1488          *
   1489          * Caller(s)   : Application.
   1490          *
   1491          * Note(s)     : (1) String buffer NOT modified.
   1492          *
   1493          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1494          *
   1495          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
   1496          *                            ... in the string pointed to by 's' ('pstr')."
   1497          *                       (2) "The terminating null byte is considered to be part of the string."
   1498          *
   1499          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
   1500          *                       "upon successful completion, strrchr() shall return" :
   1501          *
   1502          *                       (1) "a pointer to the byte" ...
   1503          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1504          *                           (A) #### Although NO strrchr() specification states to return NULL for 
   1505          *                               any other reason(s), NULL is also returned for any error(s).
   1506          *
   1507          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1508          *                       argument list for consistency with all other custom string library functions.
   1509          *                       However, the 'len_max' argument is sequentially ordered as the second argument 
   1510          *                       to comply with most standard library's strnrchr() argument list.
   1511          *
   1512          *                       See also 'Str_Char_N()  Note #2c'.
   1513          *
   1514          *               (3) String search terminates when :
   1515          *
   1516          *                   (a) String pointer passed a NULL pointer.
   1517          *                       (1) No string search performed; NULL pointer returned.
   1518          *
   1519          *                   (b) String pointer points to NULL.
   1520          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1521          *
   1522          *                   (c) String searched from end to beginning.
   1523          *                       (1) Search character NOT found in search string; NULL pointer returned 
   1524          *                           (see Note #2b2).
   1525          *                       (2) Applicable even if search character is the terminating NULL character 
   1526          *                           (see Note #2a2).
   1527          *
   1528          *                   (d) Search character found.
   1529          *                       (1) Return pointer to last occurrence of search character in search string 
   1530          *                           (see Note #2a1).
   1531          *
   1532          *                   (e) 'len_max' number of characters searched.
   1533          *                       (1) Search character NOT found in search string within last 'len_max' number 
   1534          *                           of characters; NULL pointer returned.
   1535          *                       (2) 'len_max' number of characters MAY include terminating NULL character 
   1536          *                           (see Note #2a2).
   1537          *********************************************************************************************************
   1538          */
   1539          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   1540          CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
   1541                                             CPU_SIZE_T   len_max,
   1542                                             CPU_CHAR     srch_char)
   1543          {
   \                     Str_Char_Last_N:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1544              const  CPU_CHAR    *pstr_char;
   1545                     CPU_SIZE_T   str_len_max;
   1546                     CPU_SIZE_T   str_len;
   1547          
   1548          
   1549              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Char_Last_N_0
   1550                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE024             B.N      ??Str_Char_Last_N_1
   1551              }
   1552          
   1553              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_Last_N_0:
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??Str_Char_Last_N_2
   1554                  return ((CPU_CHAR *)0);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE020             B.N      ??Str_Char_Last_N_1
   1555              }
   1556          
   1557          
   1558              pstr_char    = pstr;
   \                     ??Str_Char_Last_N_2:
   \   0000001A   0x46A1             MOV      R9,R4
   1559               str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
   \   0000001C   0x1E68             SUBS     R0,R5,#+1
   \   0000001E   0x0007             MOVS     R7,R0
   1560               str_len     = Str_Len_N(pstr_char, str_len_max);
   \   00000020   0x0039             MOVS     R1,R7
   \   00000022   0x4648             MOV      R0,R9
   \   00000024   0x.... 0x....      BL       Str_Len_N
   \   00000028   0x4680             MOV      R8,R0
   1561              pstr_char   += str_len;
   \   0000002A   0xEB18 0x0909      ADDS     R9,R8,R9
   1562          
   1563              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
   \   0000002E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000032   0xD101             BNE.N    ??Str_Char_Last_N_3
   1564                  return ((CPU_CHAR *)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE011             B.N      ??Str_Char_Last_N_1
   1565              }
   1566          
   1567              while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
   1568                     (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
   \                     ??Str_Char_Last_N_3:
   \   00000038   0x45A1             CMP      R9,R4
   \   0000003A   0xD007             BEQ.N    ??Str_Char_Last_N_4
   \   0000003C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x42B0             CMP      R0,R6
   \   00000044   0xD002             BEQ.N    ??Str_Char_Last_N_4
   1569                  pstr_char--;
   \   00000046   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000004A   0xE7F5             B.N      ??Str_Char_Last_N_3
   1570              }
   1571          
   1572          
   1573              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
   \                     ??Str_Char_Last_N_4:
   \   0000004C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x42B0             CMP      R0,R6
   \   00000054   0xD001             BEQ.N    ??Str_Char_Last_N_5
   1574                   return ((CPU_CHAR *)0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B.N      ??Str_Char_Last_N_1
   1575              }
   1576          
   1577          
   1578              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
   \                     ??Str_Char_Last_N_5:
   \   0000005A   0x4648             MOV      R0,R9
   \                     ??Str_Char_Last_N_1:
   \   0000005C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1579          }
   1580          
   1581          
   1582          /*$PAGE*/
   1583          /*
   1584          *********************************************************************************************************
   1585          *                                         Str_Char_Replace()
   1586          *
   1587          * Description : Search string for specific character and replace it by another specific character.
   1588          *
   1589          * Argument(s) : pstr            Pointer to string (see Note #1).
   1590          *
   1591          *               char_srch       Search character.
   1592          *
   1593          *               char_replace    Replace character.
   1594          *
   1595          * Return(s)   : Pointer to string, if NO error(s).
   1596          *
   1597          *               Pointer to NULL,   otherwise.
   1598          *
   1599          * Caller(s)   : Application.
   1600          *
   1601          * Note(s)     : (1) String buffer modified.
   1602          *
   1603          *               (2) String search terminates when :
   1604          *
   1605          *                   (a) String pointer passed a NULL pointer.
   1606          *                       (1) No string search performed; NULL pointer returned.
   1607          *
   1608          *                   (b) String pointer points to NULL.
   1609          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1610          *
   1611          *                   (c) String's terminating NULL character found.
   1612          *                       (1) Search character NOT found in search string; NULL pointer returned
   1613          *                       (2) Applicable even if search character is the terminating NULL character
   1614          *
   1615          *                   (d) Search character found.
   1616          *                       (1) Replace character found by the specified character.
   1617          *********************************************************************************************************
   1618          */
   1619          

   \                                 In section .text, align 2, keep-with-next
   1620          CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
   1621                                       CPU_CHAR   char_srch,
   1622                                       CPU_CHAR   char_replace)
   1623          {
   \                     Str_Char_Replace:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1624              CPU_CHAR  *pstr_rtn;
   1625          
   1626          
   1627              pstr_rtn = Str_Char_Replace_N(pstr,
   1628                                            char_srch,
   1629                                            char_replace,
   1630                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000008   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       Str_Char_Replace_N
   \   0000001A   0x0007             MOVS     R7,R0
   1631          
   1632              return (pstr_rtn);
   \   0000001C   0x0038             MOVS     R0,R7
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1633          }
   1634          
   1635          
   1636          /*$PAGE*/
   1637          /*
   1638          *********************************************************************************************************
   1639          *                                        Str_Char_Replace_N()
   1640          *
   1641          * Description : Search string for specific character and replace it by another specific character, up to
   1642          *               a maximum number of characters.
   1643          *
   1644          * Argument(s) : pstr            Pointer to string (see Note #1).
   1645          *
   1646          *               char_srch       Search character.
   1647          *
   1648          *               char_replace    Replace character.
   1649          *
   1650          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1651          *
   1652          * Return(s)   : Pointer to string, if NO error(s).
   1653          *
   1654          *               Pointer to NULL,   otherwise.
   1655          *
   1656          * Caller(s)   : Application.
   1657          *
   1658          * Note(s)     : (1) String buffer modified.
   1659          *
   1660          *               (2) String search terminates when :
   1661          *
   1662          *                   (a) String pointer passed a NULL pointer.
   1663          *                       (1) No string search performed; NULL pointer returned.
   1664          *
   1665          *                   (b) String pointer points to NULL.
   1666          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1667          *
   1668          *                   (c) String's terminating NULL character found.
   1669          *                       (1) Search character NOT found in search string; NULL pointer returned
   1670          *                       (2) Applicable even if search character is the terminating NULL character
   1671          *
   1672          *                   (d) Search character found.
   1673          *                       (1) Replace character found by the specified character.
   1674          *
   1675          *                   (e) 'len_max' number of characters searched.
   1676          *                       (1) Search character NOT found in search string within first 'len_max' number
   1677          *                           of characters; NULL pointer returned.
   1678          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1679          *                           (see Note #2a2).
   1680          *********************************************************************************************************
   1681          */
   1682          

   \                                 In section .text, align 2, keep-with-next
   1683          CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
   1684                                         CPU_CHAR     char_srch,
   1685                                         CPU_CHAR     char_replace,
   1686                                         CPU_SIZE_T   len_max)
   1687          {
   \                     Str_Char_Replace_N:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
   1688              CPU_CHAR    *pstr_char;
   1689              CPU_SIZE_T   len;
   1690          
   1691          
   1692              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??Str_Char_Replace_N_0
   1693                  return ((CPU_CHAR *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE015             B.N      ??Str_Char_Replace_N_1
   1694              }
   1695          
   1696              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
   \                     ??Str_Char_Replace_N_0:
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Char_Replace_N_2
   1697                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE011             B.N      ??Str_Char_Replace_N_1
   1698              }
   1699          
   1700              pstr_char = pstr;
   \                     ??Str_Char_Replace_N_2:
   \   00000014   0x0025             MOVS     R5,R4
   1701              len       = len_max;
   \   00000016   0x001E             MOVS     R6,R3
   1702          
   1703              while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
   1704                     (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
   1705                     ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
   \                     ??Str_Char_Replace_N_3:
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD00C             BEQ.N    ??Str_Char_Replace_N_4
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD009             BEQ.N    ??Str_Char_Replace_N_4
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD007             BEQ.N    ??Str_Char_Replace_N_4
   1706          
   1707                  if (*pstr_char == char_srch) {
   \   00000026   0x7828             LDRB     R0,[R5, #+0]
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD100             BNE.N    ??Str_Char_Replace_N_5
   1708                      *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
   \   0000002E   0x702A             STRB     R2,[R5, #+0]
   1709                  }
   1710          
   1711                  pstr_char++;
   \                     ??Str_Char_Replace_N_5:
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
   1712                  len--;
   \   00000032   0x1E76             SUBS     R6,R6,#+1
   \   00000034   0xE7F0             B.N      ??Str_Char_Replace_N_3
   1713              }
   1714          
   1715              return (pstr);
   \                     ??Str_Char_Replace_N_4:
   \   00000036   0x0020             MOVS     R0,R4
   \                     ??Str_Char_Replace_N_1:
   \   00000038   0xBC70             POP      {R4-R6}
   \   0000003A   0x4770             BX       LR               ;; return
   1716          }
   1717          
   1718          
   1719          /*$PAGE*/
   1720          /*
   1721          *********************************************************************************************************
   1722          *                                              Str_Str()
   1723          *
   1724          * Description : Search string for first occurence of a specific search string.
   1725          *
   1726          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1727          *
   1728          *               pstr_srch       Pointer to search string (see Note #1).
   1729          *
   1730          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1731          *
   1732          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1733          *
   1734          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1735          *
   1736          * Caller(s)   : Application.
   1737          *
   1738          * Note(s)     : (1) String buffers NOT modified.
   1739          *
   1740          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1741          *
   1742          *                       (1) "The strstr() function shall locate the first occurrence  in the string 
   1743          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
   1744          *                            pointed to by 's2' ('pstr_srch')" ...
   1745          *                       (2) "(excluding the terminating null byte)."
   1746          *
   1747          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1748          *
   1749          *                       (1) "Upon successful completion, strstr() shall return" :
   1750          *                           (A) "a pointer to the located string" ...
   1751          *                           (B) "or a null pointer if the string is not found."
   1752          *                               (1) #### Although NO strstr() specification states to return NULL for 
   1753          *                                   any other reason(s), NULL is also returned for any error(s).
   1754          *
   1755          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
   1756          *                            shall return 's1' ('pstr')."
   1757          *
   1758          *               (3) String search terminates when :
   1759          *
   1760          *                   (a) String pointer(s) are passed NULL pointers.
   1761          *                       (1) No string search performed; NULL pointer returned.
   1762          *
   1763          *                   (b) String pointer(s) point to NULL.
   1764          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1765          *
   1766          *                   (c) Search string length equal to zero.
   1767          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1768          *
   1769          *                   (d) Search string length greater than string length.
   1770          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1771          *
   1772          *                   (e) Entire string has been searched.
   1773          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1774          *
   1775          *                   (f) Search string found.
   1776          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1777          *********************************************************************************************************
   1778          */
   1779          

   \                                 In section .text, align 2, keep-with-next
   1780          CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
   1781                              const  CPU_CHAR  *pstr_srch)
   1782          {
   \                     Str_Str:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1783              CPU_CHAR  *pstr_rtn;
   1784          
   1785          
   1786              pstr_rtn = Str_Str_N(pstr,
   1787                                   pstr_srch,
   1788                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       Str_Str_N
   \   00000012   0x0006             MOVS     R6,R0
   1789          
   1790              return (pstr_rtn);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
   1791          }
   1792          
   1793          
   1794          /*$PAGE*/
   1795          /*
   1796          *********************************************************************************************************
   1797          *                                             Str_Str_N()
   1798          *
   1799          * Description : Search string for first occurence of a specific search string, up to a maximum number 
   1800          *                   of characters.
   1801          *
   1802          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1803          *
   1804          *               pstr_srch       Pointer to search string (see Note #1).
   1805          *
   1806          *               len_max         Maximum number of characters to search (see Note #3g).
   1807          *
   1808          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1809          *
   1810          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1811          *
   1812          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1813          *
   1814          * Caller(s)   : Application.
   1815          *
   1816          * Note(s)     : (1) String buffers NOT modified.
   1817          *
   1818          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1819          *
   1820          *                       (1) "The strstr() function shall locate the first occurrence  in the string 
   1821          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
   1822          *                            pointed to by 's2' ('pstr_srch')" ...
   1823          *                       (2) "(excluding the terminating null byte)."
   1824          *
   1825          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1826          *
   1827          *                       (1) "Upon successful completion, strstr() shall return" :
   1828          *                           (A) "a pointer to the located string" ...
   1829          *                           (B) "or a null pointer if the string is not found."
   1830          *                               (1) #### Although NO strstr() specification states to return NULL for 
   1831          *                                   any other reason(s), NULL is also returned for any error(s).
   1832          *
   1833          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
   1834          *                            shall return 's1' ('pstr')."
   1835          *
   1836          *               (3) String search terminates when :
   1837          *
   1838          *                   (a) String pointer(s) are passed NULL pointers.
   1839          *                       (1) No string search performed; NULL pointer returned.
   1840          *
   1841          *                   (b) String pointer(s) point to NULL.
   1842          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1843          *
   1844          *                   (c) Search string length equal to zero.
   1845          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1846          *
   1847          *                   (d) Search string length greater than string length.
   1848          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1849          *
   1850          *                   (e) Entire string has been searched.
   1851          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1852          *                       (2) Maximum size of the search is defined as the subtraction of the
   1853          *                           search string length from the string length.
   1854          *
   1855          *                   (f) Search string found.
   1856          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1857          *                       (2) Search string found via Str_Cmp_N().
   1858          *
   1859          *                   (g) 'len_max' number of characters searched.
   1860          *                       (1) 'len_max' number of characters does NOT include terminating NULL character
   1861          *                           (see Note #2a2).
   1862          *********************************************************************************************************
   1863          */
   1864          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   1865          CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
   1866                                const  CPU_CHAR    *pstr_srch,
   1867                                       CPU_SIZE_T   len_max)
   1868          {
   \                     Str_Str_N:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1869                     CPU_SIZE_T    str_len;
   1870                     CPU_SIZE_T    str_len_srch;
   1871                     CPU_SIZE_T    len_max_srch;
   1872                     CPU_SIZE_T    srch_len;
   1873                     CPU_SIZE_T    srch_ix;
   1874                     CPU_BOOLEAN   srch_done;
   1875                     CPU_INT16S    srch_cmp;
   1876              const  CPU_CHAR     *pstr_str;
   1877              const  CPU_CHAR     *pstr_srch_ix;
   1878          
   1879                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
   1880              if (pstr == (const CPU_CHAR *)0) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??Str_Str_N_0
   1881                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE05E             B.N      ??Str_Str_N_1
   1882              }
   1883              if (pstr_srch == (const CPU_CHAR *)0) {
   \                     ??Str_Str_N_0:
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD101             BNE.N    ??Str_Str_N_2
   1884                  return ((CPU_CHAR *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE05A             B.N      ??Str_Str_N_1
   1885              }
   1886          
   1887              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
   \                     ??Str_Str_N_2:
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE.N    ??Str_Str_N_3
   1888                  return ((CPU_CHAR *)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE056             B.N      ??Str_Str_N_1
   1889              }
   1890          
   1891                                                                          /* Lim max srch str len (to chk > str len).             */
   1892              len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
   1893                           ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
   \                     ??Str_Str_N_3:
   \   00000024   0xF116 0x0F01      CMN      R6,#+1
   \   00000028   0xD002             BEQ.N    ??Str_Str_N_4
   \   0000002A   0x1C70             ADDS     R0,R6,#+1
   \   0000002C   0x9002             STR      R0,[SP, #+8]
   \   0000002E   0xE002             B.N      ??Str_Str_N_5
   \                     ??Str_Str_N_4:
   \   00000030   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000034   0x9002             STR      R0,[SP, #+8]
   1894          
   1895              str_len      = Str_Len_N(pstr,      len_max);
   \                     ??Str_Str_N_5:
   \   00000036   0x0031             MOVS     R1,R6
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       Str_Len_N
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   1896              str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
   \   00000040   0x9902             LDR      R1,[SP, #+8]
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       Str_Len_N
   \   00000048   0x0007             MOVS     R7,R0
   1897              if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xD101             BNE.N    ??Str_Str_N_6
   1898                  return ((CPU_CHAR *)pstr);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xE03F             B.N      ??Str_Str_N_1
   1899              }
   1900              if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
   \                     ??Str_Str_N_6:
   \   00000052   0x9801             LDR      R0,[SP, #+4]
   \   00000054   0x42B8             CMP      R0,R7
   \   00000056   0xD201             BCS.N    ??Str_Str_N_7
   1901                  return ((CPU_CHAR *)0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE03A             B.N      ??Str_Str_N_1
   1902              }
   1903                                                                          /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
   1904              pstr_str = pstr      + str_len;
   \                     ??Str_Str_N_7:
   \   0000005C   0x9801             LDR      R0,[SP, #+4]
   \   0000005E   0x1900             ADDS     R0,R0,R4
   \   00000060   0x9000             STR      R0,[SP, #+0]
   1905              if (pstr_str == (const CPU_CHAR *)0) {
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD101             BNE.N    ??Str_Str_N_8
   1906                  return ((CPU_CHAR *)0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE032             B.N      ??Str_Str_N_1
   1907              }
   1908              pstr_str = pstr_srch + str_len_srch;
   \                     ??Str_Str_N_8:
   \   0000006C   0x1978             ADDS     R0,R7,R5
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   1909              if (pstr_str == (const CPU_CHAR *)0) {
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD101             BNE.N    ??Str_Str_N_9
   1910                  return ((CPU_CHAR *)0);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE02B             B.N      ??Str_Str_N_1
   1911              }
   1912          
   1913          
   1914              srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
   \                     ??Str_Str_N_9:
   \   0000007A   0x9801             LDR      R0,[SP, #+4]
   \   0000007C   0x1BC0             SUBS     R0,R0,R7
   \   0000007E   0x9003             STR      R0,[SP, #+12]
   1915              srch_ix   = 0u;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x4680             MOV      R8,R0
   1916              srch_done = DEF_NO;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x4681             MOV      R9,R0
   1917          
   1918              do {
   1919                  pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
   \                     ??Str_Str_N_10:
   \   00000088   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000008C   0x4683             MOV      R11,R0
   1920                  srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
   \   0000008E   0x003A             MOVS     R2,R7
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x4658             MOV      R0,R11
   \   00000094   0x.... 0x....      BL       Str_Cmp_N
   \   00000098   0x4682             MOV      R10,R0
   1921                  srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
   \   0000009A   0xFA0F 0xFA8A      SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
   \   0000009E   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A2   0xD102             BNE.N    ??Str_Str_N_11
   \   000000A4   0xF05F 0x0901      MOVS     R9,#+1
   \   000000A8   0xE001             B.N      ??Str_Str_N_12
   \                     ??Str_Str_N_11:
   \   000000AA   0xF05F 0x0900      MOVS     R9,#+0
   1922                  srch_ix++;
   \                     ??Str_Str_N_12:
   \   000000AE   0xF118 0x0801      ADDS     R8,R8,#+1
   1923              } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
   \   000000B2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000B6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BA   0xD102             BNE.N    ??Str_Str_N_13
   \   000000BC   0x9803             LDR      R0,[SP, #+12]
   \   000000BE   0x4540             CMP      R0,R8
   \   000000C0   0xD2E2             BCS.N    ??Str_Str_N_10
   1924          
   1925          
   1926              if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
   \                     ??Str_Str_N_13:
   \   000000C2   0xFA0F 0xFA8A      SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
   \   000000C6   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000CA   0xD001             BEQ.N    ??Str_Str_N_14
   1927                  return ((CPU_CHAR *)0);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE000             B.N      ??Str_Str_N_1
   1928              }
   1929          
   1930              return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
   \                     ??Str_Str_N_14:
   \   000000D0   0x4658             MOV      R0,R11
   \                     ??Str_Str_N_1:
   \   000000D2   0xB005             ADD      SP,SP,#+20
   \   000000D4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1931          }
   1932          
   1933          
   1934          /*$PAGE*/
   1935          /*
   1936          *********************************************************************************************************
   1937          *                                         Str_FmtNbr_Int32U()
   1938          *
   1939          * Description : Format 32-bit unsigned integer into a multi-digit character string.
   1940          *
   1941          * Argument(s) : nbr             Number           to format.
   1942          *
   1943          *               nbr_dig         Number of digits to format (see Note #1).
   1944          *
   1945          *                               The following may be used to specify the number of digits to format :
   1946          *
   1947          *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
   1948          *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
   1949          *
   1950          *               nbr_base        Base   of number to format (see Note #2).
   1951          *
   1952          *                               The following may be used to specify the number base :
   1953          *
   1954          *                                   DEF_NBR_BASE_BIN            Base  2
   1955          *                                   DEF_NBR_BASE_OCT            Base  8
   1956          *                                   DEF_NBR_BASE_DEC            Base 10
   1957          *                                   DEF_NBR_BASE_HEX            Base 16
   1958          *
   1959          *               lead_char       Prepend leading character  (see Note #3) :
   1960          *
   1961          *                                   '\0'                    Do NOT prepend leading character to string.
   1962          *                                     Printable character          Prepend leading character to string.
   1963          *                                   Unprintable character   Format invalid string (see Note #6).
   1964          *
   1965          *               lower_case      Format alphabetic characters (if any) in lower case :
   1966          *
   1967          *                                   DEF_NO          Format alphabetic characters in upper case.
   1968          *                                   DEF_YES         Format alphabetic characters in lower case.
   1969          *
   1970          *               nul             Append terminating NULL-character (see Note #4) :
   1971          *
   1972          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1973          *                                   DEF_YES                Append terminating NULL-character to string.
   1974          *
   1975          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1976          *
   1977          * Return(s)   : Pointer to formatted string, if NO error(s).
   1978          *
   1979          *               Pointer to NULL,             otherwise.
   1980          *
   1981          * Caller(s)   : Application.
   1982          *
   1983          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
   1984          *                       is performed except possible NULL-termination of the string (see Note #4).
   1985          *
   1986          *                           Example :
   1987          *
   1988          *                               nbr      = 23456
   1989          *                               nbr_dig  = 0
   1990          *                               nbr_base = 10
   1991          *
   1992          *                               pstr     = ""                   See Note #6a
   1993          *
   1994          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
   1995          *                       significant integer digits of the number to format ('nbr'); then an invalid 
   1996          *                       string is formatted instead of truncating any significant integer digits.
   1997          *
   1998          *                           Example :
   1999          *
   2000          *                               nbr      = 23456
   2001          *                               nbr_dig  = 3
   2002          *                               nbr_base = 10
   2003          *
   2004          *                               pstr     = "???"                See Note #6b
   2005          *
   2006          *               (2) The number's base MUST be between 2 & 36, inclusive.
   2007          *$PAGE*
   2008          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2009          *
   2010          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2011          *
   2012          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   2013          *                           (B) with the exception of '0'.
   2014          *
   2015          *                   (b) The number of leading characters is such that the total number of significant 
   2016          *                       integer digits plus the number of leading characters is equal to the requested 
   2017          *                       number of integer digits to format ('nbr_dig').
   2018          *
   2019          *                           Example :
   2020          *
   2021          *                               nbr       = 23456
   2022          *                               nbr_dig   = 7
   2023          *                               nbr_base  = 10
   2024          *                               lead_char = ' '
   2025          *
   2026          *                               pstr      = "  23456"
   2027          *
   2028          *                   (c) (1) If the value of the number to format is     zero  ...
   2029          *                       (2) ... & the number of digits to format is non-zero, ...
   2030          *                       (3) ... but NO leading character available;           ...
   2031          *                       (4) ... then one digit of '0' value is formatted.
   2032          *
   2033          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2034          *
   2035          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2036          *                       array formatting.
   2037          *
   2038          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2039          *                       terminate option DISABLED will cause character string run-on.
   2040          *
   2041          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2042          *
   2043          *                   (b) To prevent character buffer overrun :
   2044          *
   2045          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2046          *                                                               1 'NUL' terminator)  characters
   2047          *
   2048          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
   2049          *                   ('?') will be formatted, where the number of question marks is determined by the 
   2050          *                   number of digits to format ('nbr_dig') :
   2051          *
   2052          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2053          *                          number of     =  {
   2054          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2055          *
   2056          *********************************************************************************************************
   2057          */
   2058          

   \                                 In section .text, align 2, keep-with-next
   2059          CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
   2060                                        CPU_INT08U    nbr_dig,
   2061                                        CPU_INT08U    nbr_base,
   2062                                        CPU_CHAR      lead_char,
   2063                                        CPU_BOOLEAN   lower_case,
   2064                                        CPU_BOOLEAN   nul,
   2065                                        CPU_CHAR     *pstr)
   2066          {
   \                     Str_FmtNbr_Int32U:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9D0E             LDR      R5,[SP, #+56]
   \   00000010   0x9C0F             LDR      R4,[SP, #+60]
   \   00000012   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   2067              CPU_CHAR  *pstr_fmt;
   2068          
   2069          
   2070              pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
   2071                                          nbr_dig,
   2072                                          nbr_base,
   2073                                          DEF_NO,
   2074                                          lead_char,
   2075                                          lower_case,
   2076                                          nul,
   2077                                          pstr);
   \   00000016   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x9402             STR      R4,[SP, #+8]
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x9501             STR      R5,[SP, #+4]
   \   00000022   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000026   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x4642             MOV      R2,R8
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x0039             MOVS     R1,R7
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       Str_FmtNbr_Int32
   \   0000003A   0x4683             MOV      R11,R0
   2078          
   2079              return (pstr_fmt);
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0xB005             ADD      SP,SP,#+20
   \   00000040   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2080          }
   2081          
   2082          
   2083          /*$PAGE*/
   2084          /*
   2085          *********************************************************************************************************
   2086          *                                         Str_FmtNbr_Int32S()
   2087          *
   2088          * Description : Format 32-bit signed integer into a multi-digit character string.
   2089          *
   2090          * Argument(s) : nbr             Number           to format.
   2091          *
   2092          *               nbr_dig         Number of digits to format (see Note #1).
   2093          *
   2094          *                               The following may be used to specify the number of digits to format :
   2095          *
   2096          *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
   2097          *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
   2098          *                                                                   (plus 1 digit for possible negative sign)
   2099          *
   2100          *               nbr_base        Base   of number to format (see Note #2).
   2101          *
   2102          *                               The following may be used to specify the number base :
   2103          *
   2104          *                                   DEF_NBR_BASE_BIN            Base  2
   2105          *                                   DEF_NBR_BASE_OCT            Base  8
   2106          *                                   DEF_NBR_BASE_DEC            Base 10
   2107          *                                   DEF_NBR_BASE_HEX            Base 16
   2108          *
   2109          *               lead_char       Prepend leading character  (see Note #3) :
   2110          *
   2111          *                                   '\0'                    Do NOT prepend leading character to string.
   2112          *                                     Printable character          Prepend leading character to string.
   2113          *                                   Unprintable character   Format invalid string (see Note #6).
   2114          *
   2115          *               lower_case      Format alphabetic characters (if any) in lower case :
   2116          *
   2117          *                                   DEF_NO          Format alphabetic characters in upper case.
   2118          *                                   DEF_YES         Format alphabetic characters in lower case.
   2119          *
   2120          *               nul             Append terminating NULL-character (see Note #4) :
   2121          *
   2122          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2123          *                                   DEF_YES                Append terminating NULL-character to string.
   2124          *
   2125          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2126          *
   2127          * Return(s)   : Pointer to formatted string, if NO error(s).
   2128          *
   2129          *               Pointer to NULL,             otherwise.
   2130          *
   2131          * Caller(s)   : Application.
   2132          *
   2133          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
   2134          *                       is performed except possible NULL-termination of the string (see Note #4).
   2135          *
   2136          *                           Example :
   2137          *
   2138          *                               nbr      = -23456
   2139          *                               nbr_dig  =  0
   2140          *                               nbr_base = 10
   2141          *
   2142          *                               pstr     = ""                   See Note #6a
   2143          *
   2144          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
   2145          *                       significant integer digits of the number to format ('nbr'); then an invalid 
   2146          *                       string is formatted instead of truncating any significant integer digits.
   2147          *
   2148          *                           Example :
   2149          *
   2150          *                               nbr      = 23456
   2151          *                               nbr_dig  = 3
   2152          *                               nbr_base = 10
   2153          *
   2154          *                               pstr     = "???"                See Note #6b
   2155          *
   2156          *                   (c) If the number to format ('nbr') is negative but the number of digits to format 
   2157          *                       ('nbr_dig') is equal to the number of significant integer digits of the number 
   2158          *                       to format ('nbr'); then an invalid string is formatted instead of truncating 
   2159          *                       the negative sign.
   2160          *
   2161          *                           Example :
   2162          *
   2163          *                               nbr      = -23456
   2164          *                               nbr_dig  =  5
   2165          *                               nbr_base = 10
   2166          *
   2167          *                               pstr     = "?????"              See Note #6b
   2168          *
   2169          *               (2) The number's base MUST be between 2 & 36, inclusive.
   2170          *$PAGE*
   2171          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2172          *
   2173          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2174          *
   2175          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   2176          *                           (B) with the exception of '0'.
   2177          *
   2178          *                   (b) (1) The number of leading characters is such that the total number of significant 
   2179          *                           integer digits plus the number of leading characters plus possible negative 
   2180          *                           sign character is equal to the requested number of integer digits to format 
   2181          *                           ('nbr_dig').
   2182          *
   2183          *                               Examples :
   2184          *
   2185          *                                   nbr       = 23456
   2186          *                                   nbr_dig   = 7
   2187          *                                   nbr_base  = 10
   2188          *                                   lead_char = ' '
   2189          *
   2190          *                                   pstr      = "  23456"
   2191          *
   2192          *
   2193          *                                   nbr       = -23456
   2194          *                                   nbr_dig   =  7
   2195          *                                   nbr_base  = 10
   2196          *                                   lead_char = ' '
   2197          *
   2198          *                                   pstr      = " -23456"
   2199          *
   2200          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
   2201          *                               ('lead_char') is     a '0' digit; then the negative sign character 
   2202          *                               prefixes all leading characters prior to the formatted number.
   2203          *
   2204          *                                   Examples :
   2205          *
   2206          *                                       nbr        = -23456
   2207          *                                       nbr_dig    =  8
   2208          *                                       nbr_base   = 10
   2209          *                                       lead_char  = '0'
   2210          *
   2211          *                                       pstr       = "-0023456"
   2212          *
   2213          *
   2214          *                                       nbr        = -43981
   2215          *                                       nbr_dig    =  8
   2216          *                                       nbr_base   = 16
   2217          *                                       lead_char  = '0'
   2218          *                                       lower_case = DEF_NO
   2219          *
   2220          *                                       pstr       = "-000ABCD"
   2221          *
   2222          *                           (B) If the number to format ('nbr') is negative AND the leading character 
   2223          *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
   2224          *                               immediately prefixes the most significant digit of the formatted number.
   2225          *
   2226          *                                   Examples :
   2227          *
   2228          *                                       nbr        = -23456
   2229          *                                       nbr_dig    =  8
   2230          *                                       nbr_base   = 10
   2231          *                                       lead_char  = '#'
   2232          *
   2233          *                                       pstr       = "##-23456"
   2234          *
   2235          *
   2236          *                                       nbr        = -43981
   2237          *                                       nbr_dig    =  8
   2238          *                                       nbr_base   = 16
   2239          *                                       lead_char  = '#'
   2240          *                                       lower_case = DEF_YES
   2241          *
   2242          *                                       pstr       = "###-abcd"
   2243          *
   2244          *                   (c) (1) If the value of the number to format is     zero  ...
   2245          *                       (2) ... & the number of digits to format is non-zero, ...
   2246          *                       (3) ... but NO leading character available;           ...
   2247          *                       (4) ... then one digit of '0' value is formatted.
   2248          *
   2249          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2250          *$PAGE*
   2251          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2252          *                       array formatting.
   2253          *
   2254          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2255          *                       terminate option DISABLED will cause character string run-on.
   2256          *
   2257          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2258          *
   2259          *                   (b) To prevent character buffer overrun :
   2260          *
   2261          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2262          *                                                               1 negative sign   +
   2263          *                                                               1 'NUL' terminator)  characters
   2264          *
   2265          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
   2266          *                   ('?') will be formatted, where the number of question marks is determined by the 
   2267          *                   number of digits to format ('nbr_dig') :
   2268          *
   2269          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2270          *                          number of     =  {
   2271          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2272          *
   2273          *********************************************************************************************************
   2274          */
   2275          

   \                                 In section .text, align 2, keep-with-next
   2276          CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
   2277                                        CPU_INT08U    nbr_dig,
   2278                                        CPU_INT08U    nbr_base,
   2279                                        CPU_CHAR      lead_char,
   2280                                        CPU_BOOLEAN   lower_case,
   2281                                        CPU_BOOLEAN   nul,
   2282                                        CPU_CHAR     *pstr)
   2283          {
   \                     Str_FmtNbr_Int32S:
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x001F             MOVS     R7,R3
   \   0000000A   0x9C10             LDR      R4,[SP, #+64]
   \   0000000C   0x9D11             LDR      R5,[SP, #+68]
   \   0000000E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   2284              CPU_CHAR     *pstr_fmt;
   2285              CPU_INT32S    nbr_fmt;
   2286              CPU_BOOLEAN   nbr_neg;
   2287          
   2288          
   2289              if (nbr < 0) {                                              /* If nbr neg, ...                                      */
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD504             BPL.N    ??Str_FmtNbr_Int32S_0
   2290                  nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
   \   00000016   0x4270             RSBS     R0,R6,#+0
   \   00000018   0x4682             MOV      R10,R0
   2291                  nbr_neg =  DEF_YES;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4683             MOV      R11,R0
   \   0000001E   0xE002             B.N      ??Str_FmtNbr_Int32S_1
   2292              } else {
   2293                  nbr_fmt =  nbr;
   \                     ??Str_FmtNbr_Int32S_0:
   \   00000020   0x46B2             MOV      R10,R6
   2294                  nbr_neg =  DEF_NO;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4683             MOV      R11,R0
   2295              }
   2296          
   2297              pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
   2298                                                      nbr_dig,
   2299                                                      nbr_base,
   2300                                                      nbr_neg,
   2301                                                      lead_char,
   2302                                                      lower_case,
   2303                                                      nul,
   2304                                                      pstr);
   \                     ??Str_FmtNbr_Int32S_1:
   \   00000026   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x9502             STR      R5,[SP, #+8]
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x9401             STR      R4,[SP, #+4]
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x9700             STR      R7,[SP, #+0]
   \   00000036   0x465B             MOV      R3,R11
   \   00000038   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003A   0xF89D 0x2018      LDRB     R2,[SP, #+24]
   \   0000003E   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   00000042   0x4650             MOV      R0,R10
   \   00000044   0x.... 0x....      BL       Str_FmtNbr_Int32
   \   00000048   0x4681             MOV      R9,R0
   2305          
   2306              return (pstr_fmt);
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0xB007             ADD      SP,SP,#+28
   \   0000004E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2307          }
   2308          
   2309          
   2310          /*$PAGE*/
   2311          /*
   2312          *********************************************************************************************************
   2313          *                                           Str_FmtNbr_32()
   2314          *
   2315          * Description : Format number into a multi-digit character string.
   2316          *
   2317          * Argument(s) : nbr             Number                         to format (see Note #1).
   2318          *
   2319          *               nbr_dig         Number of decimal       digits to format (see Note #2).
   2320          *
   2321          *               nbr_dp          Number of decimal point digits to format.
   2322          *
   2323          *               lead_char       Prepend leading character (see Note #3) :
   2324          *
   2325          *                                   '\0'                    Do NOT prepend leading character to string.
   2326          *                                     Printable character          Prepend leading character to string.
   2327          *                                   Unprintable character   Format invalid string (see Note #6d).
   2328          *
   2329          *               nul             Append terminating NULL-character (see Note #4) :
   2330          *
   2331          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2332          *                                   DEF_YES                Append terminating NULL-character to string.
   2333          *
   2334          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2335          *
   2336          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
   2337          *
   2338          *               Pointer to NULL,             otherwise.
   2339          *
   2340          * Caller(s)   : Application.
   2341          *
   2342          * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
   2343          *
   2344          *
   2345          *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
   2346          *                           32-bit Floating-point Number  =  -----------------------------------------------------
   2347          *                                                                             log [External-Base]
   2348          *
   2349          *                                                             log [2 ^ 24]
   2350          *                                                         =  --------------
   2351          *                                                               log [10]
   2352          *
   2353          *                                                         <  7.225  Base-10 Digits
   2354          *
   2355          *                               where
   2356          *                                       Internal-Base                   Internal number base of floating-
   2357          *                                                                           point numbers (i.e.  2)
   2358          *                                       External-Base                   External number base of floating-
   2359          *                                                                           point numbers (i.e. 10)
   2360          *                                       Number-Internal-Base-Digits     Number of internal number base
   2361          *                                                                           significant digits (i.e. 24)
   2362          *
   2363          *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the 
   2364          *                       maximum accuracy.
   2365          *$PAGE*
   2366          *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO 
   2367          *                       formatting is performed except possible NULL-termination of the string (see Note #4).
   2368          *
   2369          *                           Example :
   2370          *
   2371          *                               nbr     = -23456.789
   2372          *                               nbr_dig =  0
   2373          *                               nbr_dp  =  0
   2374          *
   2375          *                               pstr    = ""                        See Note #7a
   2376          *
   2377          *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of 
   2378          *                           significant integer digits of the number to format ('nbr'); then an invalid 
   2379          *                           string is formatted instead of truncating any significant integer digits.
   2380          *
   2381          *                               Example :
   2382          *
   2383          *                                   nbr     = 23456.789
   2384          *                                   nbr_dig = 3
   2385          *                                   nbr_dp  = 2
   2386          *
   2387          *                                   pstr    = "??????"              See Note #7d
   2388          *
   2389          *                       (2) If the number to format ('nbr') is negative but the number of digits to format 
   2390          *                           ('nbr_dig') is equal to the number of significant integer digits of the number 
   2391          *                           to format ('nbr'); then an invalid string is formatted instead of truncating 
   2392          *                           the negative sign.
   2393          *
   2394          *                               Example :
   2395          *
   2396          *                                   nbr     = -23456.789
   2397          *                                   nbr_dig =  5
   2398          *                                   nbr_dp  =  2
   2399          *
   2400          *                                   pstr    = "????????"            See Note #7d
   2401          *
   2402          *                       (3) If the number to format ('nbr') is negative but the number of significant 
   2403          *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one 
   2404          *                           but the number of decimal point digits to format ('nbr_dp') is zero; then 
   2405          *                           an invalid string is formatted instead of truncating the negative sign.
   2406          *
   2407          *                               Example :
   2408          *
   2409          *                                   nbr     = -0.7895
   2410          *                                   nbr_dig =  1
   2411          *                                   nbr_dp  =  0
   2412          *
   2413          *                                   pstr    = "?"                   See Note #7d
   2414          *
   2415          *                       (4) (A) If the number to format ('nbr') is negative but the number of significant 
   2416          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
   2417          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2418          *                               zero; then the negative sign immediately prefixes the decimal point -- 
   2419          *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
   2420          *
   2421          *                                   Example :
   2422          *
   2423          *                                       nbr     = -0.7895
   2424          *                                       nbr_dig =  0
   2425          *                                       nbr_dp  =  2
   2426          *
   2427          *                                       pstr    = "-.78"
   2428          *
   2429          *                           (B) If the number to format ('nbr') is positive but the number of significant 
   2430          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
   2431          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2432          *                               zero; then a single decimal digit of '0' prefixes the decimal point.
   2433          *
   2434          *                               This '0' digit is used whenever a negative sign is not formatted (see 
   2435          *                               Note #2b4A) so that the formatted string's decimal point is not floating, 
   2436          *                               but fixed in the string as the 2nd character.
   2437          *
   2438          *                                   Example :
   2439          *
   2440          *                                       nbr     =  0.7895
   2441          *                                       nbr_dig =  0
   2442          *                                       nbr_dp  =  2
   2443          *
   2444          *                                       pstr    = "0.78"
   2445          *$PAGE*
   2446          *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
   2447          *
   2448          *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point 
   2449          *                               numbers, digits following all significantly-accurate digits of the number to 
   2450          *                               format ('nbr') will be inaccurate; ...
   2451          *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all 
   2452          *                               digits or decimal places following all significantly-accurate digits of the 
   2453          *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
   2454          *
   2455          *                                   Example :
   2456          *
   2457          *                                       nbr                            = 123456789.012345
   2458          *                                       nbr_dig                        = 9
   2459          *                                       nbr_dp                         = 6
   2460          *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
   2461          *
   2462          *                                       pstr                           = "123456700.000000"
   2463          *
   2464          *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr') 
   2465          *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's 
   2466          *                           &/or compiler's floating-point implementation.
   2467          *
   2468          *                       See also Note #1.
   2469          *
   2470          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2471          *
   2472          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2473          *
   2474          *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
   2475          *                           (B) with the exception of '0'.
   2476          *
   2477          *                   (b) (1) The number of leading characters is such that the total number of significant 
   2478          *                           integer digits plus the number of leading characters plus possible negative 
   2479          *                           sign character is equal to the requested number of integer digits to format 
   2480          *                           ('nbr_dig').
   2481          *
   2482          *                               Examples :
   2483          *
   2484          *                                   nbr       = 23456.789
   2485          *                                   nbr_dig   = 7
   2486          *                                   nbr_dp    = 2
   2487          *                                   lead_char = ' '
   2488          *
   2489          *                                   pstr      = "  23456.78"
   2490          *
   2491          *
   2492          *                                   nbr       = -23456.789
   2493          *                                   nbr_dig   =  7
   2494          *                                   nbr_dp    =  2
   2495          *                                   lead_char = ' '
   2496          *
   2497          *                                   pstr      = " -23456.78"
   2498          *
   2499          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
   2500          *                               ('lead_char') is     a '0' digit; then the negative sign character 
   2501          *                               prefixes all leading characters prior to the formatted number.
   2502          *
   2503          *                                   Example :
   2504          *
   2505          *                                       nbr       = -23456.789
   2506          *                                       nbr_dig   =  8
   2507          *                                       nbr_dp    =  2
   2508          *                                       lead_char = '0'
   2509          *
   2510          *                                       pstr      = "-0023456.78"
   2511          *
   2512          *                           (B) If the number to format ('nbr') is negative AND the leading character 
   2513          *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
   2514          *                               immediately prefixes the most significant digit of the formatted number.
   2515          *
   2516          *                                   Examples :
   2517          *
   2518          *                                       nbr       = -23456.789
   2519          *                                       nbr_dig   =  8
   2520          *                                       nbr_dp    =  2
   2521          *                                       lead_char = '#'
   2522          *
   2523          *                                       pstr      = "##-23456.78"
   2524          *
   2525          *                   (c) (1) If the integer value of the number to format is zero & ...
   2526          *                       (2) ... the number of digits to format is greater than one ...
   2527          *                       (3) ... OR  the number is NOT negative,                    ...
   2528          *                       (4) ... but NO leading character available;                ...
   2529          *                       (5) ... then one digit of '0' value is formatted.
   2530          *
   2531          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2532          *
   2533          *                       See also Note #2b4B.
   2534          *$PAGE*
   2535          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2536          *                       array formatting.
   2537          *
   2538          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2539          *                       terminate option DISABLED will cause character string run-on.
   2540          *
   2541          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2542          *
   2543          *                   (b) To prevent character buffer overrun :
   2544          *
   2545          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2546          *                                                              'nbr_dp'           +
   2547          *                                                               1 negative sign   +
   2548          *                                                               1 decimal point   +
   2549          *                                                               1 'NUL' terminator)  characters
   2550          *
   2551          *               (6) String format terminates when :
   2552          *
   2553          *                   (a) Format string pointer is passed a NULL pointer.
   2554          *                       (1) No      string formatted;                NULL pointer returned.
   2555          *
   2556          *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
   2557          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   2558          *
   2559          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
   2560          *                           integer digits of the number to format ('nbr'), including possible 
   2561          *                           negative sign.
   2562          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2563          *
   2564          *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
   2565          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2566          *
   2567          *                   (e) Number successfully formatted into character string array.
   2568          *
   2569          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
   2570          *                   ('?') will be formatted, where the number of question marks is determined by the 
   2571          *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
   2572          *
   2573          *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
   2574          *                                           {                                        'nbr_dp'  = 0
   2575          *                                           {
   2576          *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
   2577          *                                           {                                        'nbr_dp'  = 0
   2578          *                      Invalid string's     {
   2579          *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
   2580          *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
   2581          *                                           {         1 (for negative sign) ]
   2582          *                                           {
   2583          *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
   2584          *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
   2585          *                                           {         1 (for decimal point) ]
   2586          *
   2587          *********************************************************************************************************
   2588          */
   2589          
   2590          #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
   2591          CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
   2592                                    CPU_INT08U    nbr_dig,
   2593                                    CPU_INT08U    nbr_dp,
   2594                                    CPU_CHAR      lead_char,
   2595                                    CPU_BOOLEAN   nul,
   2596                                    CPU_CHAR     *pstr)
   2597          {
   2598              CPU_CHAR     *pstr_fmt;
   2599              CPU_DATA      i;
   2600              CPU_FP32      nbr_fmt;
   2601              CPU_FP32      nbr_log;
   2602              CPU_INT32U    nbr_shiftd;
   2603              CPU_INT16U    nbr_dig_max;
   2604              CPU_INT16U    nbr_dig_sig;
   2605              CPU_INT08U    nbr_neg_sign;
   2606              CPU_INT08U    dig_val;
   2607              CPU_FP32      dig_exp;
   2608              CPU_FP32      dp_exp;
   2609              CPU_BOOLEAN   lead_char_dig;
   2610              CPU_BOOLEAN   lead_char_fmtd;
   2611              CPU_BOOLEAN   lead_char_0;
   2612              CPU_BOOLEAN   fmt_invalid;
   2613              CPU_BOOLEAN   print_char;
   2614              CPU_BOOLEAN   nbr_neg;
   2615              CPU_BOOLEAN   nbr_neg_fmtd;
   2616          
   2617          
   2618          /*$PAGE*/
   2619                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   2620              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   2621                  return ((CPU_CHAR *)0);
   2622              }
   2623          
   2624              fmt_invalid = DEF_NO;
   2625          
   2626              if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
   2627                  fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
   2628              }
   2629          
   2630              if (lead_char != (CPU_CHAR)'\0') {
   2631                  print_char =  ASCII_IsPrint(lead_char);
   2632                  if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
   2633                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
   2634          
   2635                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
   2636                      lead_char_dig = ASCII_IsDig(lead_char);
   2637                      if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
   2638                          fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
   2639                      }
   2640                  }
   2641              }
   2642          
   2643          
   2644                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   2645              pstr_fmt = pstr;
   2646          
   2647              if (fmt_invalid == DEF_NO) {
   2648                  if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
   2649                      nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
   2650                      nbr_neg_sign =  1u;
   2651                      nbr_neg      =  DEF_YES;
   2652                  } else {
   2653                      nbr_fmt      =  nbr;
   2654                      nbr_neg_sign =  0u;
   2655                      nbr_neg      =  DEF_NO;
   2656                  }
   2657          
   2658                  nbr_log     = nbr_fmt;
   2659                  nbr_dig_max = 0u;
   2660                  while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
   2661                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   2662                      nbr_log /= 10.0f;
   2663                  }
   2664          
   2665                  if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
   2666                       (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
   2667                      ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
   2668                       (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
   2669                       (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
   2670                                                                          /* .. prepare nbr digs to fmt.                          */
   2671                      dig_exp = 1.0f;
   2672                      for (i = 1u; i < nbr_dig; i++) {
   2673                          dig_exp *= 10.0f;
   2674                      }
   2675          
   2676                      nbr_neg_fmtd   =  DEF_NO;
   2677                      nbr_dig_sig    =  0u;
   2678                      lead_char_fmtd =  DEF_NO;
   2679                      lead_char_0    = (lead_char == '0')                 /* Chk if lead char a '0' dig (see Note #3b2).          */
   2680                                     ?  DEF_YES : DEF_NO;
   2681          
   2682                  } else {                                                /* Else if nbr trunc'd, ...                             */
   2683                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
   2684                  }
   2685              }
   2686          
   2687          
   2688          /*$PAGE*/
   2689                                                                          /* ------------------- FMT NBR STR -------------------- */
   2690              for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
   2691                  if (fmt_invalid == DEF_NO) {
   2692                      if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
   2693                          nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
   2694                          if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
   2695                              (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
   2696                                                                          /* ... calc & fmt dig val;                     ...      */
   2697                              if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
   2698                                  (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
   2699          
   2700                                  if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
   2701                                      pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
   2702                                  }
   2703                                 *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
   2704                                  nbr_neg_fmtd = DEF_YES;
   2705                              }
   2706          
   2707                              if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
   2708                                  dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
   2709                                 *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
   2710          
   2711                                  nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
   2712          
   2713                              } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
   2714                                         (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
   2715                                 *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
   2716                              }
   2717          
   2718                          } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
   2719                                     (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
   2720                                     (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
   2721          
   2722                             *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
   2723                              nbr_neg_fmtd = DEF_YES;
   2724          
   2725                          } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
   2726                             *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
   2727                              lead_char_fmtd = DEF_YES;
   2728                          }
   2729          
   2730                          dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
   2731          
   2732                      } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
   2733                         *pstr_fmt++ = '0';
   2734                      }
   2735          
   2736                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2737                     *pstr_fmt++ = '?';
   2738                  }
   2739              }
   2740          
   2741          
   2742          /*$PAGE*/
   2743              if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
   2744                  if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
   2745                      if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
   2746                          if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
   2747                              (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
   2748                              *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
   2749                          } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
   2750                              *pstr_fmt++ = '0';
   2751                          }
   2752                      } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
   2753                          *pstr_fmt++ = '?';
   2754                      }
   2755                  }
   2756          
   2757                  if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
   2758                     *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
   2759                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2760                     *pstr_fmt++ = '?';
   2761                  }
   2762          
   2763                  dp_exp = 10.0f;
   2764                  for (i = 0u; i < nbr_dp; i++) {
   2765                      if (fmt_invalid == DEF_NO) {
   2766                                                                          /* If nbr sig digs < max, fmt str dps;    ...           */
   2767                          if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
   2768                              nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
   2769                              dig_val     = (CPU_INT32U)(nbr_shiftd % 10u);
   2770                             *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
   2771                              dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
   2772          
   2773                              if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
   2774                                  (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
   2775                                   nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
   2776                              }
   2777          
   2778                          } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
   2779                             *pstr_fmt++ = '0';
   2780                          }
   2781          
   2782                      } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
   2783                         *pstr_fmt++ = '?';
   2784                      }
   2785                  }
   2786              }
   2787          
   2788          
   2789              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   2790                 *pstr_fmt = (CPU_CHAR)'\0';
   2791              }
   2792          
   2793          
   2794              if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
   2795                  return ((CPU_CHAR *)0);
   2796              }
   2797          
   2798          
   2799              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
   2800          }
   2801          #endif
   2802          
   2803          
   2804          /*$PAGE*/
   2805          /*
   2806          *********************************************************************************************************
   2807          *                                        Str_ParseNbr_Int32U()
   2808          *
   2809          * Description : Parse 32-bit unsigned integer from string.
   2810          *
   2811          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   2812          *
   2813          *               pstr_next   Optional pointer to a variable to ... :
   2814          *
   2815          *                               (a) Return a pointer to first character following the integer string,
   2816          *                                       if NO error(s) [see Note #2a2B2];
   2817          *                               (b) Return a pointer to 'pstr',
   2818          *                                       otherwise      (see Note #2a2A2).
   2819          *
   2820          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   2821          *
   2822          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   2823          *
   2824          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   2825          *
   2826          *               0,                   otherwise                            (see Note #2a3B).
   2827          *
   2828          * Caller(s)   : Application.
   2829          *
   2830          * Note(s)     : (1) String buffer NOT modified.
   2831          *
   2832          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
   2833          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
   2834          *                       to a type unsigned long ... representation" :
   2835          *
   2836          *                       (1) "First, they decompose the input string into three parts" :
   2837          *
   2838          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   2839          *                                by isspace()]."
   2840          *
   2841          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   2842          *                                    input string, starting with the first non-white-space character that is of
   2843          *                                    the expected form.  The subject sequence shall contain no characters if the
   2844          *                                    input string is empty or consists entirely of white-space characters."
   2845          *
   2846          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   2847          *                                    determined by the value of 'base' ('nbr_base')" :
   2848          *
   2849          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
   2850          *                                        subject sequence is that of a decimal constant, octal constant, or 
   2851          *                                        hexadecimal constant" :
   2852          *
   2853          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   2854          *                                            sequence of decimal digits."
   2855          *
   2856          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   2857          *                                            a sequence of the digits '0' to '7' only."
   2858          *
   2859          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   2860          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   2861          *                                            (or 'F') with values 10 to 15 respectively."
   2862          *
   2863          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
   2864          *                                        of the subject sequence is a sequence of letters and digits representing 
   2865          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   2866          *
   2867          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   2868          *                                                ascribed the values 10 to 35"; ...
   2869          *                                           (B) "only letters whose ascribed values are less than that of base
   2870          *                                                are permitted."
   2871          *
   2872          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
   2873          *                                                '0X' may optionally precede the sequence of letters and digits."
   2874          *
   2875          *                                           (B) Although NO specification states that "if the value of 'base' 
   2876          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
   2877          *                                               the sequence of letters and digits"; it seems reasonable to 
   2878          *                                               allow the '0' character to be optionally parsed.
   2879          *
   2880          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   2881          *
   2882          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   2883          *                                       integer string into an unsigned integer.
   2884          *
   2885          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   2886          *                                   (b) "including the terminating null byte of the input string" ...
   2887          *                               (2) "other than a sign or a permissible letter or digit."
   2888          *$PAGE*
   2889          *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
   2890          *
   2891          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   2892          *
   2893          *                               (1) "no conversion [is] performed"; ...
   2894          *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr' 
   2895          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   2896          *
   2897          *                           (B) "If the subject sequence has the expected form" :
   2898          *
   2899          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
   2900          *                                        starting with the first digit shall be interpreted as an integer constant."
   2901          *
   2902          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
   2903          *                                        used as the base for conversion, ascribing to each letter its value as 
   2904          *                                        given above" (see Note #2a1B1b1A).
   2905          *
   2906          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   2907          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
   2908          *                                   pointer."
   2909          *
   2910          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
   2911          *
   2912          *                           (A) "Upon successful completion, these functions shall return the converted value."
   2913          *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
   2914          *                                    ... shall be returned."
   2915          *
   2916          *                           (B) "If no conversion could be performed, 0 shall be returned."
   2917          *
   2918          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2919          *                           shall fail if" :
   2920          *
   2921          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   2922          *
   2923          *                           (B) "[ERANGE] - The value to be returned is not representable."
   2924          *
   2925          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2926          *                           may fail if" :
   2927          *
   2928          *                           (A) "[EINVAL] - No conversion could be performed."
   2929          *
   2930          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   2931          *
   2932          *                   (a) Valid parse string integer :
   2933          *
   2934          *                           pstr      = "     ABCDE xyz"
   2935          *                           nbr_base  = 16
   2936          *
   2937          *                           nbr       = 703710
   2938          *                           pstr_next = " xyz"
   2939          *
   2940          *
   2941          *                   (b) Invalid parse string integer :
   2942          *
   2943          *                           pstr      = "     ABCDE"
   2944          *                           nbr_base  = 10
   2945          *
   2946          *                           nbr       =  0
   2947          *                           pstr_next = pstr = "     ABCDE"
   2948          *
   2949          *
   2950          *                   (c) Valid hexadecimal parse string integer :
   2951          *
   2952          *                           pstr      = "     0xGABCDE"
   2953          *                           nbr_base  = 16
   2954          *
   2955          *                           nbr       =  0
   2956          *                           pstr_next = "xGABCDE"
   2957          *
   2958          *
   2959          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   2960          *                               following invalid hexadecimal characters) :
   2961          *
   2962          *                           pstr      = "     0xGABCDE"
   2963          *                           nbr_base  =  0
   2964          *
   2965          *                           nbr       =  0
   2966          *                           pstr_next = "xGABCDE"
   2967          *
   2968          *
   2969          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2970          *                               following invalid octal       characters) :
   2971          *
   2972          *                           pstr      = "     0GABCDE"
   2973          *                           nbr_base  =  0
   2974          *
   2975          *                           nbr       =  0
   2976          *                           pstr_next = "GABCDE"
   2977          *
   2978          *$PAGE*
   2979          *                   (f) Parse string integer overflow :
   2980          *
   2981          *                           pstr      = "   12345678901234567890*123456"
   2982          *                           nbr_base  = 10
   2983          *
   2984          *                           nbr       = DEF_INT_32U_MAX_VAL
   2985          *                           pstr_next = "*123456"
   2986          *
   2987          *
   2988          *                   (g) Invalid negative unsigned parse string :
   2989          *
   2990          *                           pstr      = "  -12345678901234567890*123456"
   2991          *                           nbr_base  = 10
   2992          *
   2993          *                           nbr       = 0
   2994          *                           pstr_next = pstr = "  -12345678901234567890*123456"
   2995          *
   2996          *********************************************************************************************************
   2997          */
   2998          

   \                                 In section .text, align 2, keep-with-next
   2999          CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
   3000                                                  CPU_CHAR    **pstr_next,
   3001                                                  CPU_INT08U    nbr_base)
   3002          {
   \                     Str_ParseNbr_Int32U:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3003              CPU_INT32U  nbr;
   3004          
   3005          
   3006              nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
   3007                                                      pstr_next,
   3008                                                      nbr_base,
   3009                                                      DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
   3010                                       (CPU_BOOLEAN *)0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       Str_ParseNbr_Int32
   \   0000001A   0x0007             MOVS     R7,R0
   3011          
   3012              return (nbr);
   \   0000001C   0x0038             MOVS     R0,R7
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3013          }
   3014          
   3015          
   3016          /*$PAGE*/
   3017          /*
   3018          *********************************************************************************************************
   3019          *                                        Str_ParseNbr_Int32S()
   3020          *
   3021          * Description : Parse 32-bit signed integer from string.
   3022          *
   3023          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   3024          *
   3025          *               pstr_next   Optional pointer to a variable to ... :
   3026          *
   3027          *                               (a) Return a pointer to first character following the integer string,
   3028          *                                       if NO error(s) [see Note #2a2B2];
   3029          *                               (b) Return a pointer to 'pstr',
   3030          *                                       otherwise      (see Note #2a2A2).
   3031          *
   3032          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   3033          *
   3034          * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
   3035          *
   3036          *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
   3037          *
   3038          *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
   3039          *
   3040          *               0,                   otherwise                                    (see Note #2a3B).
   3041          *
   3042          * Caller(s)   : Application.
   3043          *
   3044          * Note(s)     : (1) String buffer NOT modified.
   3045          *
   3046          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3047          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
   3048          *                       to a type long ... representation" :
   3049          *
   3050          *                       (1) "First, they decompose the input string into three parts" :
   3051          *
   3052          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3053          *                                by isspace()]."
   3054          *
   3055          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3056          *                                    input string, starting with the first non-white-space character that is of
   3057          *                                    the expected form.  The subject sequence shall contain no characters if the
   3058          *                                    input string is empty or consists entirely of white-space characters."
   3059          *
   3060          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3061          *                                    determined by the value of 'base' ('nbr_base')" :
   3062          *
   3063          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
   3064          *                                        subject sequence is that of a decimal constant, octal constant, or 
   3065          *                                        hexadecimal constant" :
   3066          *
   3067          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3068          *                                            sequence of decimal digits."
   3069          *
   3070          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3071          *                                            a sequence of the digits '0' to '7' only."
   3072          *
   3073          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3074          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3075          *                                            (or 'F') with values 10 to 15 respectively."
   3076          *
   3077          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
   3078          *                                        of the subject sequence is a sequence of letters and digits representing 
   3079          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3080          *
   3081          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3082          *                                                ascribed the values 10 to 35"; ...
   3083          *                                           (B) "only letters whose ascribed values are less than that of base
   3084          *                                                are permitted."
   3085          *
   3086          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
   3087          *                                                '0X' may optionally precede the sequence of letters and digits."
   3088          *
   3089          *                                           (B) Although NO specification states that "if the value of 'base' 
   3090          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
   3091          *                                               the sequence of letters and digits"; it seems reasonable to 
   3092          *                                               allow the '0' character to be optionally parsed.
   3093          *
   3094          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3095          *
   3096          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   3097          *                                       integer string into an unsigned integer.
   3098          *
   3099          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3100          *                                   (b) "including the terminating null byte of the input string" ...
   3101          *                               (2) "other than a sign or a permissible letter or digit."
   3102          *$PAGE*
   3103          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3104          *
   3105          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3106          *
   3107          *                               (1) "no conversion is performed"; ...
   3108          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
   3109          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3110          *
   3111          *                           (B) "If the subject sequence has the expected form" :
   3112          *
   3113          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
   3114          *                                        starting with the first digit shall be interpreted as an integer constant."
   3115          *
   3116          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
   3117          *                                        used as the base for conversion, ascribing to each letter its value as 
   3118          *                                        given above" (see Note #2a1B1b1A).
   3119          *
   3120          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3121          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
   3122          *                                   pointer."
   3123          *
   3124          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3125          *
   3126          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3127          *
   3128          *                               (1) "If the correct value is outside the range of representable values", either
   3129          *                                    of the following "shall be returned" :
   3130          *                                   (a) "{LONG_MIN}" or ...
   3131          *                                   (b) "{LONG_MAX}"
   3132          *
   3133          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3134          *
   3135          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3136          *                           shall fail if" :
   3137          *
   3138          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3139          *
   3140          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3141          *
   3142          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3143          *                           may fail if" :
   3144          *
   3145          *                           (A) "[EINVAL] - No conversion could be performed."
   3146          *
   3147          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3148          *
   3149          *                   (a) Valid parse string integer :
   3150          *
   3151          *                           pstr      = "     ABCDE xyz"
   3152          *                           nbr_base  = 16
   3153          *
   3154          *                           nbr       = 703710
   3155          *                           pstr_next = " xyz"
   3156          *
   3157          *
   3158          *                   (b) Invalid parse string integer :
   3159          *
   3160          *                           pstr      = "     ABCDE"
   3161          *                           nbr_base  = 10
   3162          *
   3163          *                           nbr       =  0
   3164          *                           pstr_next = pstr = "     ABCDE"
   3165          *
   3166          *
   3167          *                   (c) Valid hexadecimal parse string integer :
   3168          *
   3169          *                           pstr      = "     0xGABCDE"
   3170          *                           nbr_base  = 16
   3171          *
   3172          *                           nbr       =  0
   3173          *                           pstr_next = "xGABCDE"
   3174          *
   3175          *
   3176          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3177          *                               following invalid hexadecimal characters) :
   3178          *
   3179          *                           pstr      = "     0xGABCDE"
   3180          *                           nbr_base  =  0
   3181          *
   3182          *                           nbr       =  0
   3183          *                           pstr_next = "xGABCDE"
   3184          *
   3185          *
   3186          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3187          *                               following invalid octal       characters) :
   3188          *
   3189          *                           pstr      = "     0GABCDE"
   3190          *                           nbr_base  =  0
   3191          *
   3192          *                           nbr       =  0
   3193          *                           pstr_next = "GABCDE"
   3194          *
   3195          *$PAGE*
   3196          *                   (f) Parse string integer overflow :
   3197          *
   3198          *                           pstr      = "   12345678901234567890*123456"
   3199          *                           nbr_base  = 10
   3200          *
   3201          *                           nbr       = DEF_INT_32S_MAX_VAL
   3202          *                           pstr_next = "*123456"
   3203          *
   3204          *
   3205          *                   (g) Parse string integer underflow :
   3206          *
   3207          *                           pstr      = "  -12345678901234567890*123456"
   3208          *                           nbr_base  = 10
   3209          *
   3210          *                           nbr       = DEF_INT_32S_MIN_VAL
   3211          *                           pstr_next = "*123456"
   3212          *
   3213          *********************************************************************************************************
   3214          */
   3215          

   \                                 In section .text, align 2, keep-with-next
   3216          CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
   3217                                                  CPU_CHAR    **pstr_next,
   3218                                                  CPU_INT08U    nbr_base)
   3219          {
   \                     Str_ParseNbr_Int32S:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   3220              CPU_INT32S   nbr;
   3221              CPU_INT32U   nbr_abs;
   3222              CPU_BOOLEAN  nbr_neg;
   3223          
   3224          
   3225              nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
   3226                                           pstr_next,
   3227                                           nbr_base,
   3228                                           DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
   3229                                          &nbr_neg);
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       Str_ParseNbr_Int32
   \   0000001C   0x4680             MOV      R8,R0
   3230          
   3231              if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
   \   0000001E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD107             BNE.N    ??Str_ParseNbr_Int32S_0
   3232                  nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
   3233                                                                              :  (CPU_INT32S)nbr_abs;
   \   00000026   0xF118 0x4F00      CMN      R8,#-2147483648
   \   0000002A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_1
   \   0000002C   0xF07F 0x4700      MVNS     R7,#-2147483648
   \   00000030   0xE009             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_1:
   \   00000032   0x4647             MOV      R7,R8
   \   00000034   0xE007             B.N      ??Str_ParseNbr_Int32S_2
   3234              } else {
   3235                  nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
   3236                                                                              : -(CPU_INT32S)nbr_abs;
   \                     ??Str_ParseNbr_Int32S_0:
   \   00000036   0xF118 0x4F00      CMN      R8,#-2147483648
   \   0000003A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_3
   \   0000003C   0xF05F 0x4700      MOVS     R7,#-2147483648
   \   00000040   0xE001             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_3:
   \   00000042   0xF1D8 0x0700      RSBS     R7,R8,#+0
   3237              }
   3238          
   3239              return (nbr);
   \                     ??Str_ParseNbr_Int32S_2:
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3240          }
   3241          
   3242          
   3243          /*$PAGE*/
   3244          /*
   3245          *********************************************************************************************************
   3246          *********************************************************************************************************
   3247          *                                           LOCAL FUNCTIONS
   3248          *********************************************************************************************************
   3249          *********************************************************************************************************
   3250          */
   3251          
   3252          /*
   3253          *********************************************************************************************************
   3254          *                                         Str_FmtNbr_Int32()
   3255          *
   3256          * Description : Format 32-bit integer into a multi-digit character string.
   3257          *
   3258          * Argument(s) : nbr             Number           to format.
   3259          *
   3260          *               nbr_dig         Number of digits to format (see Note #1).
   3261          *
   3262          *               nbr_base        Base   of number to format (see Note #2).
   3263          *
   3264          *               nbr_neg         Indicates whether number to format is negative :
   3265          *               -------
   3266          *                                   DEF_NO          Number is non-negative.
   3267          *                                   DEF_YES         Number is     negative.
   3268          *
   3269          *                               Argument validated in Str_FmtNbr_Int32U(),
   3270          *                                                     Str_FmtNbr_Int32S().
   3271          *
   3272          *               lead_char       Prepend leading character  (see Note #3) :
   3273          *
   3274          *                                   '\0'                    Do NOT prepend leading character to string.
   3275          *                                     Printable character          Prepend leading character to string.
   3276          *                                   Unprintable character   Format invalid string (see Note #6e).
   3277          *
   3278          *               lower_case      Format alphabetic characters (if any) in lower case :
   3279          *
   3280          *                                   DEF_NO          Format alphabetic characters in upper case.
   3281          *                                   DEF_YES         Format alphabetic characters in lower case.
   3282          *
   3283          *               nul             Append terminating NULL-character (see Note #4) :
   3284          *
   3285          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   3286          *                                   DEF_YES                Append terminating NULL-character to string.
   3287          *
   3288          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   3289          *
   3290          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
   3291          *
   3292          *               Pointer to NULL,             otherwise.
   3293          *
   3294          * Caller(s)   : Str_FmtNbr_Int32U(),
   3295          *               Str_FmtNbr_Int32S().
   3296          *$PAGE*
   3297          * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
   3298          *
   3299          *
   3300          *                               Maximum Number of             [  log (Number)      ]
   3301          *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
   3302          *                                   to Format                 [   log (Base)       ]
   3303          *
   3304          *                               where
   3305          *                                       Number                  Number to format
   3306          *                                       Base            Base of number to format
   3307          *
   3308          *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
   3309          *                           is performed except possible NULL-termination of the string (see Note #4).
   3310          *
   3311          *                               Example :
   3312          *
   3313          *                                   nbr      = -23456
   3314          *                                   nbr_dig  =  0
   3315          *                                   nbr_base = 10
   3316          *
   3317          *                                   pstr     = ""                   See Note #7a
   3318          *
   3319          *                       (2) If the number of digits to format ('nbr_dig') is less than the number of 
   3320          *                           significant integer digits of the number to format ('nbr'); then an invalid 
   3321          *                           string is formatted instead of truncating any significant integer digits.
   3322          *
   3323          *                               Example :
   3324          *
   3325          *                                   nbr      = 23456
   3326          *                                   nbr_dig  = 3
   3327          *                                   nbr_base = 10
   3328          *
   3329          *                                   pstr     = "???"                See Note #7b
   3330          *
   3331          *                       (3) If the number to format ('nbr') is negative but the number of digits to format 
   3332          *                           ('nbr_dig') is equal to the number of significant integer digits of the number 
   3333          *                           to format ('nbr'); then an invalid string is formatted instead of truncating 
   3334          *                           the negative sign.
   3335          *
   3336          *                               Example :
   3337          *
   3338          *                                   nbr      = -23456
   3339          *                                   nbr_dig  =  5
   3340          *                                   nbr_base = 10
   3341          *
   3342          *                                   pstr     = "?????"              See Note #7b
   3343          *
   3344          *               (2) The number's base MUST be between 2 & 36, inclusive.
   3345          *$PAGE*
   3346          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   3347          *
   3348          *                   (a) (1) Leading character MUST be a printable ASCII character.
   3349          *
   3350          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   3351          *                           (B) with the exception of '0'.
   3352          *
   3353          *                   (b) (1) The number of leading characters is such that the total number of significant 
   3354          *                           integer digits plus the number of leading characters plus possible negative 
   3355          *                           sign character is equal to the requested number of integer digits to format 
   3356          *                           ('nbr_dig').
   3357          *
   3358          *                               Examples :
   3359          *
   3360          *                                   nbr       = 23456
   3361          *                                   nbr_dig   = 7
   3362          *                                   nbr_base  = 10
   3363          *                                   lead_char = ' '
   3364          *
   3365          *                                   pstr      = "  23456"
   3366          *
   3367          *
   3368          *                                   nbr       = -23456
   3369          *                                   nbr_dig   = 7
   3370          *                                   nbr_base  = 10
   3371          *                                   lead_char = ' '
   3372          *
   3373          *                                   pstr      = " -23456"
   3374          *
   3375          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
   3376          *                               ('lead_char') is     a '0' digit; then the negative sign character 
   3377          *                               prefixes all leading characters prior to the formatted number.
   3378          *
   3379          *                                   Examples :
   3380          *
   3381          *                                       nbr        = -23456
   3382          *                                       nbr_dig    =  8
   3383          *                                       nbr_base   = 10
   3384          *                                       lead_char  = '0'
   3385          *
   3386          *                                       pstr       = "-0023456"
   3387          *
   3388          *
   3389          *                                       nbr        = -43981
   3390          *                                       nbr_dig    =  8
   3391          *                                       nbr_base   = 16
   3392          *                                       lead_char  = '0'
   3393          *                                       lower_case = DEF_NO
   3394          *
   3395          *                                       pstr       = "-000ABCD"
   3396          *
   3397          *                           (B) If the number to format ('nbr') is negative AND the leading character 
   3398          *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
   3399          *                               immediately prefixes the most significant digit of the formatted number.
   3400          *
   3401          *                                   Examples :
   3402          *
   3403          *                                       nbr        = -23456
   3404          *                                       nbr_dig    =  8
   3405          *                                       nbr_base   = 10
   3406          *                                       lead_char  = '#'
   3407          *
   3408          *                                       pstr       = "##-23456"
   3409          *
   3410          *
   3411          *                                       nbr        = -43981
   3412          *                                       nbr_dig    =  8
   3413          *                                       nbr_base   = 16
   3414          *                                       lead_char  = '#'
   3415          *                                       lower_case = DEF_YES
   3416          *
   3417          *                                       pstr       = "###-abcd"
   3418          *
   3419          *                   (c) (1) If the value of the number to format is     zero  ...
   3420          *                       (2) ... & the number of digits to format is non-zero, ...
   3421          *                       (3) ... but NO leading character available;           ...
   3422          *                       (4) ... then one digit of '0' value is formatted.
   3423          *
   3424          *                           This is NOT a leading character; but a single integer digit of '0' value.
   3425          *$PAGE*
   3426          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   3427          *                       array formatting.
   3428          *
   3429          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   3430          *                       terminate option DISABLED will cause character string run-on.
   3431          *
   3432          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   3433          *
   3434          *                   (b) To prevent character buffer overrun :
   3435          *
   3436          *                           Character array size MUST be  >=  ('nbr_dig'          +
   3437          *                                                               1 negative sign   +
   3438          *                                                               1 'NUL' terminator)  characters
   3439          *
   3440          *               (6) String format terminates when :
   3441          *
   3442          *                   (a) Format string pointer is passed a NULL pointer.
   3443          *                       (1) No      string formatted;                NULL pointer returned.
   3444          *
   3445          *                   (b) Number of digits to format ('nbr_dig') is zero.
   3446          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   3447          *
   3448          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
   3449          *                           integer digits of the number to format ('nbr'), including possible 
   3450          *                           negative sign.
   3451          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3452          *
   3453          *                   (d) Base is passed an invalid base (see Note #2).
   3454          *                       (1) Invalid string format performed; NULL pointer returned.
   3455          *
   3456          *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
   3457          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3458          *
   3459          *                   (f) Number successfully formatted into character string array.
   3460          *
   3461          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
   3462          *                   ('?') will be formatted, where the number of question marks is determined by the 
   3463          *                   number of digits to format ('nbr_dig') :
   3464          *
   3465          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   3466          *                          number of     =  {
   3467          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   3468          *
   3469          *********************************************************************************************************
   3470          */
   3471          

   \                                 In section .text, align 2, keep-with-next
   3472          static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
   3473                                               CPU_INT08U    nbr_dig,
   3474                                               CPU_INT08U    nbr_base,
   3475                                               CPU_BOOLEAN   nbr_neg,
   3476                                               CPU_CHAR      lead_char,
   3477                                               CPU_BOOLEAN   lower_case,
   3478                                               CPU_BOOLEAN   nul,
   3479                                               CPU_CHAR     *pstr)
   3480          {
   \                     Str_FmtNbr_Int32:
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x9C10             LDR      R4,[SP, #+64]
   3481              CPU_CHAR     *pstr_fmt;
   3482              CPU_DATA      i;
   3483              CPU_INT32U    nbr_fmt;
   3484              CPU_INT32U    nbr_log;
   3485              CPU_INT08U    nbr_dig_max;
   3486              CPU_INT08U    nbr_dig_min;
   3487              CPU_INT08U    nbr_dig_fmtd;
   3488              CPU_INT08U    nbr_neg_sign;
   3489              CPU_INT08U    nbr_lead_char;
   3490              CPU_INT08U    dig_val;
   3491              CPU_INT08U    lead_char_delta_0;
   3492              CPU_INT08U    lead_char_delta_a;
   3493              CPU_BOOLEAN   lead_char_dig;
   3494              CPU_BOOLEAN   lead_char_0;
   3495              CPU_BOOLEAN   fmt_invalid;
   3496              CPU_BOOLEAN   print_char;
   3497              CPU_BOOLEAN   nbr_neg_fmtd;
   3498          
   3499          
   3500          /*$PAGE*/
   3501                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   3502              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   \   0000000A   0x9813             LDR      R0,[SP, #+76]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??Str_FmtNbr_Int32_0
   3503                  return ((CPU_CHAR *)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE138             B.N      ??Str_FmtNbr_Int32_1
   3504              }
   3505          
   3506              fmt_invalid = DEF_NO;
   \                     ??Str_FmtNbr_Int32_0:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0007             MOVS     R7,R0
   3507          
   3508              if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
   \   00000018   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??Str_FmtNbr_Int32_2
   3509                  fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0007             MOVS     R7,R0
   3510              }
   3511                                                                          /* If invalid base, ...                                 */
   3512              if ((nbr_base <  2u) ||
   3513                  (nbr_base > 36u)) {
   \                     ??Str_FmtNbr_Int32_2:
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD302             BCC.N    ??Str_FmtNbr_Int32_3
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D25             CMP      R5,#+37
   \   0000002E   0xD301             BCC.N    ??Str_FmtNbr_Int32_4
   3514                  fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
   \                     ??Str_FmtNbr_Int32_3:
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0007             MOVS     R7,R0
   3515              }
   3516          
   3517              if (lead_char != (CPU_CHAR)'\0') {
   \                     ??Str_FmtNbr_Int32_4:
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD041             BEQ.N    ??Str_FmtNbr_Int32_5
   3518                  print_char =  ASCII_IsPrint(lead_char);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       ASCII_IsPrint
   \   00000042   0xF88D 0x0009      STRB     R0,[SP, #+9]
   3519                  if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
   \   00000046   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD002             BEQ.N    ??Str_FmtNbr_Int32_6
   3520                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x0007             MOVS     R7,R0
   \   00000052   0xE034             B.N      ??Str_FmtNbr_Int32_5
   3521          
   3522                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
   \                     ??Str_FmtNbr_Int32_6:
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0x2C30             CMP      R4,#+48
   \   00000058   0xD031             BEQ.N    ??Str_FmtNbr_Int32_5
   3523                      lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
   \   0000005A   0xF1B4 0x0030      SUBS     R0,R4,#+48
   \   0000005E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   3524                      if (lower_case != DEF_YES) {
   \   00000062   0xF89D 0x0044      LDRB     R0,[SP, #+68]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD004             BEQ.N    ??Str_FmtNbr_Int32_7
   3525                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
   \   0000006A   0xF1B4 0x0041      SUBS     R0,R4,#+65
   \   0000006E   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000072   0xE003             B.N      ??Str_FmtNbr_Int32_8
   3526                      } else {
   3527                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
   \                     ??Str_FmtNbr_Int32_7:
   \   00000074   0xF1B4 0x0061      SUBS     R0,R4,#+97
   \   00000078   0xF88D 0x0005      STRB     R0,[SP, #+5]
   3528                      }
   3529          
   3530                      lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
   3531                                       ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
   3532                                                              (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
   \                     ??Str_FmtNbr_Int32_8:
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D0B             CMP      R5,#+11
   \   00000080   0xD204             BCS.N    ??Str_FmtNbr_Int32_9
   \   00000082   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0x42A8             CMP      R0,R5
   \   0000008A   0xD30D             BCC.N    ??Str_FmtNbr_Int32_10
   \                     ??Str_FmtNbr_Int32_9:
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x2D0B             CMP      R5,#+11
   \   00000090   0xD30C             BCC.N    ??Str_FmtNbr_Int32_11
   \   00000092   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000096   0x280A             CMP      R0,#+10
   \   00000098   0xD306             BCC.N    ??Str_FmtNbr_Int32_10
   \   0000009A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0xF1B5 0x010A      SUBS     R1,R5,#+10
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD201             BCS.N    ??Str_FmtNbr_Int32_11
   \                     ??Str_FmtNbr_Int32_10:
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE000             B.N      ??Str_FmtNbr_Int32_12
   \                     ??Str_FmtNbr_Int32_11:
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??Str_FmtNbr_Int32_12:
   \   000000AE   0xF88D 0x000A      STRB     R0,[SP, #+10]
   3533          
   3534                      if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
   \   000000B2   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000B6   0x2801             CMP      R0,#+1
   \   000000B8   0xD101             BNE.N    ??Str_FmtNbr_Int32_5
   3535                          fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x0007             MOVS     R7,R0
   3536                      }
   3537                  }
   3538              }
   3539          
   3540          
   3541                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   3542              pstr_fmt = pstr;
   \                     ??Str_FmtNbr_Int32_5:
   \   000000BE   0x9813             LDR      R0,[SP, #+76]
   \   000000C0   0x4683             MOV      R11,R0
   3543          
   3544              if (fmt_invalid == DEF_NO) {
   \   000000C2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0xD15F             BNE.N    ??Str_FmtNbr_Int32_13
   3545                  nbr_fmt     = nbr;
   \   000000C8   0x9804             LDR      R0,[SP, #+16]
   \   000000CA   0x4682             MOV      R10,R0
   3546                  nbr_log     = nbr;
   \   000000CC   0x9804             LDR      R0,[SP, #+16]
   \   000000CE   0x4681             MOV      R9,R0
   3547                  nbr_dig_max = 1u;
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x4680             MOV      R8,R0
   3548                  while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
   \                     ??Str_FmtNbr_Int32_14:
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0x45A9             CMP      R9,R5
   \   000000D8   0xD305             BCC.N    ??Str_FmtNbr_Int32_15
   3549                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   \   000000DA   0xF118 0x0801      ADDS     R8,R8,#+1
   3550                      nbr_log /= nbr_base;
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0xFBB9 0xF9F5      UDIV     R9,R9,R5
   \   000000E4   0xE7F6             B.N      ??Str_FmtNbr_Int32_14
   3551                  }
   3552          
   3553                  nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
   \                     ??Str_FmtNbr_Int32_15:
   \   000000E6   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD101             BNE.N    ??Str_FmtNbr_Int32_16
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0xE000             B.N      ??Str_FmtNbr_Int32_17
   \                     ??Str_FmtNbr_Int32_16:
   \   000000F2   0x2000             MOVS     R0,#+0
   \                     ??Str_FmtNbr_Int32_17:
   \   000000F4   0xF88D 0x0003      STRB     R0,[SP, #+3]
   3554                  if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
   \   000000F8   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   000000FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000100   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000104   0xEB11 0x0108      ADDS     R1,R1,R8
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xDB3B             BLT.N    ??Str_FmtNbr_Int32_18
   3555                      nbr_neg_fmtd = DEF_NO;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   3556                      nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
   \   00000112   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000116   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000011A   0x4580             CMP      R8,R0
   \   0000011C   0xD201             BCS.N    ??Str_FmtNbr_Int32_19
   \   0000011E   0x4640             MOV      R0,R8
   \   00000120   0xE001             B.N      ??Str_FmtNbr_Int32_20
   \                     ??Str_FmtNbr_Int32_19:
   \   00000122   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \                     ??Str_FmtNbr_Int32_20:
   \   00000126   0xF88D 0x0008      STRB     R0,[SP, #+8]
   3557                                                                          /* ... calc nbr digs to fmt & nbr lead chars.           */
   3558                      if (lead_char != (CPU_CHAR)'\0') {
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x2C00             CMP      R4,#+0
   \   0000012E   0xD00E             BEQ.N    ??Str_FmtNbr_Int32_21
   3559                          nbr_dig_fmtd  = nbr_dig;
   \   00000130   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000134   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3560                          nbr_lead_char = nbr_dig     -
   3561                                          nbr_dig_min - nbr_neg_sign;
   \   00000138   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   0000013C   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000140   0x1A40             SUBS     R0,R0,R1
   \   00000142   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000146   0x1A40             SUBS     R0,R0,R1
   \   00000148   0xF88D 0x0007      STRB     R0,[SP, #+7]
   \   0000014C   0xE009             B.N      ??Str_FmtNbr_Int32_22
   3562                      } else {
   3563                          nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
   \                     ??Str_FmtNbr_Int32_21:
   \   0000014E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000152   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000156   0x1808             ADDS     R0,R1,R0
   \   00000158   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3564                          nbr_lead_char = 0u;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0xF88D 0x0007      STRB     R0,[SP, #+7]
   3565                      }
   3566          
   3567                      if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
   \                     ??Str_FmtNbr_Int32_22:
   \   00000162   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD008             BEQ.N    ??Str_FmtNbr_Int32_23
   3568                          lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
   3569                                      ?  DEF_YES : DEF_NO;
   \   0000016A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016C   0x2C30             CMP      R4,#+48
   \   0000016E   0xD101             BNE.N    ??Str_FmtNbr_Int32_24
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0xE000             B.N      ??Str_FmtNbr_Int32_25
   \                     ??Str_FmtNbr_Int32_24:
   \   00000174   0x2000             MOVS     R0,#+0
   \                     ??Str_FmtNbr_Int32_25:
   \   00000176   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000017A   0xE005             B.N      ??Str_FmtNbr_Int32_13
   3570                      } else {
   3571                          lead_char_0 =  DEF_NO;
   \                     ??Str_FmtNbr_Int32_23:
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000182   0xE001             B.N      ??Str_FmtNbr_Int32_13
   3572                      }
   3573          
   3574                  } else {                                                /* Else if nbr trunc'd, ...                             */
   3575                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
   \                     ??Str_FmtNbr_Int32_18:
   \   00000184   0x2001             MOVS     R0,#+1
   \   00000186   0x0007             MOVS     R7,R0
   3576                  }
   3577              }
   3578          
   3579              if (fmt_invalid != DEF_NO) {
   \                     ??Str_FmtNbr_Int32_13:
   \   00000188   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000018A   0x2F00             CMP      R7,#+0
   \   0000018C   0xD003             BEQ.N    ??Str_FmtNbr_Int32_26
   3580                  nbr_dig_fmtd = nbr_dig;
   \   0000018E   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000192   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3581              }
   3582          
   3583          
   3584          /*$PAGE*/
   3585                                                                          /* ------------------- FMT NBR STR -------------------- */
   3586              pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
   \                     ??Str_FmtNbr_Int32_26:
   \   00000196   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000019A   0xEB10 0x0B0B      ADDS     R11,R0,R11
   3587          
   3588              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   \   0000019E   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD002             BEQ.N    ??Str_FmtNbr_Int32_27
   3589                 *pstr_fmt = (CPU_CHAR)'\0';
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0xF88B 0x0000      STRB     R0,[R11, #+0]
   3590              }
   3591              pstr_fmt--;
   \                     ??Str_FmtNbr_Int32_27:
   \   000001AC   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   3592          
   3593          
   3594              for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x0006             MOVS     R6,R0
   \                     ??Str_FmtNbr_Int32_28:
   \   000001B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001B8   0x4286             CMP      R6,R0
   \   000001BA   0xD25E             BCS.N    ??Str_FmtNbr_Int32_29
   3595                  if (fmt_invalid == DEF_NO) {
   \   000001BC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001BE   0x2F00             CMP      R7,#+0
   \   000001C0   0xD154             BNE.N    ??Str_FmtNbr_Int32_30
   3596                      if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
   3597                          (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
   \   000001C2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001C6   0xD101             BNE.N    ??Str_FmtNbr_Int32_31
   \   000001C8   0x2E00             CMP      R6,#+0
   \   000001CA   0xD129             BNE.N    ??Str_FmtNbr_Int32_32
   3598                                                                          /* ... calc & fmt dig val;                      ...     */
   3599                          dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
   \                     ??Str_FmtNbr_Int32_31:
   \   000001CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CE   0xFBBA 0xF0F5      UDIV     R0,R10,R5
   \   000001D2   0xFB05 0xA010      MLS      R0,R5,R0,R10
   \   000001D6   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3600                          if (dig_val < 10u) {
   \   000001DA   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001DE   0x280A             CMP      R0,#+10
   \   000001E0   0xD207             BCS.N    ??Str_FmtNbr_Int32_33
   3601                             *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
   \   000001E2   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001E6   0x3030             ADDS     R0,R0,#+48
   \   000001E8   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   000001EC   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   000001F0   0xE012             B.N      ??Str_FmtNbr_Int32_34
   3602                          } else {
   3603                              if (lower_case !=  DEF_YES) {
   \                     ??Str_FmtNbr_Int32_33:
   \   000001F2   0xF89D 0x0044      LDRB     R0,[SP, #+68]
   \   000001F6   0x2801             CMP      R0,#+1
   \   000001F8   0xD007             BEQ.N    ??Str_FmtNbr_Int32_35
   3604                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
   \   000001FA   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000001FE   0x3037             ADDS     R0,R0,#+55
   \   00000200   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000204   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   00000208   0xE006             B.N      ??Str_FmtNbr_Int32_34
   3605                              } else {
   3606                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
   \                     ??Str_FmtNbr_Int32_35:
   \   0000020A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000020E   0x3057             ADDS     R0,R0,#+87
   \   00000210   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000214   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   3607                              }
   3608                          }
   3609          
   3610                          nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
   \                     ??Str_FmtNbr_Int32_34:
   \   00000218   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000021A   0xFBBA 0xFAF5      UDIV     R10,R10,R5
   \   0000021E   0xE02A             B.N      ??Str_FmtNbr_Int32_36
   3611          
   3612                      } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
   3613                               (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
   3614                                 (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
   3615                                ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
   3616                                 (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
   \                     ??Str_FmtNbr_Int32_32:
   \   00000220   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000224   0x2801             CMP      R0,#+1
   \   00000226   0xD119             BNE.N    ??Str_FmtNbr_Int32_37
   \   00000228   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD103             BNE.N    ??Str_FmtNbr_Int32_38
   \   00000230   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000234   0x2800             CMP      R0,#+0
   \   00000236   0xD008             BEQ.N    ??Str_FmtNbr_Int32_39
   \                     ??Str_FmtNbr_Int32_38:
   \   00000238   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000023C   0x2800             CMP      R0,#+0
   \   0000023E   0xD00D             BEQ.N    ??Str_FmtNbr_Int32_37
   \   00000240   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000244   0x1E40             SUBS     R0,R0,#+1
   \   00000246   0x4286             CMP      R6,R0
   \   00000248   0xD108             BNE.N    ??Str_FmtNbr_Int32_37
   3617          
   3618                         *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
   \                     ??Str_FmtNbr_Int32_39:
   \   0000024A   0x202D             MOVS     R0,#+45
   \   0000024C   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000250   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   3619                          nbr_neg_fmtd = DEF_YES;
   \   00000254   0x2001             MOVS     R0,#+1
   \   00000256   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000025A   0xE00C             B.N      ??Str_FmtNbr_Int32_36
   3620          
   3621                      } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
   \                     ??Str_FmtNbr_Int32_37:
   \   0000025C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000025E   0x2C00             CMP      R4,#+0
   \   00000260   0xD009             BEQ.N    ??Str_FmtNbr_Int32_36
   3622                         *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
   \   00000262   0xF88B 0x4000      STRB     R4,[R11, #+0]
   \   00000266   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000026A   0xE004             B.N      ??Str_FmtNbr_Int32_36
   3623                      }
   3624          
   3625                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   3626                     *pstr_fmt-- = '?';
   \                     ??Str_FmtNbr_Int32_30:
   \   0000026C   0x203F             MOVS     R0,#+63
   \   0000026E   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000272   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   3627                  }
   3628              }
   \                     ??Str_FmtNbr_Int32_36:
   \   00000276   0x1C76             ADDS     R6,R6,#+1
   \   00000278   0xE79C             B.N      ??Str_FmtNbr_Int32_28
   3629          
   3630          
   3631              if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
   \                     ??Str_FmtNbr_Int32_29:
   \   0000027A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000027C   0x2F00             CMP      R7,#+0
   \   0000027E   0xD001             BEQ.N    ??Str_FmtNbr_Int32_40
   3632                  return ((CPU_CHAR *)0);
   \   00000280   0x2000             MOVS     R0,#+0
   \   00000282   0xE000             B.N      ??Str_FmtNbr_Int32_1
   3633              }
   3634          
   3635          
   3636              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
   \                     ??Str_FmtNbr_Int32_40:
   \   00000284   0x9813             LDR      R0,[SP, #+76]
   \                     ??Str_FmtNbr_Int32_1:
   \   00000286   0xB007             ADD      SP,SP,#+28
   \   00000288   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3637          }
   3638          
   3639          
   3640          /*$PAGE*/
   3641          /*
   3642          *********************************************************************************************************
   3643          *                                        Str_ParseNbr_Int32()
   3644          *
   3645          * Description : Parse 32-bit integer from string.
   3646          *
   3647          * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
   3648          *
   3649          *               pstr_next       Optional pointer to a variable to ... :
   3650          *
   3651          *                                   (a) Return a pointer to first character following the integer string,
   3652          *                                           if NO error(s) [see Note #2a2B2];
   3653          *                                   (b) Return a pointer to 'pstr',
   3654          *                                           otherwise      (see Note #2a2A2).
   3655          *
   3656          *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
   3657          *
   3658          *               nbr_signed      Indicates whether number to parse is signed :
   3659          *
   3660          *                                   DEF_NO                  Number is unsigned.
   3661          *                                   DEF_YES                 Number is   signed.
   3662          *
   3663          *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
   3664          *
   3665          *                                   DEF_NO                  Number is non-negative.
   3666          *                                   DEF_YES                 Number is     negative.
   3667          *
   3668          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   3669          *
   3670          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   3671          *
   3672          *               0,                   otherwise                            (see Note #2a3B).
   3673          *
   3674          * Caller(s)   : Str_ParseNbr_Int32U(),
   3675          *               Str_ParseNbr_Int32S().
   3676          *
   3677          * Note(s)     : (1) String buffer NOT modified.
   3678          *
   3679          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3680          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
   3681          *                       to a type long ... representation" :
   3682          *
   3683          *                       (1) "First, they decompose the input string into three parts" :
   3684          *
   3685          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3686          *                                by isspace()]."
   3687          *
   3688          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3689          *                                    input string, starting with the first non-white-space character that is of
   3690          *                                    the expected form.  The subject sequence shall contain no characters if the
   3691          *                                    input string is empty or consists entirely of white-space characters."
   3692          *
   3693          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3694          *                                    determined by the value of 'base' ('nbr_base')" :
   3695          *
   3696          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
   3697          *                                        subject sequence is that of a decimal constant, octal constant, or 
   3698          *                                        hexadecimal constant" :
   3699          *
   3700          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3701          *                                            sequence of decimal digits."
   3702          *
   3703          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3704          *                                            a sequence of the digits '0' to '7' only."
   3705          *
   3706          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3707          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3708          *                                            (or 'F') with values 10 to 15 respectively."
   3709          *
   3710          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
   3711          *                                        of the subject sequence is a sequence of letters and digits representing 
   3712          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3713          *
   3714          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3715          *                                                ascribed the values 10 to 35"; ...
   3716          *                                           (B) "only letters whose ascribed values are less than that of base
   3717          *                                                are permitted."
   3718          *
   3719          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
   3720          *                                               '0X' may optionally precede the sequence of letters and digits."
   3721          *
   3722          *                                           (B) Although NO specification states that "if the value of 'base' 
   3723          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
   3724          *                                               the sequence of letters and digits"; it seems reasonable to 
   3725          *                                               allow the '0' character to be optionally parsed.
   3726          *$PAGE*
   3727          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3728          *
   3729          *                                   (a) It does NOT seem reasonable to parse & convert a negative number
   3730          *                                       integer string into an unsigned integer.  However, a negative sign
   3731          *                                       for an unsigned integer will automatically be parsed as an invalid
   3732          *                                       character (see Note #2aC1).
   3733          *
   3734          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3735          *                                   (b) "including the terminating null byte of the input string" ...
   3736          *                               (2) "other than a sign or a permissible letter or digit."
   3737          *
   3738          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3739          *
   3740          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3741          *
   3742          *                               (1) "no conversion is performed"; ...
   3743          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
   3744          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3745          *
   3746          *                           (B) "If the subject sequence has the expected form" :
   3747          *
   3748          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
   3749          *                                        starting with the first digit shall be interpreted as an integer constant."
   3750          *
   3751          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
   3752          *                                        used as the base for conversion, ascribing to each letter its value as 
   3753          *                                        given above" (see Note #2a1B1b1A).
   3754          *
   3755          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3756          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
   3757          *                                   pointer."
   3758          *
   3759          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3760          *
   3761          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3762          *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
   3763          *                                    [or] {LONG_MAX} ... shall be returned."
   3764          *
   3765          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3766          *
   3767          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3768          *                           shall fail if" :
   3769          *
   3770          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3771          *
   3772          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3773          *
   3774          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3775          *                           may fail if" :
   3776          *
   3777          *                           (A) "[EINVAL] - No conversion could be performed."
   3778          *$PAGE*
   3779          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3780          *
   3781          *                   (a) Valid parse string integer :
   3782          *
   3783          *                           pstr      = "     ABCDE xyz"
   3784          *                           nbr_base  = 16
   3785          *
   3786          *                           nbr       = 703710
   3787          *                           pstr_next = " xyz"
   3788          *
   3789          *
   3790          *                   (b) Invalid parse string integer :
   3791          *
   3792          *                           pstr      = "     ABCDE"
   3793          *                           nbr_base  = 10
   3794          *
   3795          *                           nbr       =  0
   3796          *                           pstr_next = pstr = "     ABCDE"
   3797          *
   3798          *
   3799          *                   (c) Valid hexadecimal parse string integer :
   3800          *
   3801          *                           pstr      = "     0xGABCDE"
   3802          *                           nbr_base  = 16
   3803          *
   3804          *                           nbr       =  0
   3805          *                           pstr_next = "xGABCDE"
   3806          *
   3807          *
   3808          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3809          *                               following invalid hexadecimal characters) :
   3810          *
   3811          *                           pstr      = "     0xGABCDE"
   3812          *                           nbr_base  =  0
   3813          *
   3814          *                           nbr       =  0
   3815          *                           pstr_next = "xGABCDE"
   3816          *
   3817          *
   3818          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3819          *                               following invalid octal       characters) :
   3820          *
   3821          *                           pstr      = "     0GABCDE"
   3822          *                           nbr_base  =  0
   3823          *
   3824          *                           nbr       =  0
   3825          *                           pstr_next = "GABCDE"
   3826          *
   3827          *
   3828          *                   (f) Parse string integer overflow :
   3829          *
   3830          *                           pstr      = "   12345678901234567890*123456"
   3831          *                           nbr_base  = 10
   3832          *
   3833          *                           nbr       = DEF_INT_32U_MAX_VAL
   3834          *                           pstr_next = "*123456"
   3835          *
   3836          *
   3837          *                   (g) Parse string integer underflow :
   3838          *
   3839          *                           pstr      = "  -12345678901234567890*123456"
   3840          *                           nbr_base  = 10
   3841          *
   3842          *                           nbr       = DEF_INT_32S_MIN_VAL
   3843          *                           pstr_next = "*123456"
   3844          *
   3845          *
   3846          *               (4) String parse terminates when :
   3847          *
   3848          *                   (a) Base passed an invalid base (see Note #2a1B1b).
   3849          *                       (1) No conversion performed; 0 returned.
   3850          *
   3851          *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
   3852          *                           (A) No conversion performed; 0 returned.
   3853          *
   3854          *                       (2) Invalid parse string character found (see Note #2a1C).
   3855          *                           (A) Parsed integer returned.
   3856          *                           (B) 'pstr_next' points to invalid character.
   3857          *
   3858          *                       (3) Entire  parse string converted (see Note #2a2B).
   3859          *                           (A) Parsed integer returned.
   3860          *                           (B) 'pstr_next' points to terminating NULL character.
   3861          *
   3862          *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
   3863          *                   validation or function handling in case of any error(s).
   3864          *********************************************************************************************************
   3865          */
   3866          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
   3867          static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
   3868                                                         CPU_CHAR     **pstr_next,
   3869                                                         CPU_INT08U     nbr_base,
   3870                                                         CPU_BOOLEAN    nbr_signed,
   3871                                                         CPU_BOOLEAN   *pnbr_neg)
   3872          {
   \                     Str_ParseNbr_Int32:
   \   00000000   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   3873              const  CPU_CHAR     *pstr_parse;
   3874              const  CPU_CHAR     *pstr_parse_nbr;
   3875                     CPU_CHAR     *pstr_parse_unused;
   3876                     CPU_CHAR      parse_char;
   3877                     CPU_INT08U    parse_dig;
   3878                     CPU_INT32U    nbr;
   3879                     CPU_BOOLEAN   nbr_neg_unused;
   3880                     CPU_BOOLEAN   nbr_dig;
   3881                     CPU_BOOLEAN   nbr_alpha;
   3882                     CPU_BOOLEAN   nbr_hex;
   3883                     CPU_BOOLEAN   nbr_hex_lower;
   3884                     CPU_BOOLEAN   whitespace;
   3885                     CPU_BOOLEAN   neg;
   3886                     CPU_BOOLEAN   ovf;
   3887                     CPU_BOOLEAN   done;
   3888          
   3889                                                                          /* --------------- VALIDATE PARSE ARGS ---------------- */
   3890              if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD102             BNE.N    ??Str_ParseNbr_Int32_0
   3891                  pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x0004             MOVS     R4,R0
   3892                 (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
   \   00000012   0xA802             ADD      R0,SP,#+8
   3893              }
   3894             *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
   \                     ??Str_ParseNbr_Int32_0:
   \   00000014   0x9805             LDR      R0,[SP, #+20]
   \   00000016   0x6020             STR      R0,[R4, #+0]
   3895          
   3896              if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
   \   00000018   0x9810             LDR      R0,[SP, #+64]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD104             BNE.N    ??Str_ParseNbr_Int32_1
   3897                  pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   0000001E   0xF10D 0x0006      ADD      R0,SP,#+6
   \   00000022   0x9010             STR      R0,[SP, #+64]
   3898                 (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
   \   00000024   0xF10D 0x0006      ADD      R0,SP,#+6
   3899              }
   3900             *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
   \                     ??Str_ParseNbr_Int32_1:
   \   00000028   0x9810             LDR      R0,[SP, #+64]
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
   3901          
   3902          
   3903              if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
   \   0000002E   0x9805             LDR      R0,[SP, #+20]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE.N    ??Str_ParseNbr_Int32_2
   3904                  return (0u);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE0FD             B.N      ??Str_ParseNbr_Int32_3
   3905              }
   3906                                                                          /* Rtn zero if invalid base (see Note #4a).             */
   3907              if ((nbr_base == 1u) ||
   3908                  (nbr_base > 36u)) {
   \                     ??Str_ParseNbr_Int32_2:
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD002             BEQ.N    ??Str_ParseNbr_Int32_4
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D25             CMP      R5,#+37
   \   00000042   0xD301             BCC.N    ??Str_ParseNbr_Int32_5
   3909                  return (0u);
   \                     ??Str_ParseNbr_Int32_4:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE0F5             B.N      ??Str_ParseNbr_Int32_3
   3910              }
   3911          
   3912          
   3913                                                                          /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
   3914              pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_5:
   \   00000048   0x9805             LDR      R0,[SP, #+20]
   \   0000004A   0x4683             MOV      R11,R0
   3915          
   3916              whitespace = ASCII_IsSpace(*pstr_parse);
   \   0000004C   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000050   0x.... 0x....      BL       ASCII_IsSpace
   \   00000054   0xF88D 0x0002      STRB     R0,[SP, #+2]
   3917              while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
   \                     ??Str_ParseNbr_Int32_6:
   \   00000058   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD108             BNE.N    ??Str_ParseNbr_Int32_7
   3918                  pstr_parse++;
   \   00000060   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3919                  whitespace = ASCII_IsSpace(*pstr_parse);
   \   00000064   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000068   0x.... 0x....      BL       ASCII_IsSpace
   \   0000006C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000070   0xE7F2             B.N      ??Str_ParseNbr_Int32_6
   3920              }
   3921          
   3922              switch (*pstr_parse) {
   \                     ??Str_ParseNbr_Int32_7:
   \   00000072   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000076   0x282B             CMP      R0,#+43
   \   00000078   0xD002             BEQ.N    ??Str_ParseNbr_Int32_8
   \   0000007A   0x282D             CMP      R0,#+45
   \   0000007C   0xD006             BEQ.N    ??Str_ParseNbr_Int32_9
   \   0000007E   0xE00F             B.N      ??Str_ParseNbr_Int32_10
   3923                  case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
   3924                       pstr_parse++;
   \                     ??Str_ParseNbr_Int32_8:
   \   00000080   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3925                       neg = DEF_NO;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3926                       break;
   \   0000008A   0xE00C             B.N      ??Str_ParseNbr_Int32_11
   3927          
   3928          
   3929                  case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
   3930                       if (nbr_signed == DEF_YES) {
   \                     ??Str_ParseNbr_Int32_9:
   \   0000008C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD101             BNE.N    ??Str_ParseNbr_Int32_12
   3931                           pstr_parse++;
   \   00000094   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3932                       }
   3933                       neg = DEF_YES;
   \                     ??Str_ParseNbr_Int32_12:
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3934                       break;
   \   0000009E   0xE002             B.N      ??Str_ParseNbr_Int32_11
   3935          
   3936          
   3937                  default:
   3938                       neg = DEF_NO;
   \                     ??Str_ParseNbr_Int32_10:
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3939                       break;
   3940              }
   3941          
   3942          
   3943          /*$PAGE*/
   3944                                                                          /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
   3945              pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
   \                     ??Str_ParseNbr_Int32_11:
   \   000000A6   0xF8CD 0xB00C      STR      R11,[SP, #+12]
   3946          
   3947              switch (nbr_base) {
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD004             BEQ.N    ??Str_ParseNbr_Int32_13
   \   000000B2   0x2808             CMP      R0,#+8
   \   000000B4   0xD026             BEQ.N    ??Str_ParseNbr_Int32_14
   \   000000B6   0x2810             CMP      R0,#+16
   \   000000B8   0xD02B             BEQ.N    ??Str_ParseNbr_Int32_15
   \   000000BA   0xE047             B.N      ??Str_ParseNbr_Int32_16
   3948                  case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
   3949                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_13:
   \   000000BC   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000C0   0x2830             CMP      R0,#+48
   \   000000C2   0xD11C             BNE.N    ??Str_ParseNbr_Int32_17
   3950                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   000000C4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3951                            switch (*pstr_parse) {
   \   000000C8   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000CC   0x2858             CMP      R0,#+88
   \   000000CE   0xD001             BEQ.N    ??Str_ParseNbr_Int32_18
   \   000000D0   0x2878             CMP      R0,#+120
   \   000000D2   0xD111             BNE.N    ??Str_ParseNbr_Int32_19
   3952                                case 'x':                                 /* For '0x' prefix, ...                                 */
   3953                                case 'X':
   3954                                     nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
   \                     ??Str_ParseNbr_Int32_18:
   \   000000D4   0x2010             MOVS     R0,#+16
   \   000000D6   0x0005             MOVS     R5,R0
   3955                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \   000000D8   0xF89B 0x0001      LDRB     R0,[R11, #+1]
   \   000000DC   0x0006             MOVS     R6,R0
   3956                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x.... 0x....      BL       ASCII_IsDigHex
   \   000000E6   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3957                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   000000EA   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000EE   0x2801             CMP      R0,#+1
   \   000000F0   0xD101             BNE.N    ??Str_ParseNbr_Int32_20
   3958                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   000000F2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3959                                     }
   3960                                     break;
   \                     ??Str_ParseNbr_Int32_20:
   \   000000F6   0xE004             B.N      ??Str_ParseNbr_Int32_21
   3961          
   3962          
   3963                                default:                                  /* For '0'  prefix, ...                                 */
   3964                                     nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
   \                     ??Str_ParseNbr_Int32_19:
   \   000000F8   0x2008             MOVS     R0,#+8
   \   000000FA   0x0005             MOVS     R5,R0
   3965                                     break;
   \   000000FC   0xE001             B.N      ??Str_ParseNbr_Int32_21
   3966                            }
   3967          
   3968                       } else {                                           /* For non-'0' prefix, ...                              */
   3969                           nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
   \                     ??Str_ParseNbr_Int32_17:
   \   000000FE   0x200A             MOVS     R0,#+10
   \   00000100   0x0005             MOVS     R5,R0
   3970                       }
   3971                       break;
   \                     ??Str_ParseNbr_Int32_21:
   \   00000102   0xE023             B.N      ??Str_ParseNbr_Int32_22
   3972          
   3973          
   3974                  case  8u:                                               /* See Note #2a1B1a2.                                   */
   3975                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_14:
   \   00000104   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000108   0x2830             CMP      R0,#+48
   \   0000010A   0xD101             BNE.N    ??Str_ParseNbr_Int32_23
   3976                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
   \   0000010C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3977                       }
   3978                       break;
   \                     ??Str_ParseNbr_Int32_23:
   \   00000110   0xE01C             B.N      ??Str_ParseNbr_Int32_22
   3979          
   3980          
   3981                  case 16u:                                               /* See Note #2a1B1a3.                                   */
   3982                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_15:
   \   00000112   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000116   0x2830             CMP      R0,#+48
   \   00000118   0xD117             BNE.N    ??Str_ParseNbr_Int32_24
   3983                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   0000011A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3984                            switch (*pstr_parse) {
   \   0000011E   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000122   0x2858             CMP      R0,#+88
   \   00000124   0xD001             BEQ.N    ??Str_ParseNbr_Int32_25
   \   00000126   0x2878             CMP      R0,#+120
   \   00000128   0xD10F             BNE.N    ??Str_ParseNbr_Int32_26
   3985                                case 'x':
   3986                                case 'X':
   3987                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \                     ??Str_ParseNbr_Int32_25:
   \   0000012A   0xF89B 0x0001      LDRB     R0,[R11, #+1]
   \   0000012E   0x0006             MOVS     R6,R0
   3988                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   00000130   0x0030             MOVS     R0,R6
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0x.... 0x....      BL       ASCII_IsDigHex
   \   00000138   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3989                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   0000013C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD101             BNE.N    ??Str_ParseNbr_Int32_27
   3990                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   00000144   0xF11B 0x0B01      ADDS     R11,R11,#+1
   3991                                     }
   3992                                     break;
   \                     ??Str_ParseNbr_Int32_27:
   \   00000148   0xE7FF             B.N      ??Str_ParseNbr_Int32_24
   3993          
   3994          
   3995                                default:
   3996                                     break;
   3997                            }
   3998                       }
   3999                       break;
   \                     ??Str_ParseNbr_Int32_26:
   \                     ??Str_ParseNbr_Int32_24:
   \   0000014A   0xE7FF             B.N      ??Str_ParseNbr_Int32_22
   4000          
   4001          
   4002                  default:                                                /* See Note #2a1B1b.                                    */
   4003                       break;
   4004              }
   4005          
   4006          
   4007          /*$PAGE*/
   4008                                                                          /* ------------------ PARSE INT STR ------------------- */
   4009              nbr  = 0u;
   \                     ??Str_ParseNbr_Int32_16:
   \                     ??Str_ParseNbr_Int32_22:
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x4680             MOV      R8,R0
   4010              ovf  = DEF_NO;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x4681             MOV      R9,R0
   4011              done = DEF_NO;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x4682             MOV      R10,R0
   4012          
   4013              while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
   \                     ??Str_ParseNbr_Int32_28:
   \   00000158   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000160   0xD153             BNE.N    ??Str_ParseNbr_Int32_29
   4014                  parse_char = (CPU_CHAR)*pstr_parse;
   \   00000162   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000166   0x0006             MOVS     R6,R0
   4015                  nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
   \   00000168   0x0030             MOVS     R0,R6
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016C   0x.... 0x....      BL       ASCII_IsAlphaNum
   \   00000170   0xF88D 0x0004      STRB     R0,[SP, #+4]
   4016                  if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
   \   00000174   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000178   0x2801             CMP      R0,#+1
   \   0000017A   0xD143             BNE.N    ??Str_ParseNbr_Int32_30
   4017                                                                          /* ... convert parse char into nbr dig.                 */
   4018                      nbr_dig = ASCII_IsDig(parse_char);
   \   0000017C   0x0030             MOVS     R0,R6
   \   0000017E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000180   0x.... 0x....      BL       ASCII_IsDig
   \   00000184   0xF88D 0x0005      STRB     R0,[SP, #+5]
   4019                      if (nbr_dig == DEF_YES) {
   \   00000188   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000018C   0x2801             CMP      R0,#+1
   \   0000018E   0xD103             BNE.N    ??Str_ParseNbr_Int32_31
   4020                          parse_dig = (CPU_INT08U)(parse_char - '0');
   \   00000190   0xF1B6 0x0030      SUBS     R0,R6,#+48
   \   00000194   0x0007             MOVS     R7,R0
   \   00000196   0xE012             B.N      ??Str_ParseNbr_Int32_32
   4021                      } else {
   4022                          nbr_hex_lower = ASCII_IsLower(parse_char);
   \                     ??Str_ParseNbr_Int32_31:
   \   00000198   0x0030             MOVS     R0,R6
   \   0000019A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019C   0x.... 0x....      BL       ASCII_IsLower
   \   000001A0   0xF88D 0x0003      STRB     R0,[SP, #+3]
   4023                          if (nbr_hex_lower == DEF_YES) {
   \   000001A4   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001A8   0x2801             CMP      R0,#+1
   \   000001AA   0xD104             BNE.N    ??Str_ParseNbr_Int32_33
   4024                              parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
   \   000001AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001AE   0x0030             MOVS     R0,R6
   \   000001B0   0x3857             SUBS     R0,R0,#+87
   \   000001B2   0x0007             MOVS     R7,R0
   \   000001B4   0xE003             B.N      ??Str_ParseNbr_Int32_32
   4025                          } else {
   4026                              parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
   \                     ??Str_ParseNbr_Int32_33:
   \   000001B6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001B8   0x0030             MOVS     R0,R6
   \   000001BA   0x3837             SUBS     R0,R0,#+55
   \   000001BC   0x0007             MOVS     R7,R0
   4027                          }
   4028                      }
   4029          
   4030                      if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
   \                     ??Str_ParseNbr_Int32_32:
   \   000001BE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C2   0x42AF             CMP      R7,R5
   \   000001C4   0xD21B             BCS.N    ??Str_ParseNbr_Int32_34
   4031                          if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
   \   000001C6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001CA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001CE   0xD113             BNE.N    ??Str_ParseNbr_Int32_35
   4032                              if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   \   000001D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D2   0x....             LDR.N    R0,??DataTable0
   \   000001D4   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000001D8   0x4540             CMP      R0,R8
   \   000001DA   0xD30B             BCC.N    ??Str_ParseNbr_Int32_36
   4033                                                                          /* ... merge parse char dig into nbr.                   */
   4034                                  nbr *= nbr_base;
   \   000001DC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001DE   0xFB05 0xF808      MUL      R8,R5,R8
   4035                                  nbr += parse_dig;
   \   000001E2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001E4   0xEB17 0x0808      ADDS     R8,R7,R8
   4036                                  if (nbr < parse_dig) {
   \   000001E8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001EA   0x45B8             CMP      R8,R7
   \   000001EC   0xD204             BCS.N    ??Str_ParseNbr_Int32_35
   4037                                      ovf = DEF_YES;
   \   000001EE   0x2001             MOVS     R0,#+1
   \   000001F0   0x4681             MOV      R9,R0
   \   000001F2   0xE001             B.N      ??Str_ParseNbr_Int32_35
   4038                                  }
   4039                              } else {
   4040                                  ovf = DEF_YES;
   \                     ??Str_ParseNbr_Int32_36:
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0x4681             MOV      R9,R0
   4041                              }
   4042                          }
   4043                          pstr_parse++;
   \                     ??Str_ParseNbr_Int32_35:
   \   000001F8   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000001FC   0xE7AC             B.N      ??Str_ParseNbr_Int32_28
   4044          
   4045                      } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
   4046                          done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_34:
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0x4682             MOV      R10,R0
   \   00000202   0xE7A9             B.N      ??Str_ParseNbr_Int32_28
   4047                      }
   4048          
   4049                  } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
   4050                      done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_30:
   \   00000204   0x2001             MOVS     R0,#+1
   \   00000206   0x4682             MOV      R10,R0
   \   00000208   0xE7A6             B.N      ??Str_ParseNbr_Int32_28
   4051                  }
   4052              }
   4053          
   4054              if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
   \                     ??Str_ParseNbr_Int32_29:
   \   0000020A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000020E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000212   0xD102             BNE.N    ??Str_ParseNbr_Int32_37
   4055                  nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
   \   00000214   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000218   0x4680             MOV      R8,R0
   4056              }
   4057          
   4058          
   4059              if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
   \                     ??Str_ParseNbr_Int32_37:
   \   0000021A   0x9803             LDR      R0,[SP, #+12]
   \   0000021C   0x4583             CMP      R11,R0
   \   0000021E   0xD002             BEQ.N    ??Str_ParseNbr_Int32_38
   4060                 *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
   \   00000220   0xF8C4 0xB000      STR      R11,[R4, #+0]
   \   00000224   0xE001             B.N      ??Str_ParseNbr_Int32_39
   4061              } else {
   4062                 *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_38:
   \   00000226   0x9805             LDR      R0,[SP, #+20]
   \   00000228   0x6020             STR      R0,[R4, #+0]
   4063              }
   4064          
   4065             *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
   \                     ??Str_ParseNbr_Int32_39:
   \   0000022A   0x9810             LDR      R0,[SP, #+64]
   \   0000022C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000230   0x7001             STRB     R1,[R0, #+0]
   4066          
   4067          
   4068              return (nbr);
   \   00000232   0x4640             MOV      R0,R8
   \                     ??Str_ParseNbr_Int32_3:
   \   00000234   0xB007             ADD      SP,SP,#+28
   \   00000236   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   4069          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     Str_MultOvfThTbl_Int32U
   4070          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Str_Cat
        16   -> Str_Cat_N
      12   Str_Cat_N
      16   Str_Char
        16   -> Str_Char_N
      16   Str_Char_Last
        16   -> Str_Char_Last_N
      32   Str_Char_Last_N
        32   -> Str_Len_N
       8   Str_Char_N
      24   Str_Char_Replace
        24   -> Str_Char_Replace_N
      12   Str_Char_Replace_N
      16   Str_Cmp
        16   -> Str_Cmp_N
      16   Str_CmpIgnoreCase
        16   -> Str_CmpIgnoreCase_N
      48   Str_CmpIgnoreCase_N
        48   -> ASCII_ToLower
      24   Str_Cmp_N
      16   Str_Copy
        16   -> Str_Copy_N
      12   Str_Copy_N
      64   Str_FmtNbr_Int32
        64   -> ASCII_IsPrint
      64   Str_FmtNbr_Int32S
        64   -> Str_FmtNbr_Int32
      56   Str_FmtNbr_Int32U
        56   -> Str_FmtNbr_Int32
      16   Str_Len
        16   -> Str_Len_N
       4   Str_Len_N
      64   Str_ParseNbr_Int32
        64   -> ASCII_IsAlphaNum
        64   -> ASCII_IsDig
        64   -> ASCII_IsDigHex
        64   -> ASCII_IsLower
        64   -> ASCII_IsSpace
      32   Str_ParseNbr_Int32S
        32   -> Str_ParseNbr_Int32
      24   Str_ParseNbr_Int32U
        24   -> Str_ParseNbr_Int32
      16   Str_Str
        16   -> Str_Str_N
      56   Str_Str_N
        56   -> Str_Cmp_N
        56   -> Str_Len_N


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      24  Str_Cat
     110  Str_Cat_N
      26  Str_Char
      26  Str_Char_Last
      96  Str_Char_Last_N
      88  Str_Char_N
      32  Str_Char_Replace
      60  Str_Char_Replace_N
      26  Str_Cmp
      26  Str_CmpIgnoreCase
     292  Str_CmpIgnoreCase_N
     206  Str_Cmp_N
      24  Str_Copy
      84  Str_Copy_N
     652  Str_FmtNbr_Int32
      82  Str_FmtNbr_Int32S
      68  Str_FmtNbr_Int32U
      20  Str_Len
      34  Str_Len_N
     148  Str_MultOvfThTbl_Int32U
     570  Str_ParseNbr_Int32
      76  Str_ParseNbr_Int32S
      32  Str_ParseNbr_Int32U
      24  Str_Str
     216  Str_Str_N

 
   148 bytes in section .rodata
 2 898 bytes in section .text
 
 2 898 bytes of CODE  memory
   148 bytes of CONST memory

Errors: none
Warnings: none

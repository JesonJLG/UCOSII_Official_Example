###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:22 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_adc.c                    #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_adc.c" -D                #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_adc.lst            #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_adc.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_adc.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_adc.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the ADC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_adc.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ADC DISCNUM mask */
     23          #define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
     24          
     25          /* ADC DISCEN mask */
     26          #define CR1_DISCEN_Set              ((u32)0x00000800)
     27          #define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
     28          
     29          /* ADC JAUTO mask */
     30          #define CR1_JAUTO_Set               ((u32)0x00000400)
     31          #define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
     32          
     33          /* ADC JDISCEN mask */
     34          #define CR1_JDISCEN_Set             ((u32)0x00001000)
     35          #define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
     36          
     37          /* ADC AWDCH mask */
     38          #define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
     39          
     40          /* ADC Analog watchdog enable mode mask */
     41          #define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
     42          
     43          /* CR1 register Mask */
     44          #define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
     45          
     46          /* ADC ADON mask */
     47          #define CR2_ADON_Set                ((u32)0x00000001)
     48          #define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
     49          
     50          /* ADC DMA mask */
     51          #define CR2_DMA_Set                 ((u32)0x00000100)
     52          #define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
     53          
     54          /* ADC RSTCAL mask */
     55          #define CR2_RSTCAL_Set              ((u32)0x00000008)
     56          
     57          /* ADC CAL mask */
     58          #define CR2_CAL_Set                 ((u32)0x00000004)
     59          
     60          /* ADC SWSTART mask */
     61          #define CR2_SWSTART_Set             ((u32)0x00400000)
     62          
     63          /* ADC EXTTRIG mask */
     64          #define CR2_EXTTRIG_Set             ((u32)0x00100000)
     65          #define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
     66          
     67          /* ADC Software start mask */
     68          #define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
     69          #define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
     70          
     71          /* ADC JEXTSEL mask */
     72          #define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
     73          
     74          /* ADC JEXTTRIG mask */
     75          #define CR2_JEXTTRIG_Set            ((u32)0x00008000)
     76          #define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
     77          
     78          /* ADC JSWSTART mask */
     79          #define CR2_JSWSTART_Set            ((u32)0x00200000)
     80          
     81          /* ADC injected software start mask */
     82          #define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
     83          #define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
     84          
     85          /* ADC TSPD mask */
     86          #define CR2_TSVREFE_Set             ((u32)0x00800000)
     87          #define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
     88          
     89          /* CR2 register Mask */
     90          #define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
     91          
     92          /* ADC SQx mask */
     93          #define SQR3_SQ_Set                 ((u32)0x0000001F)
     94          #define SQR2_SQ_Set                 ((u32)0x0000001F)
     95          #define SQR1_SQ_Set                 ((u32)0x0000001F)
     96          
     97          /* SQR1 register Mask */
     98          #define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
     99          
    100          /* ADC JSQx mask */
    101          #define JSQR_JSQ_Set                ((u32)0x0000001F)
    102          
    103          /* ADC JL mask */
    104          #define JSQR_JL_Set                 ((u32)0x00300000)
    105          #define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
    106          
    107          /* ADC SMPx mask */
    108          #define SMPR1_SMP_Set               ((u32)0x00000007)
    109          #define SMPR2_SMP_Set               ((u32)0x00000007)
    110          
    111          /* ADC JDRx registers offset */
    112          #define JDR_Offset                  ((u8)0x28)
    113          
    114          /* ADC1 DR register base address */
    115          #define DR_ADDRESS                  ((u32)0x4001244C)
    116          
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          /* Private functions ---------------------------------------------------------*/
    121          
    122          /*******************************************************************************
    123          * Function Name  : ADC_DeInit
    124          * Description    : Deinitializes the ADCx peripheral registers to their default
    125          *                  reset values.
    126          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    127          * Output         : None
    128          * Return         : None
    129          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    130          void ADC_DeInit(ADC_TypeDef* ADCx)
    131          {
   \                     ADC_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    132            /* Check the parameters */
    133            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    134          
    135            switch (*(u32*)&ADCx)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0x40012400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD008             BEQ.N    ??ADC_DeInit_0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable4_1  ;; 0x40012800
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD00F             BEQ.N    ??ADC_DeInit_1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable4_2  ;; 0x40013c00
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD016             BEQ.N    ??ADC_DeInit_2
   \   0000001E   0xE020             B.N      ??ADC_DeInit_3
    136            {
    137              case ADC1_BASE:
    138                /* Enable ADC1 reset state */
    139                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
   \                     ??ADC_DeInit_0:
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    140                /* Release ADC1 from reset state */
    141                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF44F 0x7000      MOV      R0,#+512
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    142                break;
   \   00000034   0xE015             B.N      ??ADC_DeInit_4
    143              
    144              case ADC2_BASE:
    145                /* Enable ADC2 reset state */
    146                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
   \                     ??ADC_DeInit_1:
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    147                /* Release ADC2 from reset state */
    148                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF44F 0x6080      MOV      R0,#+1024
   \   00000046   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    149                break;
   \   0000004A   0xE00A             B.N      ??ADC_DeInit_4
    150                
    151              case ADC3_BASE:
    152                /* Enable ADC3 reset state */
    153                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
   \                     ??ADC_DeInit_2:
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000052   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    154                /* Release ADC3 from reset state */
    155                RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xF44F 0x4000      MOV      R0,#+32768
   \   0000005C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    156                break; 
   \   00000060   0xE7FF             B.N      ??ADC_DeInit_4
    157          
    158              default:
    159                break;
    160            }
    161          }
   \                     ??ADC_DeInit_3:
   \                     ??ADC_DeInit_4:
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    162          
    163          /*******************************************************************************
    164          * Function Name  : ADC_Init
    165          * Description    : Initializes the ADCx peripheral according to the specified parameters
    166          *                  in the ADC_InitStruct.
    167          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    168          *                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
    169          *                    contains the configuration information for the specified
    170          *                    ADC peripheral.
    171          * Output         : None
    172          * Return         : None
    173          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    174          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    175          {
   \                     ADC_Init:
   \   00000000   0xB430             PUSH     {R4,R5}
    176            u32 tmpreg1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    177            u8 tmpreg2 = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    178          
    179            /* Check the parameters */
    180            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    181            assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    182            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    183            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
    184            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
    185            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    186            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    187          
    188            /*---------------------------- ADCx CR1 Configuration -----------------*/
    189            /* Get the ADCx CR1 value */
    190            tmpreg1 = ADCx->CR1;
   \   00000006   0x6844             LDR      R4,[R0, #+4]
   \   00000008   0x0023             MOVS     R3,R4
    191            /* Clear DUALMOD and SCAN bits */
    192            tmpreg1 &= CR1_CLEAR_Mask;
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable4_3  ;; 0xfff0feff
   \   0000000E   0x4023             ANDS     R3,R4,R3
    193            /* Configure ADCx: Dual mode and scan conversion mode */
    194            /* Set DUALMOD bits according to ADC_Mode value */
    195            /* Set SCAN bit according to ADC_ScanConvMode value */
    196            tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x790D             LDRB     R5,[R1, #+4]
   \   00000014   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   \   00000018   0x4323             ORRS     R3,R4,R3
    197            /* Write to ADCx CR1 */
    198            ADCx->CR1 = tmpreg1;
   \   0000001A   0x6043             STR      R3,[R0, #+4]
    199          
    200            /*---------------------------- ADCx CR2 Configuration -----------------*/
    201            /* Get the ADCx CR2 value */
    202            tmpreg1 = ADCx->CR2;
   \   0000001C   0x6884             LDR      R4,[R0, #+8]
   \   0000001E   0x0023             MOVS     R3,R4
    203            /* Clear CONT, ALIGN and EXTSEL bits */
    204            tmpreg1 &= CR2_CLEAR_Mask;
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable4_4  ;; 0xfff1f7fd
   \   00000024   0x4023             ANDS     R3,R4,R3
    205            /* Configure ADCx: external trigger event and continuous conversion mode */
    206            /* Set ALIGN bit according to ADC_DataAlign value */
    207            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    208            /* Set CONT bit according to ADC_ContinuousConvMode value */
    209            tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
    210                      ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
   \   00000026   0x68CC             LDR      R4,[R1, #+12]
   \   00000028   0x688D             LDR      R5,[R1, #+8]
   \   0000002A   0x432C             ORRS     R4,R5,R4
   \   0000002C   0x794D             LDRB     R5,[R1, #+5]
   \   0000002E   0xEA54 0x0445      ORRS     R4,R4,R5, LSL #+1
   \   00000032   0x4323             ORRS     R3,R4,R3
    211            /* Write to ADCx CR2 */
    212            ADCx->CR2 = tmpreg1;
   \   00000034   0x6083             STR      R3,[R0, #+8]
    213          
    214            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    215            /* Get the ADCx SQR1 value */
    216            tmpreg1 = ADCx->SQR1;
   \   00000036   0x6AC4             LDR      R4,[R0, #+44]
   \   00000038   0x0023             MOVS     R3,R4
    217            /* Clear L bits */
    218            tmpreg1 &= SQR1_CLEAR_Mask;
   \   0000003A   0xF433 0x0370      BICS     R3,R3,#0xF00000
    219            /* Configure ADCx: regular channel sequence length */
    220            /* Set L bits according to ADC_NbrOfChannel value */
    221            tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
   \   0000003E   0x7C0C             LDRB     R4,[R1, #+16]
   \   00000040   0x1E64             SUBS     R4,R4,#+1
   \   00000042   0x4322             ORRS     R2,R4,R2
    222            tmpreg1 |= ((u32)tmpreg2 << 20);
   \   00000044   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000046   0xEA53 0x5302      ORRS     R3,R3,R2, LSL #+20
    223            /* Write to ADCx SQR1 */
    224            ADCx->SQR1 = tmpreg1;
   \   0000004A   0x62C3             STR      R3,[R0, #+44]
    225          }
   \   0000004C   0xBC30             POP      {R4,R5}
   \   0000004E   0x4770             BX       LR               ;; return
    226          
    227          /*******************************************************************************
    228          * Function Name  : ADC_StructInit
    229          * Description    : Fills each ADC_InitStruct member with its default value.
    230          * Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
    231          *                  which will be initialized.
    232          * Output         : None
    233          * Return         : None
    234          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    236          {
    237            /* Reset ADC init structure parameters values */
    238            /* Initialize the ADC_Mode member */
    239            ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
   \                     ADC_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    240          
    241            /* initialize the ADC_ScanConvMode member */
    242            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    243          
    244            /* Initialize the ADC_ContinuousConvMode member */
    245            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    246          
    247            /* Initialize the ADC_ExternalTrigConv member */
    248            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    249          
    250            /* Initialize the ADC_DataAlign member */
    251            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    252          
    253            /* Initialize the ADC_NbrOfChannel member */
    254            ADC_InitStruct->ADC_NbrOfChannel = 1;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    255          }
   \   00000018   0x4770             BX       LR               ;; return
    256          
    257          /*******************************************************************************
    258          * Function Name  : ADC_Cmd
    259          * Description    : Enables or disables the specified ADC peripheral.
    260          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    261          *                  - NewState: new state of the ADCx peripheral. This parameter
    262          *                    can be: ENABLE or DISABLE.
    263          * Output         : None
    264          * Return         : None
    265          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    267          {
    268            /* Check the parameters */
    269            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    270            assert_param(IS_FUNCTIONAL_STATE(NewState));
    271          
    272            if (NewState != DISABLE)
   \                     ADC_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_Cmd_0
    273            {
    274              /* Set the ADON bit to wake up the ADC from power down mode */
    275              ADCx->CR2 |= CR2_ADON_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_Cmd_1
    276            }
    277            else
    278            {
    279              /* Disable the selected ADC peripheral */
    280              ADCx->CR2 &= CR2_ADON_Reset;
   \                     ??ADC_Cmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0x0852             LSRS     R2,R2,#+1
   \   00000014   0x0052             LSLS     R2,R2,#+1
   \   00000016   0x6082             STR      R2,[R0, #+8]
    281            }
    282          }
   \                     ??ADC_Cmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    283          
    284          /*******************************************************************************
    285          * Function Name  : ADC_DMACmd
    286          * Description    : Enables or disables the specified ADC DMA request.
    287          * Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
    288          *                    Note: ADC2 hasn't a DMA capability.
    289          *                  - NewState: new state of the selected ADC DMA transfer.
    290          *                    This parameter can be: ENABLE or DISABLE.
    291          * Output         : None
    292          * Return         : None
    293          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    294          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    295          {
    296            /* Check the parameters */
    297            assert_param(IS_ADC_DMA_PERIPH(ADCx));
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
    299          
    300            if (NewState != DISABLE)
   \                     ADC_DMACmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_DMACmd_0
    301            {
    302              /* Enable the selected ADC DMA request */
    303              ADCx->CR2 |= CR2_DMA_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_DMACmd_1
    304            }
    305            else
    306            {
    307              /* Disable the selected ADC DMA request */
    308              ADCx->CR2 &= CR2_DMA_Reset;
   \                     ??ADC_DMACmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF432 0x7280      BICS     R2,R2,#0x100
   \   00000016   0x6082             STR      R2,[R0, #+8]
    309            }
    310          }
   \                     ??ADC_DMACmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    311          
    312          /*******************************************************************************
    313          * Function Name  : ADC_ITConfig
    314          * Description    : Enables or disables the specified ADC interrupts.
    315          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    316          *                  - ADC_IT: specifies the ADC interrupt sources to be enabled
    317          *                    or disabled. 
    318          *                    This parameter can be any combination of the following values:
    319          *                       - ADC_IT_EOC: End of conversion interrupt mask
    320          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
    321          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
    322          *                  - NewState: new state of the specified ADC interrupts.
    323          *                    This parameter can be: ENABLE or DISABLE.
    324          * Output         : None
    325          * Return         : None
    326          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    327          void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
    328          {
   \                     ADC_ITConfig:
   \   00000000   0xB410             PUSH     {R4}
    329            u8 itmask = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    330          
    331            /* Check the parameters */
    332            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    333            assert_param(IS_FUNCTIONAL_STATE(NewState));
    334            assert_param(IS_ADC_IT(ADC_IT));
    335          
    336            /* Get the ADC IT index */
    337            itmask = (u8)ADC_IT;
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0023             MOVS     R3,R4
    338          
    339            if (NewState != DISABLE)
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD004             BEQ.N    ??ADC_ITConfig_0
    340            {
    341              /* Enable the selected ADC interrupts */
    342              ADCx->CR1 |= itmask;
   \   0000000E   0x6844             LDR      R4,[R0, #+4]
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x431C             ORRS     R4,R3,R4
   \   00000014   0x6044             STR      R4,[R0, #+4]
   \   00000016   0xE003             B.N      ??ADC_ITConfig_1
    343            }
    344            else
    345            {
    346              /* Disable the selected ADC interrupts */
    347              ADCx->CR1 &= (~(u32)itmask);
   \                     ??ADC_ITConfig_0:
   \   00000018   0x6844             LDR      R4,[R0, #+4]
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0x439C             BICS     R4,R4,R3
   \   0000001E   0x6044             STR      R4,[R0, #+4]
    348            }
    349          }
   \                     ??ADC_ITConfig_1:
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    350          
    351          /*******************************************************************************
    352          * Function Name  : ADC_ResetCalibration
    353          * Description    : Resets the selected ADC calibration registers.
    354          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    355          * Output         : None
    356          * Return         : None
    357          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    358          void ADC_ResetCalibration(ADC_TypeDef* ADCx)
    359          {
    360            /* Check the parameters */
    361            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    362          
    363            /* Resets the selected ADC calibartion registers */  
    364            ADCx->CR2 |= CR2_RSTCAL_Set;
   \                     ADC_ResetCalibration:
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000006   0x6081             STR      R1,[R0, #+8]
    365          }
   \   00000008   0x4770             BX       LR               ;; return
    366          
    367          /*******************************************************************************
    368          * Function Name  : ADC_GetResetCalibrationStatus
    369          * Description    : Gets the selected ADC reset calibration registers status.
    370          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    371          * Output         : None
    372          * Return         : The new state of ADC reset calibration registers (SET or RESET).
    373          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    374          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
    375          {
   \                     ADC_GetResetCalibrationStatus:
   \   00000000   0x0001             MOVS     R1,R0
    376            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    377          
    378            /* Check the parameters */
    379            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    380          
    381            /* Check the status of RSTCAL bit */
    382            if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0712             LSLS     R2,R2,#+28
   \   00000008   0xD502             BPL.N    ??ADC_GetResetCalibrationStatus_0
    383            {
    384              /* RSTCAL bit is set */
    385              bitstatus = SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE001             B.N      ??ADC_GetResetCalibrationStatus_1
    386            }
    387            else
    388            {
    389              /* RSTCAL bit is reset */
    390              bitstatus = RESET;
   \                     ??ADC_GetResetCalibrationStatus_0:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0010             MOVS     R0,R2
    391            }
    392          
    393            /* Return the RSTCAL bit status */
    394            return  bitstatus;
   \                     ??ADC_GetResetCalibrationStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    395          }
    396          
    397          /*******************************************************************************
    398          * Function Name  : ADC_StartCalibration
    399          * Description    : Starts the selected ADC calibration process.
    400          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    401          * Output         : None
    402          * Return         : None
    403          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    404          void ADC_StartCalibration(ADC_TypeDef* ADCx)
    405          {
    406            /* Check the parameters */
    407            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    408          
    409            /* Enable the selected ADC calibration process */  
    410            ADCx->CR2 |= CR2_CAL_Set;
   \                     ADC_StartCalibration:
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000006   0x6081             STR      R1,[R0, #+8]
    411          }
   \   00000008   0x4770             BX       LR               ;; return
    412          
    413          /*******************************************************************************
    414          * Function Name  : ADC_GetCalibrationStatus
    415          * Description    : Gets the selected ADC calibration status.
    416          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    417          * Output         : None
    418          * Return         : The new state of ADC calibration (SET or RESET).
    419          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    420          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
    421          {
   \                     ADC_GetCalibrationStatus:
   \   00000000   0x0001             MOVS     R1,R0
    422            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    423          
    424            /* Check the parameters */
    425            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    426          
    427            /* Check the status of CAL bit */
    428            if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0752             LSLS     R2,R2,#+29
   \   00000008   0xD502             BPL.N    ??ADC_GetCalibrationStatus_0
    429            {
    430              /* CAL bit is set: calibration on going */
    431              bitstatus = SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE001             B.N      ??ADC_GetCalibrationStatus_1
    432            }
    433            else
    434            {
    435              /* CAL bit is reset: end of calibration */
    436              bitstatus = RESET;
   \                     ??ADC_GetCalibrationStatus_0:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0010             MOVS     R0,R2
    437            }
    438          
    439            /* Return the CAL bit status */
    440            return  bitstatus;
   \                     ??ADC_GetCalibrationStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    441          }
    442          
    443          /*******************************************************************************
    444          * Function Name  : ADC_SoftwareStartConvCmd
    445          * Description    : Enables or disables the selected ADC software start conversion .
    446          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    447          *                  - NewState: new state of the selected ADC software start conversion.
    448          *                    This parameter can be: ENABLE or DISABLE.
    449          * Output         : None
    450          * Return         : None
    451          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    452          void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    453          {
    454            /* Check the parameters */
    455            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    456            assert_param(IS_FUNCTIONAL_STATE(NewState));
    457          
    458            if (NewState != DISABLE)
   \                     ADC_SoftwareStartConvCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_SoftwareStartConvCmd_0
    459            {
    460              /* Enable the selected ADC conversion on external event and start the selected
    461                 ADC conversion */
    462              ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF452 0x02A0      ORRS     R2,R2,#0x500000
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_SoftwareStartConvCmd_1
    463            }
    464            else
    465            {
    466              /* Disable the selected ADC conversion on external event and stop the selected
    467                 ADC conversion */
    468              ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
   \                     ??ADC_SoftwareStartConvCmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF432 0x02A0      BICS     R2,R2,#0x500000
   \   00000016   0x6082             STR      R2,[R0, #+8]
    469            }
    470          }
   \                     ??ADC_SoftwareStartConvCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    471          
    472          /*******************************************************************************
    473          * Function Name  : ADC_GetSoftwareStartConvStatus
    474          * Description    : Gets the selected ADC Software start conversion Status.
    475          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    476          * Output         : None
    477          * Return         : The new state of ADC software start conversion (SET or RESET).
    478          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    479          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    480          {
   \                     ADC_GetSoftwareStartConvStatus:
   \   00000000   0x0001             MOVS     R1,R0
    481            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    482          
    483            /* Check the parameters */
    484            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    485          
    486            /* Check the status of SWSTART bit */
    487            if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0252             LSLS     R2,R2,#+9
   \   00000008   0xD502             BPL.N    ??ADC_GetSoftwareStartConvStatus_0
    488            {
    489              /* SWSTART bit is set */
    490              bitstatus = SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE001             B.N      ??ADC_GetSoftwareStartConvStatus_1
    491            }
    492            else
    493            {
    494              /* SWSTART bit is reset */
    495              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartConvStatus_0:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0010             MOVS     R0,R2
    496            }
    497          
    498            /* Return the SWSTART bit status */
    499            return  bitstatus;
   \                     ??ADC_GetSoftwareStartConvStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    500          }
    501          
    502          /*******************************************************************************
    503          * Function Name  : ADC_DiscModeChannelCountConfig
    504          * Description    : Configures the discontinuous mode for the selected ADC regular
    505          *                  group channel.
    506          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    507          *                  - Number: specifies the discontinuous mode regular channel
    508          *                    count value. This number must be between 1 and 8.
    509          * Output         : None
    510          * Return         : None
    511          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    512          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
    513          {
   \                     ADC_DiscModeChannelCountConfig:
   \   00000000   0xB410             PUSH     {R4}
    514            u32 tmpreg1 = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    515            u32 tmpreg2 = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    516          
    517            /* Check the parameters */
    518            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    519            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    520          
    521            /* Get the old register value */
    522            tmpreg1 = ADCx->CR1;
   \   00000006   0x6844             LDR      R4,[R0, #+4]
   \   00000008   0x0022             MOVS     R2,R4
    523            /* Clear the old discontinuous mode channel count */
    524            tmpreg1 &= CR1_DISCNUM_Reset;
   \   0000000A   0xF432 0x4260      BICS     R2,R2,#0xE000
    525            /* Set the discontinuous mode channel count */
    526            tmpreg2 = Number - 1;
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x1E4C             SUBS     R4,R1,#+1
   \   00000012   0x0023             MOVS     R3,R4
    527            tmpreg1 |= tmpreg2 << 13;
   \   00000014   0xEA52 0x3243      ORRS     R2,R2,R3, LSL #+13
    528            /* Store the new register value */
    529            ADCx->CR1 = tmpreg1;
   \   00000018   0x6042             STR      R2,[R0, #+4]
    530          }
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    531          
    532          /*******************************************************************************
    533          * Function Name  : ADC_DiscModeCmd
    534          * Description    : Enables or disables the discontinuous mode on regular group
    535          *                  channel for the specified ADC
    536          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    537          *                  - NewState: new state of the selected ADC discontinuous mode
    538          *                    on regular group channel.
    539          *                    This parameter can be: ENABLE or DISABLE.
    540          * Output         : None
    541          * Return         : None
    542          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    543          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    544          {
    545            /* Check the parameters */
    546            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    547            assert_param(IS_FUNCTIONAL_STATE(NewState));
    548          
    549            if (NewState != DISABLE)
   \                     ADC_DiscModeCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_DiscModeCmd_0
    550            {
    551              /* Enable the selected ADC regular discontinuous mode */
    552              ADCx->CR1 |= CR1_DISCEN_Set;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF452 0x6200      ORRS     R2,R2,#0x800
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_DiscModeCmd_1
    553            }
    554            else
    555            {
    556              /* Disable the selected ADC regular discontinuous mode */
    557              ADCx->CR1 &= CR1_DISCEN_Reset;
   \                     ??ADC_DiscModeCmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF432 0x6200      BICS     R2,R2,#0x800
   \   00000016   0x6042             STR      R2,[R0, #+4]
    558            }
    559          }
   \                     ??ADC_DiscModeCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    560          
    561          /*******************************************************************************
    562          * Function Name  : ADC_RegularChannelConfig
    563          * Description    : Configures for the selected ADC regular channel its corresponding
    564          *                  rank in the sequencer and its sample time.
    565          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    566          *                  - ADC_Channel: the ADC channel to configure. 
    567          *                    This parameter can be one of the following values:
    568          *                       - ADC_Channel_0: ADC Channel0 selected
    569          *                       - ADC_Channel_1: ADC Channel1 selected
    570          *                       - ADC_Channel_2: ADC Channel2 selected
    571          *                       - ADC_Channel_3: ADC Channel3 selected
    572          *                       - ADC_Channel_4: ADC Channel4 selected
    573          *                       - ADC_Channel_5: ADC Channel5 selected
    574          *                       - ADC_Channel_6: ADC Channel6 selected
    575          *                       - ADC_Channel_7: ADC Channel7 selected
    576          *                       - ADC_Channel_8: ADC Channel8 selected
    577          *                       - ADC_Channel_9: ADC Channel9 selected
    578          *                       - ADC_Channel_10: ADC Channel10 selected
    579          *                       - ADC_Channel_11: ADC Channel11 selected
    580          *                       - ADC_Channel_12: ADC Channel12 selected
    581          *                       - ADC_Channel_13: ADC Channel13 selected
    582          *                       - ADC_Channel_14: ADC Channel14 selected
    583          *                       - ADC_Channel_15: ADC Channel15 selected
    584          *                       - ADC_Channel_16: ADC Channel16 selected
    585          *                       - ADC_Channel_17: ADC Channel17 selected
    586          *                  - Rank: The rank in the regular group sequencer. This parameter
    587          *                    must be between 1 to 16.
    588          *                  - ADC_SampleTime: The sample time value to be set for the
    589          *                    selected channel. 
    590          *                    This parameter can be one of the following values:
    591          *                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    592          *                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    593          *                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    594          *                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    595          *                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    596          *                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    597          *                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    598          *                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    599          * Output         : None
    600          * Return         : None
    601          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    602          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
    603          {
   \                     ADC_RegularChannelConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    604            u32 tmpreg1 = 0, tmpreg2 = 0;
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x2400             MOVS     R4,#+0
    605          
    606            /* Check the parameters */
    607            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    608            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    609            assert_param(IS_ADC_REGULAR_RANK(Rank));
    610            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    611          
    612            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    613            if (ADC_Channel > ADC_Channel_9)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x290A             CMP      R1,#+10
   \   0000000A   0xDB16             BLT.N    ??ADC_RegularChannelConfig_0
    614            {
    615              /* Get the old register value */
    616              tmpreg1 = ADCx->SMPR1;
   \   0000000C   0x68C6             LDR      R6,[R0, #+12]
   \   0000000E   0x0035             MOVS     R5,R6
    617              /* Calculate the mask to clear */
    618              tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
   \   00000010   0x2607             MOVS     R6,#+7
   \   00000012   0xF1B1 0x070A      SUBS     R7,R1,#+10
   \   00000016   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000001A   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000001E   0x40BE             LSLS     R6,R6,R7
   \   00000020   0x0034             MOVS     R4,R6
    619              /* Clear the old discontinuous mode channel count */
    620              tmpreg1 &= ~tmpreg2;
   \   00000022   0x43A5             BICS     R5,R5,R4
    621              /* Calculate the mask to set */
    622              tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \   00000024   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000026   0xF1B1 0x060A      SUBS     R6,R1,#+10
   \   0000002A   0x2703             MOVS     R7,#+3
   \   0000002C   0x437E             MULS     R6,R7,R6
   \   0000002E   0xFA13 0xF606      LSLS     R6,R3,R6
   \   00000032   0x0034             MOVS     R4,R6
    623              /* Set the discontinuous mode channel count */
    624              tmpreg1 |= tmpreg2;
   \   00000034   0x4325             ORRS     R5,R4,R5
    625              /* Store the new register value */
    626              ADCx->SMPR1 = tmpreg1;
   \   00000036   0x60C5             STR      R5,[R0, #+12]
   \   00000038   0xE011             B.N      ??ADC_RegularChannelConfig_1
    627            }
    628            else /* ADC_Channel include in ADC_Channel_[0..9] */
    629            {
    630              /* Get the old register value */
    631              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_RegularChannelConfig_0:
   \   0000003A   0x6906             LDR      R6,[R0, #+16]
   \   0000003C   0x0035             MOVS     R5,R6
    632              /* Calculate the mask to clear */
    633              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   \   0000003E   0x2607             MOVS     R6,#+7
   \   00000040   0x2703             MOVS     R7,#+3
   \   00000042   0xFB07 0xF701      MUL      R7,R7,R1
   \   00000046   0x40BE             LSLS     R6,R6,R7
   \   00000048   0x0034             MOVS     R4,R6
    634              /* Clear the old discontinuous mode channel count */
    635              tmpreg1 &= ~tmpreg2;
   \   0000004A   0x43A5             BICS     R5,R5,R4
    636              /* Calculate the mask to set */
    637              tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
   \   0000004C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004E   0x2603             MOVS     R6,#+3
   \   00000050   0xFB06 0xF601      MUL      R6,R6,R1
   \   00000054   0xFA13 0xF606      LSLS     R6,R3,R6
   \   00000058   0x0034             MOVS     R4,R6
    638              /* Set the discontinuous mode channel count */
    639              tmpreg1 |= tmpreg2;
   \   0000005A   0x4325             ORRS     R5,R4,R5
    640              /* Store the new register value */
    641              ADCx->SMPR2 = tmpreg1;
   \   0000005C   0x6105             STR      R5,[R0, #+16]
    642            }
    643            /* For Rank 1 to 6 */
    644            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_1:
   \   0000005E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000060   0x2A07             CMP      R2,#+7
   \   00000062   0xDA14             BGE.N    ??ADC_RegularChannelConfig_2
    645            {
    646              /* Get the old register value */
    647              tmpreg1 = ADCx->SQR3;
   \   00000064   0x6B46             LDR      R6,[R0, #+52]
   \   00000066   0x0035             MOVS     R5,R6
    648              /* Calculate the mask to clear */
    649              tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
   \   00000068   0x261F             MOVS     R6,#+31
   \   0000006A   0x1E57             SUBS     R7,R2,#+1
   \   0000006C   0xF05F 0x0C05      MOVS     R12,#+5
   \   00000070   0xFB0C 0xF707      MUL      R7,R12,R7
   \   00000074   0x40BE             LSLS     R6,R6,R7
   \   00000076   0x0034             MOVS     R4,R6
    650              /* Clear the old SQx bits for the selected rank */
    651              tmpreg1 &= ~tmpreg2;
   \   00000078   0x43A5             BICS     R5,R5,R4
    652              /* Calculate the mask to set */
    653              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x1E56             SUBS     R6,R2,#+1
   \   0000007E   0x2705             MOVS     R7,#+5
   \   00000080   0x437E             MULS     R6,R7,R6
   \   00000082   0xFA11 0xF606      LSLS     R6,R1,R6
   \   00000086   0x0034             MOVS     R4,R6
    654              /* Set the SQx bits for the selected rank */
    655              tmpreg1 |= tmpreg2;
   \   00000088   0x4325             ORRS     R5,R4,R5
    656              /* Store the new register value */
    657              ADCx->SQR3 = tmpreg1;
   \   0000008A   0x6345             STR      R5,[R0, #+52]
   \   0000008C   0xE02D             B.N      ??ADC_RegularChannelConfig_3
    658            }
    659            /* For Rank 7 to 12 */
    660            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_2:
   \   0000008E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000090   0x2A0D             CMP      R2,#+13
   \   00000092   0xDA14             BGE.N    ??ADC_RegularChannelConfig_4
    661            {
    662              /* Get the old register value */
    663              tmpreg1 = ADCx->SQR2;
   \   00000094   0x6B06             LDR      R6,[R0, #+48]
   \   00000096   0x0035             MOVS     R5,R6
    664              /* Calculate the mask to clear */
    665              tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
   \   00000098   0x261F             MOVS     R6,#+31
   \   0000009A   0x1FD7             SUBS     R7,R2,#+7
   \   0000009C   0xF05F 0x0C05      MOVS     R12,#+5
   \   000000A0   0xFB0C 0xF707      MUL      R7,R12,R7
   \   000000A4   0x40BE             LSLS     R6,R6,R7
   \   000000A6   0x0034             MOVS     R4,R6
    666              /* Clear the old SQx bits for the selected rank */
    667              tmpreg1 &= ~tmpreg2;
   \   000000A8   0x43A5             BICS     R5,R5,R4
    668              /* Calculate the mask to set */
    669              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
   \   000000AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0x1FD6             SUBS     R6,R2,#+7
   \   000000AE   0x2705             MOVS     R7,#+5
   \   000000B0   0x437E             MULS     R6,R7,R6
   \   000000B2   0xFA11 0xF606      LSLS     R6,R1,R6
   \   000000B6   0x0034             MOVS     R4,R6
    670              /* Set the SQx bits for the selected rank */
    671              tmpreg1 |= tmpreg2;
   \   000000B8   0x4325             ORRS     R5,R4,R5
    672              /* Store the new register value */
    673              ADCx->SQR2 = tmpreg1;
   \   000000BA   0x6305             STR      R5,[R0, #+48]
   \   000000BC   0xE015             B.N      ??ADC_RegularChannelConfig_3
    674            }
    675            /* For Rank 13 to 16 */
    676            else
    677            {
    678              /* Get the old register value */
    679              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_4:
   \   000000BE   0x6AC6             LDR      R6,[R0, #+44]
   \   000000C0   0x0035             MOVS     R5,R6
    680              /* Calculate the mask to clear */
    681              tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
   \   000000C2   0x261F             MOVS     R6,#+31
   \   000000C4   0xF1B2 0x070D      SUBS     R7,R2,#+13
   \   000000C8   0xF05F 0x0C05      MOVS     R12,#+5
   \   000000CC   0xFB0C 0xF707      MUL      R7,R12,R7
   \   000000D0   0x40BE             LSLS     R6,R6,R7
   \   000000D2   0x0034             MOVS     R4,R6
    682              /* Clear the old SQx bits for the selected rank */
    683              tmpreg1 &= ~tmpreg2;
   \   000000D4   0x43A5             BICS     R5,R5,R4
    684              /* Calculate the mask to set */
    685              tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
   \   000000D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D8   0xF1B2 0x060D      SUBS     R6,R2,#+13
   \   000000DC   0x2705             MOVS     R7,#+5
   \   000000DE   0x437E             MULS     R6,R7,R6
   \   000000E0   0xFA11 0xF606      LSLS     R6,R1,R6
   \   000000E4   0x0034             MOVS     R4,R6
    686              /* Set the SQx bits for the selected rank */
    687              tmpreg1 |= tmpreg2;
   \   000000E6   0x4325             ORRS     R5,R4,R5
    688              /* Store the new register value */
    689              ADCx->SQR1 = tmpreg1;
   \   000000E8   0x62C5             STR      R5,[R0, #+44]
    690            }
    691          }
   \                     ??ADC_RegularChannelConfig_3:
   \   000000EA   0xBCF0             POP      {R4-R7}
   \   000000EC   0x4770             BX       LR               ;; return
    692          
    693          /*******************************************************************************
    694          * Function Name  : ADC_ExternalTrigConvCmd
    695          * Description    : Enables or disables the ADCx conversion through external trigger.
    696          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    697          *                  - NewState: new state of the selected ADC external trigger
    698          *                    start of conversion.
    699          *                    This parameter can be: ENABLE or DISABLE.
    700          * Output         : None
    701          * Return         : None
    702          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    703          void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    707            assert_param(IS_FUNCTIONAL_STATE(NewState));
    708          
    709            if (NewState != DISABLE)
   \                     ADC_ExternalTrigConvCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_ExternalTrigConvCmd_0
    710            {
    711              /* Enable the selected ADC conversion on external event */
    712              ADCx->CR2 |= CR2_EXTTRIG_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF452 0x1280      ORRS     R2,R2,#0x100000
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_ExternalTrigConvCmd_1
    713            }
    714            else
    715            {
    716              /* Disable the selected ADC conversion on external event */
    717              ADCx->CR2 &= CR2_EXTTRIG_Reset;
   \                     ??ADC_ExternalTrigConvCmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF432 0x1280      BICS     R2,R2,#0x100000
   \   00000016   0x6082             STR      R2,[R0, #+8]
    718            }
    719          }
   \                     ??ADC_ExternalTrigConvCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    720          
    721          /*******************************************************************************
    722          * Function Name  : ADC_GetConversionValue
    723          * Description    : Returns the last ADCx conversion result data for regular channel.
    724          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    725          * Output         : None
    726          * Return         : The Data conversion value.
    727          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    728          u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
    729          {
    730            /* Check the parameters */
    731            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    732          
    733            /* Return the selected ADC conversion value */
    734            return (u16) ADCx->DR;
   \                     ADC_GetConversionValue:
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    735          }
    736          
    737          /*******************************************************************************
    738          * Function Name  : ADC_GetDualModeConversionValue
    739          * Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
    740          * Output         : None
    741          * Return         : The Data conversion value.
    742          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    743          u32 ADC_GetDualModeConversionValue(void)
    744          {
    745            /* Return the dual mode conversion value */
    746            return (*(vu32 *) DR_ADDRESS);
   \                     ADC_GetDualModeConversionValue:
   \   00000000   0x....             LDR.N    R0,??DataTable4_5  ;; 0x4001244c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    747          }
    748          
    749          /*******************************************************************************
    750          * Function Name  : ADC_AutoInjectedConvCmd
    751          * Description    : Enables or disables the selected ADC automatic injected group
    752          *                  conversion after regular one.
    753          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    754          *                  - NewState: new state of the selected ADC auto injected
    755          *                    conversion
    756          *                    This parameter can be: ENABLE or DISABLE.
    757          * Output         : None
    758          * Return         : None
    759          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    760          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    761          {
    762            /* Check the parameters */
    763            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    764            assert_param(IS_FUNCTIONAL_STATE(NewState));
    765          
    766            if (NewState != DISABLE)
   \                     ADC_AutoInjectedConvCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_0
    767            {
    768              /* Enable the selected ADC automatic injected group conversion */
    769              ADCx->CR1 |= CR1_JAUTO_Set;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF452 0x6280      ORRS     R2,R2,#0x400
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_AutoInjectedConvCmd_1
    770            }
    771            else
    772            {
    773              /* Disable the selected ADC automatic injected group conversion */
    774              ADCx->CR1 &= CR1_JAUTO_Reset;
   \                     ??ADC_AutoInjectedConvCmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF432 0x6280      BICS     R2,R2,#0x400
   \   00000016   0x6042             STR      R2,[R0, #+4]
    775            }
    776          }
   \                     ??ADC_AutoInjectedConvCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    777          
    778          /*******************************************************************************
    779          * Function Name  : ADC_InjectedDiscModeCmd
    780          * Description    : Enables or disables the discontinuous mode for injected group
    781          *                  channel for the specified ADC
    782          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    783          *                  - NewState: new state of the selected ADC discontinuous mode
    784          *                    on injected group channel.
    785          *                    This parameter can be: ENABLE or DISABLE.
    786          * Output         : None
    787          * Return         : None
    788          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    789          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    790          {
    791            /* Check the parameters */
    792            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    793            assert_param(IS_FUNCTIONAL_STATE(NewState));
    794          
    795            if (NewState != DISABLE)
   \                     ADC_InjectedDiscModeCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_0
    796            {
    797              /* Enable the selected ADC injected discontinuous mode */
    798              ADCx->CR1 |= CR1_JDISCEN_Set;
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF452 0x5280      ORRS     R2,R2,#0x1000
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   \   0000000E   0xE003             B.N      ??ADC_InjectedDiscModeCmd_1
    799            }
    800            else
    801            {
    802              /* Disable the selected ADC injected discontinuous mode */
    803              ADCx->CR1 &= CR1_JDISCEN_Reset;
   \                     ??ADC_InjectedDiscModeCmd_0:
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0xF432 0x5280      BICS     R2,R2,#0x1000
   \   00000016   0x6042             STR      R2,[R0, #+4]
    804            }
    805          }
   \                     ??ADC_InjectedDiscModeCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    806          
    807          /*******************************************************************************
    808          * Function Name  : ADC_ExternalTrigInjectedConvConfig
    809          * Description    : Configures the ADCx external trigger for injected channels conversion.
    810          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    811          *                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
    812          *                    start injected conversion. 
    813          *                    This parameter can be one of the following values:
    814          *                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
    815          *                         selected (for ADC1, ADC2 and ADC3)
    816          *                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
    817          *                         compare4 selected (for ADC1, ADC2 and ADC3)
    818          *                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
    819          *                         selected (for ADC1 and ADC2)
    820          *                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
    821          *                         compare1 selected (for ADC1 and ADC2)
    822          *                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
    823          *                         compare4 selected (for ADC1 and ADC2)
    824          *                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
    825          *                         selected (for ADC1 and ADC2)
    826          *                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
    827          *                         interrupt line 15 or Timer8 capture compare4 event selected
    828          *                         (for ADC1 and ADC2)                       
    829          *                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
    830          *                         compare3 selected (for ADC3 only)
    831          *                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
    832          *                         compare2 selected (for ADC3 only)                         
    833          *                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
    834          *                         compare4 selected (for ADC3 only)
    835          *                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
    836          *                         selected (for ADC3 only)                         
    837          *                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
    838          *                         compare4 selected (for ADC3 only)                        
    839          *                       - ADC_ExternalTrigInjecConv_None: Injected conversion
    840          *                         started by software and not by external trigger (for 
    841          *                         ADC1, ADC2 and ADC3)
    842          * Output         : None
    843          * Return         : None
    844          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    845          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
    846          {
    847            u32 tmpreg = 0;
   \                     ADC_ExternalTrigInjectedConvConfig:
   \   00000000   0x2200             MOVS     R2,#+0
    848          
    849            /* Check the parameters */
    850            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    851            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
    852          
    853            /* Get the old register value */
    854            tmpreg = ADCx->CR2;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0x001A             MOVS     R2,R3
    855            /* Clear the old external event selection for injected group */
    856            tmpreg &= CR2_JEXTSEL_Reset;
   \   00000006   0xF432 0x42E0      BICS     R2,R2,#0x7000
    857            /* Set the external event selection for injected group */
    858            tmpreg |= ADC_ExternalTrigInjecConv;
   \   0000000A   0x430A             ORRS     R2,R1,R2
    859            /* Store the new register value */
    860            ADCx->CR2 = tmpreg;
   \   0000000C   0x6082             STR      R2,[R0, #+8]
    861          }
   \   0000000E   0x4770             BX       LR               ;; return
    862          
    863          /*******************************************************************************
    864          * Function Name  : ADC_ExternalTrigInjectedConvCmd
    865          * Description    : Enables or disables the ADCx injected channels conversion
    866          *                  through external trigger
    867          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    868          *                  - NewState: new state of the selected ADC external trigger
    869          *                    start of injected conversion.
    870          *                    This parameter can be: ENABLE or DISABLE.
    871          * Output         : None
    872          * Return         : None
    873          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    874          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    875          {
    876            /* Check the parameters */
    877            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    878            assert_param(IS_FUNCTIONAL_STATE(NewState));
    879          
    880            if (NewState != DISABLE)
   \                     ADC_ExternalTrigInjectedConvCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_ExternalTrigInjectedConvCmd_0
    881            {
    882              /* Enable the selected ADC external event selection for injected group */
    883              ADCx->CR2 |= CR2_JEXTTRIG_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_ExternalTrigInjectedConvCmd_1
    884            }
    885            else
    886            {
    887              /* Disable the selected ADC external event selection for injected group */
    888              ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   \                     ??ADC_ExternalTrigInjectedConvCmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF432 0x4200      BICS     R2,R2,#0x8000
   \   00000016   0x6082             STR      R2,[R0, #+8]
    889            }
    890          }
   \                     ??ADC_ExternalTrigInjectedConvCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    891          
    892          /*******************************************************************************
    893          * Function Name  : ADC_SoftwareStartInjectedConvCmd
    894          * Description    : Enables or disables the selected ADC start of the injected 
    895          *                  channels conversion.
    896          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    897          *                  - NewState: new state of the selected ADC software start
    898          *                    injected conversion.
    899          *                    This parameter can be: ENABLE or DISABLE.
    900          * Output         : None
    901          * Return         : None
    902          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    903          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    904          {
    905            /* Check the parameters */
    906            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    907            assert_param(IS_FUNCTIONAL_STATE(NewState));
    908          
    909            if (NewState != DISABLE)
   \                     ADC_SoftwareStartInjectedConvCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??ADC_SoftwareStartInjectedConvCmd_0
    910            {
    911              /* Enable the selected ADC conversion for injected group on external event and start the selected
    912                 ADC injected conversion */
    913              ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF452 0x1202      ORRS     R2,R2,#0x208000
   \   0000000C   0x6082             STR      R2,[R0, #+8]
   \   0000000E   0xE003             B.N      ??ADC_SoftwareStartInjectedConvCmd_1
    914            }
    915            else
    916            {
    917              /* Disable the selected ADC conversion on external event for injected group and stop the selected
    918                 ADC injected conversion */
    919              ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   \                     ??ADC_SoftwareStartInjectedConvCmd_0:
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF432 0x1202      BICS     R2,R2,#0x208000
   \   00000016   0x6082             STR      R2,[R0, #+8]
    920            }
    921          }
   \                     ??ADC_SoftwareStartInjectedConvCmd_1:
   \   00000018   0x4770             BX       LR               ;; return
    922          
    923          /*******************************************************************************
    924          * Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
    925          * Description    : Gets the selected ADC Software start injected conversion Status.
    926          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    927          * Output         : None
    928          * Return         : The new state of ADC software start injected conversion (SET or RESET).
    929          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    930          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
    931          {
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus:
   \   00000000   0x0001             MOVS     R1,R0
    932            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    933          
    934            /* Check the parameters */
    935            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    936          
    937            /* Check the status of JSWSTART bit */
    938            if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x0292             LSLS     R2,R2,#+10
   \   00000008   0xD502             BPL.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
    939            {
    940              /* JSWSTART bit is set */
    941              bitstatus = SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE001             B.N      ??ADC_GetSoftwareStartInjectedConvCmdStatus_1
    942            }
    943            else
    944            {
    945              /* JSWSTART bit is reset */
    946              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0010             MOVS     R0,R2
    947            }
    948          
    949            /* Return the JSWSTART bit status */
    950            return  bitstatus;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    951          }
    952          
    953          /*******************************************************************************
    954          * Function Name  : ADC_InjectedChannelConfig
    955          * Description    : Configures for the selected ADC injected channel its corresponding
    956          *                  rank in the sequencer and its sample time.
    957          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    958          *                  - ADC_Channel: the ADC channel to configure. 
    959          *                    This parameter can be one of the following values:
    960          *                       - ADC_Channel_0: ADC Channel0 selected
    961          *                       - ADC_Channel_1: ADC Channel1 selected
    962          *                       - ADC_Channel_2: ADC Channel2 selected
    963          *                       - ADC_Channel_3: ADC Channel3 selected
    964          *                       - ADC_Channel_4: ADC Channel4 selected
    965          *                       - ADC_Channel_5: ADC Channel5 selected
    966          *                       - ADC_Channel_6: ADC Channel6 selected
    967          *                       - ADC_Channel_7: ADC Channel7 selected
    968          *                       - ADC_Channel_8: ADC Channel8 selected
    969          *                       - ADC_Channel_9: ADC Channel9 selected
    970          *                       - ADC_Channel_10: ADC Channel10 selected
    971          *                       - ADC_Channel_11: ADC Channel11 selected
    972          *                       - ADC_Channel_12: ADC Channel12 selected
    973          *                       - ADC_Channel_13: ADC Channel13 selected
    974          *                       - ADC_Channel_14: ADC Channel14 selected
    975          *                       - ADC_Channel_15: ADC Channel15 selected
    976          *                       - ADC_Channel_16: ADC Channel16 selected
    977          *                       - ADC_Channel_17: ADC Channel17 selected
    978          *                  - Rank: The rank in the injected group sequencer. This parameter
    979          *                    must be between 1 to 4.
    980          *                  - ADC_SampleTime: The sample time value to be set for the
    981          *                    selected channel. 
    982          *                    This parameter can be one of the following values:
    983          *                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    984          *                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    985          *                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    986          *                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    987          *                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    988          *                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    989          *                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    990          *                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    991          * Output         : None
    992          * Return         : None
    993          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    994          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
    995          {
   \                     ADC_InjectedChannelConfig:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    996            u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
    997          
    998            /* Check the parameters */
    999            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1000            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1001            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1002            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1003          
   1004            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
   1005            if (ADC_Channel > ADC_Channel_9)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x290A             CMP      R1,#+10
   \   0000000C   0xDB19             BLT.N    ??ADC_InjectedChannelConfig_0
   1006            {
   1007              /* Get the old register value */
   1008              tmpreg1 = ADCx->SMPR1;
   \   0000000E   0x68C7             LDR      R7,[R0, #+12]
   \   00000010   0x003E             MOVS     R6,R7
   1009              /* Calculate the mask to clear */
   1010              tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   \   00000012   0x2707             MOVS     R7,#+7
   \   00000014   0xF1B1 0x0C0A      SUBS     R12,R1,#+10
   \   00000018   0xF05F 0x0E03      MOVS     LR,#+3
   \   0000001C   0xFB0E 0xFC0C      MUL      R12,LR,R12
   \   00000020   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000024   0x003C             MOVS     R4,R7
   1011              /* Clear the old discontinuous mode channel count */
   1012              tmpreg1 &= ~tmpreg2;
   \   00000026   0x43A6             BICS     R6,R6,R4
   1013              /* Calculate the mask to set */
   1014              tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0xF1B1 0x070A      SUBS     R7,R1,#+10
   \   0000002E   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000032   0xFB0C 0xF707      MUL      R7,R12,R7
   \   00000036   0xFA13 0xF707      LSLS     R7,R3,R7
   \   0000003A   0x003C             MOVS     R4,R7
   1015              /* Set the discontinuous mode channel count */
   1016              tmpreg1 |= tmpreg2;
   \   0000003C   0x4326             ORRS     R6,R4,R6
   1017              /* Store the new register value */
   1018              ADCx->SMPR1 = tmpreg1;
   \   0000003E   0x60C6             STR      R6,[R0, #+12]
   \   00000040   0xE013             B.N      ??ADC_InjectedChannelConfig_1
   1019            }
   1020            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1021            {
   1022              /* Get the old register value */
   1023              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_InjectedChannelConfig_0:
   \   00000042   0x6907             LDR      R7,[R0, #+16]
   \   00000044   0x003E             MOVS     R6,R7
   1024              /* Calculate the mask to clear */
   1025              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   \   00000046   0x2707             MOVS     R7,#+7
   \   00000048   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000004C   0xFB0C 0xFC01      MUL      R12,R12,R1
   \   00000050   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000054   0x003C             MOVS     R4,R7
   1026              /* Clear the old discontinuous mode channel count */
   1027              tmpreg1 &= ~tmpreg2;
   \   00000056   0x43A6             BICS     R6,R6,R4
   1028              /* Calculate the mask to set */
   1029              tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
   \   00000058   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005A   0x2703             MOVS     R7,#+3
   \   0000005C   0xFB07 0xF701      MUL      R7,R7,R1
   \   00000060   0xFA13 0xF707      LSLS     R7,R3,R7
   \   00000064   0x003C             MOVS     R4,R7
   1030              /* Set the discontinuous mode channel count */
   1031              tmpreg1 |= tmpreg2;
   \   00000066   0x4326             ORRS     R6,R4,R6
   1032              /* Store the new register value */
   1033              ADCx->SMPR2 = tmpreg1;
   \   00000068   0x6106             STR      R6,[R0, #+16]
   1034            }
   1035          
   1036            /* Rank configuration */
   1037            /* Get the old register value */
   1038            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_1:
   \   0000006A   0x6B87             LDR      R7,[R0, #+56]
   \   0000006C   0x003E             MOVS     R6,R7
   1039            /* Get JL value: Number = JL+1 */
   1040            tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
   \   0000006E   0xF3C6 0x5701      UBFX     R7,R6,#+20,#+2
   \   00000072   0x003D             MOVS     R5,R7
   1041            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1042            tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
   \   00000074   0x271F             MOVS     R7,#+31
   \   00000076   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000078   0xF112 0x0C03      ADDS     R12,R2,#+3
   \   0000007C   0xEBBC 0x0C05      SUBS     R12,R12,R5
   \   00000080   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000084   0xF05F 0x0E05      MOVS     LR,#+5
   \   00000088   0xFB0E 0xFC0C      MUL      R12,LR,R12
   \   0000008C   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000090   0x003C             MOVS     R4,R7
   1043            /* Clear the old JSQx bits for the selected rank */
   1044            tmpreg1 &= ~tmpreg2;
   \   00000092   0x43A6             BICS     R6,R6,R4
   1045            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1046            tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
   \   00000094   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000096   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000098   0x1CD7             ADDS     R7,R2,#+3
   \   0000009A   0x1B7F             SUBS     R7,R7,R5
   \   0000009C   0x1E7F             SUBS     R7,R7,#+1
   \   0000009E   0xF05F 0x0C05      MOVS     R12,#+5
   \   000000A2   0xFB0C 0xF707      MUL      R7,R12,R7
   \   000000A6   0xFA11 0xF707      LSLS     R7,R1,R7
   \   000000AA   0x003C             MOVS     R4,R7
   1047            /* Set the JSQx bits for the selected rank */
   1048            tmpreg1 |= tmpreg2;
   \   000000AC   0x4326             ORRS     R6,R4,R6
   1049            /* Store the new register value */
   1050            ADCx->JSQR = tmpreg1;
   \   000000AE   0x6386             STR      R6,[R0, #+56]
   1051          }
   \   000000B0   0xBDF0             POP      {R4-R7,PC}       ;; return
   1052          
   1053          /*******************************************************************************
   1054          * Function Name  : ADC_InjectedSequencerLengthConfig
   1055          * Description    : Configures the sequencer length for injected channels
   1056          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1057          *                  - Length: The sequencer length. 
   1058          *                    This parameter must be a number between 1 to 4.
   1059          * Output         : None
   1060          * Return         : None
   1061          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1062          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
   1063          {
   \                     ADC_InjectedSequencerLengthConfig:
   \   00000000   0xB410             PUSH     {R4}
   1064            u32 tmpreg1 = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   1065            u32 tmpreg2 = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   1066          
   1067            /* Check the parameters */
   1068            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1069            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1070            
   1071            /* Get the old register value */
   1072            tmpreg1 = ADCx->JSQR;
   \   00000006   0x6B84             LDR      R4,[R0, #+56]
   \   00000008   0x0022             MOVS     R2,R4
   1073            /* Clear the old injected sequnence lenght JL bits */
   1074            tmpreg1 &= JSQR_JL_Reset;
   \   0000000A   0xF432 0x1240      BICS     R2,R2,#0x300000
   1075            /* Set the injected sequnence lenght JL bits */
   1076            tmpreg2 = Length - 1; 
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x1E4C             SUBS     R4,R1,#+1
   \   00000012   0x0023             MOVS     R3,R4
   1077            tmpreg1 |= tmpreg2 << 20;
   \   00000014   0xEA52 0x5203      ORRS     R2,R2,R3, LSL #+20
   1078            /* Store the new register value */
   1079            ADCx->JSQR = tmpreg1;
   \   00000018   0x6382             STR      R2,[R0, #+56]
   1080          }
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
   1081          
   1082          /*******************************************************************************
   1083          * Function Name  : ADC_SetInjectedOffset
   1084          * Description    : Set the injected channels conversion value offset
   1085          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1086          *                  - ADC_InjectedChannel: the ADC injected channel to set its
   1087          *                    offset. 
   1088          *                    This parameter can be one of the following values:
   1089          *                       - ADC_InjectedChannel_1: Injected Channel1 selected
   1090          *                       - ADC_InjectedChannel_2: Injected Channel2 selected
   1091          *                       - ADC_InjectedChannel_3: Injected Channel3 selected
   1092          *                       - ADC_InjectedChannel_4: Injected Channel4 selected
   1093          *                  - Offset: the offset value for the selected ADC injected channel
   1094          *                    This parameter must be a 12bit value.
   1095          * Output         : None
   1096          * Return         : None
   1097          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1098          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
   1099          {
   1100            /* Check the parameters */
   1101            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1102            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1103            assert_param(IS_ADC_OFFSET(Offset));  
   1104          
   1105            /* Set the selected injected channel data offset */
   1106            *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
   \                     ADC_SetInjectedOffset:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000004   0x500A             STR      R2,[R1, R0]
   1107          }
   \   00000006   0x4770             BX       LR               ;; return
   1108          
   1109          /*******************************************************************************
   1110          * Function Name  : ADC_GetInjectedConversionValue
   1111          * Description    : Returns the ADC injected channel conversion result
   1112          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1113          *                  - ADC_InjectedChannel: the converted ADC injected channel.
   1114          *                    This parameter can be one of the following values:
   1115          *                       - ADC_InjectedChannel_1: Injected Channel1 selected
   1116          *                       - ADC_InjectedChannel_2: Injected Channel2 selected
   1117          *                       - ADC_InjectedChannel_3: Injected Channel3 selected
   1118          *                       - ADC_InjectedChannel_4: Injected Channel4 selected
   1119          * Output         : None
   1120          * Return         : The Data conversion value.
   1121          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1122          u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
   1123          {
   1124            /* Check the parameters */
   1125            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1126            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1127          
   1128            /* Returns the selected injected channel conversion data value */
   1129            return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
   \                     ADC_GetInjectedConversionValue:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x6A80             LDR      R0,[R0, #+40]
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x4770             BX       LR               ;; return
   1130          }
   1131          
   1132          /*******************************************************************************
   1133          * Function Name  : ADC_AnalogWatchdogCmd
   1134          * Description    : Enables or disables the analog watchdog on single/all regular
   1135          *                  or injected channels
   1136          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1137          *                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1138          *                    This parameter can be one of the following values:
   1139          *                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
   1140          *                         a single regular channel
   1141          *                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
   1142          *                         a single injected channel
   1143          *                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
   1144          *                         watchdog on a single regular or injected channel
   1145          *                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
   1146          *                         all regular channel
   1147          *                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
   1148          *                         all injected channel
   1149          *                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
   1150          *                         on all regular and injected channels
   1151          *                       - ADC_AnalogWatchdog_None: No channel guarded by the
   1152          *                         analog watchdog
   1153          * Output         : None
   1154          * Return         : None	  
   1155          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1156          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
   1157          {
   1158            u32 tmpreg = 0;
   \                     ADC_AnalogWatchdogCmd:
   \   00000000   0x2200             MOVS     R2,#+0
   1159          
   1160            /* Check the parameters */
   1161            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1162            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1163          
   1164            /* Get the old register value */
   1165            tmpreg = ADCx->CR1;
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x001A             MOVS     R2,R3
   1166            /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1167            tmpreg &= CR1_AWDMode_Reset;
   \   00000006   0x....             LDR.N    R3,??DataTable4_6  ;; 0xff3ffdff
   \   00000008   0x401A             ANDS     R2,R3,R2
   1168            /* Set the analog watchdog enable mode */
   1169            tmpreg |= ADC_AnalogWatchdog;
   \   0000000A   0x430A             ORRS     R2,R1,R2
   1170            /* Store the new register value */
   1171            ADCx->CR1 = tmpreg;
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1172          }
   \   0000000E   0x4770             BX       LR               ;; return
   1173          
   1174          /*******************************************************************************
   1175          * Function Name  : ADC_AnalogWatchdogThresholdsConfig
   1176          * Description    : Configures the high and low thresholds of the analog watchdog.
   1177          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1178          *                  - HighThreshold: the ADC analog watchdog High threshold value.
   1179          *                    This parameter must be a 12bit value.
   1180          *                  - LowThreshold: the ADC analog watchdog Low threshold value.
   1181          *                    This parameter must be a 12bit value.
   1182          * Output         : None
   1183          * Return         : None
   1184          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1185          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
   1186                                                  u16 LowThreshold)
   1187          {
   1188            /* Check the parameters */
   1189            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1190            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1191            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1192          
   1193            /* Set the ADCx high threshold */
   1194            ADCx->HTR = HighThreshold;
   \                     ADC_AnalogWatchdogThresholdsConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6241             STR      R1,[R0, #+36]
   1195            /* Set the ADCx low threshold */
   1196            ADCx->LTR = LowThreshold;
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x6282             STR      R2,[R0, #+40]
   1197          }
   \   00000008   0x4770             BX       LR               ;; return
   1198          
   1199          /*******************************************************************************
   1200          * Function Name  : ADC_AnalogWatchdogSingleChannelConfig
   1201          * Description    : Configures the analog watchdog guarded single channel
   1202          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1203          *                  - ADC_Channel: the ADC channel to configure for the analog
   1204          *                    watchdog. 
   1205          *                    This parameter can be one of the following values:
   1206          *                       - ADC_Channel_0: ADC Channel0 selected
   1207          *                       - ADC_Channel_1: ADC Channel1 selected
   1208          *                       - ADC_Channel_2: ADC Channel2 selected
   1209          *                       - ADC_Channel_3: ADC Channel3 selected
   1210          *                       - ADC_Channel_4: ADC Channel4 selected
   1211          *                       - ADC_Channel_5: ADC Channel5 selected
   1212          *                       - ADC_Channel_6: ADC Channel6 selected
   1213          *                       - ADC_Channel_7: ADC Channel7 selected
   1214          *                       - ADC_Channel_8: ADC Channel8 selected
   1215          *                       - ADC_Channel_9: ADC Channel9 selected
   1216          *                       - ADC_Channel_10: ADC Channel10 selected
   1217          *                       - ADC_Channel_11: ADC Channel11 selected
   1218          *                       - ADC_Channel_12: ADC Channel12 selected
   1219          *                       - ADC_Channel_13: ADC Channel13 selected
   1220          *                       - ADC_Channel_14: ADC Channel14 selected
   1221          *                       - ADC_Channel_15: ADC Channel15 selected
   1222          *                       - ADC_Channel_16: ADC Channel16 selected
   1223          *                       - ADC_Channel_17: ADC Channel17 selected
   1224          * Output         : None
   1225          * Return         : None
   1226          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1227          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
   1228          {
   1229            u32 tmpreg = 0;
   \                     ADC_AnalogWatchdogSingleChannelConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   1230          
   1231            /* Check the parameters */
   1232            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1233            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1234          
   1235            /* Get the old register value */
   1236            tmpreg = ADCx->CR1;
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x001A             MOVS     R2,R3
   1237            /* Clear the Analog watchdog channel select bits */
   1238            tmpreg &= CR1_AWDCH_Reset;
   \   00000006   0x0952             LSRS     R2,R2,#+5
   \   00000008   0x0152             LSLS     R2,R2,#+5
   1239            /* Set the Analog watchdog channel */
   1240            tmpreg |= ADC_Channel;
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x430A             ORRS     R2,R1,R2
   1241            /* Store the new register value */
   1242            ADCx->CR1 = tmpreg;
   \   0000000E   0x6042             STR      R2,[R0, #+4]
   1243          }
   \   00000010   0x4770             BX       LR               ;; return
   1244          
   1245          /*******************************************************************************
   1246          * Function Name  : ADC_TempSensorVrefintCmd
   1247          * Description    : Enables or disables the temperature sensor and Vrefint channel.
   1248          * Input          : - NewState: new state of the temperature sensor.
   1249          *                    This parameter can be: ENABLE or DISABLE.
   1250          * Output         : None
   1251          * Return         : None
   1252          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1253          void ADC_TempSensorVrefintCmd(FunctionalState NewState)
   1254          {
   1255            /* Check the parameters */
   1256            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1257          
   1258            if (NewState != DISABLE)
   \                     ADC_TempSensorVrefintCmd:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   1259            {
   1260              /* Enable the temperature sensor and Vrefint channel*/
   1261              ADC1->CR2 |= CR2_TSVREFE_Set;
   \   00000006   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40012408
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \   0000000E   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40012408
   \   00000010   0x6011             STR      R1,[R2, #+0]
   \   00000012   0xE005             B.N      ??ADC_TempSensorVrefintCmd_1
   1262            }
   1263            else
   1264            {
   1265              /* Disable the temperature sensor and Vrefint channel*/
   1266              ADC1->CR2 &= CR2_TSVREFE_Reset;
   \                     ??ADC_TempSensorVrefintCmd_0:
   \   00000014   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40012408
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF431 0x0100      BICS     R1,R1,#0x800000
   \   0000001C   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40012408
   \   0000001E   0x6011             STR      R1,[R2, #+0]
   1267            }
   1268          }
   \                     ??ADC_TempSensorVrefintCmd_1:
   \   00000020   0x4770             BX       LR               ;; return
   1269          
   1270          /*******************************************************************************
   1271          * Function Name  : ADC_GetFlagStatus
   1272          * Description    : Checks whether the specified ADC flag is set or not.
   1273          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1274          *                  - ADC_FLAG: specifies the flag to check. 
   1275          *                    This parameter can be one of the following values:
   1276          *                       - ADC_FLAG_AWD: Analog watchdog flag
   1277          *                       - ADC_FLAG_EOC: End of conversion flag
   1278          *                       - ADC_FLAG_JEOC: End of injected group conversion flag
   1279          *                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
   1280          *                       - ADC_FLAG_STRT: Start of regular group conversion flag
   1281          * Output         : None
   1282          * Return         : The new state of ADC_FLAG (SET or RESET).
   1283          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1284          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
   1285          {
   \                     ADC_GetFlagStatus:
   \   00000000   0x0002             MOVS     R2,R0
   1286            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1287          
   1288            /* Check the parameters */
   1289            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1290            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1291          
   1292            /* Check the status of the specified ADC flag */
   1293            if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
   \   00000004   0x6813             LDR      R3,[R2, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x420B             TST      R3,R1
   \   0000000A   0xD002             BEQ.N    ??ADC_GetFlagStatus_0
   1294            {
   1295              /* ADC_FLAG is set */
   1296              bitstatus = SET;
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE001             B.N      ??ADC_GetFlagStatus_1
   1297            }
   1298            else
   1299            {
   1300              /* ADC_FLAG is reset */
   1301              bitstatus = RESET;
   \                     ??ADC_GetFlagStatus_0:
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x0018             MOVS     R0,R3
   1302            }
   1303          
   1304            /* Return the ADC_FLAG status */
   1305            return  bitstatus;
   \                     ??ADC_GetFlagStatus_1:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
   1306          }
   1307          
   1308          /*******************************************************************************
   1309          * Function Name  : ADC_ClearFlag
   1310          * Description    : Clears the ADCx's pending flags.
   1311          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1312          *                  - ADC_FLAG: specifies the flag to clear. 
   1313          *                    This parameter can be any combination of the following values:
   1314          *                       - ADC_FLAG_AWD: Analog watchdog flag
   1315          *                       - ADC_FLAG_EOC: End of conversion flag
   1316          *                       - ADC_FLAG_JEOC: End of injected group conversion flag
   1317          *                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
   1318          *                       - ADC_FLAG_STRT: Start of regular group conversion flag
   1319          * Output         : None
   1320          * Return         : None
   1321          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1322          void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
   1323          {
   1324            /* Check the parameters */
   1325            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1326            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1327          
   1328            /* Clear the selected ADC flags */
   1329            ADCx->SR = ~(u32)ADC_FLAG;
   \                     ADC_ClearFlag:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x43CA             MVNS     R2,R1
   \   00000004   0x6002             STR      R2,[R0, #+0]
   1330          }
   \   00000006   0x4770             BX       LR               ;; return
   1331          
   1332          /*******************************************************************************
   1333          * Function Name  : ADC_GetITStatus
   1334          * Description    : Checks whether the specified ADC interrupt has occurred or not.
   1335          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1336          *                  - ADC_IT: specifies the ADC interrupt source to check. 
   1337          *                    This parameter can be one of the following values:
   1338          *                       - ADC_IT_EOC: End of conversion interrupt mask
   1339          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
   1340          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
   1341          * Output         : None
   1342          * Return         : The new state of ADC_IT (SET or RESET).
   1343          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1344          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
   1345          {
   \                     ADC_GetITStatus:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
   1346            ITStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
   1347            u32 itmask = 0, enablestatus = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   1348          
   1349            /* Check the parameters */
   1350            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1351            assert_param(IS_ADC_GET_IT(ADC_IT));
   1352          
   1353            /* Get the ADC IT index */
   1354            itmask = ADC_IT >> 8;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x0A0D             LSRS     R5,R1,#+8
   \   0000000E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000010   0x002B             MOVS     R3,R5
   1355          
   1356            /* Get the ADC_IT enable bit status */
   1357            enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
   \   00000012   0x6855             LDR      R5,[R2, #+4]
   \   00000014   0x000E             MOVS     R6,R1
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x4035             ANDS     R5,R6,R5
   \   0000001A   0x002C             MOVS     R4,R5
   1358          
   1359            /* Check the status of the specified ADC interrupt */
   1360            if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
   \   0000001C   0x6815             LDR      R5,[R2, #+0]
   \   0000001E   0x421D             TST      R5,R3
   \   00000020   0xD004             BEQ.N    ??ADC_GetITStatus_0
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD002             BEQ.N    ??ADC_GetITStatus_0
   1361            {
   1362              /* ADC_IT is set */
   1363              bitstatus = SET;
   \   00000026   0x2501             MOVS     R5,#+1
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xE001             B.N      ??ADC_GetITStatus_1
   1364            }
   1365            else
   1366            {
   1367              /* ADC_IT is reset */
   1368              bitstatus = RESET;
   \                     ??ADC_GetITStatus_0:
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0x0028             MOVS     R0,R5
   1369            }
   1370          
   1371            /* Return the ADC_IT status */
   1372            return  bitstatus;
   \                     ??ADC_GetITStatus_1:
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xBC70             POP      {R4-R6}
   \   00000034   0x4770             BX       LR               ;; return
   1373          }
   1374          
   1375          /*******************************************************************************
   1376          * Function Name  : ADC_ClearITPendingBit
   1377          * Description    : Clears the ADCxs interrupt pending bits.
   1378          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1379          *                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
   1380          *                    This parameter can be any combination of the following values:
   1381          *                       - ADC_IT_EOC: End of conversion interrupt mask
   1382          *                       - ADC_IT_AWD: Analog watchdog interrupt mask
   1383          *                       - ADC_IT_JEOC: End of injected conversion interrupt mask
   1384          * Output         : None
   1385          * Return         : None
   1386          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1387          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
   1388          {
   1389            u8 itmask = 0;
   \                     ADC_ClearITPendingBit:
   \   00000000   0x2200             MOVS     R2,#+0
   1390          
   1391            /* Check the parameters */
   1392            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1393            assert_param(IS_ADC_IT(ADC_IT));
   1394          
   1395            /* Get the ADC IT index */
   1396            itmask = (u8)(ADC_IT >> 8);
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x0A0B             LSRS     R3,R1,#+8
   \   00000006   0x001A             MOVS     R2,R3
   1397          
   1398            /* Clear the selected ADC interrupt pending bits */
   1399            ADCx->SR = ~(u32)itmask;
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x43D3             MVNS     R3,R2
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   1400          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xFFF0FEFF         DC32     0xfff0feff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0xFFF1F7FD         DC32     0xfff1f7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x4001244C         DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0xFF3FFDFF         DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40012408         DC32     0x40012408
   1401          
   1402          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_DMACmd
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       4   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_ExternalTrigConvCmd
       0   ADC_ExternalTrigInjectedConvCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_GetCalibrationStatus
       0   ADC_GetConversionValue
       0   ADC_GetDualModeConversionValue
       0   ADC_GetFlagStatus
      12   ADC_GetITStatus
       0   ADC_GetInjectedConversionValue
       0   ADC_GetResetCalibrationStatus
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       4   ADC_ITConfig
       8   ADC_Init
      20   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       4   ADC_InjectedSequencerLengthConfig
      16   ADC_RegularChannelConfig
       0   ADC_ResetCalibration
       0   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConvCmd
       0   ADC_SoftwareStartInjectedConvCmd
       0   ADC_StartCalibration
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      16  ADC_AnalogWatchdogCmd
      18  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      16  ADC_ClearITPendingBit
      26  ADC_Cmd
      26  ADC_DMACmd
     100  ADC_DeInit
      30  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_ExternalTrigConvCmd
      26  ADC_ExternalTrigInjectedConvCmd
      16  ADC_ExternalTrigInjectedConvConfig
      24  ADC_GetCalibrationStatus
       6  ADC_GetConversionValue
       6  ADC_GetDualModeConversionValue
      26  ADC_GetFlagStatus
      54  ADC_GetITStatus
      10  ADC_GetInjectedConversionValue
      24  ADC_GetResetCalibrationStatus
      24  ADC_GetSoftwareStartConvStatus
      24  ADC_GetSoftwareStartInjectedConvCmdStatus
      36  ADC_ITConfig
      80  ADC_Init
     178  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      30  ADC_InjectedSequencerLengthConfig
     238  ADC_RegularChannelConfig
      10  ADC_ResetCalibration
       8  ADC_SetInjectedOffset
      26  ADC_SoftwareStartConvCmd
      26  ADC_SoftwareStartInjectedConvCmd
      10  ADC_StartCalibration
      26  ADC_StructInit
      34  ADC_TempSensorVrefintCmd

 
 1 328 bytes in section .text
 
 1 328 bytes of CODE memory

Errors: none
Warnings: none

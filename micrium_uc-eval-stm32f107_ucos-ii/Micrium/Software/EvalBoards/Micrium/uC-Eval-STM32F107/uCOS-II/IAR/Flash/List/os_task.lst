###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:22 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_task.c         #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_task.c" -D     #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_task.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_task.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TASK MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TASK.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #include <ucos_ii.h>
     28          #endif
     29          
     30          /*$PAGE*/
     31          /*
     32          *********************************************************************************************************
     33          *                                      CHANGE PRIORITY OF A TASK
     34          *
     35          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     36          *              priority MUST be available.
     37          *
     38          * Arguments  : oldp     is the old priority
     39          *
     40          *              newp     is the new priority
     41          *
     42          * Returns    : OS_ERR_NONE            is the call was successful
     43          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
     44          *                                     (i.e. >= OS_LOWEST_PRIO)
     45          *              OS_ERR_PRIO_EXIST      if the new priority already exist.
     46          *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
     47          *                                     not exist.
     48          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
     49          *********************************************************************************************************
     50          */
     51          
     52          #if OS_TASK_CHANGE_PRIO_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     53          INT8U  OSTaskChangePrio (INT8U  oldprio,
     54                                   INT8U  newprio)
     55          {
   \                     OSTaskChangePrio:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x000C             MOVS     R4,R1
     56          #if (OS_EVENT_EN)
     57              OS_EVENT  *pevent;
     58          #if (OS_EVENT_MULTI_EN > 0u)
     59              OS_EVENT **pevents;
     60          #endif
     61          #endif
     62              OS_TCB    *ptcb;
     63              INT8U      y_new;
     64              INT8U      x_new;
     65              INT8U      y_old;
     66              OS_PRIO    bity_new;
     67              OS_PRIO    bitx_new;
     68              OS_PRIO    bity_old;
     69              OS_PRIO    bitx_old;
     70          #if OS_CRITICAL_METHOD == 3u
     71              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
     72          #endif
     73          
     74          
     75          /*$PAGE*/
     76          #if OS_ARG_CHK_EN > 0u
     77              if (oldprio >= OS_LOWEST_PRIO) {
     78                  if (oldprio != OS_PRIO_SELF) {
     79                      return (OS_ERR_PRIO_INVALID);
     80                  }
     81              }
     82              if (newprio >= OS_LOWEST_PRIO) {
     83                  return (OS_ERR_PRIO_INVALID);
     84              }
     85          #endif
     86              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x4683             MOV      R11,R0
     87              if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000018   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??OSTaskChangePrio_0
     88                  OS_EXIT_CRITICAL();
   \   00000020   0x4658             MOV      R0,R11
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
     89                  return (OS_ERR_PRIO_EXIST);
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0xE109             B.N      ??OSTaskChangePrio_1
     90              }
     91              if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
   \                     ??OSTaskChangePrio_0:
   \   0000002A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD106             BNE.N    ??OSTaskChangePrio_2
     92                  oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000003C   0xF88D 0x0008      STRB     R0,[SP, #+8]
     93              }
     94              ptcb = OSTCBPrioTbl[oldprio];
   \                     ??OSTaskChangePrio_2:
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000048   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000004C   0x0007             MOVS     R7,R0
     95              if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD104             BNE.N    ??OSTaskChangePrio_3
     96                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0x.... 0x....      BL       OS_CPU_SR_Restore
     97                  return (OS_ERR_PRIO);
   \   00000058   0x2029             MOVS     R0,#+41
   \   0000005A   0xE0F0             B.N      ??OSTaskChangePrio_1
     98              }
     99              if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
   \                     ??OSTaskChangePrio_3:
   \   0000005C   0x2F01             CMP      R7,#+1
   \   0000005E   0xD104             BNE.N    ??OSTaskChangePrio_4
    100                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000060   0x4658             MOV      R0,R11
   \   00000062   0x.... 0x....      BL       OS_CPU_SR_Restore
    101                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000066   0x2043             MOVS     R0,#+67
   \   00000068   0xE0E9             B.N      ??OSTaskChangePrio_1
    102              }
    103          #if OS_LOWEST_PRIO <= 63u
    104              y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
   \                     ??OSTaskChangePrio_4:
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x08E0             LSRS     R0,R4,#+3
   \   0000006E   0x4680             MOV      R8,R0
    105              x_new                 = (INT8U)(newprio & 0x07u);
   \   00000070   0xF014 0x0007      ANDS     R0,R4,#0x7
   \   00000074   0xF88D 0x0003      STRB     R0,[SP, #+3]
    106          #else
    107              y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
    108              x_new                 = (INT8U)(newprio & 0x0Fu);
    109          #endif
    110              bity_new              = (OS_PRIO)(1uL << y_new);
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xFA10 0xF008      LSLS     R0,R0,R8
   \   0000007E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    111              bitx_new              = (OS_PRIO)(1uL << x_new);
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000088   0x4088             LSLS     R0,R0,R1
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    112          
    113              OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
   \   0000008E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    114              OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000A2   0xF840 0x7024      STR      R7,[R0, R4, LSL #+2]
    115              y_old                 =  ptcb->OSTCBY;
   \   000000A6   0xF897 0x0038      LDRB     R0,[R7, #+56]
   \   000000AA   0x4681             MOV      R9,R0
    116              bity_old              =  ptcb->OSTCBBitY;
   \   000000AC   0xF897 0x003A      LDRB     R0,[R7, #+58]
   \   000000B0   0xF88D 0x0002      STRB     R0,[SP, #+2]
    117              bitx_old              =  ptcb->OSTCBBitX;
   \   000000B4   0xF897 0x0039      LDRB     R0,[R7, #+57]
   \   000000B8   0x4682             MOV      R10,R0
    118              if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
   \   000000BA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000C2   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000C6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CA   0xEA10 0x0F0A      TST      R0,R10
   \   000000CE   0xD036             BEQ.N    ??OSTaskChangePrio_5
    119                   OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
   \   000000D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000D8   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000DC   0xEA30 0x000A      BICS     R0,R0,R10
   \   000000E0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000E8   0xF809 0x0001      STRB     R0,[R9, R1]
    120                   if (OSRdyTbl[y_old] == 0u) {
   \   000000EC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000F4   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD108             BNE.N    ??OSTaskChangePrio_6
    121                       OSRdyGrp &= (OS_PRIO)~bity_old;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000106   0x4388             BICS     R0,R0,R1
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000010C   0x7008             STRB     R0,[R1, #+0]
    122                   }
    123                   OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
   \                     ??OSTaskChangePrio_6:
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000118   0x4308             ORRS     R0,R1,R0
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
    124                   OSRdyTbl[y_new] |= bitx_new;
   \   00000120   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000128   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000012C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000013A   0xF808 0x0001      STRB     R0,[R8, R1]
    125              }
    126          
    127          #if (OS_EVENT_EN)
    128              pevent = ptcb->OSTCBEventPtr;
   \                     ??OSTaskChangePrio_5:
   \   0000013E   0x69F8             LDR      R0,[R7, #+28]
   \   00000140   0x0005             MOVS     R5,R0
    129              if (pevent != (OS_EVENT *)0) {
   \   00000142   0x2D00             CMP      R5,#+0
   \   00000144   0xD029             BEQ.N    ??OSTaskChangePrio_7
    130                  pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
   \   00000146   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000014A   0xEB19 0x0005      ADDS     R0,R9,R5
   \   0000014E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000150   0xEA30 0x000A      BICS     R0,R0,R10
   \   00000154   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000158   0xEB19 0x0105      ADDS     R1,R9,R5
   \   0000015C   0x72C8             STRB     R0,[R1, #+11]
    131                  if (pevent->OSEventTbl[y_old] == 0u) {
   \   0000015E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000162   0xEB19 0x0005      ADDS     R0,R9,R5
   \   00000166   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD104             BNE.N    ??OSTaskChangePrio_8
    132                      pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
   \   0000016C   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000016E   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000172   0x4388             BICS     R0,R0,R1
   \   00000174   0x72A8             STRB     R0,[R5, #+10]
    133                  }
    134                  pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
   \                     ??OSTaskChangePrio_8:
   \   00000176   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000178   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000017C   0x4308             ORRS     R0,R1,R0
   \   0000017E   0x72A8             STRB     R0,[R5, #+10]
    135                  pevent->OSEventTbl[y_new] |= bitx_new;
   \   00000180   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000184   0xEB18 0x0005      ADDS     R0,R8,R5
   \   00000188   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000018A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000018E   0x4308             ORRS     R0,R1,R0
   \   00000190   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000194   0xEB18 0x0105      ADDS     R1,R8,R5
   \   00000198   0x72C8             STRB     R0,[R1, #+11]
    136              }
    137          #if (OS_EVENT_MULTI_EN > 0u)
    138              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
   \                     ??OSTaskChangePrio_7:
   \   0000019A   0x6A38             LDR      R0,[R7, #+32]
   \   0000019C   0x2800             CMP      R0,#+0
   \   0000019E   0xD033             BEQ.N    ??OSTaskChangePrio_9
    139                  pevents =  ptcb->OSTCBEventMultiPtr;
   \   000001A0   0x6A38             LDR      R0,[R7, #+32]
   \   000001A2   0x0006             MOVS     R6,R0
    140                  pevent  = *pevents;
   \   000001A4   0x6830             LDR      R0,[R6, #+0]
   \   000001A6   0x0005             MOVS     R5,R0
    141                  while (pevent != (OS_EVENT *)0) {
   \                     ??OSTaskChangePrio_10:
   \   000001A8   0x2D00             CMP      R5,#+0
   \   000001AA   0xD02D             BEQ.N    ??OSTaskChangePrio_9
    142                      pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
   \   000001AC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001B0   0xEB19 0x0005      ADDS     R0,R9,R5
   \   000001B4   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001B6   0xEA30 0x000A      BICS     R0,R0,R10
   \   000001BA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001BE   0xEB19 0x0105      ADDS     R1,R9,R5
   \   000001C2   0x72C8             STRB     R0,[R1, #+11]
    143                      if (pevent->OSEventTbl[y_old] == 0u) {
   \   000001C4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C8   0xEB19 0x0005      ADDS     R0,R9,R5
   \   000001CC   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD104             BNE.N    ??OSTaskChangePrio_11
    144                          pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
   \   000001D2   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001D4   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000001D8   0x4388             BICS     R0,R0,R1
   \   000001DA   0x72A8             STRB     R0,[R5, #+10]
    145                      }
    146                      pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
   \                     ??OSTaskChangePrio_11:
   \   000001DC   0x7AA8             LDRB     R0,[R5, #+10]
   \   000001DE   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000001E2   0x4308             ORRS     R0,R1,R0
   \   000001E4   0x72A8             STRB     R0,[R5, #+10]
    147                      pevent->OSEventTbl[y_new] |= bitx_new;
   \   000001E6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001EA   0xEB18 0x0005      ADDS     R0,R8,R5
   \   000001EE   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001F0   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001F4   0x4308             ORRS     R0,R1,R0
   \   000001F6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001FA   0xEB18 0x0105      ADDS     R1,R8,R5
   \   000001FE   0x72C8             STRB     R0,[R1, #+11]
    148                      pevents++;
   \   00000200   0x1D36             ADDS     R6,R6,#+4
    149                      pevent                     = *pevents;
   \   00000202   0x6830             LDR      R0,[R6, #+0]
   \   00000204   0x0005             MOVS     R5,R0
   \   00000206   0xE7CF             B.N      ??OSTaskChangePrio_10
    150                  }
    151              }
    152          #endif
    153          #endif
    154          
    155              ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
   \                     ??OSTaskChangePrio_9:
   \   00000208   0xF887 0x4036      STRB     R4,[R7, #+54]
    156              ptcb->OSTCBY    = y_new;
   \   0000020C   0xF887 0x8038      STRB     R8,[R7, #+56]
    157              ptcb->OSTCBX    = x_new;
   \   00000210   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000214   0xF887 0x0037      STRB     R0,[R7, #+55]
    158              ptcb->OSTCBBitY = bity_new;
   \   00000218   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000021C   0xF887 0x003A      STRB     R0,[R7, #+58]
    159              ptcb->OSTCBBitX = bitx_new;
   \   00000220   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000224   0xF887 0x0039      STRB     R0,[R7, #+57]
    160              OS_EXIT_CRITICAL();
   \   00000228   0x4658             MOV      R0,R11
   \   0000022A   0x.... 0x....      BL       OS_CPU_SR_Restore
    161              if (OSRunning == OS_TRUE) {
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000232   0x7800             LDRB     R0,[R0, #+0]
   \   00000234   0x2801             CMP      R0,#+1
   \   00000236   0xD101             BNE.N    ??OSTaskChangePrio_12
    162                  OS_Sched();                                         /* Find new highest priority task          */
   \   00000238   0x.... 0x....      BL       OS_Sched
    163              }
    164              return (OS_ERR_NONE);
   \                     ??OSTaskChangePrio_12:
   \   0000023C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_1:
   \   0000023E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    165          }
    166          #endif
    167          /*$PAGE*/
    168          /*
    169          *********************************************************************************************************
    170          *                                            CREATE A TASK
    171          *
    172          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    173          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    174          *              created by an ISR.
    175          *
    176          * Arguments  : task     is a pointer to the task's code
    177          *
    178          *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
    179          *                       the task when the task first executes.  Where the task is concerned it thinks
    180          *                       it was invoked and passed the argument 'p_arg' as follows:
    181          *
    182          *                           void Task (void *p_arg)
    183          *                           {
    184          *                               for (;;) {
    185          *                                   Task code;
    186          *                               }
    187          *                           }
    188          *
    189          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
    190          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    191          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
    192          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
    193          *                       lowest memory location of the stack and the stack will grow with increasing
    194          *                       memory locations.
    195          *
    196          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
    197          *                       lower the number, the higher the priority.
    198          *
    199          * Returns    : OS_ERR_NONE                      if the function was successful.
    200          *              OS_ERR_PRIO_EXIST                if the task priority already exist
    201          *                                               (each task MUST have a unique priority).
    202          *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
    203          *                                               allowed (i.e. >= OS_LOWEST_PRIO)
    204          *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
    205          *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
    206          *                                               operation started.
    207          *********************************************************************************************************
    208          */
    209          
    210          #if OS_TASK_CREATE_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    211          INT8U  OSTaskCreate (void   (*task)(void *p_arg),
    212                               void    *p_arg,
    213                               OS_STK  *ptos,
    214                               INT8U    prio)
    215          {
   \                     OSTaskCreate:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    216              OS_STK     *psp;
    217              INT8U       err;
    218          #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
    219              OS_CPU_SR   cpu_sr = 0u;
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
    220          #endif
    221          
    222          
    223          
    224          #ifdef OS_SAFETY_CRITICAL_IEC61508
    225              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    226                  OS_SAFETY_CRITICAL_EXCEPTION();
    227                  return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
    228              }
    229          #endif
    230          
    231          #if OS_ARG_CHK_EN > 0u
    232              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    233                  return (OS_ERR_PRIO_INVALID);
    234              }
    235          #endif
    236              OS_ENTER_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x4682             MOV      R10,R0
    237              if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??OSTaskCreate_0
    238                  OS_EXIT_CRITICAL();
   \   00000022   0x4650             MOV      R0,R10
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Restore
    239                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000028   0x203C             MOVS     R0,#+60
   \   0000002A   0xE044             B.N      ??OSTaskCreate_1
    240              }
    241              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreate_0:
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000032   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD139             BNE.N    ??OSTaskCreate_2
    242                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
    243                                                       /* ... the same thing until task is created.              */
    244                  OS_EXIT_CRITICAL();
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    245                  psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
   \   0000004C   0x2300             MOVS     R3,#+0
   \   0000004E   0x0032             MOVS     R2,R6
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OSTaskStkInit
   \   00000058   0x4680             MOV      R8,R0
    246                  err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x9002             STR      R0,[SP, #+8]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       OS_TCBInit
   \   00000074   0x4681             MOV      R9,R0
    247                  if (err == OS_ERR_NONE) {
   \   00000076   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007E   0xD107             BNE.N    ??OSTaskCreate_3
    248                      if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD10E             BNE.N    ??OSTaskCreate_4
    249                          OS_Sched();
   \   0000008A   0x.... 0x....      BL       OS_Sched
   \   0000008E   0xE00B             B.N      ??OSTaskCreate_4
    250                      }
    251                  } else {
    252                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_3:
   \   00000090   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000094   0x4682             MOV      R10,R0
    253                      OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
   \   00000096   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xF840 0x1027      STR      R1,[R0, R7, LSL #+2]
    254                      OS_EXIT_CRITICAL();
   \   000000A2   0x4650             MOV      R0,R10
   \   000000A4   0x.... 0x....      BL       OS_CPU_SR_Restore
    255                  }
    256                  return (err);
   \                     ??OSTaskCreate_4:
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xE003             B.N      ??OSTaskCreate_1
    257              }
    258              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreate_2:
   \   000000AE   0x4650             MOV      R0,R10
   \   000000B0   0x.... 0x....      BL       OS_CPU_SR_Restore
    259              return (OS_ERR_PRIO_EXIST);
   \   000000B4   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreate_1:
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    260          }
    261          #endif
    262          /*$PAGE*/
    263          /*
    264          *********************************************************************************************************
    265          *                                  CREATE A TASK (Extended Version)
    266          *
    267          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    268          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    269          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
    270          *              additional information about a task to be specified.
    271          *
    272          * Arguments  : task      is a pointer to the task's code
    273          *
    274          *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
    275          *                        the task when the task first executes.  Where the task is concerned it thinks
    276          *                        it was invoked and passed the argument 'p_arg' as follows:
    277          *
    278          *                            void Task (void *p_arg)
    279          *                            {
    280          *                                for (;;) {
    281          *                                    Task code;
    282          *                                }
    283          *                            }
    284          *
    285          *              ptos      is a pointer to the task's top of stack.  If the configuration constant
    286          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    287          *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
    288          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
    289          *                        lowest memory location of the stack and the stack will grow with increasing
    290          *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
    291          *
    292          *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
    293          *                        lower the number, the higher the priority.
    294          *
    295          *              id        is the task's ID (0..65535)
    296          *
    297          *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
    298          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    299          *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
    300          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
    301          *                        HIGHEST memory location of the stack and the stack will grow with increasing
    302          *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
    303          *
    304          *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
    305          *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
    306          *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    307          *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
    308          *                        available on the stack.
    309          *
    310          *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
    311          *                        For example, this user memory can hold the contents of floating-point registers
    312          *                        during a context switch, the time each task takes to execute, the number of times
    313          *                        the task has been switched-in, etc.
    314          *
    315          *              opt       contains additional information (or options) about the behavior of the task.  The
    316          *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
    317          *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
    318          *
    319          *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
    320          *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
    321          *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
    322          *                                                 during a context switch.
    323          *
    324          * Returns    : OS_ERR_NONE                      if the function was successful.
    325          *              OS_ERR_PRIO_EXIST                if the task priority already exist
    326          *                                               (each task MUST have a unique priority).
    327          *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
    328          *                                               allowed (i.e. > OS_LOWEST_PRIO)
    329          *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
    330          *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
    331          *                                               operation started.
    332          *********************************************************************************************************
    333          */
    334          /*$PAGE*/
    335          #if OS_TASK_CREATE_EXT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    336          INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
    337                                  void    *p_arg,
    338                                  OS_STK  *ptos,
    339                                  INT8U    prio,
    340                                  INT16U   id,
    341                                  OS_STK  *pbos,
    342                                  INT32U   stk_size,
    343                                  void    *pext,
    344                                  INT16U   opt)
    345          {
   \                     OSTaskCreateExt:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9C10             LDR      R4,[SP, #+64]
   \   0000000A   0x9F11             LDR      R7,[SP, #+68]
   \   0000000C   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \   00000010   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   \   00000014   0x9D14             LDR      R5,[SP, #+80]
    346              OS_STK     *psp;
    347              INT8U       err;
    348          #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
    349              OS_CPU_SR   cpu_sr = 0u;
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
    350          #endif
    351          
    352          
    353          
    354          #ifdef OS_SAFETY_CRITICAL_IEC61508
    355              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    356                  OS_SAFETY_CRITICAL_EXCEPTION();
    357                  return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
    358              }
    359          #endif
    360          
    361          #if OS_ARG_CHK_EN > 0u
    362              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    363                  return (OS_ERR_PRIO_INVALID);
    364              }
    365          #endif
    366              OS_ENTER_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4683             MOV      R11,R0
    367              if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD004             BEQ.N    ??OSTaskCreateExt_0
    368                  OS_EXIT_CRITICAL();
   \   0000002A   0x4658             MOV      R0,R11
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
    369                  return (OS_ERR_TASK_CREATE_ISR);
   \   00000030   0x203C             MOVS     R0,#+60
   \   00000032   0xE04C             B.N      ??OSTaskCreateExt_1
    370              }
    371              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreateExt_0:
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000003A   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD141             BNE.N    ??OSTaskCreateExt_2
    372                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF840 0x1026      STR      R1,[R0, R6, LSL #+2]
    373                                                       /* ... the same thing until task is created.              */
    374                  OS_EXIT_CRITICAL();
   \   0000004E   0x4658             MOV      R0,R11
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
    375          
    376          #if (OS_TASK_STAT_STK_CHK_EN > 0u)
    377                  OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
   \   00000054   0x002A             MOVS     R2,R5
   \   00000056   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x.... 0x....      BL       OS_TaskStkClr
    378          #endif
    379          
    380                  psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
   \   00000060   0x002B             MOVS     R3,R5
   \   00000062   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000064   0x9A06             LDR      R2,[SP, #+24]
   \   00000066   0x9905             LDR      R1,[SP, #+20]
   \   00000068   0x9804             LDR      R0,[SP, #+16]
   \   0000006A   0x.... 0x....      BL       OSTaskStkInit
   \   0000006E   0x9003             STR      R0,[SP, #+12]
    381                  err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x9502             STR      R5,[SP, #+8]
   \   00000074   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000078   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000007C   0x0023             MOVS     R3,R4
   \   0000007E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000080   0x003A             MOVS     R2,R7
   \   00000082   0x9903             LDR      R1,[SP, #+12]
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x.... 0x....      BL       OS_TCBInit
   \   0000008C   0x4682             MOV      R10,R0
    382                  if (err == OS_ERR_NONE) {
   \   0000008E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000092   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000096   0xD107             BNE.N    ??OSTaskCreateExt_3
    383                      if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD10E             BNE.N    ??OSTaskCreateExt_4
    384                          OS_Sched();
   \   000000A2   0x.... 0x....      BL       OS_Sched
   \   000000A6   0xE00B             B.N      ??OSTaskCreateExt_4
    385                      }
    386                  } else {
    387                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_3:
   \   000000A8   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000AC   0x4683             MOV      R11,R0
    388                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xF840 0x1026      STR      R1,[R0, R6, LSL #+2]
    389                      OS_EXIT_CRITICAL();
   \   000000BA   0x4658             MOV      R0,R11
   \   000000BC   0x.... 0x....      BL       OS_CPU_SR_Restore
    390                  }
    391                  return (err);
   \                     ??OSTaskCreateExt_4:
   \   000000C0   0x4650             MOV      R0,R10
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xE003             B.N      ??OSTaskCreateExt_1
    392              }
    393              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreateExt_2:
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x.... 0x....      BL       OS_CPU_SR_Restore
    394              return (OS_ERR_PRIO_EXIST);
   \   000000CC   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreateExt_1:
   \   000000CE   0xB007             ADD      SP,SP,#+28
   \   000000D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    395          }
    396          #endif
    397          /*$PAGE*/
    398          /*
    399          *********************************************************************************************************
    400          *                                            DELETE A TASK
    401          *
    402          * Description: This function allows you to delete a task.  The calling task can delete itself by
    403          *              its own priority number.  The deleted task is returned to the dormant state and can be
    404          *              re-activated by creating the deleted task again.
    405          *
    406          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
    407          *                      the current task without knowing its priority level by setting 'prio' to
    408          *                      OS_PRIO_SELF.
    409          *
    410          * Returns    : OS_ERR_NONE             if the call is successful
    411          *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
    412          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    413          *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    414          *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
    415          *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
    416          *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
    417          *
    418          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
    419          *                    a) by making it not ready
    420          *                    b) by removing it from any wait lists
    421          *                    c) by preventing OSTimeTick() from making the task ready to run.
    422          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
    423          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
    424          *                 the next instruction following the enable interrupt instruction is ignored.
    425          *              3) An ISR cannot delete a task.
    426          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
    427          *                 task is being deleted, the current task would not be able to be rescheduled because it
    428          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
    429          *                 from being schedule.  This means that an ISR would return to the current task which is
    430          *                 being deleted.  The rest of the deletion would thus be able to be completed.
    431          *********************************************************************************************************
    432          */
    433          
    434          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    435          INT8U  OSTaskDel (INT8U prio)
    436          {
   \                     OSTaskDel:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    437          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    438              OS_FLAG_NODE *pnode;
    439          #endif
    440              OS_TCB       *ptcb;
    441          #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
    442              OS_CPU_SR     cpu_sr = 0u;
   \   00000004   0x2700             MOVS     R7,#+0
    443          #endif
    444          
    445          
    446          
    447              if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??OSTaskDel_0
    448                  return (OS_ERR_TASK_DEL_ISR);
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0xE0B3             B.N      ??OSTaskDel_1
    449              }
    450              if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
   \                     ??OSTaskDel_0:
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C3F             CMP      R4,#+63
   \   00000018   0xD101             BNE.N    ??OSTaskDel_2
    451                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000001A   0x203E             MOVS     R0,#+62
   \   0000001C   0xE0AE             B.N      ??OSTaskDel_1
    452              }
    453          #if OS_ARG_CHK_EN > 0u
    454              if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
    455                  if (prio != OS_PRIO_SELF) {
    456                      return (OS_ERR_PRIO_INVALID);
    457                  }
    458              }
    459          #endif
    460          
    461          /*$PAGE*/
    462              OS_ENTER_CRITICAL();
   \                     ??OSTaskDel_2:
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x0007             MOVS     R7,R0
    463              if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2CFF             CMP      R4,#+255
   \   00000028   0xD105             BNE.N    ??OSTaskDel_3
    464                  prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000034   0x0004             MOVS     R4,R0
    465              }
    466              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskDel_3:
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0006             MOVS     R6,R0
    467              if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD104             BNE.N    ??OSTaskDel_4
    468                  OS_EXIT_CRITICAL();
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    469                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0xE095             B.N      ??OSTaskDel_1
    470              }
    471              if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
   \                     ??OSTaskDel_4:
   \   00000050   0x2E01             CMP      R6,#+1
   \   00000052   0xD104             BNE.N    ??OSTaskDel_5
    472                  OS_EXIT_CRITICAL();
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    473                  return (OS_ERR_TASK_DEL);
   \   0000005A   0x203D             MOVS     R0,#+61
   \   0000005C   0xE08E             B.N      ??OSTaskDel_1
    474              }
    475          
    476              OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
   \                     ??OSTaskDel_5:
   \   0000005E   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000066   0x5C40             LDRB     R0,[R0, R1]
   \   00000068   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \   0000006C   0x4388             BICS     R0,R0,R1
   \   0000006E   0xF896 0x1038      LDRB     R1,[R6, #+56]
   \   00000072   0x.... 0x....      LDR.W    R2,??DataTable14_2
   \   00000076   0x5488             STRB     R0,[R1, R2]
    477              if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
   \   00000078   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000080   0x5C40             LDRB     R0,[R0, R1]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD108             BNE.N    ??OSTaskDel_6
    478                  OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0xF896 0x103A      LDRB     R1,[R6, #+58]
   \   00000090   0x4388             BICS     R0,R0,R1
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000096   0x7008             STRB     R0,[R1, #+0]
    479              }
    480          
    481          #if (OS_EVENT_EN)
    482              if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
   \                     ??OSTaskDel_6:
   \   00000098   0x69F0             LDR      R0,[R6, #+28]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD003             BEQ.N    ??OSTaskDel_7
    483                  OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
   \   0000009E   0x69F1             LDR      R1,[R6, #+28]
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       OS_EventTaskRemove
    484              }
    485          #if (OS_EVENT_MULTI_EN > 0u)
    486              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
   \                     ??OSTaskDel_7:
   \   000000A6   0x6A30             LDR      R0,[R6, #+32]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD003             BEQ.N    ??OSTaskDel_8
    487                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   000000AC   0x6A31             LDR      R1,[R6, #+32]
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    488              }
    489          #endif
    490          #endif
    491          
    492          #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
    493              pnode = ptcb->OSTCBFlagNode;
   \                     ??OSTaskDel_8:
   \   000000B4   0x6AB0             LDR      R0,[R6, #+40]
   \   000000B6   0x0005             MOVS     R5,R0
    494              if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
   \   000000B8   0x2D00             CMP      R5,#+0
   \   000000BA   0xD002             BEQ.N    ??OSTaskDel_9
    495                  OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       OS_FlagUnlink
    496              }
    497          #endif
    498          
    499              ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
   \                     ??OSTaskDel_9:
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x6330             STR      R0,[R6, #+48]
    500              ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF886 0x0034      STRB     R0,[R6, #+52]
    501              ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF886 0x0035      STRB     R0,[R6, #+53]
    502              if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x28FF             CMP      R0,#+255
   \   000000DA   0xD006             BEQ.N    ??OSTaskDel_10
    503                  OSLockNesting++;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
    504              }
    505              OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
   \                     ??OSTaskDel_10:
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x.... 0x....      BL       OS_CPU_SR_Restore
    506              OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
   \   000000F0   0x.... 0x....      BL       OS_Dummy
    507              OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
   \   000000F4   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000F8   0x0007             MOVS     R7,R0
    508              if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD006             BEQ.N    ??OSTaskDel_11
    509                  OSLockNesting--;
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x1E40             SUBS     R0,R0,#+1
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \   00000110   0x7008             STRB     R0,[R1, #+0]
    510              }
    511              OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
   \                     ??OSTaskDel_11:
   \   00000112   0x0030             MOVS     R0,R6
   \   00000114   0x.... 0x....      BL       OSTaskDelHook
    512              OSTaskCtr--;                                        /* One less task being managed                 */
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable14_7
   \   00000124   0x7008             STRB     R0,[R1, #+0]
    513              OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
   \   00000126   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
    514              if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
   \   00000132   0x69B0             LDR      R0,[R6, #+24]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD107             BNE.N    ??OSTaskDel_12
    515                  ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
   \   00000138   0x6970             LDR      R0,[R6, #+20]
   \   0000013A   0x2100             MOVS     R1,#+0
   \   0000013C   0x6181             STR      R1,[R0, #+24]
    516                  OSTCBList                  = ptcb->OSTCBNext;
   \   0000013E   0x6970             LDR      R0,[R6, #+20]
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000144   0x6008             STR      R0,[R1, #+0]
   \   00000146   0xE005             B.N      ??OSTaskDel_13
    517              } else {
    518                  ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
   \                     ??OSTaskDel_12:
   \   00000148   0x69B0             LDR      R0,[R6, #+24]
   \   0000014A   0x6971             LDR      R1,[R6, #+20]
   \   0000014C   0x6141             STR      R1,[R0, #+20]
    519                  ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
   \   0000014E   0x6970             LDR      R0,[R6, #+20]
   \   00000150   0x69B1             LDR      R1,[R6, #+24]
   \   00000152   0x6181             STR      R1,[R0, #+24]
    520              }
    521              ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
   \                     ??OSTaskDel_13:
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x6170             STR      R0,[R6, #+20]
    522              OSTCBFreeList       = ptcb;
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   00000160   0x6006             STR      R6,[R0, #+0]
    523          #if OS_TASK_NAME_EN > 0u
    524              ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
   \   00000162   0x....             ADR.N    R0,??DataTable8  ;; "\?"
   \   00000164   0x6530             STR      R0,[R6, #+80]
    525          #endif
    526              OS_EXIT_CRITICAL();
   \   00000166   0x0038             MOVS     R0,R7
   \   00000168   0x.... 0x....      BL       OS_CPU_SR_Restore
    527              if (OSRunning == OS_TRUE) {
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x2801             CMP      R0,#+1
   \   00000174   0xD101             BNE.N    ??OSTaskDel_14
    528                  OS_Sched();                                     /* Find new highest priority task              */
   \   00000176   0x.... 0x....      BL       OS_Sched
    529              }
    530              return (OS_ERR_NONE);
   \                     ??OSTaskDel_14:
   \   0000017A   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDel_1:
   \   0000017C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    531          }
    532          #endif
    533          /*$PAGE*/
    534          /*
    535          *********************************************************************************************************
    536          *                                  REQUEST THAT A TASK DELETE ITSELF
    537          *
    538          * Description: This function is used to:
    539          *                   a) notify a task to delete itself.
    540          *                   b) to see if a task requested that the current task delete itself.
    541          *              This function is a little tricky to understand.  Basically, you have a task that needs
    542          *              to be deleted however, this task has resources that it has allocated (memory buffers,
    543          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
    544          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
    545          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
    546          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
    547          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
    548          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
    549          *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
    550          *              this:
    551          *
    552          *                   void Task(void *p_arg)
    553          *                   {
    554          *                       .
    555          *                       .
    556          *                       while (1) {
    557          *                           OSTimeDly(1);
    558          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
    559          *                               Release any owned resources;
    560          *                               De-allocate any dynamic memory;
    561          *                               OSTaskDel(OS_PRIO_SELF);
    562          *                           }
    563          *                       }
    564          *                   }
    565          *
    566          * Arguments  : prio    is the priority of the task to request the delete from
    567          *
    568          * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
    569          *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
    570          *                                     the request has been executed.
    571          *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
    572          *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
    573          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    574          *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    575          *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
    576          *                                     deleted.
    577          *********************************************************************************************************
    578          */
    579          /*$PAGE*/
    580          #if OS_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    581          INT8U  OSTaskDelReq (INT8U prio)
    582          {
   \                     OSTaskDelReq:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    583              INT8U      stat;
    584              OS_TCB    *ptcb;
    585          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    586              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    587          #endif
    588          
    589          
    590          
    591              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C3F             CMP      R4,#+63
   \   0000000A   0xD101             BNE.N    ??OSTaskDelReq_0
    592                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000000C   0x203E             MOVS     R0,#+62
   \   0000000E   0xE02F             B.N      ??OSTaskDelReq_1
    593              }
    594          #if OS_ARG_CHK_EN > 0u
    595              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    596                  if (prio != OS_PRIO_SELF) {
    597                      return (OS_ERR_PRIO_INVALID);
    598                  }
    599              }
    600          #endif
    601              if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
   \                     ??OSTaskDelReq_0:
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CFF             CMP      R4,#+255
   \   00000014   0xD10E             BNE.N    ??OSTaskDelReq_2
    602                  OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x0006             MOVS     R6,R0
    603                  stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000026   0x0007             MOVS     R7,R0
    604                  OS_EXIT_CRITICAL();
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
    605                  return (stat);
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE01D             B.N      ??OSTaskDelReq_1
    606              }
    607              OS_ENTER_CRITICAL();
   \                     ??OSTaskDelReq_2:
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000038   0x0006             MOVS     R6,R0
    608              ptcb = OSTCBPrioTbl[prio];
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000040   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000044   0x0005             MOVS     R5,R0
    609              if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD104             BNE.N    ??OSTaskDelReq_3
    610                  OS_EXIT_CRITICAL();
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       OS_CPU_SR_Restore
    611                  return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
   \   00000050   0x2043             MOVS     R0,#+67
   \   00000052   0xE00D             B.N      ??OSTaskDelReq_1
    612              }
    613              if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
   \                     ??OSTaskDelReq_3:
   \   00000054   0x2D01             CMP      R5,#+1
   \   00000056   0xD104             BNE.N    ??OSTaskDelReq_4
    614                  OS_EXIT_CRITICAL();
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0x.... 0x....      BL       OS_CPU_SR_Restore
    615                  return (OS_ERR_TASK_DEL);
   \   0000005E   0x203D             MOVS     R0,#+61
   \   00000060   0xE006             B.N      ??OSTaskDelReq_1
    616              }
    617              ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
   \                     ??OSTaskDelReq_4:
   \   00000062   0x203F             MOVS     R0,#+63
   \   00000064   0xF885 0x003B      STRB     R0,[R5, #+59]
    618              OS_EXIT_CRITICAL();
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0x.... 0x....      BL       OS_CPU_SR_Restore
    619              return (OS_ERR_NONE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDelReq_1:
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    620          }
    621          #endif
    622          /*$PAGE*/
    623          /*
    624          *********************************************************************************************************
    625          *                                       GET THE NAME OF A TASK
    626          *
    627          * Description: This function is called to obtain the name of a task.
    628          *
    629          * Arguments  : prio      is the priority of the task that you want to obtain the name from.
    630          *
    631          *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
    632          *
    633          *              perr      is a pointer to an error code that can contain one of the following values:
    634          *
    635          *                        OS_ERR_NONE                if the requested task is resumed
    636          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    637          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    638          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    639          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    640          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    641          *
    642          *
    643          * Returns    : The length of the string or 0 if the task does not exist.
    644          *********************************************************************************************************
    645          */
    646          
    647          #if OS_TASK_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    648          INT8U  OSTaskNameGet (INT8U    prio,
    649                                INT8U  **pname,
    650                                INT8U   *perr)
    651          {
   \                     OSTaskNameGet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    652              OS_TCB    *ptcb;
    653              INT8U      len;
    654          #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
    655              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
    656          #endif
    657          
    658          
    659          
    660          #ifdef OS_SAFETY_CRITICAL
    661              if (perr == (INT8U *)0) {
    662                  OS_SAFETY_CRITICAL_EXCEPTION();
    663                  return (0u);
    664              }
    665          #endif
    666          
    667          #if OS_ARG_CHK_EN > 0u
    668              if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
    669                  if (prio != OS_PRIO_SELF) {
    670                      *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
    671                      return (0u);
    672                  }
    673              }
    674              if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
    675                  *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
    676                  return (0u);
    677              }
    678          #endif
    679              if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSTaskNameGet_0
    680                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    681                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE030             B.N      ??OSTaskNameGet_1
    682              }
    683              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameGet_0:
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000024   0x4681             MOV      R9,R0
    684              if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2CFF             CMP      R4,#+255
   \   0000002A   0xD105             BNE.N    ??OSTaskNameGet_2
    685                  prio = OSTCBCur->OSTCBPrio;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000036   0x0004             MOVS     R4,R0
    686              }
    687              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameGet_2:
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000003E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000042   0x0007             MOVS     R7,R0
    688              if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD106             BNE.N    ??OSTaskNameGet_3
    689                  OS_EXIT_CRITICAL();                              /* No                                         */
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    690                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000004E   0x2043             MOVS     R0,#+67
   \   00000050   0x7030             STRB     R0,[R6, #+0]
    691                  return (0u);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE015             B.N      ??OSTaskNameGet_1
    692              }
    693              if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
   \                     ??OSTaskNameGet_3:
   \   00000056   0x2F01             CMP      R7,#+1
   \   00000058   0xD106             BNE.N    ??OSTaskNameGet_4
    694                  OS_EXIT_CRITICAL();                              /* Yes                                        */
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x.... 0x....      BL       OS_CPU_SR_Restore
    695                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   00000060   0x2043             MOVS     R0,#+67
   \   00000062   0x7030             STRB     R0,[R6, #+0]
    696                  return (0u);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE00C             B.N      ??OSTaskNameGet_1
    697              }
    698              *pname = ptcb->OSTCBTaskName;
   \                     ??OSTaskNameGet_4:
   \   00000068   0x6D38             LDR      R0,[R7, #+80]
   \   0000006A   0x6028             STR      R0,[R5, #+0]
    699              len    = OS_StrLen(*pname);
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       OS_StrLen
   \   00000072   0x4680             MOV      R8,R0
    700              OS_EXIT_CRITICAL();
   \   00000074   0x4648             MOV      R0,R9
   \   00000076   0x.... 0x....      BL       OS_CPU_SR_Restore
    701              *perr  = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7030             STRB     R0,[R6, #+0]
    702              return (len);
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskNameGet_1:
   \   00000082   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    703          }
    704          #endif
    705          
    706          /*$PAGE*/
    707          /*
    708          *********************************************************************************************************
    709          *                                       ASSIGN A NAME TO A TASK
    710          *
    711          * Description: This function is used to set the name of a task.
    712          *
    713          * Arguments  : prio      is the priority of the task that you want the assign a name to.
    714          *
    715          *              pname     is a pointer to an ASCII string that contains the name of the task.
    716          *
    717          *              perr       is a pointer to an error code that can contain one of the following values:
    718          *
    719          *                        OS_ERR_NONE                if the requested task is resumed
    720          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    721          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    722          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    723          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    724          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    725          *
    726          * Returns    : None
    727          *********************************************************************************************************
    728          */
    729          #if OS_TASK_NAME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    730          void  OSTaskNameSet (INT8U   prio,
    731                               INT8U  *pname,
    732                               INT8U  *perr)
    733          {
   \                     OSTaskNameSet:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    734              OS_TCB    *ptcb;
    735          #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
    736              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    737          #endif
    738          
    739          
    740          
    741          #ifdef OS_SAFETY_CRITICAL
    742              if (perr == (INT8U *)0) {
    743                  OS_SAFETY_CRITICAL_EXCEPTION();
    744                  return;
    745              }
    746          #endif
    747          
    748          #if OS_ARG_CHK_EN > 0u
    749              if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
    750                  if (prio != OS_PRIO_SELF) {
    751                      *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
    752                      return;
    753                  }
    754              }
    755              if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
    756                  *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
    757                  return;
    758              }
    759          #endif
    760              if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??OSTaskNameSet_0
    761                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000018   0x2012             MOVS     R0,#+18
   \   0000001A   0x7030             STRB     R0,[R6, #+0]
    762                  return;
   \   0000001C   0xE027             B.N      ??OSTaskNameSet_1
    763              }
    764              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameSet_0:
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
    765              if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2CFF             CMP      R4,#+255
   \   00000028   0xD105             BNE.N    ??OSTaskNameSet_2
    766                  prio = OSTCBCur->OSTCBPrio;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000034   0x0004             MOVS     R4,R0
    767              }
    768              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameSet_2:
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x0007             MOVS     R7,R0
    769              if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD105             BNE.N    ??OSTaskNameSet_3
    770                  OS_EXIT_CRITICAL();                          /* No                                             */
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    771                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0x7030             STRB     R0,[R6, #+0]
    772                  return;
   \   00000050   0xE00D             B.N      ??OSTaskNameSet_1
    773              }
    774              if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
   \                     ??OSTaskNameSet_3:
   \   00000052   0x2F01             CMP      R7,#+1
   \   00000054   0xD105             BNE.N    ??OSTaskNameSet_4
    775                  OS_EXIT_CRITICAL();                          /* Yes                                            */
   \   00000056   0x4640             MOV      R0,R8
   \   00000058   0x.... 0x....      BL       OS_CPU_SR_Restore
    776                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000005C   0x2043             MOVS     R0,#+67
   \   0000005E   0x7030             STRB     R0,[R6, #+0]
    777                  return;
   \   00000060   0xE005             B.N      ??OSTaskNameSet_1
    778              }
    779              ptcb->OSTCBTaskName = pname;
   \                     ??OSTaskNameSet_4:
   \   00000062   0x653D             STR      R5,[R7, #+80]
    780              OS_EXIT_CRITICAL();
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Restore
    781              *perr               = OS_ERR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x7030             STRB     R0,[R6, #+0]
    782          }
   \                     ??OSTaskNameSet_1:
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    783          #endif
    784          
    785          /*$PAGE*/
    786          /*
    787          *********************************************************************************************************
    788          *                                       RESUME A SUSPENDED TASK
    789          *
    790          * Description: This function is called to resume a previously suspended task.  This is the only call that
    791          *              will remove an explicit task suspension.
    792          *
    793          * Arguments  : prio     is the priority of the task to resume.
    794          *
    795          * Returns    : OS_ERR_NONE                if the requested task is resumed
    796          *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
    797          *                                         (i.e. >= OS_LOWEST_PRIO)
    798          *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
    799          *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
    800          *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
    801          *********************************************************************************************************
    802          */
    803          
    804          #if OS_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    805          INT8U  OSTaskResume (INT8U prio)
    806          {
   \                     OSTaskResume:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    807              OS_TCB    *ptcb;
    808          #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
    809              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    810          #endif
    811          
    812          
    813          
    814          #if OS_ARG_CHK_EN > 0u
    815              if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
    816                  return (OS_ERR_PRIO_INVALID);
    817              }
    818          #endif
    819              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
    820              ptcb = OSTCBPrioTbl[prio];
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x....             LDR.N    R0,??DataTable14
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x0005             MOVS     R5,R0
    821              if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD104             BNE.N    ??OSTaskResume_0
    822                  OS_EXIT_CRITICAL();
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
    823                  return (OS_ERR_TASK_RESUME_PRIO);
   \   00000020   0x2046             MOVS     R0,#+70
   \   00000022   0xE040             B.N      ??OSTaskResume_1
    824              }
    825              if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
   \                     ??OSTaskResume_0:
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD104             BNE.N    ??OSTaskResume_2
    826                  OS_EXIT_CRITICAL();
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
    827                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000002E   0x2043             MOVS     R0,#+67
   \   00000030   0xE039             B.N      ??OSTaskResume_1
    828              }
    829              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
   \                     ??OSTaskResume_2:
   \   00000032   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000036   0x0700             LSLS     R0,R0,#+28
   \   00000038   0xD531             BPL.N    ??OSTaskResume_3
    830                  ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
   \   0000003A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000003E   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000042   0xF885 0x0034      STRB     R0,[R5, #+52]
    831                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
   \   00000046   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD122             BNE.N    ??OSTaskResume_4
    832                      if (ptcb->OSTCBDly == 0u) {
   \   0000004E   0x6B28             LDR      R0,[R5, #+48]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD11B             BNE.N    ??OSTaskResume_5
    833                          OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
   \   00000054   0x....             LDR.N    R0,??DataTable14_3
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF895 0x103A      LDRB     R1,[R5, #+58]
   \   0000005C   0x4308             ORRS     R0,R1,R0
   \   0000005E   0x....             LDR.N    R1,??DataTable14_3
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    834                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000062   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   00000066   0x....             LDR.N    R1,??DataTable14_2
   \   00000068   0x5C40             LDRB     R0,[R0, R1]
   \   0000006A   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0xF895 0x1038      LDRB     R1,[R5, #+56]
   \   00000074   0x....             LDR.N    R2,??DataTable14_2
   \   00000076   0x5488             STRB     R0,[R1, R2]
    835                          OS_EXIT_CRITICAL();
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Restore
    836                          if (OSRunning == OS_TRUE) {
   \   0000007E   0x....             LDR.N    R0,??DataTable14_4
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD109             BNE.N    ??OSTaskResume_6
    837                              OS_Sched();                               /* Find new highest priority task        */
   \   00000086   0x.... 0x....      BL       OS_Sched
   \   0000008A   0xE006             B.N      ??OSTaskResume_6
    838                          }
    839                      } else {
    840                          OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_5:
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000092   0xE002             B.N      ??OSTaskResume_6
    841                      }
    842                  } else {                                              /* Must be pending on event              */
    843                      OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_4:
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x.... 0x....      BL       OS_CPU_SR_Restore
    844                  }
    845                  return (OS_ERR_NONE);
   \                     ??OSTaskResume_6:
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE003             B.N      ??OSTaskResume_1
    846              }
    847              OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_3:
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       OS_CPU_SR_Restore
    848              return (OS_ERR_TASK_NOT_SUSPENDED);
   \   000000A4   0x2044             MOVS     R0,#+68
   \                     ??OSTaskResume_1:
   \   000000A6   0xBD70             POP      {R4-R6,PC}       ;; return
    849          }
    850          #endif
    851          /*$PAGE*/
    852          /*
    853          *********************************************************************************************************
    854          *                                           STACK CHECKING
    855          *
    856          * Description: This function is called to check the amount of free memory left on the specified task's
    857          *              stack.
    858          *
    859          * Arguments  : prio          is the task priority
    860          *
    861          *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
    862          *
    863          * Returns    : OS_ERR_NONE            upon success
    864          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    865          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    866          *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
    867          *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
    868          *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
    869          *********************************************************************************************************
    870          */
    871          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    872          INT8U  OSTaskStkChk (INT8U         prio,
    873                               OS_STK_DATA  *p_stk_data)
    874          {
   \                     OSTaskStkChk:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    875              OS_TCB    *ptcb;
    876              OS_STK    *pchk;
    877              INT32U     nfree;
    878              INT32U     size;
    879          #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
    880              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
    881          #endif
    882          
    883          
    884          
    885          #if OS_ARG_CHK_EN > 0u
    886              if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
    887                  if (prio != OS_PRIO_SELF) {
    888                      return (OS_ERR_PRIO_INVALID);
    889                  }
    890              }
    891              if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
    892                  return (OS_ERR_PDATA_NULL);
    893              }
    894          #endif
    895              p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6028             STR      R0,[R5, #+0]
    896              p_stk_data->OSUsed = 0u;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6068             STR      R0,[R5, #+4]
    897              OS_ENTER_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x4682             MOV      R10,R0
    898              if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2CFF             CMP      R4,#+255
   \   0000001E   0xD104             BNE.N    ??OSTaskStkChk_0
    899                  prio = OSTCBCur->OSTCBPrio;
   \   00000020   0x....             LDR.N    R0,??DataTable14_1
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   00000028   0x0004             MOVS     R4,R0
    900              }
    901              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskStkChk_0:
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x....             LDR.N    R0,??DataTable14
   \   0000002E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000032   0x0006             MOVS     R6,R0
    902              if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD104             BNE.N    ??OSTaskStkChk_1
    903                  OS_EXIT_CRITICAL();
   \   00000038   0x4650             MOV      R0,R10
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    904                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000003E   0x2043             MOVS     R0,#+67
   \   00000040   0xE025             B.N      ??OSTaskStkChk_2
    905              }
    906              if (ptcb == OS_TCB_RESERVED) {
   \                     ??OSTaskStkChk_1:
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xD104             BNE.N    ??OSTaskStkChk_3
    907                  OS_EXIT_CRITICAL();
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    908                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000004C   0x2043             MOVS     R0,#+67
   \   0000004E   0xE01E             B.N      ??OSTaskStkChk_2
    909              }
    910              if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
   \                     ??OSTaskStkChk_3:
   \   00000050   0x7C30             LDRB     R0,[R6, #+16]
   \   00000052   0x07C0             LSLS     R0,R0,#+31
   \   00000054   0xD404             BMI.N    ??OSTaskStkChk_4
    911                  OS_EXIT_CRITICAL();
   \   00000056   0x4650             MOV      R0,R10
   \   00000058   0x.... 0x....      BL       OS_CPU_SR_Restore
    912                  return (OS_ERR_TASK_OPT);
   \   0000005C   0x2045             MOVS     R0,#+69
   \   0000005E   0xE016             B.N      ??OSTaskStkChk_2
    913              }
    914              nfree = 0u;
   \                     ??OSTaskStkChk_4:
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x4680             MOV      R8,R0
    915              size  = ptcb->OSTCBStkSize;
   \   00000064   0x68F0             LDR      R0,[R6, #+12]
   \   00000066   0x4681             MOV      R9,R0
    916              pchk  = ptcb->OSTCBStkBottom;
   \   00000068   0x68B0             LDR      R0,[R6, #+8]
   \   0000006A   0x0007             MOVS     R7,R0
    917              OS_EXIT_CRITICAL();
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    918          #if OS_STK_GROWTH == 1u
    919              while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
   \                     ??OSTaskStkChk_5:
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0x1D07             ADDS     R7,R0,#+4
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD102             BNE.N    ??OSTaskStkChk_6
    920                  nfree++;
   \   0000007C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000080   0xE7F7             B.N      ??OSTaskStkChk_5
    921              }
    922          #else
    923              while (*pchk-- == (OS_STK)0) {
    924                  nfree++;
    925              }
    926          #endif
    927              p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
   \                     ??OSTaskStkChk_6:
   \   00000082   0xF8C5 0x8000      STR      R8,[R5, #+0]
    928              p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
   \   00000086   0xEBB9 0x0008      SUBS     R0,R9,R8
   \   0000008A   0x6068             STR      R0,[R5, #+4]
    929              return (OS_ERR_NONE);
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??OSTaskStkChk_2:
   \   0000008E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    930          }
    931          #endif
    932          /*$PAGE*/
    933          /*
    934          *********************************************************************************************************
    935          *                                           SUSPEND A TASK
    936          *
    937          * Description: This function is called to suspend a task.  The task can be the calling task if the
    938          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
    939          *
    940          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
    941          *                       calling task will suspend itself and rescheduling will occur.
    942          *
    943          * Returns    : OS_ERR_NONE               if the requested task is suspended
    944          *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
    945          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    946          *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    947          *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
    948          *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
    949          *
    950          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
    951          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
    952          *              running when the event arrives.
    953          *********************************************************************************************************
    954          */
    955          
    956          #if OS_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    957          INT8U  OSTaskSuspend (INT8U prio)
    958          {
   \                     OSTaskSuspend:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    959              BOOLEAN    self;
    960              OS_TCB    *ptcb;
    961              INT8U      y;
    962          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
    963              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    964          #endif
    965          
    966          
    967          
    968          #if OS_ARG_CHK_EN > 0u
    969              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
    970                  return (OS_ERR_TASK_SUSPEND_IDLE);
    971              }
    972              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    973                  if (prio != OS_PRIO_SELF) {
    974                      return (OS_ERR_PRIO_INVALID);
    975                  }
    976              }
    977          #endif
    978              OS_ENTER_CRITICAL();
   \   0000000A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000E   0x4680             MOV      R8,R0
    979              if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CFF             CMP      R4,#+255
   \   00000014   0xD107             BNE.N    ??OSTaskSuspend_0
    980                  prio = OSTCBCur->OSTCBPrio;
   \   00000016   0x....             LDR.N    R0,??DataTable14_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001E   0x0004             MOVS     R4,R0
    981                  self = OS_TRUE;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0xE00B             B.N      ??OSTaskSuspend_1
    982              } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
   \                     ??OSTaskSuspend_0:
   \   00000026   0x....             LDR.N    R0,??DataTable14_1
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD102             BNE.N    ??OSTaskSuspend_2
    983                  self = OS_TRUE;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0005             MOVS     R5,R0
   \   00000038   0xE001             B.N      ??OSTaskSuspend_1
    984              } else {
    985                  self = OS_FALSE;                                        /* No suspending another task          */
   \                     ??OSTaskSuspend_2:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0005             MOVS     R5,R0
    986              }
    987              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskSuspend_1:
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x....             LDR.N    R0,??DataTable14
   \   00000042   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000046   0x0006             MOVS     R6,R0
    988              if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD104             BNE.N    ??OSTaskSuspend_3
    989                  OS_EXIT_CRITICAL();
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    990                  return (OS_ERR_TASK_SUSPEND_PRIO);
   \   00000052   0x2048             MOVS     R0,#+72
   \   00000054   0xE02D             B.N      ??OSTaskSuspend_4
    991              }
    992              if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
   \                     ??OSTaskSuspend_3:
   \   00000056   0x2E01             CMP      R6,#+1
   \   00000058   0xD104             BNE.N    ??OSTaskSuspend_5
    993                  OS_EXIT_CRITICAL();
   \   0000005A   0x4640             MOV      R0,R8
   \   0000005C   0x.... 0x....      BL       OS_CPU_SR_Restore
    994                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000060   0x2043             MOVS     R0,#+67
   \   00000062   0xE026             B.N      ??OSTaskSuspend_4
    995              }
    996              y            = ptcb->OSTCBY;
   \                     ??OSTaskSuspend_5:
   \   00000064   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000068   0x0007             MOVS     R7,R0
    997              OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
   \   0000006A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006C   0x....             LDR.N    R0,??DataTable14_2
   \   0000006E   0x5C38             LDRB     R0,[R7, R0]
   \   00000070   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \   00000074   0x4388             BICS     R0,R0,R1
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x....             LDR.N    R1,??DataTable14_2
   \   0000007A   0x5478             STRB     R0,[R7, R1]
    998              if (OSRdyTbl[y] == 0u) {
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0x....             LDR.N    R0,??DataTable14_2
   \   00000080   0x5C38             LDRB     R0,[R7, R0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD106             BNE.N    ??OSTaskSuspend_6
    999                  OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
   \   00000086   0x....             LDR.N    R0,??DataTable14_3
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0xF896 0x103A      LDRB     R1,[R6, #+58]
   \   0000008E   0x4388             BICS     R0,R0,R1
   \   00000090   0x....             LDR.N    R1,??DataTable14_3
   \   00000092   0x7008             STRB     R0,[R1, #+0]
   1000              }
   1001              ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
   \                     ??OSTaskSuspend_6:
   \   00000094   0xF896 0x0034      LDRB     R0,[R6, #+52]
   \   00000098   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000009C   0xF886 0x0034      STRB     R0,[R6, #+52]
   1002              OS_EXIT_CRITICAL();
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
   1003              if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D01             CMP      R5,#+1
   \   000000AA   0xD101             BNE.N    ??OSTaskSuspend_7
   1004                  OS_Sched();                                             /* Find new highest priority task      */
   \   000000AC   0x.... 0x....      BL       OS_Sched
   1005              }
   1006              return (OS_ERR_NONE);
   \                     ??OSTaskSuspend_7:
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??OSTaskSuspend_4:
   \   000000B2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1007          }
   1008          #endif
   1009          /*$PAGE*/
   1010          /*
   1011          *********************************************************************************************************
   1012          *                                            QUERY A TASK
   1013          *
   1014          * Description: This function is called to obtain a copy of the desired task's TCB.
   1015          *
   1016          * Arguments  : prio         is the priority of the task to obtain information from.
   1017          *
   1018          *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
   1019          *
   1020          * Returns    : OS_ERR_NONE            if the requested task is suspended
   1021          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
   1022          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
   1023          *              OS_ERR_PRIO            if the desired task has not been created
   1024          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
   1025          *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
   1026          *********************************************************************************************************
   1027          */
   1028          
   1029          #if OS_TASK_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1030          INT8U  OSTaskQuery (INT8U    prio,
   1031                              OS_TCB  *p_task_data)
   1032          {
   \                     OSTaskQuery:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1033              OS_TCB    *ptcb;
   1034          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1035              OS_CPU_SR  cpu_sr = 0u;
   \   00000006   0x2700             MOVS     R7,#+0
   1036          #endif
   1037          
   1038          
   1039          
   1040          #if OS_ARG_CHK_EN > 0u
   1041              if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
   1042                  if (prio != OS_PRIO_SELF) {
   1043                      return (OS_ERR_PRIO_INVALID);
   1044                  }
   1045              }
   1046              if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
   1047                  return (OS_ERR_PDATA_NULL);
   1048              }
   1049          #endif
   1050              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000C   0x0007             MOVS     R7,R0
   1051              if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2CFF             CMP      R4,#+255
   \   00000012   0xD104             BNE.N    ??OSTaskQuery_0
   1052                  prio = OSTCBCur->OSTCBPrio;
   \   00000014   0x....             LDR.N    R0,??DataTable14_1
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001C   0x0004             MOVS     R4,R0
   1053              }
   1054              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskQuery_0:
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x....             LDR.N    R0,??DataTable14
   \   00000022   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000026   0x0006             MOVS     R6,R0
   1055              if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD104             BNE.N    ??OSTaskQuery_1
   1056                  OS_EXIT_CRITICAL();
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
   1057                  return (OS_ERR_PRIO);
   \   00000032   0x2029             MOVS     R0,#+41
   \   00000034   0xE00F             B.N      ??OSTaskQuery_2
   1058              }
   1059              if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
   \                     ??OSTaskQuery_1:
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD104             BNE.N    ??OSTaskQuery_3
   1060                  OS_EXIT_CRITICAL();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
   1061                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000040   0x2043             MOVS     R0,#+67
   \   00000042   0xE008             B.N      ??OSTaskQuery_2
   1062              }
   1063                                                           /* Copy TCB into user storage area                    */
   1064              OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
   \                     ??OSTaskQuery_3:
   \   00000044   0x2258             MOVS     R2,#+88
   \   00000046   0x0031             MOVS     R1,R6
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_MemCopy
   1065              OS_EXIT_CRITICAL();
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
   1066              return (OS_ERR_NONE);
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??OSTaskQuery_2:
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1067          }
   1068          #endif
   1069          /*$PAGE*/
   1070          /*
   1071          *********************************************************************************************************
   1072          *                              GET THE CURRENT VALUE OF A TASK REGISTER
   1073          *
   1074          * Description: This function is called to obtain the current value of a task register.  Task registers
   1075          *              are application specific and can be used to store task specific values such as 'error
   1076          *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
   1077          *
   1078          * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
   1079          *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
   1080          *
   1081          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
   1082          *                        than OS_TASK_REG_TBL_SIZE
   1083          *
   1084          *              perr      is a pointer to a variable that will hold an error code related to this call.
   1085          *
   1086          *                        OS_ERR_NONE            if the call was successful
   1087          *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
   1088          *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
   1089          *
   1090          * Returns    : The current value of the task's register or 0 if an error is detected.
   1091          *
   1092          * Note(s)    : The maximum number of task variables is 254
   1093          *********************************************************************************************************
   1094          */
   1095          
   1096          #if OS_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1097          INT32U  OSTaskRegGet (INT8U   prio,
   1098                                INT8U   id,
   1099                                INT8U  *perr)
   1100          {
   \                     OSTaskRegGet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1101          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1102              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0x2700             MOVS     R7,#+0
   1103          #endif
   1104              INT32U     value;
   1105              OS_TCB    *ptcb;
   1106          
   1107          
   1108          
   1109          #ifdef OS_SAFETY_CRITICAL
   1110              if (perr == (INT8U *)0) {
   1111                  OS_SAFETY_CRITICAL_EXCEPTION();
   1112                  return (0u);
   1113              }
   1114          #endif
   1115          
   1116          #if OS_ARG_CHK_EN > 0u
   1117              if (prio >= OS_LOWEST_PRIO) {
   1118                  if (prio != OS_PRIO_SELF) {
   1119                      *perr = OS_ERR_PRIO_INVALID;
   1120                      return (0u);
   1121                  }
   1122              }
   1123              if (id >= OS_TASK_REG_TBL_SIZE) {
   1124                  *perr = OS_ERR_ID_INVALID;
   1125                  return (0u);
   1126              }
   1127          #endif
   1128              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x0007             MOVS     R7,R0
   1129              if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2CFF             CMP      R4,#+255
   \   00000016   0xD103             BNE.N    ??OSTaskRegGet_0
   1130                  ptcb = OSTCBCur;
   \   00000018   0x....             LDR.N    R0,??DataTable14_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4681             MOV      R9,R0
   \   0000001E   0xE004             B.N      ??OSTaskRegGet_1
   1131              } else {
   1132                  ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskRegGet_0:
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x....             LDR.N    R0,??DataTable14
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x4681             MOV      R9,R0
   1133              }
   1134              value = ptcb->OSTCBRegTbl[id];
   \                     ??OSTaskRegGet_1:
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0xEB19 0x0085      ADDS     R0,R9,R5, LSL #+2
   \   00000030   0x6D40             LDR      R0,[R0, #+84]
   \   00000032   0x4680             MOV      R8,R0
   1135              OS_EXIT_CRITICAL();
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
   1136              *perr = OS_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
   1137              return (value);
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1138          }
   1139          #endif
   1140          
   1141          /*$PAGE*/
   1142          /*
   1143          ************************************************************************************************************************
   1144          *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
   1145          *
   1146          * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
   1147          *              allocated dynamically instead of statically.
   1148          *
   1149          * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
   1150          *
   1151          *                            OS_ERR_NONE               if the call was successful
   1152          *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
   1153          *                                                           have available through OS_TASK_REG_TBL_SIZE.
   1154          *
   1155          * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
   1156          ************************************************************************************************************************
   1157          */
   1158          
   1159          #if OS_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1160          INT8U  OSTaskRegGetID (INT8U  *perr)
   1161          {
   \                     OSTaskRegGetID:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1162          #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
   1163              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
   1164          #endif
   1165              INT8U      id;
   1166          
   1167          
   1168          #ifdef OS_SAFETY_CRITICAL
   1169              if (perr == (INT8U *)0) {
   1170                  OS_SAFETY_CRITICAL_EXCEPTION();
   1171                  return ((INT8U)OS_TASK_REG_TBL_SIZE);
   1172              }
   1173          #endif
   1174          
   1175              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   1176              if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
   \   0000000C   0x....             LDR.N    R0,??DataTable14_10
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD006             BEQ.N    ??OSTaskRegGetID_0
   1177                 *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
   \   00000014   0x2096             MOVS     R0,#+150
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   1178                  OS_EXIT_CRITICAL();
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
   1179                  return ((INT8U)OS_TASK_REG_TBL_SIZE);
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00E             B.N      ??OSTaskRegGetID_1
   1180              }
   1181               
   1182              id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
   \                     ??OSTaskRegGetID_0:
   \   00000022   0x....             LDR.N    R0,??DataTable14_10
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x0006             MOVS     R6,R0
   1183              OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
   \   00000028   0x....             LDR.N    R0,??DataTable14_10
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable14_10
   \   00000030   0x7008             STRB     R0,[R1, #+0]
   1184              OS_EXIT_CRITICAL();
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Restore
   1185             *perr = OS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   1186              return (id);
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskRegGetID_1:
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   1187          }
   1188          #endif
   1189          
   1190          /*$PAGE*/
   1191          /*
   1192          *********************************************************************************************************
   1193          *                              SET THE CURRENT VALUE OF A TASK VARIABLE
   1194          *
   1195          * Description: This function is called to change the current value of a task register.  Task registers
   1196          *              are application specific and can be used to store task specific values such as 'error
   1197          *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
   1198          *
   1199          * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
   1200          *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
   1201          *
   1202          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
   1203          *                        than OS_TASK_REG_TBL_SIZE
   1204          *
   1205          *              value     is the desired value for the task register.
   1206          *
   1207          *              perr      is a pointer to a variable that will hold an error code related to this call.
   1208          *
   1209          *                        OS_ERR_NONE            if the call was successful
   1210          *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
   1211          *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
   1212          *
   1213          * Returns    : The current value of the task's variable or 0 if an error is detected.
   1214          *
   1215          * Note(s)    : The maximum number of task variables is 254
   1216          *********************************************************************************************************
   1217          */
   1218          
   1219          #if OS_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1220          void  OSTaskRegSet (INT8U    prio,
   1221                              INT8U    id,
   1222                              INT32U   value,
   1223                              INT8U   *perr)
   1224          {
   \                     OSTaskRegSet:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1225          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   1226              OS_CPU_SR  cpu_sr = 0u;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1227          #endif
   1228              OS_TCB    *ptcb;
   1229          
   1230          
   1231          #ifdef OS_SAFETY_CRITICAL
   1232              if (perr == (INT8U *)0) {
   1233                  OS_SAFETY_CRITICAL_EXCEPTION();
   1234                  return;
   1235              }
   1236          #endif
   1237          
   1238          #if OS_ARG_CHK_EN > 0u
   1239              if (prio >= OS_LOWEST_PRIO) {
   1240                  if (prio != OS_PRIO_SELF) {
   1241                      *perr = OS_ERR_PRIO_INVALID;
   1242                      return;
   1243                  }
   1244              }
   1245              if (id >= OS_TASK_REG_TBL_SIZE) {
   1246                  *perr = OS_ERR_ID_INVALID;
   1247                  return;
   1248              }
   1249          #endif
   1250              OS_ENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x4680             MOV      R8,R0
   1251              if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2CFF             CMP      R4,#+255
   \   0000001A   0xD103             BNE.N    ??OSTaskRegSet_0
   1252                  ptcb = OSTCBCur;
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4681             MOV      R9,R0
   \   00000022   0xE004             B.N      ??OSTaskRegSet_1
   1253              } else {
   1254                  ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskRegSet_0:
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x....             LDR.N    R0,??DataTable14
   \   00000028   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002C   0x4681             MOV      R9,R0
   1255              }
   1256              ptcb->OSTCBRegTbl[id] = value;
   \                     ??OSTaskRegSet_1:
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0xEB19 0x0085      ADDS     R0,R9,R5, LSL #+2
   \   00000034   0x6546             STR      R6,[R0, #+84]
   1257              OS_EXIT_CRITICAL();
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
   1258              *perr                 = OS_ERR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7038             STRB     R0,[R7, #+0]
   1259          }
   \   00000040   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1260          #endif
   1261          
   1262          /*$PAGE*/
   1263          /*
   1264          *********************************************************************************************************
   1265          *                                    CATCH ACCIDENTAL TASK RETURN
   1266          *
   1267          * Description: This function is called if a task accidentally returns without deleting itself.  In other
   1268          *              words, a task should either be an infinite loop or delete itself if it's done.
   1269          *
   1270          * Arguments  : none
   1271          *
   1272          * Returns    : none
   1273          *
   1274          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
   1275          *********************************************************************************************************
   1276          */
   1277          

   \                                 In section .text, align 2, keep-with-next
   1278          void  OS_TaskReturn (void)
   1279          {
   \                     OS_TaskReturn:
   \   00000000   0xB580             PUSH     {R7,LR}
   1280              OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
   \   00000002   0x....             LDR.N    R0,??DataTable14_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSTaskReturnHook
   1281          
   1282          #if OS_TASK_DEL_EN > 0u
   1283              (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x.... 0x....      BL       OSTaskDel
   1284          #else
   1285              for (;;) {
   1286                  OSTimeDly(OS_TICKS_PER_SEC);
   1287              }
   1288          #endif
   1289          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
   1290          
   1291          /*$PAGE*/
   1292          /*
   1293          *********************************************************************************************************
   1294          *                                          CLEAR TASK STACK
   1295          *
   1296          * Description: This function is used to clear the stack of a task (i.e. write all zeros)
   1297          *
   1298          * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
   1299          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
   1300          *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
   1301          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
   1302          *                       highest memory location of the stack and the stack will grow with increasing
   1303          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
   1304          *
   1305          *              size     is the number of 'stack elements' to clear.
   1306          *
   1307          *              opt      contains additional information (or options) about the behavior of the task.  The
   1308          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
   1309          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
   1310          *
   1311          * Returns    : none
   1312          *********************************************************************************************************
   1313          */
   1314          #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1315          void  OS_TaskStkClr (OS_STK  *pbos,
   1316                               INT32U   size,
   1317                               INT16U   opt)
   1318          {
   1319              if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
   \                     OS_TaskStkClr:
   \   00000000   0x07D3             LSLS     R3,R2,#+31
   \   00000002   0xD508             BPL.N    ??OS_TaskStkClr_0
   1320                  if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
   \   00000004   0x0793             LSLS     R3,R2,#+30
   \   00000006   0xD506             BPL.N    ??OS_TaskStkClr_0
   1321          #if OS_STK_GROWTH == 1u
   1322                      while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
   \                     ??OS_TaskStkClr_1:
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??OS_TaskStkClr_0
   1323                          size--;
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   1324                          *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x6003             STR      R3,[R0, #+0]
   \   00000012   0x1D00             ADDS     R0,R0,#+4
   \   00000014   0xE7F8             B.N      ??OS_TaskStkClr_1
   1325                      }
   1326          #else
   1327                      while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
   1328                          size--;
   1329                          *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
   1330                      }
   1331          #endif
   1332                  }
   1333              }
   1334          }
   \                     ??OS_TaskStkClr_0:
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     OSTCBFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
   1335          
   1336          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   OSTaskChangePrio
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_Sched
      48   OSTaskCreate
        48   -> OSTaskStkInit
        48   -> OS_CPU_SR_Restore
        48   -> OS_CPU_SR_Save
        48   -> OS_Sched
        48   -> OS_TCBInit
      64   OSTaskCreateExt
        64   -> OSTaskStkInit
        64   -> OS_CPU_SR_Restore
        64   -> OS_CPU_SR_Save
        64   -> OS_Sched
        64   -> OS_TCBInit
        64   -> OS_TaskStkClr
      24   OSTaskDel
        24   -> OSTaskDelHook
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_Dummy
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskRemoveMulti
        24   -> OS_FlagUnlink
        24   -> OS_Sched
      24   OSTaskDelReq
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      32   OSTaskNameGet
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_StrLen
      24   OSTaskNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      24   OSTaskQuery
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_MemCopy
      32   OSTaskRegGet
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      16   OSTaskRegGetID
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      32   OSTaskRegSet
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      16   OSTaskResume
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
      32   OSTaskStkChk
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      24   OSTaskSuspend
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_Sched
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook
       0   OS_TaskStkClr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable8
     578  OSTaskChangePrio
     188  OSTaskCreate
     212  OSTaskCreateExt
     382  OSTaskDel
     114  OSTaskDelReq
     134  OSTaskNameGet
     114  OSTaskNameSet
      88  OSTaskQuery
      68  OSTaskRegGet
      66  OSTaskRegGetID
      68  OSTaskRegSet
     168  OSTaskResume
     146  OSTaskStkChk
     182  OSTaskSuspend
      18  OS_TaskReturn
      24  OS_TaskStkClr

 
     2 bytes in section .rodata
 2 598 bytes in section .text
 
 2 598 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none

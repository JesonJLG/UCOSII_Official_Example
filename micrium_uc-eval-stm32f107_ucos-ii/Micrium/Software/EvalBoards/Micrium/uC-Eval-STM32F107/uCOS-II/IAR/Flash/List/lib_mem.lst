###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:20 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uC-LIB\lib_mem.c                 #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uC-LIB\lib_mem.c" -D             #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\lib_mem.lst                  #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\lib_mem.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                     STANDARD MEMORY OPERATIONS
     26          *
     27          * Filename      : lib_mem.c
     28          * Version       : V1.37.01
     29          * Programmer(s) : ITJ
     30          *                 FGK
     31          *                 JFD
     32          *                 FBJ
     33          *********************************************************************************************************
     34          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     35          *
     36          *                     (a) ALL standard library functions are implemented in the custom library modules :
     37          *
     38          *                         (1) \<Custom Library Directory>\lib_*.*
     39          *
     40          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     41          *
     42          *                               where
     43          *                                       <Custom Library Directory>      directory path for custom library software
     44          *                                       <cpu>                           directory name for specific processor (CPU)
     45          *                                       <compiler>                      directory name for specific compiler
     46          *
     47          *                     (b) Product-specific library functions are implemented in individual products.
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                            INCLUDE FILES
     55          *********************************************************************************************************
     56          */
     57          
     58          #define    MICRIUM_SOURCE
     59          #define    LIB_MEM_MODULE
     60          #include  <lib_mem.h>
     61          
     62          
     63          /*$PAGE*/
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL DEFINES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                           LOCAL CONSTANTS
     74          *********************************************************************************************************
     75          */
     76          
     77          
     78          /*
     79          *********************************************************************************************************
     80          *                                          LOCAL DATA TYPES
     81          *********************************************************************************************************
     82          */
     83          
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                            LOCAL TABLES
     88          *********************************************************************************************************
     89          */
     90          
     91          
     92          /*
     93          *********************************************************************************************************
     94          *                                       LOCAL GLOBAL VARIABLES
     95          *********************************************************************************************************
     96          */
     97          
     98          #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .bss, align 4
     99          MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
   \                     Mem_PoolTbl:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
   \                     Mem_PoolHeap:
   \   00000000                      DS8 72
    101          
    102          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
    103          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
   \                     Mem_Heap:
   \   00000000                      DS8 27648
    104          #endif
    105          #endif
    106          
    107          
    108          /*
    109          *********************************************************************************************************
    110          *                                      LOCAL FUNCTION PROTOTYPES
    111          *********************************************************************************************************
    112          */
    113          
    114          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
    115          
    116          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    117          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL          *pmem_pool,
    118                                                       void              *pmem_blk);
    119          #endif
    120          
    121          
    122          static  CPU_SIZE_T    Mem_SegCalcTotSize    (void              *pmem_addr,
    123                                                       MEM_POOL_BLK_QTY   blk_nbr,
    124                                                       CPU_SIZE_T         blk_size,
    125                                                       CPU_SIZE_T         blk_align);
    126          
    127          static  void         *Mem_SegAlloc          (MEM_POOL          *pmem_pool,
    128                                                       CPU_SIZE_T         size,
    129                                                       CPU_SIZE_T         align);
    130          
    131          #endif
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                     LOCAL CONFIGURATION ERRORS
    137          *********************************************************************************************************
    138          */
    139          
    140          
    141          /*$PAGE*/
    142          /*
    143          *********************************************************************************************************
    144          *                                             Mem_Init()
    145          *
    146          * Description : (1) Initialize Memory Management Module :
    147          *
    148          *                   (a) Initialize heap memory pool
    149          *                   (b) Initialize      memory pool table
    150          *
    151          *
    152          * Argument(s) : none.
    153          *
    154          * Return(s)   : none.
    155          *
    156          * Caller(s)   : Application.
    157          *
    158          * Note(s)     : (2) Mem_Init() MUST be called ... :
    159          *
    160          *                   (a) ONLY ONCE from a product's application; ...
    161          *                   (b) BEFORE product's application calls any memory library module function(s)
    162          *********************************************************************************************************
    163          */
    164          

   \                                 In section .text, align 2, keep-with-next
    165          void  Mem_Init (void)
    166          {
    167          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    168              MEM_POOL  *pmem_pool;
    169          
    170                                                                                  /* --------- INIT MEM HEAP SEG / POOL --------- */
    171              pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
   \                     Mem_Init:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000004   0x0008             MOVS     R0,R1
    172              pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x50414548
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    173              pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000010   0x6041             STR      R1,[R0, #+4]
    174              pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6081             STR      R1,[R0, #+8]
    175              pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    176              pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6101             STR      R1,[R0, #+16]
    177              pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6141             STR      R1,[R0, #+20]
    178              pmem_pool->PoolAddrStart    = (void       *) 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6181             STR      R1,[R0, #+24]
    179              pmem_pool->PoolAddrEnd      = (void       *) 0;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x61C1             STR      R1,[R0, #+28]
    180              pmem_pool->PoolPtrs         = (void      **) 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6201             STR      R1,[R0, #+32]
    181              pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6301             STR      R1,[R0, #+48]
    182              pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x62C1             STR      R1,[R0, #+44]
    183              pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6241             STR      R1,[R0, #+36]
    184          
    185          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    186              pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    187              pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    188          #else
    189              pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000003E   0x6381             STR      R1,[R0, #+56]
    190              pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000044   0x63C1             STR      R1,[R0, #+60]
    191          #endif
    192          
    193              pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
   \   00000046   0xF44F 0x41D8      MOV      R1,#+27648
   \   0000004A   0x6401             STR      R1,[R0, #+64]
    194              pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
   \   0000004C   0xF44F 0x41D8      MOV      R1,#+27648
   \   00000050   0x6441             STR      R1,[R0, #+68]
    195          
    196                                                                                  /* ------------ INIT MEM POOL TBL ------------- */
    197              Mem_PoolTbl = &Mem_PoolHeap;
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable10
   \   0000005A   0x600A             STR      R2,[R1, #+0]
    198          #endif
    199          }
   \   0000005C   0x4770             BX       LR               ;; return
    200          
    201          
    202          /*$PAGE*/
    203          /*
    204          *********************************************************************************************************
    205          *                                              Mem_Clr()
    206          *
    207          * Description : Clear data buffer (see Note #2).
    208          *
    209          * Argument(s) : pmem        Pointer to memory buffer to clear.
    210          *
    211          *               size        Number of data buffer octets to clear (see Note #1).
    212          *
    213          * Return(s)   : none.
    214          *
    215          * Caller(s)   : Application.
    216          *
    217          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    218          *
    219          *                   See also 'Mem_Set()  Note #1'.
    220          *
    221          *               (2) Clear data by setting each data octet to 0.
    222          *********************************************************************************************************
    223          */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void  Mem_Clr (void        *pmem,
    226                         CPU_SIZE_T   size)
    227          {
   \                     Mem_Clr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    228              Mem_Set(pmem,
    229                      0u,                                                 /* See Note #2.                                         */
    230                      size);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Mem_Set
    231          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    232          
    233          
    234          /*$PAGE*/
    235          /*
    236          *********************************************************************************************************
    237          *                                              Mem_Set()
    238          *
    239          * Description : Fill data buffer with specified data octet.
    240          *
    241          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    242          *
    243          *               data_val    Data fill octet value.
    244          *
    245          *               size        Number of data buffer octets to fill (see Note #1).
    246          *
    247          * Return(s)   : none.
    248          *
    249          * Caller(s)   : Application.
    250          *
    251          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    252          *
    253          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    254          *                   words.
    255          *
    256          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    257          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    258          *                       addresses.
    259          *
    260          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    261          *                   address boundary.
    262          *
    263          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    264          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    265          *                  'mem_align_mod' arithmetic operation.
    266          *********************************************************************************************************
    267          */
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void  Mem_Set (void        *pmem,
    270                         CPU_INT08U   data_val,
    271                         CPU_SIZE_T   size)
    272          {
   \                     Mem_Set:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    273              CPU_SIZE_T   size_rem;
    274              CPU_ALIGN    data_align;
    275              CPU_ALIGN   *pmem_align;
    276              CPU_INT08U  *pmem_08;
    277              CPU_DATA     mem_align_mod;
    278              CPU_DATA     i;
    279          
    280          
    281          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    282              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD037             BEQ.N    ??Mem_Set_0
    283                  return;
    284              }
    285              if (pmem == (void *)0) {
   \                     ??Mem_Set_1:
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD035             BEQ.N    ??Mem_Set_0
    286                  return;
    287              }
    288          #endif
    289          
    290          
    291              data_align = 0u;
   \                     ??Mem_Set_2:
   \   0000000C   0xF05F 0x0E00      MOVS     LR,#+0
   \   00000010   0x4674             MOV      R4,LR
    292              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   00000012   0xF05F 0x0E00      MOVS     LR,#+0
   \   00000016   0x46F4             MOV      R12,LR
   \                     ??Mem_Set_3:
   \   00000018   0xF1BC 0x0F04      CMP      R12,#+4
   \   0000001C   0xD205             BCS.N    ??Mem_Set_4
    293                  data_align <<=  DEF_OCTET_NBR_BITS;
   \   0000001E   0x0224             LSLS     R4,R4,#+8
    294                  data_align  |= (CPU_ALIGN)data_val;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x430C             ORRS     R4,R1,R4
    295              }
   \   00000024   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   00000028   0xE7F6             B.N      ??Mem_Set_3
    296          
    297              size_rem      =  size;
   \                     ??Mem_Set_4:
   \   0000002A   0x0013             MOVS     R3,R2
    298              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   0000002C   0xF05F 0x0E04      MOVS     LR,#+4
   \   00000030   0xFBB0 0xF8FE      UDIV     R8,R0,LR
   \   00000034   0xFB08 0x081E      MLS      R8,R8,LR,R0
   \   00000038   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003C   0x4647             MOV      R7,R8
    299          
    300              pmem_08 = (CPU_INT08U *)pmem;
   \   0000003E   0x0006             MOVS     R6,R0
    301              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD00B             BEQ.N    ??Mem_Set_5
    302                  i = mem_align_mod;
   \   00000044   0x46BC             MOV      R12,R7
    303                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    304                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Set_6:
   \   00000046   0x2B00             CMP      R3,#+0
   \   00000048   0xD008             BEQ.N    ??Mem_Set_5
   \   0000004A   0xF1BC 0x0F04      CMP      R12,#+4
   \   0000004E   0xD205             BCS.N    ??Mem_Set_5
    305                     *pmem_08++ = data_val;
   \   00000050   0x7031             STRB     R1,[R6, #+0]
   \   00000052   0x1C76             ADDS     R6,R6,#+1
    306                      size_rem -= sizeof(CPU_INT08U);
   \   00000054   0x1E5B             SUBS     R3,R3,#+1
    307                      i++;
   \   00000056   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   0000005A   0xE7F4             B.N      ??Mem_Set_6
    308                  }
    309              }
    310          
    311              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
   \                     ??Mem_Set_5:
   \   0000005C   0x0035             MOVS     R5,R6
    312              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
   \                     ??Mem_Set_7:
   \   0000005E   0x2B04             CMP      R3,#+4
   \   00000060   0xD303             BCC.N    ??Mem_Set_8
    313                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \   00000062   0x602C             STR      R4,[R5, #+0]
   \   00000064   0x1D2D             ADDS     R5,R5,#+4
    314                  size_rem    -= sizeof(CPU_ALIGN);
   \   00000066   0x1F1B             SUBS     R3,R3,#+4
   \   00000068   0xE7F9             B.N      ??Mem_Set_7
    315              }
    316          
    317              pmem_08 = (CPU_INT08U *)pmem_align;
   \                     ??Mem_Set_8:
   \   0000006A   0x002E             MOVS     R6,R5
    318              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
   \                     ??Mem_Set_9:
   \   0000006C   0x2B00             CMP      R3,#+0
   \   0000006E   0xD003             BEQ.N    ??Mem_Set_10
    319                 *pmem_08++   = data_val;
   \   00000070   0x7031             STRB     R1,[R6, #+0]
   \   00000072   0x1C76             ADDS     R6,R6,#+1
    320                  size_rem   -= sizeof(CPU_INT08U);
   \   00000074   0x1E5B             SUBS     R3,R3,#+1
   \   00000076   0xE7F9             B.N      ??Mem_Set_9
    321              }
    322          }
   \                     ??Mem_Set_10:
   \                     ??Mem_Set_0:
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    323          
    324          
    325          /*$PAGE*/
    326          /*
    327          *********************************************************************************************************
    328          *                                             Mem_Copy()
    329          *
    330          * Description : Copy data octets from one memory buffer to another memory buffer.
    331          *
    332          * Argument(s) : pdest       Pointer to destination memory buffer.
    333          *
    334          *               psrc        Pointer to source      memory buffer.
    335          *
    336          *               size        Number of octets to copy (see Note #1).
    337          *
    338          * Return(s)   : none.
    339          *
    340          * Caller(s)   : Application.
    341          *
    342          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    343          *
    344          *               (2) Memory buffers NOT checked for overlapping.
    345          *
    346          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    347          *                       copying takes place between objects that overlap, the behavior is undefined".
    348          *
    349          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    350          *                       successfully copy to a destination memory buffer at a lower  address value even
    351          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    352          *                       word copy overlaps.
    353          *
    354          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    355          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    356          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    357          *                       ever overlap.
    358          *
    359          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    360          *                       buffers as long as the source memory buffer is at a higher address value than the
    361          *                       destination memory buffer.
    362          *
    363          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    364          *                   words.
    365          *
    366          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    367          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    368          *                       addresses.
    369          *
    370          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    371          *                   address boundary.
    372          *
    373          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    374          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    375          *                  'mem_align_mod' arithmetic operation.
    376          *********************************************************************************************************
    377          */
    378          /*$PAGE*/
    379          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    380          void  Mem_Copy (       void        *pdest,
    381                          const  void        *psrc,
    382                                 CPU_SIZE_T   size)
    383          {
    384                     CPU_SIZE_T    size_rem;
    385                     CPU_SIZE_T    mem_gap_octets;
    386                     CPU_ALIGN    *pmem_align_dest;
    387              const  CPU_ALIGN    *pmem_align_src;
    388                     CPU_INT08U   *pmem_08_dest;
    389              const  CPU_INT08U   *pmem_08_src;
    390                     CPU_DATA      i;
    391                     CPU_DATA      mem_align_mod_dest;
    392                     CPU_DATA      mem_align_mod_src;
    393                     CPU_BOOLEAN   mem_aligned;
    394          
    395          
    396          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    397              if (size < 1) {                                             /* See Note #1.                                         */
    398                  return;
    399              }
    400              if (pdest == (void *)0) {
    401                  return;
    402              }
    403              if (psrc  == (void *)0) {
    404                  return;
    405              }
    406          #endif
    407          
    408          
    409              size_rem           =  size;
    410          
    411              pmem_08_dest       = (      CPU_INT08U *)pdest;
    412              pmem_08_src        = (const CPU_INT08U *)psrc;
    413          
    414              mem_gap_octets     = pmem_08_src - pmem_08_dest;
    415          
    416          
    417              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
    418                                                                          /* See Note #4.                                         */
    419                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    420                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    421          
    422                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    423          
    424                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
    425                                                                          /* ... optimize copy for mem buf alignment.             */
    426                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
    427                          i = mem_align_mod_dest;
    428                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    429                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    430                             *pmem_08_dest++ = *pmem_08_src++;
    431                              size_rem      -=  sizeof(CPU_INT08U);
    432                              i++;
    433                          }
    434                      }
    435          
    436                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3a.                                        */
    437                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    438                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    439                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    440                          size_rem         -=  sizeof(CPU_ALIGN);
    441                      }
    442          
    443                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    444                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    445                  }
    446              }
    447          
    448              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    449                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    450                  size_rem      -=  sizeof(CPU_INT08U);
    451              }
    452          }
    453          #endif
    454          
    455          
    456          /*
    457          *********************************************************************************************************
    458          *                                             Mem_Move()
    459          *
    460          * Description : Move data octets from one memory buffer to another memory buffer, or within the same
    461          *               memory buffer. Overlapping is correctly handled for all move operations.
    462          *
    463          * Argument(s) : pdest       Pointer to destination memory buffer.
    464          *
    465          *               psrc        Pointer to source      memory buffer.
    466          *
    467          *               size        Number of octets to move (see Note #1).
    468          *
    469          * Return(s)   : none.
    470          *
    471          * Caller(s)   : Application.
    472          *
    473          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    474          *
    475          *               (2) Memory buffers checked for overlapping.
    476          *
    477          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    478          *                   words.
    479          *
    480          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    481          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    482          *                       addresses.
    483          *
    484          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    485          *                   address boundary.
    486          *
    487          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    488          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    489          *                  'mem_align_mod' arithmetic operation.
    490          *********************************************************************************************************
    491          */
    492          /*$PAGE*/
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  Mem_Move (       void        *pdest,
    495                          const  void        *psrc,
    496                                 CPU_SIZE_T   size)
    497          {
   \                     Mem_Move:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    498                     CPU_SIZE_T    size_rem;
    499                     CPU_SIZE_T    mem_gap_octets;
    500                     CPU_ALIGN    *pmem_align_dest;
    501              const  CPU_ALIGN    *pmem_align_src;
    502                     CPU_INT08U   *pmem_08_dest;
    503              const  CPU_INT08U   *pmem_08_src;
    504                     CPU_INT08S    i;
    505                     CPU_DATA      mem_align_mod_dest;
    506                     CPU_DATA      mem_align_mod_src;
    507                     CPU_BOOLEAN   mem_aligned;
    508          
    509          
    510          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    511              if (size < 1) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD072             BEQ.N    ??Mem_Move_0
    512                  return;
    513              }
    514              if (pdest == (void *)0) {
   \                     ??Mem_Move_1:
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD06F             BEQ.N    ??Mem_Move_0
    515                  return;
    516              }
    517              if (psrc  == (void *)0) {
   \                     ??Mem_Move_2:
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD06D             BEQ.N    ??Mem_Move_0
    518                  return;
    519              }
    520          #endif
    521          
    522              pmem_08_src  = (const CPU_INT08U *)psrc;
   \                     ??Mem_Move_3:
   \   00000018   0x46A2             MOV      R10,R4
    523              pmem_08_dest = (      CPU_INT08U *)pdest;
   \   0000001A   0x9804             LDR      R0,[SP, #+16]
   \   0000001C   0x4681             MOV      R9,R0
    524              if (pmem_08_src > pmem_08_dest) {
   \   0000001E   0x45D1             CMP      R9,R10
   \   00000020   0xD205             BCS.N    ??Mem_Move_4
    525                  Mem_Copy(pdest, psrc, size);
   \   00000022   0x002A             MOVS     R2,R5
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x9804             LDR      R0,[SP, #+16]
   \   00000028   0x.... 0x....      BL       Mem_Copy
    526                  return;
   \   0000002C   0xE062             B.N      ??Mem_Move_0
    527              }
    528          
    529              size_rem           =  size;
   \                     ??Mem_Move_4:
   \   0000002E   0x002E             MOVS     R6,R5
    530          
    531              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \   00000030   0x9804             LDR      R0,[SP, #+16]
   \   00000032   0x1828             ADDS     R0,R5,R0
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x4681             MOV      R9,R0
    532              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \   00000038   0x1928             ADDS     R0,R5,R4
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x4682             MOV      R10,R0
    533              
    534              mem_gap_octets     = pmem_08_dest - pmem_08_src;
   \   0000003E   0xEBB9 0x000A      SUBS     R0,R9,R10
   \   00000042   0x9003             STR      R0,[SP, #+12]
    535              
    536          
    537              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000044   0x9803             LDR      R0,[SP, #+12]
   \   00000046   0x2804             CMP      R0,#+4
   \   00000048   0xD348             BCC.N    ??Mem_Move_5
    538              
    539                                                                          /* See Note #4.                                         */
    540                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   00000050   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x9100             STR      R1,[SP, #+0]
    541                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0xFBBA 0xF1F0      UDIV     R1,R10,R0
   \   0000005E   0xFB01 0xA110      MLS      R1,R1,R0,R10
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x9102             STR      R1,[SP, #+8]
    542          
    543                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x9902             LDR      R1,[SP, #+8]
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD101             BNE.N    ??Mem_Move_6
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE000             B.N      ??Mem_Move_7
   \                     ??Mem_Move_6:
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??Mem_Move_7:
   \   00000074   0xF88D 0x0004      STRB     R0,[SP, #+4]
    544          
    545                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \   00000078   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD12D             BNE.N    ??Mem_Move_5
    546                                                                          /* ... optimize copy for mem buf alignment.             */
    547                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD014             BEQ.N    ??Mem_Move_8
    548                          i = mem_align_mod_dest;
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x4683             MOV      R11,R0
    549                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    550                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Move_9:
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD010             BEQ.N    ??Mem_Move_8
   \   0000008E   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   00000092   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000096   0xD40B             BMI.N    ??Mem_Move_8
    551                             *pmem_08_dest-- = *pmem_08_src--;
   \   00000098   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000009C   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000A0   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000A4   0xF1B9 0x0901      SUBS     R9,R9,#+1
    552                              size_rem      -=  sizeof(CPU_INT08U);
   \   000000A8   0x1E76             SUBS     R6,R6,#+1
    553                              i--;
   \   000000AA   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   000000AE   0xE7EC             B.N      ??Mem_Move_9
    554                          }
    555                      }
    556          
    557                                                                          /* See Note #3a.                                        */
    558                      pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
   \                     ??Mem_Move_8:
   \   000000B0   0xF1B9 0x0003      SUBS     R0,R9,#+3
   \   000000B4   0x0007             MOVS     R7,R0
    559                      pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
   \   000000B6   0xF1BA 0x0003      SUBS     R0,R10,#+3
   \   000000BA   0x4680             MOV      R8,R0
    560                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
   \                     ??Mem_Move_10:
   \   000000BC   0x2E04             CMP      R6,#+4
   \   000000BE   0xD307             BCC.N    ??Mem_Move_11
    561                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \   000000C0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C4   0x6038             STR      R0,[R7, #+0]
   \   000000C6   0xF1B8 0x0804      SUBS     R8,R8,#+4
   \   000000CA   0x1F3F             SUBS     R7,R7,#+4
    562                          size_rem         -=  sizeof(CPU_ALIGN);
   \   000000CC   0x1F36             SUBS     R6,R6,#+4
   \   000000CE   0xE7F5             B.N      ??Mem_Move_10
    563                      }
    564          
    565                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \                     ??Mem_Move_11:
   \   000000D0   0xF207 0x0003      ADDW     R0,R7,#+3
   \   000000D4   0x4681             MOV      R9,R0
    566                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \   000000D6   0xF208 0x0003      ADDW     R0,R8,#+3
   \   000000DA   0x4682             MOV      R10,R0
    567          
    568                  }
    569              }
    570          
    571              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
   \                     ??Mem_Move_5:
   \   000000DC   0x2E00             CMP      R6,#+0
   \   000000DE   0xD009             BEQ.N    ??Mem_Move_12
    572                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \   000000E0   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000E4   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000E8   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000EC   0xF1B9 0x0901      SUBS     R9,R9,#+1
    573                  size_rem      -=  sizeof(CPU_INT08U);
   \   000000F0   0x1E76             SUBS     R6,R6,#+1
   \   000000F2   0xE7F3             B.N      ??Mem_Move_5
    574              }
    575          }
   \                     ??Mem_Move_12:
   \                     ??Mem_Move_0:
   \   000000F4   0xB005             ADD      SP,SP,#+20
   \   000000F6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    576          
    577          
    578          /*$PAGE*/
    579          /*
    580          *********************************************************************************************************
    581          *                                              Mem_Cmp()
    582          *
    583          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    584          *
    585          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    586          *
    587          *               p2_mem      Pointer to second memory buffer.
    588          *
    589          *               size        Number of data buffer octets to compare (see Note #1).
    590          *
    591          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    592          *
    593          *               DEF_NO,  otherwise.
    594          *
    595          * Caller(s)   : Application.
    596          *
    597          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    598          *                   identical null compare.
    599          *
    600          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    601          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    602          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    603          *                   on dissimilar memory buffers that vary only in the least significant octets.
    604          *
    605          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    606          *                   data words.
    607          *
    608          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    609          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    610          *                       addresses.
    611          *
    612          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    613          *                   address boundary.
    614          *
    615          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    616          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    617          *                  'mem_align_mod' arithmetic operation.
    618          *********************************************************************************************************
    619          */
    620          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    621          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    622                                const  void        *p2_mem,
    623                                       CPU_SIZE_T   size)
    624          {
   \                     Mem_Cmp:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0003             MOVS     R3,R0
    625                     CPU_SIZE_T    size_rem;
    626                     CPU_ALIGN    *p1_mem_align;
    627                     CPU_ALIGN    *p2_mem_align;
    628              const  CPU_INT08U   *p1_mem_08;
    629              const  CPU_INT08U   *p2_mem_08;
    630                     CPU_DATA      i;
    631                     CPU_DATA      mem_align_mod_1;
    632                     CPU_DATA      mem_align_mod_2;
    633                     CPU_BOOLEAN   mem_aligned;
    634                     CPU_BOOLEAN   mem_cmp;
    635          
    636          
    637              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??Mem_Cmp_0
    638                  return (DEF_YES);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE077             B.N      ??Mem_Cmp_1
    639              }
    640              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0:
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD101             BNE.N    ??Mem_Cmp_2
    641                  return (DEF_NO);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE073             B.N      ??Mem_Cmp_1
    642              }
    643              if (p2_mem == (void *)0) {
   \                     ??Mem_Cmp_2:
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD101             BNE.N    ??Mem_Cmp_3
    644                  return (DEF_NO);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06F             B.N      ??Mem_Cmp_1
    645              }
    646          
    647          
    648              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_3:
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x4683             MOV      R11,R0
    649              size_rem        =  size;
   \   00000022   0x0014             MOVS     R4,R2
    650                                                                          /* Start @ end of mem bufs (see Note #2).               */
    651              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   00000024   0x18D0             ADDS     R0,R2,R3
   \   00000026   0x0007             MOVS     R7,R0
    652              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   00000028   0x1850             ADDS     R0,R2,R1
   \   0000002A   0x4686             MOV      LR,R0
    653                                                                          /* See Note #4.                                         */
    654              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xFBB7 0xFCF0      UDIV     R12,R7,R0
   \   00000032   0xFB0C 0x7C10      MLS      R12,R12,R0,R7
   \   00000036   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000003A   0x46E1             MOV      R9,R12
    655              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \   0000003C   0xF05F 0x0C04      MOVS     R12,#+4
   \   00000040   0xFBBE 0xF0FC      UDIV     R0,LR,R12
   \   00000044   0xFB00 0xE01C      MLS      R0,R0,R12,LR
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    656          
    657              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x4581             CMP      R9,R0
   \   00000050   0xD102             BNE.N    ??Mem_Cmp_4
   \   00000052   0xF05F 0x0A01      MOVS     R10,#+1
   \   00000056   0xE001             B.N      ??Mem_Cmp_5
   \                     ??Mem_Cmp_4:
   \   00000058   0xF05F 0x0A00      MOVS     R10,#+0
    658          
    659              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Cmp_5:
   \   0000005C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000060   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000064   0xD136             BNE.N    ??Mem_Cmp_6
    660                                                                          /* ... optimize cmp for mem buf alignment.              */
    661                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   00000066   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006A   0xD018             BEQ.N    ??Mem_Cmp_7
    662                      i = mem_align_mod_1;
   \   0000006C   0x46C8             MOV      R8,R9
    663                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    664                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    665                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Cmp_8:
   \   0000006E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000072   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000076   0xD112             BNE.N    ??Mem_Cmp_7
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD010             BEQ.N    ??Mem_Cmp_7
   \   0000007C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000080   0xD00D             BEQ.N    ??Mem_Cmp_7
    666                          p1_mem_08--;
   \   00000082   0x1E7F             SUBS     R7,R7,#+1
    667                          p2_mem_08--;
   \   00000084   0xF1BE 0x0E01      SUBS     LR,LR,#+1
    668                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000088   0x7838             LDRB     R0,[R7, #+0]
   \   0000008A   0xF89E 0xC000      LDRB     R12,[LR, #+0]
   \   0000008E   0x4560             CMP      R0,R12
   \   00000090   0xD001             BEQ.N    ??Mem_Cmp_9
    669                               mem_cmp = DEF_NO;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x4683             MOV      R11,R0
    670                          }
    671                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_9:
   \   00000096   0x1E64             SUBS     R4,R4,#+1
    672                          i--;
   \   00000098   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000009C   0xE7E7             B.N      ??Mem_Cmp_8
    673                      }
    674                  }
    675          
    676                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
   \                     ??Mem_Cmp_7:
   \   0000009E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A2   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000A6   0xD115             BNE.N    ??Mem_Cmp_6
    677                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
   \   000000A8   0x003D             MOVS     R5,R7
    678                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \   000000AA   0x4676             MOV      R6,LR
    679          
    680                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    681                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
   \                     ??Mem_Cmp_10:
   \   000000AC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B0   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000B4   0xD10C             BNE.N    ??Mem_Cmp_11
   \   000000B6   0x2C04             CMP      R4,#+4
   \   000000B8   0xD30A             BCC.N    ??Mem_Cmp_11
    682                          p1_mem_align--;
   \   000000BA   0x1F2D             SUBS     R5,R5,#+4
    683                          p2_mem_align--;
   \   000000BC   0x1F36             SUBS     R6,R6,#+4
    684                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF8D6 0xC000      LDR      R12,[R6, #+0]
   \   000000C4   0x4560             CMP      R0,R12
   \   000000C6   0xD001             BEQ.N    ??Mem_Cmp_12
    685                               mem_cmp = DEF_NO;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x4683             MOV      R11,R0
    686                          }
    687                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_12:
   \   000000CC   0x1F24             SUBS     R4,R4,#+4
   \   000000CE   0xE7ED             B.N      ??Mem_Cmp_10
    688                      }
    689          
    690                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
   \                     ??Mem_Cmp_11:
   \   000000D0   0x002F             MOVS     R7,R5
    691                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \   000000D2   0x46B6             MOV      LR,R6
    692                  }
    693              }
    694          
    695              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    696                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
   \                     ??Mem_Cmp_6:
   \   000000D4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D8   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000DC   0xD10D             BNE.N    ??Mem_Cmp_13
   \   000000DE   0x2C00             CMP      R4,#+0
   \   000000E0   0xD00B             BEQ.N    ??Mem_Cmp_13
    697                  p1_mem_08--;
   \   000000E2   0x1E7F             SUBS     R7,R7,#+1
    698                  p2_mem_08--;
   \   000000E4   0xF1BE 0x0E01      SUBS     LR,LR,#+1
    699                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   000000E8   0x7838             LDRB     R0,[R7, #+0]
   \   000000EA   0xF89E 0xC000      LDRB     R12,[LR, #+0]
   \   000000EE   0x4560             CMP      R0,R12
   \   000000F0   0xD001             BEQ.N    ??Mem_Cmp_14
    700                       mem_cmp = DEF_NO;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x4683             MOV      R11,R0
    701                  }
    702                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_14:
   \   000000F6   0x1E64             SUBS     R4,R4,#+1
   \   000000F8   0xE7EC             B.N      ??Mem_Cmp_6
    703              }
    704          
    705              return (mem_cmp);
   \                     ??Mem_Cmp_13:
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Mem_Cmp_1:
   \   000000FE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    706          }
    707          
    708          
    709          /*$PAGE*/
    710          /*
    711          *********************************************************************************************************
    712          *                                           Mem_HeapAlloc()
    713          *
    714          * Description : Allocate a memory block from the heap memory pool.
    715          *
    716          * Argument(s) : size            Size      of memory block to allocate (in octets).
    717          *
    718          *               align           Alignment of memory block to specific word boundary (in octets).
    719          *
    720          *               poctets_reqd    Optional pointer to a variable to ... :
    721          *
    722          *                                   (a) Return the number of octets required to successfully
    723          *                                           allocate the memory block, if any error(s);
    724          *                                   (b) Return 0, otherwise.
    725          *
    726          *               perr        Pointer to variable that will receive the return error code from this function :
    727          *
    728          *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
    729          *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
    730          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    731          *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available
    732          *                                                                   memory from heap.
    733          *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
    734          *
    735          * Return(s)   : Pointer to memory block, if NO error(s).
    736          *
    737          *               Pointer to NULL,         otherwise.
    738          *
    739          * Caller(s)   : Application.
    740          *
    741          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    742          *                   validation or function handling in case of any error(s).
    743          *
    744          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    745          *********************************************************************************************************
    746          */
    747          /*$PAGE*/
    748          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    749          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    750                                CPU_SIZE_T   align,
    751                                CPU_SIZE_T  *poctets_reqd,
    752                                LIB_ERR     *perr)
    753          {
   \                     Mem_HeapAlloc:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    754              MEM_POOL    *pmem_pool_heap;
    755              void        *pmem_addr;
    756              void        *pmem_blk;
    757              CPU_SIZE_T   octets_reqd_unused;
    758              CPU_SIZE_T   size_rem;
    759              CPU_SIZE_T   size_req;
    760              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    761          
    762          
    763          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    764              if (perr == (LIB_ERR *)0) {
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD101             BNE.N    ??Mem_HeapAlloc_0
    765                  CPU_SW_EXCEPTION((void *)0);
   \   00000014   0x.... 0x....      BL       CPU_SW_Exception
    766              }
    767          #endif
    768          
    769                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    770              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   \                     ??Mem_HeapAlloc_0:
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD102             BNE.N    ??Mem_HeapAlloc_1
    771                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x0006             MOVS     R6,R0
    772                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   \   00000020   0xA801             ADD      R0,SP,#+4
    773              }
    774             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
   \                     ??Mem_HeapAlloc_1:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6030             STR      R0,[R6, #+0]
    775          
    776          
    777          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    778              if (size < 1) {
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD104             BNE.N    ??Mem_HeapAlloc_2
    779                 *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
   \   0000002A   0xF242 0x7074      MOVW     R0,#+10100
   \   0000002E   0x8038             STRH     R0,[R7, #+0]
    780                  return ((void *)0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE04E             B.N      ??Mem_HeapAlloc_3
    781              }
    782          
    783              if (align < 1) {
   \                     ??Mem_HeapAlloc_2:
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD104             BNE.N    ??Mem_HeapAlloc_4
    784                 *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   00000038   0xF242 0x7075      MOVW     R0,#+10101
   \   0000003C   0x8038             STRH     R0,[R7, #+0]
    785                  return ((void *)0);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE047             B.N      ??Mem_HeapAlloc_3
    786              }
    787          #endif
    788          
    789                                                                              /* -------------- ALLOC HEAP MEM BLK -------------- */
    790              pmem_pool_heap = &Mem_PoolHeap;
   \                     ??Mem_HeapAlloc_4:
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000046   0x4680             MOV      R8,R0
    791          
    792              CPU_CRITICAL_ENTER();
   \   00000048   0x.... 0x....      BL       CPU_SR_Save
   \   0000004C   0x4683             MOV      R11,R0
    793          
    794              pmem_addr = pmem_pool_heap->SegAddrNextAvail;
   \   0000004E   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   00000052   0x9002             STR      R0,[SP, #+8]
    795              size_rem  = pmem_pool_heap->SegSizeRem;
   \   00000054   0xF8D8 0x0044      LDR      R0,[R8, #+68]
   \   00000058   0x9000             STR      R0,[SP, #+0]
    796              size_req  = Mem_SegCalcTotSize(pmem_addr,
    797                                             1u,                              /* Calc alloc for single mem blk from heap.         */
    798                                             size,
    799                                             align);
   \   0000005A   0x002B             MOVS     R3,R5
   \   0000005C   0x0022             MOVS     R2,R4
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x9802             LDR      R0,[SP, #+8]
   \   00000062   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   00000066   0x4682             MOV      R10,R0
    800          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    801              if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
   \   00000068   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000006C   0xD108             BNE.N    ??Mem_HeapAlloc_5
    802                  CPU_CRITICAL_EXIT();
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
    803                 *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
   \   00000074   0x6034             STR      R4,[R6, #+0]
    804                 *perr         = LIB_MEM_ERR_HEAP_OVF;
   \   00000076   0xF242 0x70E3      MOVW     R0,#+10211
   \   0000007A   0x8038             STRH     R0,[R7, #+0]
    805                  return ((void *)0);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE028             B.N      ??Mem_HeapAlloc_3
    806              }
    807          #endif
    808          
    809              if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
   \                     ??Mem_HeapAlloc_5:
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x4550             CMP      R0,R10
   \   00000084   0xD20B             BCS.N    ??Mem_HeapAlloc_6
    810                  CPU_CRITICAL_EXIT();
   \   00000086   0x4658             MOV      R0,R11
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    811                 *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   00000092   0x6030             STR      R0,[R6, #+0]
    812                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \   00000094   0xF242 0x70E2      MOVW     R0,#+10210
   \   00000098   0x8038             STRH     R0,[R7, #+0]
    813                  return ((void *)0);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE019             B.N      ??Mem_HeapAlloc_3
    814              }
    815          
    816              pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
   \                     ??Mem_HeapAlloc_6:
   \   0000009E   0x002A             MOVS     R2,R5
   \   000000A0   0x0021             MOVS     R1,R4
   \   000000A2   0x4640             MOV      R0,R8
   \   000000A4   0x.... 0x....      BL       Mem_SegAlloc
   \   000000A8   0x4681             MOV      R9,R0
    817              if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
   \   000000AA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AE   0xD109             BNE.N    ??Mem_HeapAlloc_7
    818                  CPU_CRITICAL_EXIT();
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
    819                 *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
   \   000000B6   0xF8C6 0xA000      STR      R10,[R6, #+0]
    820                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \   000000BA   0xF242 0x70E2      MOVW     R0,#+10210
   \   000000BE   0x8038             STRH     R0,[R7, #+0]
    821                  return ((void *)0);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE006             B.N      ??Mem_HeapAlloc_3
    822              }
    823          
    824              CPU_CRITICAL_EXIT();
   \                     ??Mem_HeapAlloc_7:
   \   000000C4   0x4658             MOV      R0,R11
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
    825          
    826             *perr =  LIB_MEM_ERR_NONE;
   \   000000CA   0xF242 0x7010      MOVW     R0,#+10000
   \   000000CE   0x8038             STRH     R0,[R7, #+0]
    827          
    828              return (pmem_blk);
   \   000000D0   0x4648             MOV      R0,R9
   \                     ??Mem_HeapAlloc_3:
   \   000000D2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    829          }
    830          #endif
    831          
    832          
    833          /*$PAGE*/
    834          /*
    835          *********************************************************************************************************
    836          *                                        Mem_HeapGetSizeRem()
    837          *
    838          * Description : Get remaining heap memory size available to allocate.
    839          *
    840          * Argument(s) : align       Desired word boundary alignment (in octets) to return remaining memory size from.
    841          *
    842          *               perr        Pointer to variable that will receive the return error code from this function :
    843          *
    844          *                                                               ---- RETURNED BY Mem_PoolGetSizeRem() : ----
    845          *                               LIB_MEM_ERR_NONE                Heap memory pool remaining size successfully
    846          *                                                                   returned.
    847          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    848          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    849          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    850          *
    851          * Return(s)   : Remaining heap memory size (in octets), if NO error(s).
    852          *
    853          *               0,                                      otherwise.
    854          *
    855          * Caller(s)   : Application.
    856          *
    857          * Note(s)     : none.
    858          *********************************************************************************************************
    859          */
    860          
    861          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    862          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    863                                          LIB_ERR     *perr)
    864          {
   \                     Mem_HeapGetSizeRem:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    865              CPU_SIZE_T  size_rem;
    866          
    867          
    868              size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000000E   0x.... 0x....      BL       Mem_SegGetSizeRem
   \   00000012   0x0006             MOVS     R6,R0
    869          
    870              return (size_rem);
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    871          }
    872          #endif
    873          
    874          
    875          /*$PAGE*/
    876          /*
    877          *********************************************************************************************************
    878          *                                         Mem_SegGetSizeRem()
    879          *
    880          * Description : Get memory pool's remaining segment size available to allocate.
    881          *
    882          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
    883          *
    884          *               align       Desired word boundary alignment (in octets) to return remaining memory size from.
    885          *
    886          *               perr        Pointer to variable that will receive the return error code from this function :
    887          *
    888          *                               LIB_MEM_ERR_NONE                Memory segment remaining size successfully
    889          *                                                                   returned.
    890          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    891          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    892          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    893          *
    894          * Return(s)   : Remaining memory segment size (in octets) [see Note #1], if NO error(s).
    895          *
    896          *               0,                                                       otherwise.
    897          *
    898          * Caller(s)   : Application.
    899          *
    900          * Note(s)     : (1) Remaining size of memory segment returned from either :
    901          *
    902          *                   (a) Segment's configured dedicated memory, if any
    903          *                   (b) Heap memory pool,                      otherwise
    904          *
    905          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    906          *********************************************************************************************************
    907          */
    908          /*$PAGE*/
    909          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    910          CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
    911                                         CPU_SIZE_T   align,
    912                                         LIB_ERR     *perr)
    913          {
   \                     Mem_SegGetSizeRem:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    914              MEM_POOL    *pmem_seg;
    915              MEM_POOL    *pmem_seg_size;
    916              CPU_SIZE_T   size_rem;
    917              CPU_SIZE_T   size_rem_mod;
    918              CPU_SIZE_T   seg_addr_mod;
    919              CPU_ADDR     seg_addr;
    920              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
    921          
    922          
    923          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    924                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
    925              if (perr == (LIB_ERR *)0) {
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??Mem_SegGetSizeRem_0
    926                  CPU_SW_EXCEPTION(0u);
   \   00000014   0x.... 0x....      BL       CPU_SW_Exception
    927              }
    928                                                                          /* ---------------- VALIDATE MEM ALIGN ---------------- */
    929              if (align < 1) {
   \                     ??Mem_SegGetSizeRem_0:
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD104             BNE.N    ??Mem_SegGetSizeRem_1
    930                 *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   0000001C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000020   0x8030             STRH     R0,[R6, #+0]
    931                  return (0u);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE04D             B.N      ??Mem_SegGetSizeRem_2
    932              }
    933          	if (align > DEF_ALIGN_MAX_NBR_OCTETS) {
   \                     ??Mem_SegGetSizeRem_1:
   \   00000026   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000002A   0xD904             BLS.N    ??Mem_SegGetSizeRem_3
    934          	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \   0000002C   0xF242 0x7075      MOVW     R0,#+10101
   \   00000030   0x8030             STRH     R0,[R6, #+0]
    935                  return (0u);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE045             B.N      ??Mem_SegGetSizeRem_2
    936              }
    937                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
    938              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   \                     ??Mem_SegGetSizeRem_3:
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD104             BNE.N    ??Mem_SegGetSizeRem_4
    939                 *perr =  LIB_MEM_ERR_NULL_PTR;
   \   0000003A   0xF242 0x7011      MOVW     R0,#+10001
   \   0000003E   0x8030             STRH     R0,[R6, #+0]
    940                  return (0u);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE03E             B.N      ??Mem_SegGetSizeRem_2
    941              }
    942          #endif
    943          
    944              CPU_CRITICAL_ENTER();
   \                     ??Mem_SegGetSizeRem_4:
   \   00000044   0x.... 0x....      BL       CPU_SR_Save
   \   00000048   0x4682             MOV      R10,R0
    945          
    946          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    947              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD003             BEQ.N    ??Mem_SegGetSizeRem_5
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x50414548
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD106             BNE.N    ??Mem_SegGetSizeRem_6
    948                  case LIB_MEM_TYPE_HEAP:
    949                  case LIB_MEM_TYPE_POOL:
    950                       break;
    951          
    952          
    953                  case LIB_MEM_TYPE_NONE:
    954                  default:
    955                       CPU_CRITICAL_EXIT();
    956                      *perr =  LIB_MEM_ERR_INVALID_POOL;
    957                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    958              }
    959          #endif
    960          
    961                                                                          /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    962              pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
   \                     ??Mem_SegGetSizeRem_5:
   \   0000005C   0x6860             LDR      R0,[R4, #+4]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
    963              pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
    964                            ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x6B80             LDR      R0,[R0, #+56]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD00B             BEQ.N    ??Mem_SegGetSizeRem_7
   \   00000068   0xE007             B.N      ??Mem_SegGetSizeRem_8
   \                     ??Mem_SegGetSizeRem_6:
   \   0000006A   0x4650             MOV      R0,R10
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000070   0xF242 0x7088      MOVW     R0,#+10120
   \   00000074   0x8030             STRH     R0,[R6, #+0]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE023             B.N      ??Mem_SegGetSizeRem_2
   \                     ??Mem_SegGetSizeRem_8:
   \   0000007A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \   0000007E   0xE001             B.N      ??Mem_SegGetSizeRem_9
   \                     ??Mem_SegGetSizeRem_7:
   \   00000080   0x.... 0x....      LDR.W    R11,??DataTable10
    965              size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
   \                     ??Mem_SegGetSizeRem_9:
   \   00000084   0xF8DB 0x0044      LDR      R0,[R11, #+68]
   \   00000088   0x0007             MOVS     R7,R0
    966              seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
   \   0000008A   0xF8DB 0x003C      LDR      R0,[R11, #+60]
   \   0000008E   0x9001             STR      R0,[SP, #+4]
    967          
    968              CPU_CRITICAL_EXIT();
   \   00000090   0x4650             MOV      R0,R10
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    969          
    970              if (align > 1) {                                            /* If align > 1 octet, ...                              */
   \   00000096   0x2D02             CMP      R5,#+2
   \   00000098   0xD30F             BCC.N    ??Mem_SegGetSizeRem_10
    971                  seg_addr_mod  =  seg_addr % align;
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0xFBB0 0xF1F5      UDIV     R1,R0,R5
   \   000000A0   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   000000A4   0x4681             MOV      R9,R0
    972                  size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
   \   000000A6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AA   0xD002             BEQ.N    ??Mem_SegGetSizeRem_11
   \   000000AC   0xEBB5 0x0809      SUBS     R8,R5,R9
   \   000000B0   0xE001             B.N      ??Mem_SegGetSizeRem_12
   \                     ??Mem_SegGetSizeRem_11:
   \   000000B2   0xF05F 0x0800      MOVS     R8,#+0
    973                  size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
   \                     ??Mem_SegGetSizeRem_12:
   \   000000B6   0xEBB7 0x0708      SUBS     R7,R7,R8
    974              }
    975          
    976          
    977             *perr =  LIB_MEM_ERR_NONE;
   \                     ??Mem_SegGetSizeRem_10:
   \   000000BA   0xF242 0x7010      MOVW     R0,#+10000
   \   000000BE   0x8030             STRH     R0,[R6, #+0]
    978          
    979              return (size_rem);
   \   000000C0   0x0038             MOVS     R0,R7
   \                     ??Mem_SegGetSizeRem_2:
   \   000000C2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    980          }
    981          #endif
    982          
    983          
    984          /*$PAGE*/
    985          /*
    986          *********************************************************************************************************
    987          *                                            Mem_PoolClr()
    988          *
    989          * Description : Clear a memory pool (see Note #1).
    990          *
    991          * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
    992          *
    993          *               perr        Pointer to variable that will receive the return error code from this function :
    994          *
    995          *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
    996          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    997          *
    998          * Return(s)   : none.
    999          *
   1000          * Caller(s)   : Application,
   1001          *               Mem_PoolCreate().
   1002          *
   1003          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1004          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1005          *
   1006          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1007          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1008          *                       this will likely corrupt the memory pool management.
   1009          *
   1010          *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1011          *********************************************************************************************************
   1012          */
   1013          
   1014          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1015          void  Mem_PoolClr (MEM_POOL  *pmem_pool,
   1016                             LIB_ERR   *perr)
   1017          {
   \                     Mem_PoolClr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1018          
   1019          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1020              if (perr == (LIB_ERR *)0) {
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE.N    ??Mem_PoolClr_0
   1021                  CPU_SW_EXCEPTION(;);
   \   0000000A   0x.... 0x....      BL       CPU_SW_Exception
   1022              }
   1023          #endif
   1024          
   1025                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1026              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolClr_0:
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE.N    ??Mem_PoolClr_1
   1027                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   00000012   0xF242 0x7011      MOVW     R0,#+10001
   \   00000016   0x8028             STRH     R0,[R5, #+0]
   1028                  return;
   \   00000018   0xE027             B.N      ??Mem_PoolClr_2
   1029              }
   1030          
   1031          
   1032              pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
   \                     ??Mem_PoolClr_1:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_5  ;; 0x454e4f4e
   \   0000001E   0x6020             STR      R0,[R4, #+0]
   1033              pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6060             STR      R0,[R4, #+4]
   1034              pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x60A0             STR      R0,[R4, #+8]
   1035              pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x60E0             STR      R0,[R4, #+12]
   1036              pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1037              pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6160             STR      R0,[R4, #+20]
   1038              pmem_pool->PoolAddrStart    = (void       *)0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x61A0             STR      R0,[R4, #+24]
   1039              pmem_pool->PoolAddrEnd      = (void       *)0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x61E0             STR      R0,[R4, #+28]
   1040              pmem_pool->PoolPtrs         = (void      **)0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6220             STR      R0,[R4, #+32]
   1041              pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x62A0             STR      R0,[R4, #+40]
   1042              pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6360             STR      R0,[R4, #+52]
   1043              pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6320             STR      R0,[R4, #+48]
   1044              pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x62E0             STR      R0,[R4, #+44]
   1045              pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6260             STR      R0,[R4, #+36]
   1046              pmem_pool->SegAddr          = (void       *)0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   1047              pmem_pool->SegAddrNextAvail = (void       *)0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x63E0             STR      R0,[R4, #+60]
   1048              pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6420             STR      R0,[R4, #+64]
   1049              pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6460             STR      R0,[R4, #+68]
   1050          
   1051          
   1052             *perr = LIB_MEM_ERR_NONE;
   \   00000064   0xF242 0x7010      MOVW     R0,#+10000
   \   00000068   0x8028             STRH     R0,[R5, #+0]
   1053          }
   \                     ??Mem_PoolClr_2:
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1054          #endif
   1055          
   1056          
   1057          /*$PAGE*/
   1058          /*
   1059          *********************************************************************************************************
   1060          *                                          Mem_PoolCreate()
   1061          *
   1062          * Description : (1) Create a memory pool :
   1063          *
   1064          *                   (a) Create    memory pool from heap or dedicated memory
   1065          *                   (b) Allocate  memory pool memory blocks
   1066          *                   (c) Update    memory pool table
   1067          *                   (d) Configure memory pool
   1068          *
   1069          *
   1070          *               (2) Memory pools are indexed by the Memory Segments they use.
   1071          *
   1072          *                   (a) The memory pool table is composed by a two-dimensional list :
   1073          *
   1074          *                       (1) Memory segments manage the following memory segment/pool information :
   1075          *
   1076          *                           (A) Memory segment base           address
   1077          *                           (B) Memory segment next available address
   1078          *                           (C) Memory segment total     size
   1079          *                           (D) Memory segment remaining size
   1080          *
   1081          *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
   1082          *                           segment information.  To access the memory segment information, the head
   1083          *                           memory segment must be accessed via each memory pool's 'SegHeadPtr'.
   1084          *
   1085          *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
   1086          *                       memory segment for the memory blocks they have.  The heads of the memory pool are
   1087          *                       linked horizontally to form a memory pool table.
   1088          *
   1089          *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
   1090          *
   1091          *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
   1092          *                           form the list of memory segments.
   1093          *
   1094          *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
   1095          *                           each memory segment.
   1096          *
   1097          *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
   1098          *                       Segments Primary List.  The point of insertion is such to keep ascended order by
   1099          *                       memory segment base address.
   1100          *
   1101          *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
   1102          *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
   1103          *
   1104          *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
   1105          *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
   1106          *                           memory pool.
   1107          *
   1108          *
   1109          *                                        |                                                                 |
   1110          *                                        |<----------------------- Memory Segments ----------------------->|
   1111          *                                        |                         (see Note #2a1)                         |
   1112          *
   1113          *                                 Lowest Memory Segment                                      Highest Memory Segment
   1114          *                                     Base Address                                                Base Address
   1115          *                                    (see Note #2c)                                              (see Note #2c)
   1116          *
   1117          *                                           |             SegNextPtr             Heap Memory Pool       |
   1118          *                                           |          (see Note #2b2)            (see Note #2d)        |
   1119          *                                           |                     |                                     |
   1120          *                                           v                     |                      |              v
   1121          *                                                                 |                      v
   1122          *        ---          Head of Memory     -------        -------   v    -------        -------        -------
   1123          *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
   1124          *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
   1125          *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
   1126          *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
   1127          *         |                              |     |        |     |   |    |     |        |  P  |        |     |
   1128          *         |                              |     |        |     |   |    |     |        |     |        |     |
   1129          *         |                              -------        -------   |    -------        -------        -------
   1130          *         |                                | ^                    |      | ^
   1131          *         |                                | |            SegPrevPtr     | |
   1132          *         |                                v |         (see Note #2b2)   v |
   1133          *         |                              -------                       -------
   1134          *                                        |     |                       |     |
   1135          *    Memory Pools                        |     |                       |     |
   1136          *  (see Note #2a2)                       |     |                       |     |
   1137          *                                        |     |                       |     |
   1138          *         |                              |     |                       |     |
   1139          *         |                              -------                       -------
   1140          *         |                                | ^
   1141          *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
   1142          *         |             (see Note #2b3)    v |    (see Note #2b3)
   1143          *         |                              -------
   1144          *         |                              |     |
   1145          *         |                              |     |
   1146          *         |                              |     |
   1147          *         |                              |     |
   1148          *         v                              |     |
   1149          *        ---                             -------
   1150          *
   1151          *$PAGE*
   1152          * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
   1153          *
   1154          *               pmem_base_addr      Memory pool base address :
   1155          *
   1156          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1157          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1158          *                                                                   specified by its base address.
   1159          *
   1160          *               mem_size            Size      of memory pool segment          (in octets).
   1161          *
   1162          *               blk_nbr             Number    of memory pool blocks to create.
   1163          *
   1164          *               blk_size            Size      of memory pool blocks to create (in octets).
   1165          *
   1166          *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
   1167          *
   1168          *               poctets_reqd        Optional pointer to a variable to ... :
   1169          *
   1170          *                                       (a) Return the number of octets required to successfully
   1171          *                                               allocate the memory pool, if any error(s);
   1172          *                                       (b) Return 0, otherwise.
   1173          *
   1174          *               perr        Pointer to variable that will receive the return error code from this function :
   1175          *
   1176          *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
   1177          *
   1178          *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
   1179          *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available
   1180          *                                                                       memory from heap.
   1181          *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
   1182          *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available
   1183          *                                                                       memory from segment for memory pools.
   1184          *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
   1185          *
   1186          *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
   1187          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
   1188          *                                                                       segment(s) in memory pool table.
   1189          *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
   1190          *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
   1191          *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
   1192          *
   1193          *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
   1194          *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
   1195          *
   1196          * Return(s)   : none.
   1197          *
   1198          * Caller(s)   : Application.
   1199          *
   1200          * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1201          *
   1202          *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other
   1203          *                   validation or function handling in case of any error(s).
   1204          *
   1205          *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1206          *********************************************************************************************************
   1207          */
   1208          /*$PAGE*/
   1209          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1210          void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
   1211                                void              *pmem_base_addr,
   1212                                CPU_SIZE_T         mem_size,
   1213                                MEM_POOL_BLK_QTY   blk_nbr,
   1214                                CPU_SIZE_T         blk_size,
   1215                                CPU_SIZE_T         blk_align,
   1216                                CPU_SIZE_T        *poctets_reqd,
   1217                                LIB_ERR           *perr)
   1218          {
   \                     Mem_PoolCreate:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB092             SUB      SP,SP,#+72
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x9D20             LDR      R5,[SP, #+128]
   \   0000000A   0x9E21             LDR      R6,[SP, #+132]
   1219              MEM_POOL           *pmem_pool_heap;
   1220              MEM_POOL           *pmem_pool_next;
   1221              MEM_POOL           *pmem_seg;
   1222              MEM_POOL           *pmem_seg_prev;
   1223              MEM_POOL           *pmem_seg_next;
   1224              void              **ppool_ptr;
   1225              void               *pmem_blk;
   1226              CPU_INT08U         *pmem_addr_ptrs;
   1227              CPU_INT08U         *pmem_addr_pool;
   1228              CPU_INT08U         *pmem_base_addr_start;
   1229              CPU_INT08U         *pmem_base_addr_end;
   1230              CPU_INT08U         *pmem_seg_addr_start;
   1231              CPU_INT08U         *pmem_seg_addr_end;
   1232              MEM_POOL_BLK_QTY    blk_rem;
   1233              CPU_SIZE_T          octets_reqd_unused;
   1234              CPU_SIZE_T          size_tot;
   1235              CPU_SIZE_T          size_tot_ptrs;
   1236              CPU_SIZE_T          size_tot_pool;
   1237              CPU_SIZE_T          size_rem;
   1238              CPU_SIZE_T          size_pool_ptrs;
   1239              CPU_SIZE_T          i;
   1240              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   1241          
   1242          
   1243          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1244              if (perr == (LIB_ERR *)0) {
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD101             BNE.N    ??Mem_PoolCreate_0
   1245                  CPU_SW_EXCEPTION(;);
   \   00000014   0x.... 0x....      BL       CPU_SW_Exception
   1246              }
   1247          #endif
   1248          
   1249                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
   1250              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   \                     ??Mem_PoolCreate_0:
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD102             BNE.N    ??Mem_PoolCreate_1
   1251                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   \   0000001C   0xA80F             ADD      R0,SP,#+60
   \   0000001E   0x0005             MOVS     R5,R0
   1252                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   \   00000020   0xA80F             ADD      R0,SP,#+60
   1253              }
   1254             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
   \                     ??Mem_PoolCreate_1:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6028             STR      R0,[R5, #+0]
   1255          
   1256          
   1257          
   1258              Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
   \   00000026   0x0031             MOVS     R1,R6
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       Mem_PoolClr
   1259              if (*perr != LIB_MEM_ERR_NONE) {
   \   0000002E   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000032   0xF242 0x7110      MOVW     R1,#+10000
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xF040 0x81D5      BNE.W    ??Mem_PoolCreate_2
   1260                   return;
   1261              }
   1262          
   1263          
   1264                                                                              /* ----------- VALIDATE MEM POOL CREATE ----------- */
   1265          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1266              if (pmem_base_addr != (void *)0) {
   \                     ??Mem_PoolCreate_3:
   \   0000003C   0x9812             LDR      R0,[SP, #+72]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD006             BEQ.N    ??Mem_PoolCreate_4
   1267                  if (mem_size < 1) {
   \   00000042   0x9813             LDR      R0,[SP, #+76]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD103             BNE.N    ??Mem_PoolCreate_4
   1268                     *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
   \   00000048   0xF242 0x707E      MOVW     R0,#+10110
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
   1269                      return;
   \   0000004E   0xE1CA             B.N      ??Mem_PoolCreate_2
   1270                  }
   1271              }
   1272          
   1273              if (blk_nbr < 1) {
   \                     ??Mem_PoolCreate_4:
   \   00000050   0x9814             LDR      R0,[SP, #+80]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD103             BNE.N    ??Mem_PoolCreate_5
   1274                 *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
   \   00000056   0xF242 0x7092      MOVW     R0,#+10130
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   1275                  return;
   \   0000005C   0xE1C3             B.N      ??Mem_PoolCreate_2
   1276              }
   1277          
   1278              if (blk_size < 1) {
   \                     ??Mem_PoolCreate_5:
   \   0000005E   0x981E             LDR      R0,[SP, #+120]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD103             BNE.N    ??Mem_PoolCreate_6
   1279                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   00000064   0xF242 0x7093      MOVW     R0,#+10131
   \   00000068   0x8030             STRH     R0,[R6, #+0]
   1280                  return;
   \   0000006A   0xE1BC             B.N      ??Mem_PoolCreate_2
   1281              }
   1282          
   1283              if (blk_align < 1) {
   \                     ??Mem_PoolCreate_6:
   \   0000006C   0x981F             LDR      R0,[SP, #+124]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD103             BNE.N    ??Mem_PoolCreate_7
   1284                 *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   \   00000072   0xF242 0x7094      MOVW     R0,#+10132
   \   00000076   0x8030             STRH     R0,[R6, #+0]
   1285                  return;
   \   00000078   0xE1B5             B.N      ??Mem_PoolCreate_2
   1286              }
   1287          #endif
   1288          
   1289          
   1290                                                                              /* ------------ VALIDATE MEM POOL TBL ------------- */
   1291              if (Mem_PoolTbl == (MEM_POOL *)0) {
   \                     ??Mem_PoolCreate_7:
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD103             BNE.N    ??Mem_PoolCreate_8
   1292                 *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
   \   00000084   0xF242 0x70E7      MOVW     R0,#+10215
   \   00000088   0x8030             STRH     R0,[R6, #+0]
   1293                  return;
   \   0000008A   0xE1AC             B.N      ??Mem_PoolCreate_2
   1294              }
   1295          
   1296          
   1297          
   1298          /*$PAGE*/
   1299                                                                              /* ---------------- CREATE MEM POOL --------------- */
   1300              pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
   \                     ??Mem_PoolCreate_8:
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000090   0x9002             STR      R0,[SP, #+8]
   1301              size_tot       = (CPU_SIZE_T) 0u;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x9000             STR      R0,[SP, #+0]
   1302          
   1303              CPU_CRITICAL_ENTER();
   \   00000096   0x.... 0x....      BL       CPU_SR_Save
   \   0000009A   0x4682             MOV      R10,R0
   1304          
   1305              if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
   \   0000009C   0x9812             LDR      R0,[SP, #+72]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD153             BNE.N    ??Mem_PoolCreate_9
   1306                  pmem_seg        =  pmem_pool_heap;
   \   000000A2   0x9802             LDR      R0,[SP, #+8]
   \   000000A4   0x0007             MOVS     R7,R0
   1307                  pmem_seg_prev   =  pmem_pool_heap;
   \   000000A6   0x9802             LDR      R0,[SP, #+8]
   \   000000A8   0x9006             STR      R0,[SP, #+24]
   1308                  pmem_seg_next   =  pmem_pool_heap;
   \   000000AA   0x9802             LDR      R0,[SP, #+8]
   \   000000AC   0x4683             MOV      R11,R0
   1309          
   1310                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1311                                                                              /* Calc tot mem   size for mem pool ptrs.           */
   1312                  pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   \   000000AE   0x9802             LDR      R0,[SP, #+8]
   \   000000B0   0x6BC0             LDR      R0,[R0, #+60]
   \   000000B2   0x900A             STR      R0,[SP, #+40]
   1313                  size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1314                                                        (CPU_SIZE_T)blk_nbr,
   1315                                                        (CPU_SIZE_T)sizeof(void *),
   1316                                                        (CPU_SIZE_T)sizeof(void *));
   \   000000B4   0x2304             MOVS     R3,#+4
   \   000000B6   0x2204             MOVS     R2,#+4
   \   000000B8   0x9914             LDR      R1,[SP, #+80]
   \   000000BA   0x980A             LDR      R0,[SP, #+40]
   \   000000BC   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   000000C0   0x9003             STR      R0,[SP, #+12]
   1317          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1318                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   \   000000C2   0x9803             LDR      R0,[SP, #+12]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD106             BNE.N    ??Mem_PoolCreate_10
   1319                      CPU_CRITICAL_EXIT();
   \   000000C8   0x4650             MOV      R0,R10
   \   000000CA   0x.... 0x....      BL       CPU_SR_Restore
   1320                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \   000000CE   0xF242 0x70E3      MOVW     R0,#+10211
   \   000000D2   0x8030             STRH     R0,[R6, #+0]
   1321                      return;
   \   000000D4   0xE187             B.N      ??Mem_PoolCreate_2
   1322                  }
   1323          #endif
   1324                                                                              /* Calc tot mem   size for mem blks.                */
   1325                  pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
   \                     ??Mem_PoolCreate_10:
   \   000000D6   0x9803             LDR      R0,[SP, #+12]
   \   000000D8   0x990A             LDR      R1,[SP, #+40]
   \   000000DA   0x1840             ADDS     R0,R0,R1
   \   000000DC   0x9004             STR      R0,[SP, #+16]
   1326                  size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1327                                                        (CPU_SIZE_T)blk_nbr,
   1328                                                        (CPU_SIZE_T)blk_size,
   1329                                                        (CPU_SIZE_T)blk_align);
   \   000000DE   0x9B1F             LDR      R3,[SP, #+124]
   \   000000E0   0x9A1E             LDR      R2,[SP, #+120]
   \   000000E2   0x9914             LDR      R1,[SP, #+80]
   \   000000E4   0x9804             LDR      R0,[SP, #+16]
   \   000000E6   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   000000EA   0x9001             STR      R0,[SP, #+4]
   1330          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1331                  if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
   \   000000EC   0x9801             LDR      R0,[SP, #+4]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD106             BNE.N    ??Mem_PoolCreate_11
   1332                      CPU_CRITICAL_EXIT();
   \   000000F2   0x4650             MOV      R0,R10
   \   000000F4   0x.... 0x....      BL       CPU_SR_Restore
   1333                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \   000000F8   0xF242 0x70E3      MOVW     R0,#+10211
   \   000000FC   0x8030             STRH     R0,[R6, #+0]
   1334                      return;
   \   000000FE   0xE172             B.N      ??Mem_PoolCreate_2
   1335                  }
   1336          #endif
   1337          
   1338                  size_tot = size_tot_ptrs + size_tot_pool;
   \                     ??Mem_PoolCreate_11:
   \   00000100   0x9803             LDR      R0,[SP, #+12]
   \   00000102   0x9901             LDR      R1,[SP, #+4]
   \   00000104   0x1808             ADDS     R0,R1,R0
   \   00000106   0x9000             STR      R0,[SP, #+0]
   1339          
   1340          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1341                  if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
   1342                      (size_tot < size_tot_pool)) {
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0x9903             LDR      R1,[SP, #+12]
   \   0000010C   0x4288             CMP      R0,R1
   \   0000010E   0xD303             BCC.N    ??Mem_PoolCreate_12
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x9901             LDR      R1,[SP, #+4]
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD206             BCS.N    ??Mem_PoolCreate_13
   1343                      CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_12:
   \   00000118   0x4650             MOV      R0,R10
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
   1344                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \   0000011E   0xF242 0x70E3      MOVW     R0,#+10211
   \   00000122   0x8030             STRH     R0,[R6, #+0]
   1345                      return;
   \   00000124   0xE15F             B.N      ??Mem_PoolCreate_2
   1346                  }
   1347          #endif
   1348          
   1349                  size_rem = pmem_pool_heap->SegSizeRem;
   \                     ??Mem_PoolCreate_13:
   \   00000126   0x9802             LDR      R0,[SP, #+8]
   \   00000128   0x6C40             LDR      R0,[R0, #+68]
   \   0000012A   0x4680             MOV      R8,R0
   1350                  if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0x4580             CMP      R8,R0
   \   00000130   0xF080 0x80B9      BCS.W    ??Mem_PoolCreate_14
   1351                      CPU_CRITICAL_EXIT();
   \   00000134   0x4650             MOV      R0,R10
   \   00000136   0x.... 0x....      BL       CPU_SR_Restore
   1352                     *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
   \   0000013A   0x9800             LDR      R0,[SP, #+0]
   \   0000013C   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000140   0x6028             STR      R0,[R5, #+0]
   1353                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \   00000142   0xF242 0x70E2      MOVW     R0,#+10210
   \   00000146   0x8030             STRH     R0,[R6, #+0]
   1354                      return;
   \   00000148   0xE14D             B.N      ??Mem_PoolCreate_2
   1355                  }
   1356          
   1357          /*$PAGE*/
   1358              } else {                                                        /* Else cfg mem pool from dedicated mem.            */
   1359                                                                              /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
   1360                  pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
   \                     ??Mem_PoolCreate_9:
   \   0000014A   0x9812             LDR      R0,[SP, #+72]
   \   0000014C   0x9009             STR      R0,[SP, #+36]
   1361                  pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
   \   0000014E   0x9813             LDR      R0,[SP, #+76]
   \   00000150   0x9912             LDR      R1,[SP, #+72]
   \   00000152   0x1840             ADDS     R0,R0,R1
   \   00000154   0x1E40             SUBS     R0,R0,#+1
   \   00000156   0x9005             STR      R0,[SP, #+20]
   1362          
   1363          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1364                  if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
   \   00000158   0x9805             LDR      R0,[SP, #+20]
   \   0000015A   0x9909             LDR      R1,[SP, #+36]
   \   0000015C   0x4288             CMP      R0,R1
   \   0000015E   0xD206             BCS.N    ??Mem_PoolCreate_15
   1365                      CPU_CRITICAL_EXIT();
   \   00000160   0x4650             MOV      R0,R10
   \   00000162   0x.... 0x....      BL       CPU_SR_Restore
   1366                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \   00000166   0xF242 0x7097      MOVW     R0,#+10135
   \   0000016A   0x8030             STRH     R0,[R6, #+0]
   1367                      return;
   \   0000016C   0xE13B             B.N      ??Mem_PoolCreate_2
   1368                  }
   1369          #endif
   1370          
   1371                  pmem_seg      = (MEM_POOL *)0;
   \                     ??Mem_PoolCreate_15:
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x0007             MOVS     R7,R0
   1372                  pmem_seg_prev = (MEM_POOL *)0;
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x9006             STR      R0,[SP, #+24]
   1373                  pmem_seg_next =  Mem_PoolTbl;
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x4683             MOV      R11,R0
   1374          
   1375                  while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
   \                     ??Mem_PoolCreate_16:
   \   0000017E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000182   0xD03D             BEQ.N    ??Mem_PoolCreate_17
   1376          
   1377                      if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
   1378                          (mem_size       == pmem_seg_next->SegSizeTot)) {
   \   00000184   0x9812             LDR      R0,[SP, #+72]
   \   00000186   0xF8DB 0x1038      LDR      R1,[R11, #+56]
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD106             BNE.N    ??Mem_PoolCreate_18
   \   0000018E   0x9813             LDR      R0,[SP, #+76]
   \   00000190   0xF8DB 0x1040      LDR      R1,[R11, #+64]
   \   00000194   0x4288             CMP      R0,R1
   \   00000196   0xD101             BNE.N    ??Mem_PoolCreate_18
   1379          
   1380                           pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
   \   00000198   0x465F             MOV      R7,R11
   1381                           break;
   \   0000019A   0xE031             B.N      ??Mem_PoolCreate_17
   1382          
   1383                      } else {
   1384                          pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
   \                     ??Mem_PoolCreate_18:
   \   0000019C   0xF8DB 0x0038      LDR      R0,[R11, #+56]
   \   000001A0   0x9008             STR      R0,[SP, #+32]
   1385                          pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
   \   000001A2   0xF8DB 0x0040      LDR      R0,[R11, #+64]
   \   000001A6   0xF8DB 0x1038      LDR      R1,[R11, #+56]
   \   000001AA   0x1840             ADDS     R0,R0,R1
   \   000001AC   0x1E40             SUBS     R0,R0,#+1
   \   000001AE   0x900B             STR      R0,[SP, #+44]
   1386          
   1387          
   1388                          if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
   \   000001B0   0x9805             LDR      R0,[SP, #+20]
   \   000001B2   0x9908             LDR      R1,[SP, #+32]
   \   000001B4   0x4288             CMP      R0,R1
   \   000001B6   0xD323             BCC.N    ??Mem_PoolCreate_17
   1389                              break;                                          /* ... new mem seg NOT avail in tbl.                */
   1390          
   1391                                                                              /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
   1392                          } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
   1393                                      (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
   1394                                     ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
   1395                                      (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
   1396                                     ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
   1397                                      (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
   \                     ??Mem_PoolCreate_19:
   \   000001B8   0x9808             LDR      R0,[SP, #+32]
   \   000001BA   0x9909             LDR      R1,[SP, #+36]
   \   000001BC   0x4288             CMP      R0,R1
   \   000001BE   0xD303             BCC.N    ??Mem_PoolCreate_20
   \   000001C0   0x9805             LDR      R0,[SP, #+20]
   \   000001C2   0x9908             LDR      R1,[SP, #+32]
   \   000001C4   0x4288             CMP      R0,R1
   \   000001C6   0xD20F             BCS.N    ??Mem_PoolCreate_21
   \                     ??Mem_PoolCreate_20:
   \   000001C8   0x9809             LDR      R0,[SP, #+36]
   \   000001CA   0x9908             LDR      R1,[SP, #+32]
   \   000001CC   0x4288             CMP      R0,R1
   \   000001CE   0xD303             BCC.N    ??Mem_PoolCreate_22
   \   000001D0   0x980B             LDR      R0,[SP, #+44]
   \   000001D2   0x9905             LDR      R1,[SP, #+20]
   \   000001D4   0x4288             CMP      R0,R1
   \   000001D6   0xD207             BCS.N    ??Mem_PoolCreate_21
   \                     ??Mem_PoolCreate_22:
   \   000001D8   0x980B             LDR      R0,[SP, #+44]
   \   000001DA   0x9909             LDR      R1,[SP, #+36]
   \   000001DC   0x4288             CMP      R0,R1
   \   000001DE   0xD30A             BCC.N    ??Mem_PoolCreate_23
   \   000001E0   0x9805             LDR      R0,[SP, #+20]
   \   000001E2   0x990B             LDR      R1,[SP, #+44]
   \   000001E4   0x4288             CMP      R0,R1
   \   000001E6   0xD306             BCC.N    ??Mem_PoolCreate_23
   1398                              CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_21:
   \   000001E8   0x4650             MOV      R0,R10
   \   000001EA   0x.... 0x....      BL       CPU_SR_Restore
   1399                             *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
   \   000001EE   0xF242 0x707F      MOVW     R0,#+10111
   \   000001F2   0x8030             STRH     R0,[R6, #+0]
   1400                              return;
   \   000001F4   0xE0F7             B.N      ??Mem_PoolCreate_2
   1401                          }
   1402                      }
   1403                                                                              /* If mem seg NOT found, adv to next mem seg.       */
   1404                      pmem_seg_prev = pmem_seg_next;
   \                     ??Mem_PoolCreate_23:
   \   000001F6   0xF8CD 0xB018      STR      R11,[SP, #+24]
   1405                      pmem_seg_next = pmem_seg_next->SegNextPtr;
   \   000001FA   0xF8DB 0xB00C      LDR      R11,[R11, #+12]
   \   000001FE   0xE7BE             B.N      ??Mem_PoolCreate_16
   1406                  }
   1407          
   1408                  if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
   \                     ??Mem_PoolCreate_17:
   \   00000200   0x2F00             CMP      R7,#+0
   \   00000202   0xD108             BNE.N    ??Mem_PoolCreate_24
   1409                      pmem_seg                    = pmem_pool;
   \   00000204   0x0027             MOVS     R7,R4
   1410                      pmem_pool->SegAddr          = pmem_base_addr;
   \   00000206   0x9812             LDR      R0,[SP, #+72]
   \   00000208   0x63A0             STR      R0,[R4, #+56]
   1411                      pmem_pool->SegAddrNextAvail = pmem_base_addr;
   \   0000020A   0x9812             LDR      R0,[SP, #+72]
   \   0000020C   0x63E0             STR      R0,[R4, #+60]
   1412                      pmem_pool->SegSizeTot       = mem_size;
   \   0000020E   0x9813             LDR      R0,[SP, #+76]
   \   00000210   0x6420             STR      R0,[R4, #+64]
   1413                      pmem_pool->SegSizeRem       = mem_size;
   \   00000212   0x9813             LDR      R0,[SP, #+76]
   \   00000214   0x6460             STR      R0,[R4, #+68]
   1414                  }
   1415          
   1416          /*$PAGE*/
   1417                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1418                                                                              /* Calc tot mem size for mem pool ptrs.             */
   1419                  pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   \                     ??Mem_PoolCreate_24:
   \   00000216   0x9802             LDR      R0,[SP, #+8]
   \   00000218   0x6BC0             LDR      R0,[R0, #+60]
   \   0000021A   0x900A             STR      R0,[SP, #+40]
   1420                  size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1421                                                       (CPU_SIZE_T)blk_nbr,
   1422                                                       (CPU_SIZE_T)sizeof(void *),
   1423                                                       (CPU_SIZE_T)sizeof(void *));
   \   0000021C   0x2304             MOVS     R3,#+4
   \   0000021E   0x2204             MOVS     R2,#+4
   \   00000220   0x9914             LDR      R1,[SP, #+80]
   \   00000222   0x980A             LDR      R0,[SP, #+40]
   \   00000224   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   00000228   0x9003             STR      R0,[SP, #+12]
   1424          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1425                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   \   0000022A   0x9803             LDR      R0,[SP, #+12]
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD106             BNE.N    ??Mem_PoolCreate_25
   1426                      CPU_CRITICAL_EXIT();
   \   00000230   0x4650             MOV      R0,R10
   \   00000232   0x.... 0x....      BL       CPU_SR_Restore
   1427                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \   00000236   0xF242 0x70E3      MOVW     R0,#+10211
   \   0000023A   0x8030             STRH     R0,[R6, #+0]
   1428                      return;
   \   0000023C   0xE0D3             B.N      ??Mem_PoolCreate_2
   1429                  }
   1430          #endif
   1431          
   1432                  size_rem = pmem_pool_heap->SegSizeRem;
   \                     ??Mem_PoolCreate_25:
   \   0000023E   0x9802             LDR      R0,[SP, #+8]
   \   00000240   0x6C40             LDR      R0,[R0, #+68]
   \   00000242   0x4680             MOV      R8,R0
   1433                  if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
   \   00000244   0x9803             LDR      R0,[SP, #+12]
   \   00000246   0x4580             CMP      R8,R0
   \   00000248   0xD20A             BCS.N    ??Mem_PoolCreate_26
   1434                      CPU_CRITICAL_EXIT();
   \   0000024A   0x4650             MOV      R0,R10
   \   0000024C   0x.... 0x....      BL       CPU_SR_Restore
   1435                     *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
   \   00000250   0x9803             LDR      R0,[SP, #+12]
   \   00000252   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000256   0x6028             STR      R0,[R5, #+0]
   1436                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \   00000258   0xF242 0x70E2      MOVW     R0,#+10210
   \   0000025C   0x8030             STRH     R0,[R6, #+0]
   1437                      return;
   \   0000025E   0xE0C2             B.N      ??Mem_PoolCreate_2
   1438                  }
   1439          
   1440                                                                              /* Calc tot mem size for mem blks.                  */
   1441                  pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   \                     ??Mem_PoolCreate_26:
   \   00000260   0x6BF8             LDR      R0,[R7, #+60]
   \   00000262   0x9004             STR      R0,[SP, #+16]
   1442                  size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1443                                                       (CPU_SIZE_T)blk_nbr,
   1444                                                       (CPU_SIZE_T)blk_size,
   1445                                                       (CPU_SIZE_T)blk_align);
   \   00000264   0x9B1F             LDR      R3,[SP, #+124]
   \   00000266   0x9A1E             LDR      R2,[SP, #+120]
   \   00000268   0x9914             LDR      R1,[SP, #+80]
   \   0000026A   0x9804             LDR      R0,[SP, #+16]
   \   0000026C   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   00000270   0x9001             STR      R0,[SP, #+4]
   1446          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1447                  if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
   \   00000272   0x9801             LDR      R0,[SP, #+4]
   \   00000274   0x2800             CMP      R0,#+0
   \   00000276   0xD106             BNE.N    ??Mem_PoolCreate_27
   1448                      CPU_CRITICAL_EXIT();
   \   00000278   0x4650             MOV      R0,R10
   \   0000027A   0x.... 0x....      BL       CPU_SR_Restore
   1449                     *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
   \   0000027E   0xF242 0x70D9      MOVW     R0,#+10201
   \   00000282   0x8030             STRH     R0,[R6, #+0]
   1450                      return;
   \   00000284   0xE0AF             B.N      ??Mem_PoolCreate_2
   1451                  }
   1452          #endif
   1453          
   1454                  size_rem = pmem_seg->SegSizeRem;
   \                     ??Mem_PoolCreate_27:
   \   00000286   0x6C78             LDR      R0,[R7, #+68]
   \   00000288   0x4680             MOV      R8,R0
   1455                  if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
   \   0000028A   0x9801             LDR      R0,[SP, #+4]
   \   0000028C   0x4580             CMP      R8,R0
   \   0000028E   0xD20A             BCS.N    ??Mem_PoolCreate_14
   1456                      CPU_CRITICAL_EXIT();
   \   00000290   0x4650             MOV      R0,R10
   \   00000292   0x.... 0x....      BL       CPU_SR_Restore
   1457                     *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
   \   00000296   0x9801             LDR      R0,[SP, #+4]
   \   00000298   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000029C   0x6028             STR      R0,[R5, #+0]
   1458                     *perr         = LIB_MEM_ERR_SEG_EMPTY;
   \   0000029E   0xF242 0x70D8      MOVW     R0,#+10200
   \   000002A2   0x8030             STRH     R0,[R6, #+0]
   1459                      return;
   \   000002A4   0xE09F             B.N      ??Mem_PoolCreate_2
   1460                  }
   1461              }
   1462          
   1463          
   1464          /*$PAGE*/
   1465                                                                              /* ---------------- ALLOC MEM BLKs ---------------- */
   1466              size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
   \                     ??Mem_PoolCreate_14:
   \   000002A6   0x9814             LDR      R0,[SP, #+80]
   \   000002A8   0x0080             LSLS     R0,R0,#+2
   \   000002AA   0x9007             STR      R0,[SP, #+28]
   1467                                                                              /* Alloc stk of ptrs for mem blks from heap.        */
   1468              ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
   1469                                                     (CPU_SIZE_T)size_pool_ptrs,
   1470                                                     (CPU_SIZE_T)sizeof(void *));
   \   000002AC   0x2204             MOVS     R2,#+4
   \   000002AE   0x9907             LDR      R1,[SP, #+28]
   \   000002B0   0x9802             LDR      R0,[SP, #+8]
   \   000002B2   0x.... 0x....      BL       Mem_SegAlloc
   \   000002B6   0x900C             STR      R0,[SP, #+48]
   1471              if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
   \   000002B8   0x980C             LDR      R0,[SP, #+48]
   \   000002BA   0x2800             CMP      R0,#+0
   \   000002BC   0xD121             BNE.N    ??Mem_PoolCreate_28
   1472                  size_rem = pmem_pool_heap->SegSizeRem;
   \   000002BE   0x9802             LDR      R0,[SP, #+8]
   \   000002C0   0x6C40             LDR      R0,[R0, #+68]
   \   000002C2   0x4680             MOV      R8,R0
   1473                  CPU_CRITICAL_EXIT();
   \   000002C4   0x4650             MOV      R0,R10
   \   000002C6   0x.... 0x....      BL       CPU_SR_Restore
   1474                                                                              /* ... rtn add'l heap size needed.                  */
   1475                  if (pmem_base_addr == (void *)0) {
   \   000002CA   0x9812             LDR      R0,[SP, #+72]
   \   000002CC   0x2800             CMP      R0,#+0
   \   000002CE   0xD10A             BNE.N    ??Mem_PoolCreate_29
   1476                      if (size_tot > size_rem) {
   \   000002D0   0x9800             LDR      R0,[SP, #+0]
   \   000002D2   0x4580             CMP      R8,R0
   \   000002D4   0xD204             BCS.N    ??Mem_PoolCreate_30
   1477                         *poctets_reqd = size_tot - size_rem;
   \   000002D6   0x9800             LDR      R0,[SP, #+0]
   \   000002D8   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000002DC   0x6028             STR      R0,[R5, #+0]
   \   000002DE   0xE00C             B.N      ??Mem_PoolCreate_31
   1478                      } else {
   1479                         *poctets_reqd = size_tot;
   \                     ??Mem_PoolCreate_30:
   \   000002E0   0x9800             LDR      R0,[SP, #+0]
   \   000002E2   0x6028             STR      R0,[R5, #+0]
   \   000002E4   0xE009             B.N      ??Mem_PoolCreate_31
   1480                      }
   1481                  } else {
   1482                      if (size_pool_ptrs > size_rem) {
   \                     ??Mem_PoolCreate_29:
   \   000002E6   0x9807             LDR      R0,[SP, #+28]
   \   000002E8   0x4580             CMP      R8,R0
   \   000002EA   0xD204             BCS.N    ??Mem_PoolCreate_32
   1483                         *poctets_reqd = size_pool_ptrs - size_rem;
   \   000002EC   0x9807             LDR      R0,[SP, #+28]
   \   000002EE   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000002F2   0x6028             STR      R0,[R5, #+0]
   \   000002F4   0xE001             B.N      ??Mem_PoolCreate_31
   1484                      } else {
   1485                         *poctets_reqd = size_pool_ptrs;
   \                     ??Mem_PoolCreate_32:
   \   000002F6   0x9807             LDR      R0,[SP, #+28]
   \   000002F8   0x6028             STR      R0,[R5, #+0]
   1486                      }
   1487                  }
   1488                 *perr = LIB_MEM_ERR_HEAP_EMPTY;
   \                     ??Mem_PoolCreate_31:
   \   000002FA   0xF242 0x70E2      MOVW     R0,#+10210
   \   000002FE   0x8030             STRH     R0,[R6, #+0]
   1489                  return;
   \   00000300   0xE071             B.N      ??Mem_PoolCreate_2
   1490              }
   1491          
   1492              for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
   \                     ??Mem_PoolCreate_28:
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0x4681             MOV      R9,R0
   \                     ??Mem_PoolCreate_33:
   \   00000306   0x9814             LDR      R0,[SP, #+80]
   \   00000308   0x4581             CMP      R9,R0
   \   0000030A   0xD22F             BCS.N    ??Mem_PoolCreate_34
   1493                  pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
   \   0000030C   0x9A1F             LDR      R2,[SP, #+124]
   \   0000030E   0x991E             LDR      R1,[SP, #+120]
   \   00000310   0x0038             MOVS     R0,R7
   \   00000312   0x.... 0x....      BL       Mem_SegAlloc
   \   00000316   0x900E             STR      R0,[SP, #+56]
   1494                  if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
   \   00000318   0x980E             LDR      R0,[SP, #+56]
   \   0000031A   0x2800             CMP      R0,#+0
   \   0000031C   0xD11F             BNE.N    ??Mem_PoolCreate_35
   1495                      pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   \   0000031E   0x6BF8             LDR      R0,[R7, #+60]
   \   00000320   0x9004             STR      R0,[SP, #+16]
   1496                      size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
   \   00000322   0x6C78             LDR      R0,[R7, #+68]
   \   00000324   0x4680             MOV      R8,R0
   1497                      CPU_CRITICAL_EXIT();
   \   00000326   0x4650             MOV      R0,R10
   \   00000328   0x.... 0x....      BL       CPU_SR_Restore
   1498                      blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
   \   0000032C   0x9814             LDR      R0,[SP, #+80]
   \   0000032E   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000332   0x9010             STR      R0,[SP, #+64]
   1499                      size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
   1500                                                           (MEM_POOL_BLK_QTY)blk_rem,
   1501                                                           (CPU_SIZE_T      )blk_size,
   1502                                                           (CPU_SIZE_T      )blk_align);
   \   00000334   0x9B1F             LDR      R3,[SP, #+124]
   \   00000336   0x9A1E             LDR      R2,[SP, #+120]
   \   00000338   0x9910             LDR      R1,[SP, #+64]
   \   0000033A   0x9804             LDR      R0,[SP, #+16]
   \   0000033C   0x.... 0x....      BL       Mem_SegCalcTotSize
   \   00000340   0x9000             STR      R0,[SP, #+0]
   1503                                                                              /* ... rtn add'l seg  size needed.                  */
   1504                      if (size_tot > size_rem) {
   \   00000342   0x9800             LDR      R0,[SP, #+0]
   \   00000344   0x4580             CMP      R8,R0
   \   00000346   0xD204             BCS.N    ??Mem_PoolCreate_36
   1505                         *poctets_reqd = size_tot - size_rem;
   \   00000348   0x9800             LDR      R0,[SP, #+0]
   \   0000034A   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000034E   0x6028             STR      R0,[R5, #+0]
   \   00000350   0xE001             B.N      ??Mem_PoolCreate_37
   1506                      } else {
   1507                         *poctets_reqd = size_tot;
   \                     ??Mem_PoolCreate_36:
   \   00000352   0x9800             LDR      R0,[SP, #+0]
   \   00000354   0x6028             STR      R0,[R5, #+0]
   1508                      }
   1509                     *perr = LIB_MEM_ERR_SEG_EMPTY;
   \                     ??Mem_PoolCreate_37:
   \   00000356   0xF242 0x70D8      MOVW     R0,#+10200
   \   0000035A   0x8030             STRH     R0,[R6, #+0]
   1510                      return;
   \   0000035C   0xE043             B.N      ??Mem_PoolCreate_2
   1511                  }
   1512                  ppool_ptr[i] = pmem_blk;
   \                     ??Mem_PoolCreate_35:
   \   0000035E   0x980C             LDR      R0,[SP, #+48]
   \   00000360   0x990E             LDR      R1,[SP, #+56]
   \   00000362   0xF840 0x1029      STR      R1,[R0, R9, LSL #+2]
   1513              }
   \   00000366   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000036A   0xE7CC             B.N      ??Mem_PoolCreate_33
   1514          
   1515          
   1516          /*$PAGE*/
   1517                                                                              /* ------------- UPDATE MEM POOL TBL -------------- */
   1518              if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
   \                     ??Mem_PoolCreate_34:
   \   0000036C   0x42A7             CMP      R7,R4
   \   0000036E   0xD112             BNE.N    ??Mem_PoolCreate_38
   1519                                                                              /* Update cur  mem seg  links.                      */
   1520                  pmem_pool->SegPrevPtr = pmem_seg_prev;
   \   00000370   0x9806             LDR      R0,[SP, #+24]
   \   00000372   0x60A0             STR      R0,[R4, #+8]
   1521                  pmem_pool->SegNextPtr = pmem_seg_next;
   \   00000374   0xF8C4 0xB00C      STR      R11,[R4, #+12]
   1522          
   1523                  if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
   \   00000378   0x9806             LDR      R0,[SP, #+24]
   \   0000037A   0x2800             CMP      R0,#+0
   \   0000037C   0xD002             BEQ.N    ??Mem_PoolCreate_39
   1524                      pmem_seg_prev->SegNextPtr = pmem_pool;
   \   0000037E   0x9806             LDR      R0,[SP, #+24]
   \   00000380   0x60C4             STR      R4,[R0, #+12]
   \   00000382   0xE002             B.N      ??Mem_PoolCreate_40
   1525                  } else {
   1526                      Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
   \                     ??Mem_PoolCreate_39:
   \   00000384   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000388   0x6004             STR      R4,[R0, #+0]
   1527                  }
   1528          
   1529                  if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
   \                     ??Mem_PoolCreate_40:
   \   0000038A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000038E   0xD00D             BEQ.N    ??Mem_PoolCreate_41
   1530                      pmem_seg_next->SegPrevPtr = pmem_pool;
   \   00000390   0xF8CB 0x4008      STR      R4,[R11, #+8]
   \   00000394   0xE00A             B.N      ??Mem_PoolCreate_41
   1531                  }
   1532          
   1533              } else {                                                        /* Add mem pool into mem seg.                       */
   1534                                                                              /* Update cur  mem pool links.                      */
   1535                  pmem_pool_next         = pmem_seg->PoolNextPtr;
   \                     ??Mem_PoolCreate_38:
   \   00000396   0x6978             LDR      R0,[R7, #+20]
   \   00000398   0x900D             STR      R0,[SP, #+52]
   1536                  pmem_pool->PoolPrevPtr = pmem_seg;
   \   0000039A   0x6127             STR      R7,[R4, #+16]
   1537                  pmem_pool->PoolNextPtr = pmem_pool_next;
   \   0000039C   0x980D             LDR      R0,[SP, #+52]
   \   0000039E   0x6160             STR      R0,[R4, #+20]
   1538          
   1539                  pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
   \   000003A0   0x617C             STR      R4,[R7, #+20]
   1540          
   1541                  if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
   \   000003A2   0x980D             LDR      R0,[SP, #+52]
   \   000003A4   0x2800             CMP      R0,#+0
   \   000003A6   0xD001             BEQ.N    ??Mem_PoolCreate_41
   1542                      pmem_pool_next->PoolPrevPtr = pmem_pool;
   \   000003A8   0x980D             LDR      R0,[SP, #+52]
   \   000003AA   0x6104             STR      R4,[R0, #+16]
   1543                  }
   1544              }
   1545          
   1546          
   1547          
   1548                                                                              /* ----------------- CFG MEM POOL ----------------- */
   1549              pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
   \                     ??Mem_PoolCreate_41:
   \   000003AC   0x.... 0x....      LDR.W    R0,??DataTable10_4  ;; 0x4c4f4f50
   \   000003B0   0x6020             STR      R0,[R4, #+0]
   1550              pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
   \   000003B2   0x6067             STR      R7,[R4, #+4]
   1551              pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
   \   000003B4   0x9804             LDR      R0,[SP, #+16]
   \   000003B6   0x61A0             STR      R0,[R4, #+24]
   1552              pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
   \   000003B8   0x9801             LDR      R0,[SP, #+4]
   \   000003BA   0x9904             LDR      R1,[SP, #+16]
   \   000003BC   0x1840             ADDS     R0,R0,R1
   \   000003BE   0x1E40             SUBS     R0,R0,#+1
   \   000003C0   0x61E0             STR      R0,[R4, #+28]
   1553              pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
   \   000003C2   0x980C             LDR      R0,[SP, #+48]
   \   000003C4   0x6220             STR      R0,[R4, #+32]
   1554              pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
   \   000003C6   0x9801             LDR      R0,[SP, #+4]
   \   000003C8   0x62A0             STR      R0,[R4, #+40]
   1555              pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
   \   000003CA   0x981F             LDR      R0,[SP, #+124]
   \   000003CC   0x6360             STR      R0,[R4, #+52]
   1556              pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
   \   000003CE   0x981E             LDR      R0,[SP, #+120]
   \   000003D0   0x6320             STR      R0,[R4, #+48]
   1557              pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
   \   000003D2   0x9814             LDR      R0,[SP, #+80]
   \   000003D4   0x62E0             STR      R0,[R4, #+44]
   1558              pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
   \   000003D6   0x9814             LDR      R0,[SP, #+80]
   \   000003D8   0x6260             STR      R0,[R4, #+36]
   1559          
   1560          
   1561              CPU_CRITICAL_EXIT();
   \   000003DA   0x4650             MOV      R0,R10
   \   000003DC   0x.... 0x....      BL       CPU_SR_Restore
   1562          
   1563             *perr = LIB_MEM_ERR_NONE;
   \   000003E0   0xF242 0x7010      MOVW     R0,#+10000
   \   000003E4   0x8030             STRH     R0,[R6, #+0]
   1564          }
   \                     ??Mem_PoolCreate_2:
   \   000003E6   0xB015             ADD      SP,SP,#+84
   \   000003E8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1565          #endif
   1566          
   1567          
   1568          /*$PAGE*/
   1569          /*
   1570          *********************************************************************************************************
   1571          *                                      Mem_PoolBlkGetNbrAvail()
   1572          *
   1573          * Description : Get memory pools remaining number of blocks available to allocate.
   1574          *
   1575          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
   1576          *
   1577          *               perr        Pointer to variable that will receive the return error code from this function :
   1578          *
   1579          *                               LIB_MEM_ERR_NONE                Memory pool available number of blocks
   1580          *                                                                   successfully returned.
   1581          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1582          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1583          *
   1584          * Return(s)   : Remaining memory pool blocks (see Note #1), if NO error(s).
   1585          *
   1586          *               0,                                          otherwise.
   1587          *
   1588          * Caller(s)   : Application.
   1589          *
   1590          * Note(s)     : (1) (a) Mem_PoolBlkGetNbrAvail() ONLY supports non-heap memory pools.
   1591          *                   (b) Mem_HeapGetSizeRem()/Mem_SegGetSizeRem() should be used for heap memory pool/segment.
   1592          *
   1593          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1594          *********************************************************************************************************
   1595          */
   1596          /*$PAGE*/
   1597          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1598          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
   1599                                                    LIB_ERR   *perr)
   1600          {
   \                     Mem_PoolBlkGetNbrAvail:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1601              MEM_POOL_BLK_QTY  nbr_blk_rem;
   1602              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
   1603          
   1604          
   1605          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1606                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1607              if (perr == (LIB_ERR *)0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_PoolBlkGetNbrAvail_0
   1608                  CPU_SW_EXCEPTION(0u);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
   1609              }
   1610                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1611              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   \                     ??Mem_PoolBlkGetNbrAvail_0:
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE.N    ??Mem_PoolBlkGetNbrAvail_1
   1612                 *perr =  LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1613                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE018             B.N      ??Mem_PoolBlkGetNbrAvail_2
   1614              }
   1615          #endif
   1616          
   1617              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGetNbrAvail_1:
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x0007             MOVS     R7,R0
   1618          
   1619          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1620              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD109             BNE.N    ??Mem_PoolBlkGetNbrAvail_3
   1621                  case LIB_MEM_TYPE_POOL:
   1622                       break;
   1623          
   1624          
   1625                  case LIB_MEM_TYPE_NONE:
   1626                  case LIB_MEM_TYPE_HEAP:
   1627                  default:
   1628                       CPU_CRITICAL_EXIT();
   1629                      *perr =  LIB_MEM_ERR_INVALID_POOL;
   1630                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
   1631              }
   1632          #endif
   1633          
   1634                                                                          /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
   1635              nbr_blk_rem = pmem_pool->BlkIx;
   \   0000002E   0x6A60             LDR      R0,[R4, #+36]
   \   00000030   0x0006             MOVS     R6,R0
   1636          
   1637              CPU_CRITICAL_EXIT();
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
   1638          
   1639          
   1640             *perr =  LIB_MEM_ERR_NONE;
   \   00000038   0xF242 0x7010      MOVW     R0,#+10000
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
   1641          
   1642              return (nbr_blk_rem);
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xE006             B.N      ??Mem_PoolBlkGetNbrAvail_2
   \                     ??Mem_PoolBlkGetNbrAvail_3:
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x.... 0x....      BL       CPU_SR_Restore
   \   00000048   0xF242 0x7088      MOVW     R0,#+10120
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??Mem_PoolBlkGetNbrAvail_2:
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1643          }
   1644          #endif
   1645          
   1646          
   1647          /*$PAGE*/
   1648          /*
   1649          *********************************************************************************************************
   1650          *                                          Mem_PoolBlkGet()
   1651          *
   1652          * Description : Get a memory block from memory pool.
   1653          *
   1654          * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
   1655          *
   1656          *               size        Size of requested memory (in octets).
   1657          *
   1658          *               perr        Pointer to variable that will receive the return error code from this function :
   1659          *
   1660          *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
   1661          *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1662          *
   1663          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1664          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1665          *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1666          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1667          *
   1668          * Return(s)   : Pointer to memory block, if NO error(s).
   1669          *
   1670          *               Pointer to NULL,         otherwise.
   1671          *
   1672          * Caller(s)   : Application.
   1673          *
   1674          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1675          *********************************************************************************************************
   1676          */
   1677          /*$PAGE*/
   1678          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1679          void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
   1680                                 CPU_SIZE_T   size,
   1681                                 LIB_ERR     *perr)
   1682          {
   \                     Mem_PoolBlkGet:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1683              void  *pmem_blk;
   1684              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
   1685          
   1686          
   1687          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1688              if (perr == (LIB_ERR *)0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??Mem_PoolBlkGet_0
   1689                  CPU_SW_EXCEPTION((void *)0);
   \   0000000C   0x.... 0x....      BL       CPU_SW_Exception
   1690              }
   1691          #endif
   1692          
   1693                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1694          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1695              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   \                     ??Mem_PoolBlkGet_0:
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE.N    ??Mem_PoolBlkGet_1
   1696                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   00000014   0xF242 0x7011      MOVW     R0,#+10001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1697                  return ((void *)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE049             B.N      ??Mem_PoolBlkGet_2
   1698              }
   1699          
   1700              if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
   \                     ??Mem_PoolBlkGet_1:
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??Mem_PoolBlkGet_3
   1701                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   00000024   0xF242 0x7093      MOVW     R0,#+10131
   \   00000028   0x8028             STRH     R0,[R5, #+0]
   1702                  return ((void *)0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE041             B.N      ??Mem_PoolBlkGet_2
   1703              }
   1704          #endif
   1705          
   1706              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGet_3:
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x0007             MOVS     R7,R0
   1707          
   1708          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1709              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD007             BEQ.N    ??Mem_PoolBlkGet_4
   1710                  CPU_CRITICAL_EXIT();
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   1711                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \   00000042   0xF242 0x7088      MOVW     R0,#+10120
   \   00000046   0x8028             STRH     R0,[R5, #+0]
   1712                  return ((void *)0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE032             B.N      ??Mem_PoolBlkGet_2
   1713              }
   1714          
   1715              if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
   \                     ??Mem_PoolBlkGet_4:
   \   0000004C   0x6B20             LDR      R0,[R4, #+48]
   \   0000004E   0x9900             LDR      R1,[SP, #+0]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD207             BCS.N    ??Mem_PoolBlkGet_5
   1716                  CPU_CRITICAL_EXIT();
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
   1717                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \   0000005A   0xF242 0x7093      MOVW     R0,#+10131
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
   1718                  return ((void *)0);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE026             B.N      ??Mem_PoolBlkGet_2
   1719              }
   1720          #endif
   1721          
   1722             (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
   \                     ??Mem_PoolBlkGet_5:
   \   00000064   0xA800             ADD      R0,SP,#+0
   1723          
   1724              if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
   \   00000066   0x6A60             LDR      R0,[R4, #+36]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD107             BNE.N    ??Mem_PoolBlkGet_6
   1725                  CPU_CRITICAL_EXIT();
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   1726                 *perr = LIB_MEM_ERR_POOL_EMPTY;
   \   00000072   0xF242 0x70DE      MOVW     R0,#+10206
   \   00000076   0x8028             STRH     R0,[R5, #+0]
   1727                  return ((void *)0);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE01A             B.N      ??Mem_PoolBlkGet_2
   1728              }
   1729          
   1730              if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
   \                     ??Mem_PoolBlkGet_6:
   \   0000007C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000007E   0x6A61             LDR      R1,[R4, #+36]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD207             BCS.N    ??Mem_PoolBlkGet_7
   1731                  CPU_CRITICAL_EXIT();
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
   1732                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \   0000008A   0xF242 0x7095      MOVW     R0,#+10133
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   1733                  return ((void *)0);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE00E             B.N      ??Mem_PoolBlkGet_2
   1734              }
   1735          
   1736                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1737              pmem_pool->BlkIx--;
   \                     ??Mem_PoolBlkGet_7:
   \   00000094   0x6A60             LDR      R0,[R4, #+36]
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x6260             STR      R0,[R4, #+36]
   1738              pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   \   0000009A   0x6A60             LDR      R0,[R4, #+36]
   \   0000009C   0x6A21             LDR      R1,[R4, #+32]
   \   0000009E   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   000000A2   0x0006             MOVS     R6,R0
   1739          
   1740              CPU_CRITICAL_EXIT();
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x.... 0x....      BL       CPU_SR_Restore
   1741          
   1742             *perr =  LIB_MEM_ERR_NONE;
   \   000000AA   0xF242 0x7010      MOVW     R0,#+10000
   \   000000AE   0x8028             STRH     R0,[R5, #+0]
   1743          
   1744              return (pmem_blk);
   \   000000B0   0x0030             MOVS     R0,R6
   \                     ??Mem_PoolBlkGet_2:
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1745          }
   1746          #endif
   1747          
   1748          
   1749          /*$PAGE*/
   1750          /*
   1751          *********************************************************************************************************
   1752          *                                      Mem_PoolBlkGetUsedAtIx()
   1753          *
   1754          * Description : Get a used memory block from memory pool, by index.
   1755          *
   1756          * Argument(s) : pmem_pool   Pointer to memory pool to get memory block from.
   1757          *
   1758          *               used_ix     Index of the used memory block to get.
   1759          *
   1760          *               perr        Pointer to variable that will receive the return error code from this function :
   1761          *
   1762          *                               LIB_MEM_ERR_NONE                    Memory block successfully returned.
   1763          *                               LIB_MEM_ERR_POOL_FULL           All memory blocks available in memory pool.
   1764          *
   1765          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1766          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1767          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1768          *
   1769          * Return(s)   : Pointer to memory block, if NO error(s).
   1770          *
   1771          *               Pointer to NULL,         otherwise.
   1772          *
   1773          * Caller(s)   : Application.
   1774          *
   1775          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1776          *
   1777          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   1778          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   1779          *                   lock to avoid the index to be modified.
   1780          *********************************************************************************************************
   1781          */
   1782          /*$PAGE*/
   1783          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1784          void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
   1785                                         MEM_POOL_IX        used_ix,
   1786                                         LIB_ERR           *perr)
   1787          {
   \                     Mem_PoolBlkGetUsedAtIx:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1788              MEM_POOL_IX   blk_ix;
   1789              void         *pmem_blk;
   1790              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   1791          
   1792          
   1793          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1794              if (perr == (LIB_ERR *)0) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??Mem_PoolBlkGetUsedAtIx_0
   1795                  CPU_SW_EXCEPTION((void *)0);
   \   00000012   0x.... 0x....      BL       CPU_SW_Exception
   1796              }
   1797          #endif
   1798          
   1799                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1800          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1801              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   \                     ??Mem_PoolBlkGetUsedAtIx_0:
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD104             BNE.N    ??Mem_PoolBlkGetUsedAtIx_1
   1802                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   0000001A   0xF242 0x7011      MOVW     R0,#+10001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
   1803                  return ((void *)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE03F             B.N      ??Mem_PoolBlkGetUsedAtIx_2
   1804              }
   1805          #endif
   1806          
   1807              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGetUsedAtIx_1:
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x4681             MOV      R9,R0
   1808          
   1809          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1810              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD007             BEQ.N    ??Mem_PoolBlkGetUsedAtIx_3
   1811                  CPU_CRITICAL_EXIT();
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
   1812                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \   00000038   0xF242 0x7088      MOVW     R0,#+10120
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
   1813                  return ((void *)0);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE030             B.N      ??Mem_PoolBlkGetUsedAtIx_2
   1814              }
   1815          
   1816              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
   \                     ??Mem_PoolBlkGetUsedAtIx_3:
   \   00000042   0x6A60             LDR      R0,[R4, #+36]
   \   00000044   0x6AE1             LDR      R1,[R4, #+44]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD307             BCC.N    ??Mem_PoolBlkGetUsedAtIx_4
   1817                  CPU_CRITICAL_EXIT();
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0x.... 0x....      BL       CPU_SR_Restore
   1818                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \   00000050   0xF242 0x7095      MOVW     R0,#+10133
   \   00000054   0x8030             STRH     R0,[R6, #+0]
   1819                  return ((void *)0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE024             B.N      ??Mem_PoolBlkGetUsedAtIx_2
   1820              }
   1821          #endif
   1822          
   1823              blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
   \                     ??Mem_PoolBlkGetUsedAtIx_4:
   \   0000005A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005C   0x1B40             SUBS     R0,R0,R5
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0x0007             MOVS     R7,R0
   1824          
   1825              if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
   \   00000062   0x6AE0             LDR      R0,[R4, #+44]
   \   00000064   0x4287             CMP      R7,R0
   \   00000066   0xD307             BCC.N    ??Mem_PoolBlkGetUsedAtIx_5
   1826                  CPU_CRITICAL_EXIT();
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
   1827                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \   0000006E   0xF242 0x7095      MOVW     R0,#+10133
   \   00000072   0x8030             STRH     R0,[R6, #+0]
   1828                  return ((void *)0);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE015             B.N      ??Mem_PoolBlkGetUsedAtIx_2
   1829              }
   1830          
   1831              if (blk_ix < pmem_pool->BlkIx) {
   \                     ??Mem_PoolBlkGetUsedAtIx_5:
   \   00000078   0x6A60             LDR      R0,[R4, #+36]
   \   0000007A   0x4287             CMP      R7,R0
   \   0000007C   0xD207             BCS.N    ??Mem_PoolBlkGetUsedAtIx_6
   1832                  CPU_CRITICAL_EXIT();
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x.... 0x....      BL       CPU_SR_Restore
   1833                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \   00000084   0xF242 0x7095      MOVW     R0,#+10133
   \   00000088   0x8030             STRH     R0,[R6, #+0]
   1834                  return ((void *)0);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE00A             B.N      ??Mem_PoolBlkGetUsedAtIx_2
   1835              }
   1836                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1837              pmem_blk = pmem_pool->PoolPtrs[blk_ix];
   \                     ??Mem_PoolBlkGetUsedAtIx_6:
   \   0000008E   0x6A20             LDR      R0,[R4, #+32]
   \   00000090   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000094   0x4680             MOV      R8,R0
   1838          
   1839              CPU_CRITICAL_EXIT();
   \   00000096   0x4648             MOV      R0,R9
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
   1840          
   1841             *perr =  LIB_MEM_ERR_NONE;
   \   0000009C   0xF242 0x7010      MOVW     R0,#+10000
   \   000000A0   0x8030             STRH     R0,[R6, #+0]
   1842          
   1843              return (pmem_blk);
   \   000000A2   0x4640             MOV      R0,R8
   \                     ??Mem_PoolBlkGetUsedAtIx_2:
   \   000000A4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1844          }
   1845          #endif
   1846          
   1847          
   1848          /*$PAGE*/
   1849          /*
   1850          *********************************************************************************************************
   1851          *                                          Mem_PoolBlkFree()
   1852          *
   1853          * Description : Free a memory block to memory pool.
   1854          *
   1855          * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
   1856          *
   1857          *               pmem_blk    Pointer to memory block address to free.
   1858          *
   1859          *               perr        Pointer to variable that will receive the return error code from this function :
   1860          *
   1861          *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
   1862          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1863          *                                                                           memory pool.
   1864          *
   1865          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1866          *                                                                           a NULL pointer.
   1867          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1868          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1869          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1870          *                                                                            in memory pool.
   1871          *
   1872          * Return(s)   : none.
   1873          *
   1874          * Caller(s)   : Application.
   1875          *
   1876          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1877          *********************************************************************************************************
   1878          */
   1879          /*$PAGE*/
   1880          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1881          void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
   1882                                 void      *pmem_blk,
   1883                                 LIB_ERR   *perr)
   1884          {
   \                     Mem_PoolBlkFree:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1885              void         *p_addr;
   1886              CPU_BOOLEAN   addr_valid;
   1887              MEM_POOL_IX   i;
   1888              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
   1889          
   1890          
   1891          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1892              if (perr == (LIB_ERR *)0) {
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??Mem_PoolBlkFree_0
   1893                  CPU_SW_EXCEPTION(;);
   \   00000012   0x.... 0x....      BL       CPU_SW_Exception
   1894              }
   1895          #endif
   1896          
   1897                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   1898          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   1899              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolBlkFree_0:
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD103             BNE.N    ??Mem_PoolBlkFree_1
   1900                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   0000001A   0xF242 0x7011      MOVW     R0,#+10001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
   1901                  return;
   \   00000020   0xE076             B.N      ??Mem_PoolBlkFree_2
   1902              }
   1903          
   1904              if (pmem_blk == (void *)0) {
   \                     ??Mem_PoolBlkFree_1:
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD103             BNE.N    ??Mem_PoolBlkFree_3
   1905                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   00000026   0xF242 0x7011      MOVW     R0,#+10001
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
   1906                  return;
   \   0000002C   0xE070             B.N      ??Mem_PoolBlkFree_2
   1907              }
   1908          #endif
   1909          
   1910              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkFree_3:
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x4682             MOV      R10,R0
   1911          
   1912          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1913              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD006             BEQ.N    ??Mem_PoolBlkFree_4
   1914                  CPU_CRITICAL_EXIT();
   \   0000003C   0x4650             MOV      R0,R10
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   1915                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \   00000042   0xF242 0x7088      MOVW     R0,#+10120
   \   00000046   0x8030             STRH     R0,[R6, #+0]
   1916                  return;
   \   00000048   0xE062             B.N      ??Mem_PoolBlkFree_2
   1917              }
   1918          
   1919              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   \                     ??Mem_PoolBlkFree_4:
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       Mem_PoolBlkIsValidAddr
   \   00000052   0x4680             MOV      R8,R0
   1920              if (addr_valid != DEF_OK) {
   \   00000054   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000058   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000005C   0xD006             BEQ.N    ??Mem_PoolBlkFree_5
   1921                  CPU_CRITICAL_EXIT();
   \   0000005E   0x4650             MOV      R0,R10
   \   00000060   0x.... 0x....      BL       CPU_SR_Restore
   1922                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \   00000064   0xF242 0x7097      MOVW     R0,#+10135
   \   00000068   0x8030             STRH     R0,[R6, #+0]
   1923                  return;
   \   0000006A   0xE051             B.N      ??Mem_PoolBlkFree_2
   1924              }
   1925          
   1926              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   \                     ??Mem_PoolBlkFree_5:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4681             MOV      R9,R0
   \                     ??Mem_PoolBlkFree_6:
   \   00000070   0x6A60             LDR      R0,[R4, #+36]
   \   00000072   0x4581             CMP      R9,R0
   \   00000074   0xD20E             BCS.N    ??Mem_PoolBlkFree_7
   1927                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   \   00000076   0x6A20             LDR      R0,[R4, #+32]
   \   00000078   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   0000007C   0x4285             CMP      R5,R0
   \   0000007E   0xD106             BNE.N    ??Mem_PoolBlkFree_8
   1928                      CPU_CRITICAL_EXIT();
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
   1929                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   \   00000086   0xF242 0x7098      MOVW     R0,#+10136
   \   0000008A   0x8030             STRH     R0,[R6, #+0]
   1930                      return;
   \   0000008C   0xE040             B.N      ??Mem_PoolBlkFree_2
   1931                  }
   1932              }
   \                     ??Mem_PoolBlkFree_8:
   \   0000008E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000092   0xE7ED             B.N      ??Mem_PoolBlkFree_6
   1933          #endif
   1934          
   1935              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
   \                     ??Mem_PoolBlkFree_7:
   \   00000094   0x6A60             LDR      R0,[R4, #+36]
   \   00000096   0x6AE1             LDR      R1,[R4, #+44]
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD306             BCC.N    ??Mem_PoolBlkFree_9
   1936                  CPU_CRITICAL_EXIT();
   \   0000009C   0x4650             MOV      R0,R10
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
   1937                 *perr = LIB_MEM_ERR_POOL_FULL;
   \   000000A2   0xF242 0x70DD      MOVW     R0,#+10205
   \   000000A6   0x8030             STRH     R0,[R6, #+0]
   1938                  return;
   \   000000A8   0xE032             B.N      ??Mem_PoolBlkFree_2
   1939              }
   1940          
   1941                                                                              /* ------------- FREE MEM BLK TO POOL ------------- */
   1942              addr_valid = DEF_NO;
   \                     ??Mem_PoolBlkFree_9:
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x4680             MOV      R8,R0
   1943              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
   \   000000AE   0x6A60             LDR      R0,[R4, #+36]
   \   000000B0   0x4681             MOV      R9,R0
   \                     ??Mem_PoolBlkFree_10:
   \   000000B2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B4   0x4581             CMP      R9,R0
   \   000000B6   0xD20B             BCS.N    ??Mem_PoolBlkFree_11
   1944                  p_addr = pmem_pool->PoolPtrs[i];
   \   000000B8   0x6A20             LDR      R0,[R4, #+32]
   \   000000BA   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   000000BE   0x0007             MOVS     R7,R0
   1945                  if (p_addr == pmem_blk) {
   \   000000C0   0x42AF             CMP      R7,R5
   \   000000C2   0xD102             BNE.N    ??Mem_PoolBlkFree_12
   1946                      addr_valid = DEF_YES;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x4680             MOV      R8,R0
   1947                      break;
   \   000000C8   0xE002             B.N      ??Mem_PoolBlkFree_11
   1948                  }
   1949              }
   \                     ??Mem_PoolBlkFree_12:
   \   000000CA   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000CE   0xE7F0             B.N      ??Mem_PoolBlkFree_10
   1950                                                                              /* Swap addr of mem blk to free in tbl.             */
   1951              if (addr_valid == DEF_YES) {
   \                     ??Mem_PoolBlkFree_11:
   \   000000D0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D4   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000D8   0xD114             BNE.N    ??Mem_PoolBlkFree_13
   1952                  pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   \   000000DA   0x6A60             LDR      R0,[R4, #+36]
   \   000000DC   0x6A21             LDR      R1,[R4, #+32]
   \   000000DE   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   000000E2   0x6A21             LDR      R1,[R4, #+32]
   \   000000E4   0xF841 0x0029      STR      R0,[R1, R9, LSL #+2]
   1953              } else {
   1954          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1955                  CPU_CRITICAL_EXIT();
   1956                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1957                  return;
   1958          #endif
   1959              }
   1960          
   1961                                                                              /* Free mem blk.                                    */
   1962              pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
   \   000000E8   0x6A60             LDR      R0,[R4, #+36]
   \   000000EA   0x6A21             LDR      R1,[R4, #+32]
   \   000000EC   0xF841 0x5020      STR      R5,[R1, R0, LSL #+2]
   1963              pmem_pool->BlkIx++;
   \   000000F0   0x6A60             LDR      R0,[R4, #+36]
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0x6260             STR      R0,[R4, #+36]
   1964          
   1965              CPU_CRITICAL_EXIT();
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
   1966          
   1967             *perr = LIB_MEM_ERR_NONE;
   \   000000FC   0xF242 0x7010      MOVW     R0,#+10000
   \   00000100   0x8030             STRH     R0,[R6, #+0]
   1968          }
   \   00000102   0xE005             B.N      ??Mem_PoolBlkFree_2
   \                     ??Mem_PoolBlkFree_13:
   \   00000104   0x4650             MOV      R0,R10
   \   00000106   0x.... 0x....      BL       CPU_SR_Restore
   \   0000010A   0xF242 0x7088      MOVW     R0,#+10120
   \   0000010E   0x8030             STRH     R0,[R6, #+0]
   \                     ??Mem_PoolBlkFree_2:
   \   00000110   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1969          #endif
   1970          
   1971          
   1972          /*$PAGE*/
   1973          /*
   1974          *********************************************************************************************************
   1975          *                                          Mem_PoolBlkIxGet()
   1976          *
   1977          * Description : Get temporary index of a memory block in a memory pool.
   1978          *
   1979          * Argument(s) : pmem_pool   Pointer to memory pool.
   1980          *
   1981          *               pmem_blk    Pointer to memory block to get index for.
   1982          *
   1983          *               perr        Pointer to variable that will receive the return error code from this function :
   1984          *
   1985          *                               LIB_MEM_ERR_NONE                        Memory block successfully freed.
   1986          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1987          *                                                                           memory pool.
   1988          *
   1989          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1990          *                                                                           a NULL pointer.
   1991          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1992          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1993          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1994          *                                                                            in memory pool.
   1995          *
   1996          * Return(s)   : Index of the memory block.
   1997          *
   1998          * Caller(s)   : Application.
   1999          *
   2000          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2001          *
   2002          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   2003          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   2004          *                   lock to avoid the index to be modified.
   2005          *********************************************************************************************************
   2006          */
   2007          /*$PAGE*/
   2008          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2009          MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
   2010                                         void      *pmem_blk,
   2011                                         LIB_ERR   *perr)
   2012          {
   \                     Mem_PoolBlkIxGet:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2013              void         *p_addr;
   2014              CPU_BOOLEAN   addr_valid;
   2015              MEM_POOL_IX   i;
   2016              MEM_POOL_IX   pool_ix;
   2017              MEM_POOL_IX   invalid_ix;
   2018              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   2019          
   2020          
   2021              invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
   \   0000000E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000012   0x4683             MOV      R11,R0
   2022          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   2023              if (perr == (LIB_ERR *)0) {
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??Mem_PoolBlkIxGet_0
   2024                  CPU_SW_EXCEPTION(invalid_ix);
   \   00000018   0x.... 0x....      BL       CPU_SW_Exception
   2025              }
   2026          #endif
   2027          
   2028                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   2029          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   2030              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolBlkIxGet_0:
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??Mem_PoolBlkIxGet_1
   2031                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   00000020   0xF242 0x7011      MOVW     R0,#+10001
   \   00000024   0x8030             STRH     R0,[R6, #+0]
   2032                  return (invalid_ix);
   \   00000026   0x4658             MOV      R0,R11
   \   00000028   0xE071             B.N      ??Mem_PoolBlkIxGet_2
   2033              }
   2034          
   2035              if (pmem_blk == (void *)0) {
   \                     ??Mem_PoolBlkIxGet_1:
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD104             BNE.N    ??Mem_PoolBlkIxGet_3
   2036                 *perr = LIB_MEM_ERR_NULL_PTR;
   \   0000002E   0xF242 0x7011      MOVW     R0,#+10001
   \   00000032   0x8030             STRH     R0,[R6, #+0]
   2037                  return (invalid_ix);
   \   00000034   0x4658             MOV      R0,R11
   \   00000036   0xE06A             B.N      ??Mem_PoolBlkIxGet_2
   2038              }
   2039          #endif
   2040          
   2041              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkIxGet_3:
   \   00000038   0x.... 0x....      BL       CPU_SR_Save
   \   0000003C   0x4681             MOV      R9,R0
   2042          
   2043          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2044              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x....             LDR.N    R1,??DataTable10_4  ;; 0x4c4f4f50
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD007             BEQ.N    ??Mem_PoolBlkIxGet_4
   2045                  CPU_CRITICAL_EXIT();
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
   2046                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \   0000004C   0xF242 0x7088      MOVW     R0,#+10120
   \   00000050   0x8030             STRH     R0,[R6, #+0]
   2047                  return(invalid_ix);
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0xE05B             B.N      ??Mem_PoolBlkIxGet_2
   2048              }
   2049          
   2050              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   \                     ??Mem_PoolBlkIxGet_4:
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       Mem_PoolBlkIsValidAddr
   \   0000005E   0x0007             MOVS     R7,R0
   2051              if (addr_valid != DEF_OK) {
   \   00000060   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000062   0x2F01             CMP      R7,#+1
   \   00000064   0xD007             BEQ.N    ??Mem_PoolBlkIxGet_5
   2052                  CPU_CRITICAL_EXIT();
   \   00000066   0x4648             MOV      R0,R9
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
   2053                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \   0000006C   0xF242 0x7097      MOVW     R0,#+10135
   \   00000070   0x8030             STRH     R0,[R6, #+0]
   2054                  return (invalid_ix);
   \   00000072   0x4658             MOV      R0,R11
   \   00000074   0xE04B             B.N      ??Mem_PoolBlkIxGet_2
   2055              }
   2056          
   2057              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   \                     ??Mem_PoolBlkIxGet_5:
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x4682             MOV      R10,R0
   \                     ??Mem_PoolBlkIxGet_6:
   \   0000007A   0x6A60             LDR      R0,[R4, #+36]
   \   0000007C   0x4582             CMP      R10,R0
   \   0000007E   0xD20F             BCS.N    ??Mem_PoolBlkIxGet_7
   2058                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   \   00000080   0x6A20             LDR      R0,[R4, #+32]
   \   00000082   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   00000086   0x4285             CMP      R5,R0
   \   00000088   0xD107             BNE.N    ??Mem_PoolBlkIxGet_8
   2059                      CPU_CRITICAL_EXIT();
   \   0000008A   0x4648             MOV      R0,R9
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
   2060                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   \   00000090   0xF242 0x7098      MOVW     R0,#+10136
   \   00000094   0x8030             STRH     R0,[R6, #+0]
   2061                      return (invalid_ix);
   \   00000096   0x4658             MOV      R0,R11
   \   00000098   0xE039             B.N      ??Mem_PoolBlkIxGet_2
   2062                  }
   2063              }
   \                     ??Mem_PoolBlkIxGet_8:
   \   0000009A   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000009E   0xE7EC             B.N      ??Mem_PoolBlkIxGet_6
   2064          #endif
   2065          
   2066              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
   \                     ??Mem_PoolBlkIxGet_7:
   \   000000A0   0x6A60             LDR      R0,[R4, #+36]
   \   000000A2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD307             BCC.N    ??Mem_PoolBlkIxGet_9
   2067                  CPU_CRITICAL_EXIT();
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
   2068                 *perr = LIB_MEM_ERR_POOL_FULL;
   \   000000AE   0xF242 0x70DD      MOVW     R0,#+10205
   \   000000B2   0x8030             STRH     R0,[R6, #+0]
   2069                  return (invalid_ix);
   \   000000B4   0x4658             MOV      R0,R11
   \   000000B6   0xE02A             B.N      ??Mem_PoolBlkIxGet_2
   2070              }
   2071          
   2072              addr_valid = DEF_NO;
   \                     ??Mem_PoolBlkIxGet_9:
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x0007             MOVS     R7,R0
   2073              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
   \   000000BC   0x6A60             LDR      R0,[R4, #+36]
   \   000000BE   0x4682             MOV      R10,R0
   \                     ??Mem_PoolBlkIxGet_10:
   \   000000C0   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C2   0x4582             CMP      R10,R0
   \   000000C4   0xD20C             BCS.N    ??Mem_PoolBlkIxGet_11
   2074                  p_addr = pmem_pool->PoolPtrs[i];
   \   000000C6   0x6A20             LDR      R0,[R4, #+32]
   \   000000C8   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   2075                  if (p_addr == pmem_blk) {
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0x42A8             CMP      R0,R5
   \   000000D2   0xD102             BNE.N    ??Mem_PoolBlkIxGet_12
   2076                      addr_valid = DEF_YES;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x0007             MOVS     R7,R0
   2077                      break;
   \   000000D8   0xE002             B.N      ??Mem_PoolBlkIxGet_11
   2078                  }
   2079              }
   \                     ??Mem_PoolBlkIxGet_12:
   \   000000DA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000DE   0xE7EF             B.N      ??Mem_PoolBlkIxGet_10
   2080                                                                              /* Return ix of mem blk in tbl.                     */
   2081              if (addr_valid == DEF_YES) {
   \                     ??Mem_PoolBlkIxGet_11:
   \   000000E0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E2   0x2F01             CMP      R7,#+1
   \   000000E4   0xD10C             BNE.N    ??Mem_PoolBlkIxGet_13
   2082                  pool_ix = pmem_pool->BlkNbr - 1 - i;
   \   000000E6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E8   0x1E40             SUBS     R0,R0,#+1
   \   000000EA   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   000000EE   0x4680             MOV      R8,R0
   2083                  CPU_CRITICAL_EXIT();
   \   000000F0   0x4648             MOV      R0,R9
   \   000000F2   0x.... 0x....      BL       CPU_SR_Restore
   2084                 *perr = LIB_MEM_ERR_NONE;
   \   000000F6   0xF242 0x7010      MOVW     R0,#+10000
   \   000000FA   0x8030             STRH     R0,[R6, #+0]
   2085                  return (pool_ix);
   \   000000FC   0x4640             MOV      R0,R8
   \   000000FE   0xE006             B.N      ??Mem_PoolBlkIxGet_2
   2086              } else {
   2087                  CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolBlkIxGet_13:
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x.... 0x....      BL       CPU_SR_Restore
   2088                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \   00000106   0xF242 0x7088      MOVW     R0,#+10120
   \   0000010A   0x8030             STRH     R0,[R6, #+0]
   2089                  return (invalid_ix);
   \   0000010C   0x4658             MOV      R0,R11
   \                     ??Mem_PoolBlkIxGet_2:
   \   0000010E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2090              }
   2091          
   2092          }
   2093          #endif
   2094          
   2095          
   2096          /*$PAGE*/
   2097          /*
   2098          *********************************************************************************************************
   2099          *********************************************************************************************************
   2100          *                                           LOCAL FUNCTIONS
   2101          *********************************************************************************************************
   2102          *********************************************************************************************************
   2103          */
   2104          
   2105          /*
   2106          *********************************************************************************************************
   2107          *                                      Mem_PoolBlkIsValidAddr()
   2108          *
   2109          * Description : Calculates if a given memory block address is valid for the memory pool.
   2110          *
   2111          * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
   2112          *               ---------   Argument validated in Mem_PoolBlkFree().
   2113          *
   2114          *               pmem_blk    Pointer to memory block address to validate.
   2115          *               --------    Argument validated in Mem_PoolBlkFree().
   2116          *
   2117          * Return(s)   : DEF_YES, if valid memory pool block address.
   2118          *
   2119          *               DEF_NO,  otherwise.
   2120          *
   2121          * Caller(s)   : Mem_PoolBlkFree().
   2122          *
   2123          * Note(s)     : none.
   2124          *********************************************************************************************************
   2125          */
   2126          
   2127          #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
   2128               (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))

   \                                 In section .text, align 2, keep-with-next
   2129          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
   2130                                                       void      *pmem_blk)
   2131          {
   \                     Mem_PoolBlkIsValidAddr:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0003             MOVS     R3,R0
   2132              CPU_INT08U   *ppool_addr_first;
   2133              void         *ppool_addr_start;
   2134              void         *ppool_addr_end;
   2135              CPU_SIZE_T    align_offset;
   2136              CPU_SIZE_T    blk_align;
   2137              CPU_SIZE_T    blk_align_offset;
   2138              CPU_SIZE_T    blk_size;
   2139              CPU_SIZE_T    mem_align;
   2140              CPU_SIZE_T    mem_align_offset;
   2141              CPU_SIZE_T    mem_diff;
   2142              CPU_BOOLEAN   addr_valid;
   2143          
   2144          
   2145              ppool_addr_start = pmem_pool->PoolAddrStart;
   \   00000006   0x6998             LDR      R0,[R3, #+24]
   \   00000008   0x0004             MOVS     R4,R0
   2146              ppool_addr_end   = pmem_pool->PoolAddrEnd;
   \   0000000A   0x69D8             LDR      R0,[R3, #+28]
   \   0000000C   0x4683             MOV      R11,R0
   2147          
   2148              if ((pmem_blk < ppool_addr_start) ||
   2149                  (pmem_blk > ppool_addr_end)) {
   \   0000000E   0x42A1             CMP      R1,R4
   \   00000010   0xD301             BCC.N    ??Mem_PoolBlkIsValidAddr_0
   \   00000012   0x458B             CMP      R11,R1
   \   00000014   0xD201             BCS.N    ??Mem_PoolBlkIsValidAddr_1
   2150                  return (DEF_NO);
   \                     ??Mem_PoolBlkIsValidAddr_0:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE032             B.N      ??Mem_PoolBlkIsValidAddr_2
   2151              }
   2152          
   2153              blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
   \                     ??Mem_PoolBlkIsValidAddr_1:
   \   0000001A   0x6B58             LDR      R0,[R3, #+52]
   \   0000001C   0x0002             MOVS     R2,R0
   2154              align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
   \   0000001E   0x0010             MOVS     R0,R2
   \   00000020   0xFBB4 0xFAF0      UDIV     R10,R4,R0
   \   00000024   0xFB00 0x401A      MLS      R0,R0,R10,R4
   \   00000028   0x0005             MOVS     R5,R0
   2155              if (align_offset != 0u) {
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD002             BEQ.N    ??Mem_PoolBlkIsValidAddr_3
   2156                  mem_align_offset = blk_align - align_offset;
   \   0000002E   0x1B50             SUBS     R0,R2,R5
   \   00000030   0x4686             MOV      LR,R0
   \   00000032   0xE001             B.N      ??Mem_PoolBlkIsValidAddr_4
   2157              } else {
   2158                  mem_align_offset = 0u;
   \                     ??Mem_PoolBlkIsValidAddr_3:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4686             MOV      LR,R0
   2159              }
   2160          
   2161              blk_size     = pmem_pool->BlkSize;
   \                     ??Mem_PoolBlkIsValidAddr_4:
   \   00000038   0x6B18             LDR      R0,[R3, #+48]
   \   0000003A   0x0007             MOVS     R7,R0
   2162              align_offset = blk_size % blk_align;
   \   0000003C   0xFBB7 0xF0F2      UDIV     R0,R7,R2
   \   00000040   0xFB02 0x7010      MLS      R0,R2,R0,R7
   \   00000044   0x0005             MOVS     R5,R0
   2163              if (align_offset != 0u) {
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD002             BEQ.N    ??Mem_PoolBlkIsValidAddr_5
   2164                  blk_align_offset = blk_align - align_offset;
   \   0000004A   0x1B50             SUBS     R0,R2,R5
   \   0000004C   0x0006             MOVS     R6,R0
   \   0000004E   0xE001             B.N      ??Mem_PoolBlkIsValidAddr_6
   2165              } else {
   2166                  blk_align_offset = 0u;
   \                     ??Mem_PoolBlkIsValidAddr_5:
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0006             MOVS     R6,R0
   2167              }
   2168          
   2169              ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
   \                     ??Mem_PoolBlkIsValidAddr_6:
   \   00000054   0xEB1E 0x0A04      ADDS     R10,LR,R4
   \   00000058   0xF8CD 0xA000      STR      R10,[SP, #+0]
   2170              mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x1A08             SUBS     R0,R1,R0
   \   00000060   0x4680             MOV      R8,R0
   2171              mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
   \   00000062   0x19F0             ADDS     R0,R6,R7
   \   00000064   0x4684             MOV      R12,R0
   2172          
   2173              addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
   \   00000066   0xFBB8 0xF0FC      UDIV     R0,R8,R12
   \   0000006A   0xFB0C 0x8010      MLS      R0,R12,R0,R8
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD102             BNE.N    ??Mem_PoolBlkIsValidAddr_7
   \   00000072   0xF05F 0x0901      MOVS     R9,#+1
   \   00000076   0xE001             B.N      ??Mem_PoolBlkIsValidAddr_8
   \                     ??Mem_PoolBlkIsValidAddr_7:
   \   00000078   0xF05F 0x0900      MOVS     R9,#+0
   2174          
   2175              return (addr_valid);
   \                     ??Mem_PoolBlkIsValidAddr_8:
   \   0000007C   0x4648             MOV      R0,R9
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Mem_PoolBlkIsValidAddr_2:
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2176          }
   2177          #endif
   2178          
   2179          
   2180          /*$PAGE*/
   2181          /*
   2182          *********************************************************************************************************
   2183          *                                        Mem_SegCalcTotSize()
   2184          *
   2185          * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
   2186          *
   2187          *
   2188          *                       -----                     ======================  ---
   2189          *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
   2190          *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
   2191          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
   2192          *                         |                       |  /  /  /  /  /  /  |   v
   2193          *                         |                       ======================  ---
   2194          *                         |                       |                    |   ^
   2195          *                         |                       |                    |   |
   2196          *                         |                       |     Mem Blk #1     |   |        Blk Size
   2197          *                         |                       |                    |   |     (see Note #1c)
   2198          *                         |                       |                    |   v
   2199          *                         |                       ----------------------  ---
   2200          *                         |                       |  /  /  /  /  /  /  |   ^
   2201          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2202          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2203          *                         |                       |  /  /  /  /  /  /  |   v
   2204          *                         |                       ======================  ---
   2205          *                                                 |         .          |
   2206          *                     Total Size                  |         .          |
   2207          *                   (see Note #2c)                |         .          |
   2208          *                                                 ======================  ---
   2209          *                         |                       |                    |   ^
   2210          *                         |                       |                    |   |
   2211          *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
   2212          *                         |                       |                    |   |     (see Note #1c)
   2213          *                         |                       |                    |   v
   2214          *                         |                       ----------------------  ---
   2215          *                         |                       |  /  /  /  /  /  /  |   ^
   2216          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2217          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2218          *                         |                       |  /  /  /  /  /  /  |   v
   2219          *                         |                       ======================  ---
   2220          *                         |                       |                    |   ^
   2221          *                         |                       |                    |   |
   2222          *                         |                       |     Mem Blk #N     |   |        Blk Size
   2223          *                         |                       |                    |   |     (see Note #1c)
   2224          *                         v                       |                    |   v
   2225          *                       -----                     ======================  ---
   2226          *
   2227          *               where
   2228          *
   2229          *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
   2230          *
   2231          *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
   2232          *
   2233          *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
   2234          *
   2235          *                   (d) Align               Required block memory alignment     ('blk_align')
   2236          *
   2237          *                   (e) Mem Align Offset    Offset required to align first memory block
   2238          *
   2239          *                   (f) Blk Align Offset    Offset required to align every memory block
   2240          *
   2241          *
   2242          *               (2) The total size is calculated based on the following equations :
   2243          *
   2244          *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
   2245          *                   (a) Mem Align Offset  =  {
   2246          *                                            { (2) 0                          , if memory address is     aligned
   2247          *
   2248          *
   2249          *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
   2250          *                   (b) Blk Align Offset  =  {
   2251          *                                            { (2) 0                          , if memory block   is     aligned
   2252          *
   2253          *
   2254          *                   (c) Total Size        =   Mem Align Offset
   2255          *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
   2256          *                                         +   Blk Size
   2257          *
   2258          *
   2259          * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
   2260          *
   2261          *               blk_nbr     Number of memory blocks to allocate.
   2262          *               -------     Argument checked in Mem_HeapAlloc(),
   2263          *                                               Mem_PoolCreate().
   2264          *
   2265          *               blk_size    Size   of memory block  to allocate.
   2266          *               --------    Argument checked in Mem_HeapAlloc(),
   2267          *                                               Mem_PoolCreate().
   2268          *
   2269          *               blk_align   Required block word-boundary memory alignment (in octets).
   2270          *               ---------   Argument checked in Mem_HeapAlloc(),
   2271          *                                               Mem_PoolCreate().
   2272          *
   2273          * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
   2274          *
   2275          *               0,                                                                  otherwise.
   2276          *$PAGE*
   2277          * Caller(s)   : Mem_HeapAlloc(),
   2278          *               Mem_PoolCreate().
   2279          *
   2280          * Note(s)     : none.
   2281          *********************************************************************************************************
   2282          */
   2283          
   2284          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2285          static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
   2286                                                  MEM_POOL_BLK_QTY   blk_nbr,
   2287                                                  CPU_SIZE_T         blk_size,
   2288                                                  CPU_SIZE_T         blk_align)
   2289          {
   \                     Mem_SegCalcTotSize:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   2290          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2291              CPU_SIZE_T  blk_size_mem_aligned;
   2292              CPU_SIZE_T  blk_size_aligned;
   2293              CPU_SIZE_T  blk_size_aligned_nbr;
   2294              CPU_SIZE_T  blk_size_tot;
   2295          #endif
   2296              CPU_SIZE_T  align_offset;
   2297              CPU_SIZE_T  mem_align_offset;
   2298              CPU_SIZE_T  blk_align_offset;
   2299              CPU_SIZE_T  size_tot;
   2300          
   2301                                                                              /* Calc mem align (see Note #2a).                   */
   2302              align_offset = (CPU_ADDR)pmem_addr % blk_align;
   \   00000006   0x4658             MOV      R0,R11
   \   00000008   0xFBB0 0xFAF3      UDIV     R10,R0,R3
   \   0000000C   0xFB03 0x001A      MLS      R0,R3,R10,R0
   \   00000010   0x4684             MOV      R12,R0
   2303              if (align_offset != 0u) {
   \   00000012   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000016   0xD003             BEQ.N    ??Mem_SegCalcTotSize_0
   2304                  mem_align_offset = blk_align - align_offset;
   \   00000018   0xEBB3 0x000C      SUBS     R0,R3,R12
   \   0000001C   0x4686             MOV      LR,R0
   \   0000001E   0xE001             B.N      ??Mem_SegCalcTotSize_1
   2305              } else {
   2306                  mem_align_offset = 0u;
   \                     ??Mem_SegCalcTotSize_0:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4686             MOV      LR,R0
   2307              }
   2308                                                                              /* Calc blk align (see Note #2b).                   */
   2309              align_offset = blk_size % blk_align;
   \                     ??Mem_SegCalcTotSize_1:
   \   00000024   0xFBB2 0xF0F3      UDIV     R0,R2,R3
   \   00000028   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   0000002C   0x4684             MOV      R12,R0
   2310              if (align_offset != 0u) {
   \   0000002E   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000032   0xD003             BEQ.N    ??Mem_SegCalcTotSize_2
   2311                  blk_align_offset = blk_align - align_offset;
   \   00000034   0xEBB3 0x000C      SUBS     R0,R3,R12
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0xE001             B.N      ??Mem_SegCalcTotSize_3
   2312              } else {
   2313                  blk_align_offset = 0u;
   \                     ??Mem_SegCalcTotSize_2:
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4680             MOV      R8,R0
   2314              }
   2315                                                                              /* Calc tot size  (see Note #2c).                   */
   2316              size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
   \                     ??Mem_SegCalcTotSize_3:
   \   00000040   0xEB18 0x0002      ADDS     R0,R8,R2
   \   00000044   0xF1B1 0x0A01      SUBS     R10,R1,#+1
   \   00000048   0xFB0A 0xE000      MLA      R0,R10,R0,LR
   \   0000004C   0x1810             ADDS     R0,R2,R0
   \   0000004E   0x4681             MOV      R9,R0
   2317          
   2318          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
   2319              blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
   \   00000050   0xEB12 0x000E      ADDS     R0,R2,LR
   \   00000054   0x0004             MOVS     R4,R0
   2320              if ((blk_size_mem_aligned < mem_align_offset) ||
   2321                  (blk_size_mem_aligned < blk_size)) {
   \   00000056   0x4574             CMP      R4,LR
   \   00000058   0xD301             BCC.N    ??Mem_SegCalcTotSize_4
   \   0000005A   0x4294             CMP      R4,R2
   \   0000005C   0xD201             BCS.N    ??Mem_SegCalcTotSize_5
   2322                  return (0u);
   \                     ??Mem_SegCalcTotSize_4:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE027             B.N      ??Mem_SegCalcTotSize_6
   2323              }
   2324          
   2325              if (blk_nbr > 1) {
   \                     ??Mem_SegCalcTotSize_5:
   \   00000062   0x2902             CMP      R1,#+2
   \   00000064   0xD324             BCC.N    ??Mem_SegCalcTotSize_7
   2326                  blk_size_aligned = blk_size + blk_align_offset;
   \   00000066   0xEB18 0x0002      ADDS     R0,R8,R2
   \   0000006A   0x0005             MOVS     R5,R0
   2327                  if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
   2328                      (blk_size_aligned < blk_size)) {
   \   0000006C   0x4545             CMP      R5,R8
   \   0000006E   0xD301             BCC.N    ??Mem_SegCalcTotSize_8
   \   00000070   0x4295             CMP      R5,R2
   \   00000072   0xD201             BCS.N    ??Mem_SegCalcTotSize_9
   2329                      return (0u);
   \                     ??Mem_SegCalcTotSize_8:
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE01C             B.N      ??Mem_SegCalcTotSize_6
   2330                  }
   2331          
   2332                  blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
   \                     ??Mem_SegCalcTotSize_9:
   \   00000078   0x1E48             SUBS     R0,R1,#+1
   \   0000007A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000007E   0x0006             MOVS     R6,R0
   2333                  if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
   2334                      (blk_size_aligned_nbr < blk_align_offset) ||
   2335                      (blk_size_aligned_nbr < blk_size)) {
   \   00000080   0x42AE             CMP      R6,R5
   \   00000082   0xD303             BCC.N    ??Mem_SegCalcTotSize_10
   \   00000084   0x4546             CMP      R6,R8
   \   00000086   0xD301             BCC.N    ??Mem_SegCalcTotSize_10
   \   00000088   0x4296             CMP      R6,R2
   \   0000008A   0xD201             BCS.N    ??Mem_SegCalcTotSize_11
   2336                      return (0u);
   \                     ??Mem_SegCalcTotSize_10:
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE010             B.N      ??Mem_SegCalcTotSize_6
   2337                  }
   2338          
   2339                  blk_size_tot = blk_size_aligned_nbr + blk_size;
   \                     ??Mem_SegCalcTotSize_11:
   \   00000090   0x1990             ADDS     R0,R2,R6
   \   00000092   0x0007             MOVS     R7,R0
   2340                  if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
   2341                      (blk_size_tot < blk_size)) {
   \   00000094   0x42B7             CMP      R7,R6
   \   00000096   0xD301             BCC.N    ??Mem_SegCalcTotSize_12
   \   00000098   0x4297             CMP      R7,R2
   \   0000009A   0xD201             BCS.N    ??Mem_SegCalcTotSize_13
   2342                      return (0u);
   \                     ??Mem_SegCalcTotSize_12:
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE008             B.N      ??Mem_SegCalcTotSize_6
   2343                  }
   2344          
   2345                  if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
   2346                      (size_tot < blk_size_aligned_nbr) ||
   2347                      (size_tot < blk_size_tot)) {
   \                     ??Mem_SegCalcTotSize_13:
   \   000000A0   0x45A1             CMP      R9,R4
   \   000000A2   0xD303             BCC.N    ??Mem_SegCalcTotSize_14
   \   000000A4   0x45B1             CMP      R9,R6
   \   000000A6   0xD301             BCC.N    ??Mem_SegCalcTotSize_14
   \   000000A8   0x45B9             CMP      R9,R7
   \   000000AA   0xD201             BCS.N    ??Mem_SegCalcTotSize_7
   2348                      return (0u);
   \                     ??Mem_SegCalcTotSize_14:
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE000             B.N      ??Mem_SegCalcTotSize_6
   2349                  }
   2350              }
   2351          #endif
   2352          
   2353              return (size_tot);
   \                     ??Mem_SegCalcTotSize_7:
   \   000000B0   0x4648             MOV      R0,R9
   \                     ??Mem_SegCalcTotSize_6:
   \   000000B2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2354          }
   2355          #endif
   2356          
   2357          
   2358          /*$PAGE*/
   2359          /*
   2360          *********************************************************************************************************
   2361          *                                           Mem_SegAlloc()
   2362          *
   2363          * Description : Allocates memory from specific segment.
   2364          *
   2365          * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
   2366          *               ---------   Argument validated in Mem_HeapAlloc(),
   2367          *                                                 Mem_PoolCreate().
   2368          *
   2369          *               size        Size of memory to allocate.
   2370          *               ----        Argument validated in Mem_HeapAlloc(),
   2371          *                                                 Mem_PoolCreate().
   2372          *
   2373          *               align       Required starting word-boundary memory alignment (in octets).
   2374          *               -----       Argument validated in Mem_HeapAlloc(),
   2375          *                                                 Mem_PoolCreate().
   2376          *
   2377          * Return(s)   : Pointer to allocated memory, if NO error(s).
   2378          *
   2379          *               Pointer to NULL,             otherwise.
   2380          *
   2381          * Caller(s)   : Mem_HeapAlloc(),
   2382          *               Mem_PoolCreate().
   2383          *
   2384          * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
   2385          *
   2386          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2387          *
   2388          *                   (a) However, this function is already called within critical sections.
   2389          *********************************************************************************************************
   2390          */
   2391          
   2392          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2393          static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
   2394                                       CPU_SIZE_T   size,
   2395                                       CPU_SIZE_T   align)
   2396          {
   \                     Mem_SegAlloc:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
   2397              CPU_INT08U  *pmem_addr;
   2398              CPU_INT08U  *pmem_addr_next;
   2399              CPU_SIZE_T   mem_align;
   2400              CPU_SIZE_T   align_offset;
   2401              CPU_SIZE_T   size_tot;
   2402          
   2403          
   2404              pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
   \   00000004   0x6BD8             LDR      R0,[R3, #+60]
   \   00000006   0x0004             MOVS     R4,R0
   2405          
   2406              mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
   \   00000008   0xFBB4 0xF0F2      UDIV     R0,R4,R2
   \   0000000C   0xFB02 0x4010      MLS      R0,R2,R0,R4
   \   00000010   0x0006             MOVS     R6,R0
   2407          
   2408              if (mem_align != 0u) {
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD002             BEQ.N    ??Mem_SegAlloc_0
   2409                  align_offset = align - mem_align;
   \   00000016   0x1B90             SUBS     R0,R2,R6
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0xE001             B.N      ??Mem_SegAlloc_1
   2410              } else {
   2411                  align_offset = 0u;
   \                     ??Mem_SegAlloc_0:
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0007             MOVS     R7,R0
   2412              }
   2413          
   2414              size_tot = align_offset + size;
   \                     ??Mem_SegAlloc_1:
   \   00000020   0x19C8             ADDS     R0,R1,R7
   \   00000022   0x4684             MOV      R12,R0
   2415              if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
   \   00000024   0x6C58             LDR      R0,[R3, #+68]
   \   00000026   0x4560             CMP      R0,R12
   \   00000028   0xD201             BCS.N    ??Mem_SegAlloc_2
   2416                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE013             B.N      ??Mem_SegAlloc_3
   2417              }
   2418          
   2419          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2420              if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
   2421                  (size_tot < size)) {
   \                     ??Mem_SegAlloc_2:
   \   0000002E   0x45BC             CMP      R12,R7
   \   00000030   0xD301             BCC.N    ??Mem_SegAlloc_4
   \   00000032   0x458C             CMP      R12,R1
   \   00000034   0xD201             BCS.N    ??Mem_SegAlloc_5
   2422                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \                     ??Mem_SegAlloc_4:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE00D             B.N      ??Mem_SegAlloc_3
   2423              }
   2424          #endif
   2425          
   2426              pmem_addr_next = pmem_addr + size_tot;
   \                     ??Mem_SegAlloc_5:
   \   0000003A   0xEB1C 0x0004      ADDS     R0,R12,R4
   \   0000003E   0x0005             MOVS     R5,R0
   2427          
   2428          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2429              if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
   \   00000040   0x42A5             CMP      R5,R4
   \   00000042   0xD201             BCS.N    ??Mem_SegAlloc_6
   2430                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE006             B.N      ??Mem_SegAlloc_3
   2431              }
   2432          #endif
   2433          
   2434              pmem_addr += align_offset;                                      /* Align mem addr.                                  */
   \                     ??Mem_SegAlloc_6:
   \   00000048   0x193C             ADDS     R4,R7,R4
   2435          
   2436              pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
   \   0000004A   0x63DD             STR      R5,[R3, #+60]
   2437              pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
   \   0000004C   0x6C58             LDR      R0,[R3, #+68]
   \   0000004E   0xEBB0 0x000C      SUBS     R0,R0,R12
   \   00000052   0x6458             STR      R0,[R3, #+68]
   2438          
   2439              return ((void *)pmem_addr);
   \   00000054   0x0020             MOVS     R0,R4
   \                     ??Mem_SegAlloc_3:
   \   00000056   0xBCF0             POP      {R4-R7}
   \   00000058   0x4770             BX       LR               ;; return
   2440          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     Mem_PoolHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x50414548         DC32     0x50414548

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Mem_Heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Mem_PoolTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x4C4F4F50         DC32     0x4c4f4f50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e
   2441          #endif
   2442          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Mem_Clr
        16   -> Mem_Set
      40   Mem_Cmp
      48   Mem_HeapAlloc
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_SW_Exception
        48   -> Mem_SegAlloc
        48   -> Mem_SegCalcTotSize
      16   Mem_HeapGetSizeRem
        16   -> Mem_SegGetSizeRem
       0   Mem_Init
      56   Mem_Move
        56   -> Mem_Copy
      32   Mem_PoolBlkFree
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_SW_Exception
        32   -> Mem_PoolBlkIsValidAddr
      24   Mem_PoolBlkGet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
      24   Mem_PoolBlkGetNbrAvail
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
      32   Mem_PoolBlkGetUsedAtIx
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_SW_Exception
      40   Mem_PoolBlkIsValidAddr
      40   Mem_PoolBlkIxGet
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_SW_Exception
        40   -> Mem_PoolBlkIsValidAddr
      16   Mem_PoolClr
        16   -> CPU_SW_Exception
     120   Mem_PoolCreate
       120   -> CPU_SR_Restore
       120   -> CPU_SR_Save
       120   -> CPU_SW_Exception
       120   -> Mem_PoolClr
       120   -> Mem_SegAlloc
       120   -> Mem_SegCalcTotSize
      16   Mem_SegAlloc
      36   Mem_SegCalcTotSize
      48   Mem_SegGetSizeRem
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_SW_Exception
      24   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
      18  Mem_Clr
     258  Mem_Cmp
   27648  Mem_Heap
     214  Mem_HeapAlloc
      24  Mem_HeapGetSizeRem
      94  Mem_Init
     250  Mem_Move
     276  Mem_PoolBlkFree
     180  Mem_PoolBlkGet
      82  Mem_PoolBlkGetNbrAvail
     168  Mem_PoolBlkGetUsedAtIx
     132  Mem_PoolBlkIsValidAddr
     274  Mem_PoolBlkIxGet
     108  Mem_PoolClr
    1004  Mem_PoolCreate
      72  Mem_PoolHeap
       4  Mem_PoolTbl
      90  Mem_SegAlloc
     182  Mem_SegCalcTotSize
     198  Mem_SegGetSizeRem
     124  Mem_Set

 
 27 724 bytes in section .bss
  3 700 bytes in section .text
 
  3 700 bytes of CODE memory
 27 724 bytes of DATA memory

Errors: none
Warnings: none

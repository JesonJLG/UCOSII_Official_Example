###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:23 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_fsmc.c                   #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_fsmc.c" -D               #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_fsmc.lst           #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_fsmc.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_fsmc.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_fsmc.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the FSMC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_fsmc.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* --------------------- FSMC registers bit mask ---------------------------- */
     23          /* FSMC BCRx Mask */
     24          #define BCR_MBKEN_Set                       ((u32)0x00000001)
     25          #define BCR_MBKEN_Reset                     ((u32)0x000FFFFE)
     26          #define BCR_FACCEN_Set                      ((u32)0x00000040)
     27          
     28          /* FSMC PCRx Mask */
     29          #define PCR_PBKEN_Set                       ((u32)0x00000004)
     30          #define PCR_PBKEN_Reset                     ((u32)0x000FFFFB)
     31          #define PCR_ECCEN_Set                       ((u32)0x00000040)
     32          #define PCR_ECCEN_Reset                     ((u32)0x000FFFBF)
     33          #define PCR_MemoryType_NAND                 ((u32)0x00000008)
     34          
     35          /* Private macro -------------------------------------------------------------*/
     36          /* Private variables ---------------------------------------------------------*/
     37          /* Private function prototypes -----------------------------------------------*/
     38          /* Private functions ---------------------------------------------------------*/
     39          
     40          /*******************************************************************************
     41          * Function Name  : FSMC_NORSRAMDeInit
     42          * Description    : Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     43          *                  reset values.
     44          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
     45          *                    This parameter can be one of the following values:
     46          *                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     47          *                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     48          *                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     49          *                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4                       
     50          * Output         : None
     51          * Return         : None
     52          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
     54          {
     55            /* Check the parameter */
     56            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
     57            
     58            /* FSMC_Bank1_NORSRAM1 */
     59            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     FSMC_NORSRAMDeInit:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD106             BNE.N    ??FSMC_NORSRAMDeInit_0
     60            {
     61              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \   00000004   0x0081             LSLS     R1,R0,#+2
   \   00000006   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   0000000A   0xF243 0x02DB      MOVW     R2,#+12507
   \   0000000E   0x600A             STR      R2,[R1, #+0]
   \   00000010   0xE005             B.N      ??FSMC_NORSRAMDeInit_1
     62            }
     63            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
     64            else
     65            {   
     66              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_0:
   \   00000012   0x0081             LSLS     R1,R0,#+2
   \   00000014   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000018   0xF243 0x02D2      MOVW     R2,#+12498
   \   0000001C   0x600A             STR      R2,[R1, #+0]
     67            }
     68          
     69            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_1:
   \   0000001E   0x0081             LSLS     R1,R0,#+2
   \   00000020   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000024   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000028   0x604A             STR      R2,[R1, #+4]
     70            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0xa0000104
   \   0000002E   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000032   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     71          }
   \   00000036   0x4770             BX       LR               ;; return
     72          
     73          /*******************************************************************************
     74          * Function Name  : FSMC_NANDDeInit
     75          * Description    : Deinitializes the FSMC NAND Banks registers to their default 
     76          *                  reset values.
     77          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
     78          *                    This parameter can be one of the following values:
     79          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
     80          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND                       
     81          * Output         : None
     82          * Return         : None
     83          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          void FSMC_NANDDeInit(u32 FSMC_Bank)
     85          {
     86            /* Check the parameter */
     87            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
     88            
     89            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit:
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD112             BNE.N    ??FSMC_NANDDeInit_0
     90            {
     91              /* Set the FSMC_Bank2 registers to their reset values */
     92              FSMC_Bank2->PCR2 = 0x00000018;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0xa0000060
   \   00000008   0x2218             MOVS     R2,#+24
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     93              FSMC_Bank2->SR2 = 0x00000040;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0xa0000064
   \   00000010   0x2240             MOVS     R2,#+64
   \   00000012   0x600A             STR      R2,[R1, #+0]
     94              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xa0000068
   \   00000018   0xF05F 0x32FC      MOVS     R2,#-50529028
   \   0000001C   0x600A             STR      R2,[R1, #+0]
     95              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0xa000006c
   \   00000022   0xF05F 0x32FC      MOVS     R2,#-50529028
   \   00000026   0x600A             STR      R2,[R1, #+0]
   \   00000028   0xE011             B.N      ??FSMC_NANDDeInit_1
     96            }
     97            /* FSMC_Bank3_NAND */  
     98            else
     99            {
    100              /* Set the FSMC_Bank3 registers to their reset values */
    101              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0:
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0xa0000080
   \   0000002E   0x2218             MOVS     R2,#+24
   \   00000030   0x600A             STR      R2,[R1, #+0]
    102              FSMC_Bank3->SR3 = 0x00000040;
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable15_6  ;; 0xa0000084
   \   00000036   0x2240             MOVS     R2,#+64
   \   00000038   0x600A             STR      R2,[R1, #+0]
    103              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable15_7  ;; 0xa0000088
   \   0000003E   0xF05F 0x32FC      MOVS     R2,#-50529028
   \   00000042   0x600A             STR      R2,[R1, #+0]
    104              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable15_8  ;; 0xa000008c
   \   00000048   0xF05F 0x32FC      MOVS     R2,#-50529028
   \   0000004C   0x600A             STR      R2,[R1, #+0]
    105            }  
    106          }
   \                     ??FSMC_NANDDeInit_1:
   \   0000004E   0x4770             BX       LR               ;; return
    107          
    108          /*******************************************************************************
    109          * Function Name  : FSMC_PCCARDDeInit
    110          * Description    : Deinitializes the FSMC PCCARD Bank registers to their default 
    111          *                  reset values.
    112          * Input          : None                       
    113          * Output         : None
    114          * Return         : None
    115          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          void FSMC_PCCARDDeInit(void)
    117          {
    118            /* Set the FSMC_Bank4 registers to their reset values */
    119            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0xa00000a0
   \   00000004   0x2118             MOVS     R1,#+24
   \   00000006   0x6001             STR      R1,[R0, #+0]
    120            FSMC_Bank4->SR4 = 0x00000000;	
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    121            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_11  ;; 0xa00000a8
   \   00000014   0xF05F 0x31FC      MOVS     R1,#-50529028
   \   00000018   0x6001             STR      R1,[R0, #+0]
    122            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_12  ;; 0xa00000ac
   \   0000001E   0xF05F 0x31FC      MOVS     R1,#-50529028
   \   00000022   0x6001             STR      R1,[R0, #+0]
    123            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_13  ;; 0xa00000b0
   \   00000028   0xF05F 0x31FC      MOVS     R1,#-50529028
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    124          }
   \   0000002E   0x4770             BX       LR               ;; return
    125          
    126          /*******************************************************************************
    127          * Function Name  : FSMC_NORSRAMInit
    128          * Description    : Initializes the FSMC NOR/SRAM Banks according to the 
    129          *                  specified parameters in the FSMC_NORSRAMInitStruct.
    130          * Input          : - FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    131          *                  structure that contains the configuration information for 
    132          *                  the FSMC NOR/SRAM specified Banks.                       
    133          * Output         : None
    134          * Return         : None
    135          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    137          { 
    138            /* Check the parameters */
    139            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    140            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    141            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    142            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    143            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    144            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    145            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    146            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    147            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    148            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    149            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    150            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    151            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    152            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    153            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    154            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    155            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    156            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    157            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    158            
    159            /* Bank1 NOR/SRAM control register configuration */ 
    160            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    161                      (u32)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    162                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    163                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    164                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    165                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    166                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    167                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    168                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    169                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    170                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    171                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \                     FSMC_NORSRAMInit:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x4311             ORRS     R1,R2,R1
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0x4311             ORRS     R1,R2,R1
   \   0000000A   0x6902             LDR      R2,[R0, #+16]
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   \   00000010   0x4311             ORRS     R1,R2,R1
   \   00000012   0x6982             LDR      R2,[R0, #+24]
   \   00000014   0x4311             ORRS     R1,R2,R1
   \   00000016   0x69C2             LDR      R2,[R0, #+28]
   \   00000018   0x4311             ORRS     R1,R2,R1
   \   0000001A   0x6A02             LDR      R2,[R0, #+32]
   \   0000001C   0x4311             ORRS     R1,R2,R1
   \   0000001E   0x6A42             LDR      R2,[R0, #+36]
   \   00000020   0x4311             ORRS     R1,R2,R1
   \   00000022   0x6A82             LDR      R2,[R0, #+40]
   \   00000024   0x4311             ORRS     R1,R2,R1
   \   00000026   0x6AC2             LDR      R2,[R0, #+44]
   \   00000028   0x4311             ORRS     R1,R2,R1
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x0092             LSLS     R2,R2,#+2
   \   0000002E   0xF1B2 0x42C0      SUBS     R2,R2,#+1610612736
   \   00000032   0x6011             STR      R1,[R2, #+0]
    172          
    173            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \   00000034   0x6881             LDR      R1,[R0, #+8]
   \   00000036   0x2908             CMP      R1,#+8
   \   00000038   0xD10B             BNE.N    ??FSMC_NORSRAMInit_0
    174            {
    175              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (u32)BCR_FACCEN_Set;
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x0089             LSLS     R1,R1,#+2
   \   0000003E   0xF1B1 0x41C0      SUBS     R1,R1,#+1610612736
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000048   0x6802             LDR      R2,[R0, #+0]
   \   0000004A   0x0092             LSLS     R2,R2,#+2
   \   0000004C   0xF1B2 0x42C0      SUBS     R2,R2,#+1610612736
   \   00000050   0x6011             STR      R1,[R2, #+0]
    176            }
    177          
    178            /* Bank1 NOR/SRAM timing register configuration */
    179            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    180                      (u32)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    181                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    182                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    183                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    184                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    185                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    186                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0:
   \   00000052   0x6B01             LDR      R1,[R0, #+48]
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x6B02             LDR      R2,[R0, #+48]
   \   00000058   0x6852             LDR      R2,[R2, #+4]
   \   0000005A   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \   0000005E   0x6B02             LDR      R2,[R0, #+48]
   \   00000060   0x6892             LDR      R2,[R2, #+8]
   \   00000062   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000066   0x6B02             LDR      R2,[R0, #+48]
   \   00000068   0x68D2             LDR      R2,[R2, #+12]
   \   0000006A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000006E   0x6B02             LDR      R2,[R0, #+48]
   \   00000070   0x6912             LDR      R2,[R2, #+16]
   \   00000072   0xEA51 0x5102      ORRS     R1,R1,R2, LSL #+20
   \   00000076   0x6B02             LDR      R2,[R0, #+48]
   \   00000078   0x6952             LDR      R2,[R2, #+20]
   \   0000007A   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   0000007E   0x6B02             LDR      R2,[R0, #+48]
   \   00000080   0x6992             LDR      R2,[R2, #+24]
   \   00000082   0x4311             ORRS     R1,R2,R1
   \   00000084   0x6802             LDR      R2,[R0, #+0]
   \   00000086   0x0092             LSLS     R2,R2,#+2
   \   00000088   0xF1B2 0x42C0      SUBS     R2,R2,#+1610612736
   \   0000008C   0x6051             STR      R1,[R2, #+4]
    187                      
    188          
    189              
    190            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    191            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \   0000008E   0x6A81             LDR      R1,[R0, #+40]
   \   00000090   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000094   0xD11A             BNE.N    ??FSMC_NORSRAMInit_1
    192            {
    193              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    194              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    195              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    196              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    197              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    198              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    199          
    200              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    201                        (u32)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    202                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    203                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    204                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    205                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    206                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \   00000096   0x6B41             LDR      R1,[R0, #+52]
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x6B42             LDR      R2,[R0, #+52]
   \   0000009C   0x6852             LDR      R2,[R2, #+4]
   \   0000009E   0xEA51 0x1102      ORRS     R1,R1,R2, LSL #+4
   \   000000A2   0x6B42             LDR      R2,[R0, #+52]
   \   000000A4   0x6892             LDR      R2,[R2, #+8]
   \   000000A6   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000AA   0x6B42             LDR      R2,[R0, #+52]
   \   000000AC   0x6912             LDR      R2,[R2, #+16]
   \   000000AE   0xEA51 0x5102      ORRS     R1,R1,R2, LSL #+20
   \   000000B2   0x6B42             LDR      R2,[R0, #+52]
   \   000000B4   0x6952             LDR      R2,[R2, #+20]
   \   000000B6   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   000000BA   0x6B42             LDR      R2,[R0, #+52]
   \   000000BC   0x6992             LDR      R2,[R2, #+24]
   \   000000BE   0x4311             ORRS     R1,R2,R1
   \   000000C0   0x6802             LDR      R2,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R3,??DataTable15  ;; 0xa0000104
   \   000000C6   0xF843 0x1022      STR      R1,[R3, R2, LSL #+2]
   \   000000CA   0xE006             B.N      ??FSMC_NORSRAMInit_2
    207            }
    208            else
    209            {
    210              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1:
   \   000000CC   0x6801             LDR      R1,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   000000D2   0xF07F 0x4370      MVNS     R3,#-268435456
   \   000000D6   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    211            }
    212          }
   \                     ??FSMC_NORSRAMInit_2:
   \   000000DA   0x4770             BX       LR               ;; return
    213          
    214          /*******************************************************************************
    215          * Function Name  : FSMC_NANDInit
    216          * Description    : Initializes the FSMC NAND Banks according to the specified 
    217          *                  parameters in the FSMC_NANDInitStruct.
    218          * Input          : - FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    219          *                    structure that contains the configuration information for 
    220          *                    the FSMC NAND specified Banks.                       
    221          * Output         : None
    222          * Return         : None
    223          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    224          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    225          {
   \                     FSMC_NANDInit:
   \   00000000   0xB430             PUSH     {R4,R5}
    226            u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    227              
    228            /* Check the parameters */
    229            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    230            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    231            assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    232            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    233            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    234            assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct->FSMC_AddressLowMapping));
    235            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    236            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    237          
    238            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    239            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    240            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    241            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    242          
    243            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    244            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    245            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    246            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    247            
    248            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    249            tmppcr = (u32)FSMC_NANDInitStruct->FSMC_Waitfeature |
    250                      PCR_MemoryType_NAND |
    251                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    252                      FSMC_NANDInitStruct->FSMC_ECC |
    253                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    254                      FSMC_NANDInitStruct->FSMC_AddressLowMapping |
    255                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    256                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \   00000008   0x6844             LDR      R4,[R0, #+4]
   \   0000000A   0x6885             LDR      R5,[R0, #+8]
   \   0000000C   0x432C             ORRS     R4,R5,R4
   \   0000000E   0x68C5             LDR      R5,[R0, #+12]
   \   00000010   0x432C             ORRS     R4,R5,R4
   \   00000012   0x6905             LDR      R5,[R0, #+16]
   \   00000014   0x432C             ORRS     R4,R5,R4
   \   00000016   0x6945             LDR      R5,[R0, #+20]
   \   00000018   0x432C             ORRS     R4,R5,R4
   \   0000001A   0x6985             LDR      R5,[R0, #+24]
   \   0000001C   0xEA54 0x2445      ORRS     R4,R4,R5, LSL #+9
   \   00000020   0x69C5             LDR      R5,[R0, #+28]
   \   00000022   0xEA54 0x3445      ORRS     R4,R4,R5, LSL #+13
   \   00000026   0xF054 0x0408      ORRS     R4,R4,#0x8
   \   0000002A   0x0021             MOVS     R1,R4
    257                      
    258            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    259            tmppmem = (u32)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    260                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    261                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    262                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   0000002C   0x6A04             LDR      R4,[R0, #+32]
   \   0000002E   0x6824             LDR      R4,[R4, #+0]
   \   00000030   0x6A05             LDR      R5,[R0, #+32]
   \   00000032   0x686D             LDR      R5,[R5, #+4]
   \   00000034   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   \   00000038   0x6A05             LDR      R5,[R0, #+32]
   \   0000003A   0x68AD             LDR      R5,[R5, #+8]
   \   0000003C   0xEA54 0x4405      ORRS     R4,R4,R5, LSL #+16
   \   00000040   0x6A05             LDR      R5,[R0, #+32]
   \   00000042   0x68ED             LDR      R5,[R5, #+12]
   \   00000044   0xEA54 0x6405      ORRS     R4,R4,R5, LSL #+24
   \   00000048   0x0022             MOVS     R2,R4
    263                      
    264            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    265            tmppatt = (u32)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    266                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    267                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    268                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \   0000004A   0x6A44             LDR      R4,[R0, #+36]
   \   0000004C   0x6824             LDR      R4,[R4, #+0]
   \   0000004E   0x6A45             LDR      R5,[R0, #+36]
   \   00000050   0x686D             LDR      R5,[R5, #+4]
   \   00000052   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   \   00000056   0x6A45             LDR      R5,[R0, #+36]
   \   00000058   0x68AD             LDR      R5,[R5, #+8]
   \   0000005A   0xEA54 0x4405      ORRS     R4,R4,R5, LSL #+16
   \   0000005E   0x6A45             LDR      R5,[R0, #+36]
   \   00000060   0x68ED             LDR      R5,[R5, #+12]
   \   00000062   0xEA54 0x6405      ORRS     R4,R4,R5, LSL #+24
   \   00000066   0x0023             MOVS     R3,R4
    269            
    270            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \   00000068   0x6804             LDR      R4,[R0, #+0]
   \   0000006A   0x2C10             CMP      R4,#+16
   \   0000006C   0xD109             BNE.N    ??FSMC_NANDInit_0
    271            {
    272              /* FSMC_Bank2_NAND registers configuration */
    273              FSMC_Bank2->PCR2 = tmppcr;
   \   0000006E   0x.... 0x....      LDR.W    R4,??DataTable15_1  ;; 0xa0000060
   \   00000072   0x6021             STR      R1,[R4, #+0]
    274              FSMC_Bank2->PMEM2 = tmppmem;
   \   00000074   0x.... 0x....      LDR.W    R4,??DataTable15_3  ;; 0xa0000068
   \   00000078   0x6022             STR      R2,[R4, #+0]
    275              FSMC_Bank2->PATT2 = tmppatt;
   \   0000007A   0x.... 0x....      LDR.W    R4,??DataTable15_4  ;; 0xa000006c
   \   0000007E   0x6023             STR      R3,[R4, #+0]
   \   00000080   0xE008             B.N      ??FSMC_NANDInit_1
    276            }
    277            else
    278            {
    279              /* FSMC_Bank3_NAND registers configuration */
    280              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0:
   \   00000082   0x.... 0x....      LDR.W    R4,??DataTable15_5  ;; 0xa0000080
   \   00000086   0x6021             STR      R1,[R4, #+0]
    281              FSMC_Bank3->PMEM3 = tmppmem;
   \   00000088   0x.... 0x....      LDR.W    R4,??DataTable15_7  ;; 0xa0000088
   \   0000008C   0x6022             STR      R2,[R4, #+0]
    282              FSMC_Bank3->PATT3 = tmppatt;
   \   0000008E   0x.... 0x....      LDR.W    R4,??DataTable15_8  ;; 0xa000008c
   \   00000092   0x6023             STR      R3,[R4, #+0]
    283            }
    284          }
   \                     ??FSMC_NANDInit_1:
   \   00000094   0xBC30             POP      {R4,R5}
   \   00000096   0x4770             BX       LR               ;; return
    285          
    286          /*******************************************************************************
    287          * Function Name  : FSMC_PCCARDInit
    288          * Description    : Initializes the FSMC PCCARD Bank according to the specified 
    289          *                  parameters in the FSMC_PCCARDInitStruct.
    290          * Input          : - FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    291          *                    structure that contains the configuration information for 
    292          *                    the FSMC PCCARD Bank.                       
    293          * Output         : None
    294          * Return         : None
    295          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    297          {
    298            /* Check the parameters */
    299            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    300            assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct->FSMC_AddressLowMapping));
    301            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    302            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    303          
    304           
    305            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    306            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    307            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    308            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    309            
    310            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    311            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    312            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    313            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    314          
    315            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    316            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    317            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    318            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    319            
    320            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    321            FSMC_Bank4->PCR4 = (u32)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    322                               FSMC_MemoryDataWidth_16b |  
    323                               FSMC_PCCARDInitStruct->FSMC_AddressLowMapping |
    324                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    325                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \                     FSMC_PCCARDInit:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0x4311             ORRS     R1,R2,R1
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xEA51 0x2142      ORRS     R1,R1,R2, LSL #+9
   \   0000000C   0x68C2             LDR      R2,[R0, #+12]
   \   0000000E   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \   00000012   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable15_9  ;; 0xa00000a0
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    326                      
    327            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    328            FSMC_Bank4->PMEM4 = (u32)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    329                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    330                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    331                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   0000001C   0x6901             LDR      R1,[R0, #+16]
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6902             LDR      R2,[R0, #+16]
   \   00000022   0x6852             LDR      R2,[R2, #+4]
   \   00000024   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000028   0x6902             LDR      R2,[R0, #+16]
   \   0000002A   0x6892             LDR      R2,[R2, #+8]
   \   0000002C   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000030   0x6902             LDR      R2,[R0, #+16]
   \   00000032   0x68D2             LDR      R2,[R2, #+12]
   \   00000034   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable15_11  ;; 0xa00000a8
   \   0000003C   0x6011             STR      R1,[R2, #+0]
    332                      
    333            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    334            FSMC_Bank4->PATT4 = (u32)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    335                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    336                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    337                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \   0000003E   0x6941             LDR      R1,[R0, #+20]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x6942             LDR      R2,[R0, #+20]
   \   00000044   0x6852             LDR      R2,[R2, #+4]
   \   00000046   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   0000004A   0x6942             LDR      R2,[R0, #+20]
   \   0000004C   0x6892             LDR      R2,[R2, #+8]
   \   0000004E   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000052   0x6942             LDR      R2,[R0, #+20]
   \   00000054   0x68D2             LDR      R2,[R2, #+12]
   \   00000056   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable15_12  ;; 0xa00000ac
   \   0000005E   0x6011             STR      R1,[R2, #+0]
    338                      
    339            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    340            FSMC_Bank4->PIO4 = (u32)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    341                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    342                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    343                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \   00000060   0x6981             LDR      R1,[R0, #+24]
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x6982             LDR      R2,[R0, #+24]
   \   00000066   0x6852             LDR      R2,[R2, #+4]
   \   00000068   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   0000006C   0x6982             LDR      R2,[R0, #+24]
   \   0000006E   0x6892             LDR      R2,[R2, #+8]
   \   00000070   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   00000074   0x6982             LDR      R2,[R0, #+24]
   \   00000076   0x68D2             LDR      R2,[R2, #+12]
   \   00000078   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable15_13  ;; 0xa00000b0
   \   00000080   0x6011             STR      R1,[R2, #+0]
    344          }
   \   00000082   0x4770             BX       LR               ;; return
    345          
    346          /*******************************************************************************
    347          * Function Name  : FSMC_NORSRAMStructInit
    348          * Description    : Fills each FSMC_NORSRAMInitStruct member with its default value.
    349          * Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    350          *                    structure which will be initialized.
    351          * Output         : None
    352          * Return         : None
    353          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    355          {  
    356            /* Reset NOR/SRAM Init structure parameters values */
    357            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    358            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x6041             STR      R1,[R0, #+4]
    359            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    360            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    361            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    362            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    363            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    364            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    365            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \   00000020   0xF44F 0x5180      MOV      R1,#+4096
   \   00000024   0x6201             STR      R1,[R0, #+32]
    366            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \   00000026   0xF44F 0x5100      MOV      R1,#+8192
   \   0000002A   0x6241             STR      R1,[R0, #+36]
    367            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6281             STR      R1,[R0, #+40]
    368            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x62C1             STR      R1,[R0, #+44]
    369            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000034   0x6B01             LDR      R1,[R0, #+48]
   \   00000036   0x220F             MOVS     R2,#+15
   \   00000038   0x600A             STR      R2,[R1, #+0]
    370            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   0000003A   0x6B01             LDR      R1,[R0, #+48]
   \   0000003C   0x220F             MOVS     R2,#+15
   \   0000003E   0x604A             STR      R2,[R1, #+4]
    371            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000040   0x6B01             LDR      R1,[R0, #+48]
   \   00000042   0x22FF             MOVS     R2,#+255
   \   00000044   0x608A             STR      R2,[R1, #+8]
    372            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   00000046   0x6B01             LDR      R1,[R0, #+48]
   \   00000048   0x220F             MOVS     R2,#+15
   \   0000004A   0x60CA             STR      R2,[R1, #+12]
    373            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   0000004C   0x6B01             LDR      R1,[R0, #+48]
   \   0000004E   0x220F             MOVS     R2,#+15
   \   00000050   0x610A             STR      R2,[R1, #+16]
    374            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000052   0x6B01             LDR      R1,[R0, #+48]
   \   00000054   0x220F             MOVS     R2,#+15
   \   00000056   0x614A             STR      R2,[R1, #+20]
    375            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \   00000058   0x6B01             LDR      R1,[R0, #+48]
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x618A             STR      R2,[R1, #+24]
    376            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   0000005E   0x6B41             LDR      R1,[R0, #+52]
   \   00000060   0x220F             MOVS     R2,#+15
   \   00000062   0x600A             STR      R2,[R1, #+0]
    377            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000064   0x6B41             LDR      R1,[R0, #+52]
   \   00000066   0x220F             MOVS     R2,#+15
   \   00000068   0x604A             STR      R2,[R1, #+4]
    378            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   0000006A   0x6B41             LDR      R1,[R0, #+52]
   \   0000006C   0x22FF             MOVS     R2,#+255
   \   0000006E   0x608A             STR      R2,[R1, #+8]
    379            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   00000070   0x6B41             LDR      R1,[R0, #+52]
   \   00000072   0x220F             MOVS     R2,#+15
   \   00000074   0x60CA             STR      R2,[R1, #+12]
    380            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000076   0x6B41             LDR      R1,[R0, #+52]
   \   00000078   0x220F             MOVS     R2,#+15
   \   0000007A   0x610A             STR      R2,[R1, #+16]
    381            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \   0000007C   0x6B41             LDR      R1,[R0, #+52]
   \   0000007E   0x220F             MOVS     R2,#+15
   \   00000080   0x614A             STR      R2,[R1, #+20]
    382            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \   00000082   0x6B41             LDR      R1,[R0, #+52]
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x618A             STR      R2,[R1, #+24]
    383          }
   \   00000088   0x4770             BX       LR               ;; return
    384          
    385          /*******************************************************************************
    386          * Function Name  : FSMC_NANDStructInit
    387          * Description    : Fills each FSMC_NANDInitStruct member with its default value.
    388          * Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NANDInitTypeDef 
    389          *                    structure which will be initialized.
    390          * Output         : None
    391          * Return         : None
    392          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    393          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    394          { 
    395            /* Reset NAND Init structure parameters values */
    396            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit:
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x6001             STR      R1,[R0, #+0]
    397            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    398            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    399            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    400            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    401            FSMC_NANDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6141             STR      R1,[R0, #+20]
    402            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    403            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    404            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000020   0x6A01             LDR      R1,[R0, #+32]
   \   00000022   0x22FC             MOVS     R2,#+252
   \   00000024   0x600A             STR      R2,[R1, #+0]
    405            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000026   0x6A01             LDR      R1,[R0, #+32]
   \   00000028   0x22FC             MOVS     R2,#+252
   \   0000002A   0x604A             STR      R2,[R1, #+4]
    406            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x22FC             MOVS     R2,#+252
   \   00000030   0x608A             STR      R2,[R1, #+8]
    407            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0x22FC             MOVS     R2,#+252
   \   00000036   0x60CA             STR      R2,[R1, #+12]
    408            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000038   0x6A41             LDR      R1,[R0, #+36]
   \   0000003A   0x22FC             MOVS     R2,#+252
   \   0000003C   0x600A             STR      R2,[R1, #+0]
    409            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000003E   0x6A41             LDR      R1,[R0, #+36]
   \   00000040   0x22FC             MOVS     R2,#+252
   \   00000042   0x604A             STR      R2,[R1, #+4]
    410            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000044   0x6A41             LDR      R1,[R0, #+36]
   \   00000046   0x22FC             MOVS     R2,#+252
   \   00000048   0x608A             STR      R2,[R1, #+8]
    411            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \   0000004A   0x6A41             LDR      R1,[R0, #+36]
   \   0000004C   0x22FC             MOVS     R2,#+252
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
    412          }
   \   00000050   0x4770             BX       LR               ;; return
    413          
    414          /*******************************************************************************
    415          * Function Name  : FSMC_PCCARDStructInit
    416          * Description    : Fills each FSMC_PCCARDInitStruct member with its default value.
    417          * Input          : - FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    418          *                    structure which will be initialized.
    419          * Output         : None
    420          * Return         : None
    421          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    422          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    423          {
    424            /* Reset PCCARD Init structure parameters values */
    425            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    426            FSMC_PCCARDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    427            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    428            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    429            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000010   0x6901             LDR      R1,[R0, #+16]
   \   00000012   0x22FC             MOVS     R2,#+252
   \   00000014   0x600A             STR      R2,[R1, #+0]
    430            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000016   0x6901             LDR      R1,[R0, #+16]
   \   00000018   0x22FC             MOVS     R2,#+252
   \   0000001A   0x604A             STR      R2,[R1, #+4]
    431            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   0000001C   0x6901             LDR      R1,[R0, #+16]
   \   0000001E   0x22FC             MOVS     R2,#+252
   \   00000020   0x608A             STR      R2,[R1, #+8]
    432            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x22FC             MOVS     R2,#+252
   \   00000026   0x60CA             STR      R2,[R1, #+12]
    433            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0x22FC             MOVS     R2,#+252
   \   0000002C   0x600A             STR      R2,[R1, #+0]
    434            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000002E   0x6941             LDR      R1,[R0, #+20]
   \   00000030   0x22FC             MOVS     R2,#+252
   \   00000032   0x604A             STR      R2,[R1, #+4]
    435            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0x22FC             MOVS     R2,#+252
   \   00000038   0x608A             STR      R2,[R1, #+8]
    436            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \   0000003A   0x6941             LDR      R1,[R0, #+20]
   \   0000003C   0x22FC             MOVS     R2,#+252
   \   0000003E   0x60CA             STR      R2,[R1, #+12]
    437            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000040   0x6981             LDR      R1,[R0, #+24]
   \   00000042   0x22FC             MOVS     R2,#+252
   \   00000044   0x600A             STR      R2,[R1, #+0]
    438            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000046   0x6981             LDR      R1,[R0, #+24]
   \   00000048   0x22FC             MOVS     R2,#+252
   \   0000004A   0x604A             STR      R2,[R1, #+4]
    439            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   0000004C   0x6981             LDR      R1,[R0, #+24]
   \   0000004E   0x22FC             MOVS     R2,#+252
   \   00000050   0x608A             STR      R2,[R1, #+8]
    440            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   00000052   0x6981             LDR      R1,[R0, #+24]
   \   00000054   0x22FC             MOVS     R2,#+252
   \   00000056   0x60CA             STR      R2,[R1, #+12]
    441          }
   \   00000058   0x4770             BX       LR               ;; return
    442          
    443          /*******************************************************************************
    444          * Function Name  : FSMC_NORSRAMCmd
    445          * Description    : Enables or disables the specified NOR/SRAM Memory Bank.
    446          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    447          *                    This parameter can be one of the following values:
    448          *                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    449          *                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    450          *                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    451          *                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    452          *                : - NewState: new state of the FSMC_Bank.
    453          *                    This parameter can be: ENABLE or DISABLE.
    454          * Output         : None
    455          * Return         : None
    456          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    457          void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
    458          {
    459            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    460            assert_param(IS_FUNCTIONAL_STATE(NewState));
    461            
    462            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00A             BEQ.N    ??FSMC_NORSRAMCmd_0
    463            {
    464              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    465              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
   \   00000006   0x0082             LSLS     R2,R0,#+2
   \   00000008   0xF1B2 0x42C0      SUBS     R2,R2,#+1610612736
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000012   0x0083             LSLS     R3,R0,#+2
   \   00000014   0xF1B3 0x43C0      SUBS     R3,R3,#+1610612736
   \   00000018   0x601A             STR      R2,[R3, #+0]
   \   0000001A   0xE009             B.N      ??FSMC_NORSRAMCmd_1
    466            }
    467            else
    468            {
    469              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    470              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
   \                     ??FSMC_NORSRAMCmd_0:
   \   0000001C   0x0082             LSLS     R2,R0,#+2
   \   0000001E   0xF1B2 0x42C0      SUBS     R2,R2,#+1610612736
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x....             LDR.N    R3,??DataTable15_14  ;; 0xffffe
   \   00000026   0x401A             ANDS     R2,R3,R2
   \   00000028   0x0083             LSLS     R3,R0,#+2
   \   0000002A   0xF1B3 0x43C0      SUBS     R3,R3,#+1610612736
   \   0000002E   0x601A             STR      R2,[R3, #+0]
    471            }
    472          }
   \                     ??FSMC_NORSRAMCmd_1:
   \   00000030   0x4770             BX       LR               ;; return
    473          
    474          /*******************************************************************************
    475          * Function Name  : FSMC_NANDCmd
    476          * Description    : Enables or disables the specified NAND Memory Bank.
    477          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    478          *                    This parameter can be one of the following values:
    479          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    480          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    481          *                : - NewState: new state of the FSMC_Bank.
    482          *                    This parameter can be: ENABLE or DISABLE.
    483          * Output         : None
    484          * Return         : None
    485          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    486          void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
    487          {
    488            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490            
    491            if (NewState != DISABLE)
   \                     FSMC_NANDCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00F             BEQ.N    ??FSMC_NANDCmd_0
    492            {
    493              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    494              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD106             BNE.N    ??FSMC_NANDCmd_1
    495              {
    496                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
   \   0000000A   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   00000012   0x....             LDR.N    R3,??DataTable15_1  ;; 0xa0000060
   \   00000014   0x601A             STR      R2,[R3, #+0]
   \   00000016   0xE015             B.N      ??FSMC_NANDCmd_2
    497              }
    498              else
    499              {
    500                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
   \                     ??FSMC_NANDCmd_1:
   \   00000018   0x....             LDR.N    R2,??DataTable15_5  ;; 0xa0000080
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   00000020   0x....             LDR.N    R3,??DataTable15_5  ;; 0xa0000080
   \   00000022   0x601A             STR      R2,[R3, #+0]
   \   00000024   0xE00E             B.N      ??FSMC_NANDCmd_2
    501              }
    502            }
    503            else
    504            {
    505              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    506              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0:
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD106             BNE.N    ??FSMC_NANDCmd_3
    507              {
    508                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
   \   0000002A   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x....             LDR.N    R3,??DataTable15_15  ;; 0xffffb
   \   00000030   0x401A             ANDS     R2,R3,R2
   \   00000032   0x....             LDR.N    R3,??DataTable15_1  ;; 0xa0000060
   \   00000034   0x601A             STR      R2,[R3, #+0]
   \   00000036   0xE005             B.N      ??FSMC_NANDCmd_2
    509              }
    510              else
    511              {
    512                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
   \                     ??FSMC_NANDCmd_3:
   \   00000038   0x....             LDR.N    R2,??DataTable15_5  ;; 0xa0000080
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x....             LDR.N    R3,??DataTable15_15  ;; 0xffffb
   \   0000003E   0x401A             ANDS     R2,R3,R2
   \   00000040   0x....             LDR.N    R3,??DataTable15_5  ;; 0xa0000080
   \   00000042   0x601A             STR      R2,[R3, #+0]
    513              }
    514            }
    515          }
   \                     ??FSMC_NANDCmd_2:
   \   00000044   0x4770             BX       LR               ;; return
    516          
    517          /*******************************************************************************
    518          * Function Name  : FSMC_PCCARDCmd
    519          * Description    : Enables or disables the PCCARD Memory Bank.
    520          * Input          : - NewState: new state of the PCCARD Memory Bank.  
    521          *                    This parameter can be: ENABLE or DISABLE.
    522          * Output         : None
    523          * Return         : None
    524          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    525          void FSMC_PCCARDCmd(FunctionalState NewState)
    526          {
    527            assert_param(IS_FUNCTIONAL_STATE(NewState));
    528            
    529            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??FSMC_PCCARDCmd_0
    530            {
    531              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    532              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
   \   00000006   0x....             LDR.N    R1,??DataTable15_9  ;; 0xa00000a0
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   0000000E   0x....             LDR.N    R2,??DataTable15_9  ;; 0xa00000a0
   \   00000010   0x6011             STR      R1,[R2, #+0]
   \   00000012   0xE005             B.N      ??FSMC_PCCARDCmd_1
    533            }
    534            else
    535            {
    536              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    537              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
   \                     ??FSMC_PCCARDCmd_0:
   \   00000014   0x....             LDR.N    R1,??DataTable15_9  ;; 0xa00000a0
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x....             LDR.N    R2,??DataTable15_15  ;; 0xffffb
   \   0000001A   0x4011             ANDS     R1,R2,R1
   \   0000001C   0x....             LDR.N    R2,??DataTable15_9  ;; 0xa00000a0
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    538            }
    539          }
   \                     ??FSMC_PCCARDCmd_1:
   \   00000020   0x4770             BX       LR               ;; return
    540          
    541          /*******************************************************************************
    542          * Function Name  : FSMC_NANDECCCmd
    543          * Description    : Enables or disables the FSMC NAND ECC feature.
    544          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    545          *                    This parameter can be one of the following values:
    546          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    547          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    548          *                : - NewState: new state of the FSMC NAND ECC feature.  
    549          *                    This parameter can be: ENABLE or DISABLE.
    550          * Output         : None
    551          * Return         : None
    552          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    553          void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
    554          {
    555            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    556            assert_param(IS_FUNCTIONAL_STATE(NewState));
    557            
    558            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00F             BEQ.N    ??FSMC_NANDECCCmd_0
    559            {
    560              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    561              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   0x2810             CMP      R0,#+16
   \   00000008   0xD106             BNE.N    ??FSMC_NANDECCCmd_1
    562              {
    563                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
   \   0000000A   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000012   0x....             LDR.N    R3,??DataTable15_1  ;; 0xa0000060
   \   00000014   0x601A             STR      R2,[R3, #+0]
   \   00000016   0xE015             B.N      ??FSMC_NANDECCCmd_2
    564              }
    565              else
    566              {
    567                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
   \                     ??FSMC_NANDECCCmd_1:
   \   00000018   0x....             LDR.N    R2,??DataTable15_5  ;; 0xa0000080
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000020   0x....             LDR.N    R3,??DataTable15_5  ;; 0xa0000080
   \   00000022   0x601A             STR      R2,[R3, #+0]
   \   00000024   0xE00E             B.N      ??FSMC_NANDECCCmd_2
    568              }
    569            }
    570            else
    571            {
    572              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    573              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0:
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD106             BNE.N    ??FSMC_NANDECCCmd_3
    574              {
    575                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
   \   0000002A   0x....             LDR.N    R2,??DataTable15_1  ;; 0xa0000060
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x....             LDR.N    R3,??DataTable15_16  ;; 0xfffbf
   \   00000030   0x401A             ANDS     R2,R3,R2
   \   00000032   0x....             LDR.N    R3,??DataTable15_1  ;; 0xa0000060
   \   00000034   0x601A             STR      R2,[R3, #+0]
   \   00000036   0xE005             B.N      ??FSMC_NANDECCCmd_2
    576              }
    577              else
    578              {
    579                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
   \                     ??FSMC_NANDECCCmd_3:
   \   00000038   0x....             LDR.N    R2,??DataTable15_5  ;; 0xa0000080
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x....             LDR.N    R3,??DataTable15_16  ;; 0xfffbf
   \   0000003E   0x401A             ANDS     R2,R3,R2
   \   00000040   0x....             LDR.N    R3,??DataTable15_5  ;; 0xa0000080
   \   00000042   0x601A             STR      R2,[R3, #+0]
    580              }
    581            }
    582          }
   \                     ??FSMC_NANDECCCmd_2:
   \   00000044   0x4770             BX       LR               ;; return
    583          
    584          /*******************************************************************************
    585          * Function Name  : FSMC_GetECC
    586          * Description    : Returns the error correction code register value.
    587          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    588          *                    This parameter can be one of the following values:
    589          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    590          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    591          * Output         : None
    592          * Return         : The Error Correction Code (ECC) value.
    593          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    594          u32 FSMC_GetECC(u32 FSMC_Bank)
    595          {
   \                     FSMC_GetECC:
   \   00000000   0x0001             MOVS     R1,R0
    596            u32 eccval = 0x00000000;
   \   00000002   0x2000             MOVS     R0,#+0
    597            
    598            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000004   0x2910             CMP      R1,#+16
   \   00000006   0xD103             BNE.N    ??FSMC_GetECC_0
    599            {
    600              /* Get the ECCR2 register value */
    601              eccval = FSMC_Bank2->ECCR2;
   \   00000008   0x....             LDR.N    R2,??DataTable15_17  ;; 0xa0000074
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE002             B.N      ??FSMC_GetECC_1
    602            }
    603            else
    604            {
    605              /* Get the ECCR3 register value */
    606              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0:
   \   00000010   0x....             LDR.N    R2,??DataTable15_18  ;; 0xa0000094
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x0010             MOVS     R0,R2
    607            }
    608            /* Return the error correction code value */
    609            return(eccval);
   \                     ??FSMC_GetECC_1:
   \   00000016   0x4770             BX       LR               ;; return
    610          }
    611          
    612          /*******************************************************************************
    613          * Function Name  : FSMC_ITConfig
    614          * Description    : Enables or disables the specified FSMC interrupts.
    615          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    616          *                    This parameter can be one of the following values:
    617          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    618          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    619          *                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    620          *                  - FSMC_IT: specifies the FSMC interrupt sources to be
    621          *                    enabled or disabled.
    622          *                    This parameter can be any combination of the following values:
    623          *                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    624          *                       - FSMC_IT_Level: Level edge detection interrupt.                                  
    625          *                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
    626          *                  - NewState: new state of the specified FSMC interrupts.
    627          *                    This parameter can be: ENABLE or DISABLE.
    628          * Output         : None
    629          * Return         : None
    630          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    631          void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
    632          {
   \                     FSMC_ITConfig:
   \   00000000   0xB410             PUSH     {R4}
    633            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    634            assert_param(IS_FSMC_IT(FSMC_IT));	
    635            assert_param(IS_FUNCTIONAL_STATE(NewState));
    636            
    637            if (NewState != DISABLE)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD016             BEQ.N    ??FSMC_ITConfig_0
    638            {
    639              /* Enable the selected FSMC_Bank2 interrupts */
    640              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000008   0x2810             CMP      R0,#+16
   \   0000000A   0xD105             BNE.N    ??FSMC_ITConfig_1
    641              {
    642                FSMC_Bank2->SR2 |= FSMC_IT;
   \   0000000C   0x....             LDR.N    R3,??DataTable15_2  ;; 0xa0000064
   \   0000000E   0x681B             LDR      R3,[R3, #+0]
   \   00000010   0x430B             ORRS     R3,R1,R3
   \   00000012   0x....             LDR.N    R4,??DataTable15_2  ;; 0xa0000064
   \   00000014   0x6023             STR      R3,[R4, #+0]
   \   00000016   0xE024             B.N      ??FSMC_ITConfig_2
    643              }
    644              /* Enable the selected FSMC_Bank3 interrupts */
    645              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1:
   \   00000018   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000001C   0xD105             BNE.N    ??FSMC_ITConfig_3
    646              {
    647                FSMC_Bank3->SR3 |= FSMC_IT;
   \   0000001E   0x....             LDR.N    R3,??DataTable15_6  ;; 0xa0000084
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0x430B             ORRS     R3,R1,R3
   \   00000024   0x....             LDR.N    R4,??DataTable15_6  ;; 0xa0000084
   \   00000026   0x6023             STR      R3,[R4, #+0]
   \   00000028   0xE01B             B.N      ??FSMC_ITConfig_2
    648              }
    649              /* Enable the selected FSMC_Bank4 interrupts */
    650              else
    651              {
    652                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_3:
   \   0000002A   0x....             LDR.N    R3,??DataTable15_10  ;; 0xa00000a4
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x430B             ORRS     R3,R1,R3
   \   00000030   0x....             LDR.N    R4,??DataTable15_10  ;; 0xa00000a4
   \   00000032   0x6023             STR      R3,[R4, #+0]
   \   00000034   0xE015             B.N      ??FSMC_ITConfig_2
    653              }
    654            }
    655            else
    656            {
    657              /* Disable the selected FSMC_Bank2 interrupts */
    658              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0:
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD105             BNE.N    ??FSMC_ITConfig_4
    659              {
    660                
    661                FSMC_Bank2->SR2 &= (u32)~FSMC_IT;
   \   0000003A   0x....             LDR.N    R3,??DataTable15_2  ;; 0xa0000064
   \   0000003C   0x681B             LDR      R3,[R3, #+0]
   \   0000003E   0x438B             BICS     R3,R3,R1
   \   00000040   0x....             LDR.N    R4,??DataTable15_2  ;; 0xa0000064
   \   00000042   0x6023             STR      R3,[R4, #+0]
   \   00000044   0xE00D             B.N      ??FSMC_ITConfig_2
    662              }
    663              /* Disable the selected FSMC_Bank3 interrupts */
    664              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_4:
   \   00000046   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004A   0xD105             BNE.N    ??FSMC_ITConfig_5
    665              {
    666                FSMC_Bank3->SR3 &= (u32)~FSMC_IT;
   \   0000004C   0x....             LDR.N    R3,??DataTable15_6  ;; 0xa0000084
   \   0000004E   0x681B             LDR      R3,[R3, #+0]
   \   00000050   0x438B             BICS     R3,R3,R1
   \   00000052   0x....             LDR.N    R4,??DataTable15_6  ;; 0xa0000084
   \   00000054   0x6023             STR      R3,[R4, #+0]
   \   00000056   0xE004             B.N      ??FSMC_ITConfig_2
    667              }
    668              /* Disable the selected FSMC_Bank4 interrupts */
    669              else
    670              {
    671                FSMC_Bank4->SR4 &= (u32)~FSMC_IT;    
   \                     ??FSMC_ITConfig_5:
   \   00000058   0x....             LDR.N    R3,??DataTable15_10  ;; 0xa00000a4
   \   0000005A   0x681B             LDR      R3,[R3, #+0]
   \   0000005C   0x438B             BICS     R3,R3,R1
   \   0000005E   0x....             LDR.N    R4,??DataTable15_10  ;; 0xa00000a4
   \   00000060   0x6023             STR      R3,[R4, #+0]
    672              }
    673            }
    674          }
   \                     ??FSMC_ITConfig_2:
   \   00000062   0xBC10             POP      {R4}
   \   00000064   0x4770             BX       LR               ;; return
    675                            
    676          /*******************************************************************************
    677          * Function Name  : FSMC_GetFlagStatus
    678          * Description    : Checks whether the specified FSMC flag is set or not.
    679          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    680          *                    This parameter can be one of the following values:
    681          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    682          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    683          *                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    684          *                  - FSMC_FLAG: specifies the flag to check.
    685          *                    This parameter can be one of the following values:
    686          *                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    687          *                       - FSMC_FLAG_Level: Level detection Flag.
    688          *                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    689          *                       - FSMC_FLAG_FEMPT: Fifo empty Flag. 
    690          * Output         : None
    691          * Return         : The new state of FSMC_FLAG (SET or RESET).
    692          *******************************************************************************/                   

   \                                 In section .text, align 2, keep-with-next
    693          FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
    694          {
   \                     FSMC_GetFlagStatus:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    695            FlagStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    696            u32 tmpsr = 0x00000000;
   \   00000006   0x2300             MOVS     R3,#+0
    697            
    698            /* Check the parameters */
    699            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    700            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    701            
    702            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000008   0x2A10             CMP      R2,#+16
   \   0000000A   0xD103             BNE.N    ??FSMC_GetFlagStatus_0
    703            {
    704              tmpsr = FSMC_Bank2->SR2;
   \   0000000C   0x....             LDR.N    R4,??DataTable15_2  ;; 0xa0000064
   \   0000000E   0x6824             LDR      R4,[R4, #+0]
   \   00000010   0x0023             MOVS     R3,R4
   \   00000012   0xE009             B.N      ??FSMC_GetFlagStatus_1
    705            }  
    706            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_0:
   \   00000014   0xF5B2 0x7F80      CMP      R2,#+256
   \   00000018   0xD103             BNE.N    ??FSMC_GetFlagStatus_2
    707            {
    708              tmpsr = FSMC_Bank3->SR3;
   \   0000001A   0x....             LDR.N    R4,??DataTable15_6  ;; 0xa0000084
   \   0000001C   0x6824             LDR      R4,[R4, #+0]
   \   0000001E   0x0023             MOVS     R3,R4
   \   00000020   0xE002             B.N      ??FSMC_GetFlagStatus_1
    709            }
    710            /* FSMC_Bank4_PCCARD*/
    711            else
    712            {
    713              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_2:
   \   00000022   0x....             LDR.N    R4,??DataTable15_10  ;; 0xa00000a4
   \   00000024   0x6824             LDR      R4,[R4, #+0]
   \   00000026   0x0023             MOVS     R3,R4
    714            } 
    715            
    716            /* Get the flag status */
    717            if ((tmpsr & FSMC_FLAG) != (u16)RESET )
   \                     ??FSMC_GetFlagStatus_1:
   \   00000028   0x420B             TST      R3,R1
   \   0000002A   0xD002             BEQ.N    ??FSMC_GetFlagStatus_3
    718            {
    719              bitstatus = SET;
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xE001             B.N      ??FSMC_GetFlagStatus_4
    720            }
    721            else
    722            {
    723              bitstatus = RESET;
   \                     ??FSMC_GetFlagStatus_3:
   \   00000032   0x2400             MOVS     R4,#+0
   \   00000034   0x0020             MOVS     R0,R4
    724            }
    725            /* Return the flag status */
    726            return bitstatus;
   \                     ??FSMC_GetFlagStatus_4:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xBC10             POP      {R4}
   \   0000003A   0x4770             BX       LR               ;; return
    727          }
    728          
    729          /*******************************************************************************
    730          * Function Name  : FSMC_ClearFlag
    731          * Description    : Clears the FSMCs pending flags.
    732          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    733          *                    This parameter can be one of the following values:
    734          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    735          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    736          *                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    737          *                  - FSMC_FLAG: specifies the flag to clear.
    738          *                    This parameter can be any combination of the following values:
    739          *                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    740          *                       - FSMC_FLAG_Level: Level detection Flag.
    741          *                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    742          * Output         : None
    743          * Return         : None
    744          *******************************************************************************/                   

   \                                 In section .text, align 2, keep-with-next
    745          void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
    746          {
    747           /* Check the parameters */
    748            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    749            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    750              
    751            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag:
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD105             BNE.N    ??FSMC_ClearFlag_0
    752            {
    753              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \   00000004   0x....             LDR.N    R2,??DataTable15_2  ;; 0xa0000064
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x438A             BICS     R2,R2,R1
   \   0000000A   0x....             LDR.N    R3,??DataTable15_2  ;; 0xa0000064
   \   0000000C   0x601A             STR      R2,[R3, #+0]
   \   0000000E   0xE00D             B.N      ??FSMC_ClearFlag_1
    754            }  
    755            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0:
   \   00000010   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000014   0xD105             BNE.N    ??FSMC_ClearFlag_2
    756            {
    757              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \   00000016   0x....             LDR.N    R2,??DataTable15_6  ;; 0xa0000084
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x438A             BICS     R2,R2,R1
   \   0000001C   0x....             LDR.N    R3,??DataTable15_6  ;; 0xa0000084
   \   0000001E   0x601A             STR      R2,[R3, #+0]
   \   00000020   0xE004             B.N      ??FSMC_ClearFlag_1
    758            }
    759            /* FSMC_Bank4_PCCARD*/
    760            else
    761            {
    762              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_2:
   \   00000022   0x....             LDR.N    R2,??DataTable15_10  ;; 0xa00000a4
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x438A             BICS     R2,R2,R1
   \   00000028   0x....             LDR.N    R3,??DataTable15_10  ;; 0xa00000a4
   \   0000002A   0x601A             STR      R2,[R3, #+0]
    763            }
    764          }
   \                     ??FSMC_ClearFlag_1:
   \   0000002C   0x4770             BX       LR               ;; return
    765          
    766          /*******************************************************************************
    767          * Function Name  : FSMC_GetITStatus
    768          * Description    : Checks whether the specified FSMC interrupt has occurred or not.
    769          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    770          *                    This parameter can be one of the following values:
    771          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    772          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    773          *                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    774          *                  - FSMC_IT: specifies the FSMC interrupt source to check.
    775          *                    This parameter can be one of the following values:
    776          *                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    777          *                       - FSMC_IT_Level: Level edge detection interrupt.                                  
    778          *                       - FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    779          * Output         : None
    780          * Return         : The new state of FSMC_IT (SET or RESET).
    781          *******************************************************************************/ 

   \                                 In section .text, align 2, keep-with-next
    782          ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
    783          {
   \                     FSMC_GetITStatus:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    784            ITStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    785            u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2500             MOVS     R5,#+0
    786            
    787            /* Check the parameters */
    788            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    789            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    790            
    791            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   0000000C   0x2A10             CMP      R2,#+16
   \   0000000E   0xD103             BNE.N    ??FSMC_GetITStatus_0
    792            {
    793              tmpsr = FSMC_Bank2->SR2;
   \   00000010   0x....             LDR.N    R6,??DataTable15_2  ;; 0xa0000064
   \   00000012   0x6836             LDR      R6,[R6, #+0]
   \   00000014   0x0033             MOVS     R3,R6
   \   00000016   0xE009             B.N      ??FSMC_GetITStatus_1
    794            }  
    795            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_0:
   \   00000018   0xF5B2 0x7F80      CMP      R2,#+256
   \   0000001C   0xD103             BNE.N    ??FSMC_GetITStatus_2
    796            {
    797              tmpsr = FSMC_Bank3->SR3;
   \   0000001E   0x....             LDR.N    R6,??DataTable15_6  ;; 0xa0000084
   \   00000020   0x6836             LDR      R6,[R6, #+0]
   \   00000022   0x0033             MOVS     R3,R6
   \   00000024   0xE002             B.N      ??FSMC_GetITStatus_1
    798            }
    799            /* FSMC_Bank4_PCCARD*/
    800            else
    801            {
    802              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_2:
   \   00000026   0x....             LDR.N    R6,??DataTable15_10  ;; 0xa00000a4
   \   00000028   0x6836             LDR      R6,[R6, #+0]
   \   0000002A   0x0033             MOVS     R3,R6
    803            } 
    804            
    805            itstatus = tmpsr & FSMC_IT;
   \                     ??FSMC_GetITStatus_1:
   \   0000002C   0xEA11 0x0603      ANDS     R6,R1,R3
   \   00000030   0x0034             MOVS     R4,R6
    806            
    807            itenable = tmpsr & (FSMC_IT >> 3);
   \   00000032   0xEA13 0x06D1      ANDS     R6,R3,R1, LSR #+3
   \   00000036   0x0035             MOVS     R5,R6
    808          
    809            if ((itstatus != (u32)RESET)  && (itenable != (u32)RESET))
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD004             BEQ.N    ??FSMC_GetITStatus_3
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD002             BEQ.N    ??FSMC_GetITStatus_3
    810            {
    811              bitstatus = SET;
   \   00000040   0x2601             MOVS     R6,#+1
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xE001             B.N      ??FSMC_GetITStatus_4
    812            }
    813            else
    814            {
    815              bitstatus = RESET;
   \                     ??FSMC_GetITStatus_3:
   \   00000046   0x2600             MOVS     R6,#+0
   \   00000048   0x0030             MOVS     R0,R6
    816            }
    817            return bitstatus; 
   \                     ??FSMC_GetITStatus_4:
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBC70             POP      {R4-R6}
   \   0000004E   0x4770             BX       LR               ;; return
    818          }
    819          
    820          /*******************************************************************************
    821          * Function Name  : FSMC_ClearITPendingBit
    822          * Description    : Clears the FSMCs interrupt pending bits.
    823          * Input          : - FSMC_Bank: specifies the FSMC Bank to be used
    824          *                    This parameter can be one of the following values:
    825          *                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
    826          *                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
    827          *                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    828          *                  - FSMC_IT: specifies the interrupt pending bit to clear.
    829          *                    This parameter can be any combination of the following values:
    830          *                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    831          *                       - FSMC_IT_Level: Level edge detection interrupt.                                  
    832          *                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
    833          * Output         : None
    834          * Return         : None
    835          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    836          void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
    837          {
    838            /* Check the parameters */
    839            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    840            assert_param(IS_FSMC_IT(FSMC_IT));
    841              
    842            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit:
   \   00000000   0x2810             CMP      R0,#+16
   \   00000002   0xD106             BNE.N    ??FSMC_ClearITPendingBit_0
    843            {
    844              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \   00000004   0x....             LDR.N    R2,??DataTable15_2  ;; 0xa0000064
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \   0000000C   0x....             LDR.N    R3,??DataTable15_2  ;; 0xa0000064
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE00F             B.N      ??FSMC_ClearITPendingBit_1
    845            }  
    846            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0:
   \   00000012   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000016   0xD106             BNE.N    ??FSMC_ClearITPendingBit_2
    847            {
    848              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \   00000018   0x....             LDR.N    R2,??DataTable15_6  ;; 0xa0000084
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \   00000020   0x....             LDR.N    R3,??DataTable15_6  ;; 0xa0000084
   \   00000022   0x601A             STR      R2,[R3, #+0]
   \   00000024   0xE005             B.N      ??FSMC_ClearITPendingBit_1
    849            }
    850            /* FSMC_Bank4_PCCARD*/
    851            else
    852            {
    853              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_2:
   \   00000026   0x....             LDR.N    R2,??DataTable15_10  ;; 0xa00000a4
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \   0000002E   0x....             LDR.N    R3,??DataTable15_10  ;; 0xa00000a4
   \   00000030   0x601A             STR      R2,[R3, #+0]
    854            }
    855          }
   \                     ??FSMC_ClearITPendingBit_1:
   \   00000032   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xA0000104         DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xA0000060         DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xA0000064         DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0xA0000068         DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xA000006C         DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0xA0000080         DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0xA0000084         DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xA0000088         DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0xA000008C         DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0xA00000A0         DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0xA00000A4         DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0xA00000A8         DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0xA00000AC         DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0xA00000B0         DC32     0xa00000b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x000FFFFE         DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x000FFFFB         DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x000FFFBF         DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0xA0000074         DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0xA0000094         DC32     0xa0000094
    856          
    857          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FSMC_ClearFlag
       0   FSMC_ClearITPendingBit
       0   FSMC_GetECC
       4   FSMC_GetFlagStatus
      12   FSMC_GetITStatus
       4   FSMC_ITConfig
       0   FSMC_NANDCmd
       0   FSMC_NANDDeInit
       0   FSMC_NANDECCCmd
       8   FSMC_NANDInit
       0   FSMC_NANDStructInit
       0   FSMC_NORSRAMCmd
       0   FSMC_NORSRAMDeInit
       0   FSMC_NORSRAMInit
       0   FSMC_NORSRAMStructInit
       0   FSMC_PCCARDCmd
       0   FSMC_PCCARDDeInit
       0   FSMC_PCCARDInit
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      46  FSMC_ClearFlag
      52  FSMC_ClearITPendingBit
      24  FSMC_GetECC
      60  FSMC_GetFlagStatus
      80  FSMC_GetITStatus
     102  FSMC_ITConfig
      70  FSMC_NANDCmd
      80  FSMC_NANDDeInit
      70  FSMC_NANDECCCmd
     152  FSMC_NANDInit
      82  FSMC_NANDStructInit
      50  FSMC_NORSRAMCmd
      56  FSMC_NORSRAMDeInit
     220  FSMC_NORSRAMInit
     138  FSMC_NORSRAMStructInit
      34  FSMC_PCCARDCmd
      48  FSMC_PCCARDDeInit
     132  FSMC_PCCARDInit
      90  FSMC_PCCARDStructInit

 
 1 662 bytes in section .text
 
 1 662 bytes of CODE memory

Errors: none
Warnings: none

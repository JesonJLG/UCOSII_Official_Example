###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\uCOS-II\Source\os_sem.c          #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\uCOS-II\Source\os_sem.c" -D      #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\os_sem.lst                   #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\os_sem.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\uCOS-II\Source\os_sem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                          SEMAPHORE MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2012, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_SEM.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.92.07
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #define  MICRIUM_SOURCE
     25          
     26          #ifndef  OS_MASTER_FILE
     27          #include <ucos_ii.h>
     28          #endif
     29          
     30          #if OS_SEM_EN > 0u
     31          /*$PAGE*/
     32          /*
     33          *********************************************************************************************************
     34          *                                          ACCEPT SEMAPHORE
     35          *
     36          * Description: This function checks the semaphore to see if a resource is available or, if an event
     37          *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
     38          *              resource is not available or the event did not occur.
     39          *
     40          * Arguments  : pevent     is a pointer to the event control block
     41          *
     42          * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
     43          *                         decremented to obtain the resource.
     44          *              == 0       if the resource is not available or the event did not occur or,
     45          *                         if 'pevent' is a NULL pointer or,
     46          *                         if you didn't pass a pointer to a semaphore
     47          *********************************************************************************************************
     48          */
     49          
     50          #if OS_SEM_ACCEPT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     51          INT16U  OSSemAccept (OS_EVENT *pevent)
     52          {
   \                     OSSemAccept:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     53              INT16U     cnt;
     54          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
     55              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
     56          #endif
     57          
     58          
     59          
     60          #if OS_ARG_CHK_EN > 0u
     61              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
     62                  return (0u);
     63              }
     64          #endif
     65              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD001             BEQ.N    ??OSSemAccept_0
     66                  return (0u);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??OSSemAccept_1
     67              }
     68              OS_ENTER_CRITICAL();
   \                     ??OSSemAccept_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x0006             MOVS     R6,R0
     69              cnt = pevent->OSEventCnt;
   \   00000016   0x8920             LDRH     R0,[R4, #+8]
   \   00000018   0x0005             MOVS     R5,R0
     70              if (cnt > 0u) {                                   /* See if resource is available                  */
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD002             BEQ.N    ??OSSemAccept_2
     71                  pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
   \   00000020   0x8920             LDRH     R0,[R4, #+8]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x8120             STRH     R0,[R4, #+8]
     72              }
     73              OS_EXIT_CRITICAL();
   \                     ??OSSemAccept_2:
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
     74              return (cnt);                                     /* Return semaphore count                        */
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemAccept_1:
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
     75          }
     76          #endif
     77          
     78          /*$PAGE*/
     79          /*
     80          *********************************************************************************************************
     81          *                                         CREATE A SEMAPHORE
     82          *
     83          * Description: This function creates a semaphore.
     84          *
     85          * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
     86          *                            available (or no event has occurred).  You initialize the semaphore to a
     87          *                            non-zero value to specify how many resources are available (e.g. if you have
     88          *                            10 resources, you would initialize the semaphore to 10).
     89          *
     90          * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
     91          *                            created semaphore
     92          *              == (void *)0  if no event control blocks were available
     93          *********************************************************************************************************
     94          */
     95          

   \                                 In section .text, align 2, keep-with-next
     96          OS_EVENT  *OSSemCreate (INT16U cnt)
     97          {
   \                     OSSemCreate:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     98              OS_EVENT  *pevent;
     99          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    100              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2600             MOVS     R6,#+0
    101          #endif
    102          
    103          
    104          
    105          #ifdef OS_SAFETY_CRITICAL_IEC61508
    106              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    107                  OS_SAFETY_CRITICAL_EXCEPTION();
    108                  return ((OS_EVENT *)0);
    109              }
    110          #endif
    111          
    112              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \   00000006   0x....             LDR.N    R0,??DataTable2_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??OSSemCreate_0
    113                  return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01E             B.N      ??OSSemCreate_1
    114              }
    115              OS_ENTER_CRITICAL();
   \                     ??OSSemCreate_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x0006             MOVS     R6,R0
    116              pevent = OSEventFreeList;                              /* Get next free event control block        */
   \   00000018   0x....             LDR.N    R0,??DataTable2_2
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0005             MOVS     R5,R0
    117              if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
   \   0000001E   0x....             LDR.N    R0,??DataTable2_2
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??OSSemCreate_2
    118                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
   \   00000026   0x....             LDR.N    R0,??DataTable2_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x....             LDR.N    R1,??DataTable2_2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    119              }
    120              OS_EXIT_CRITICAL();
   \                     ??OSSemCreate_2:
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
    121              if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD009             BEQ.N    ??OSSemCreate_3
    122                  pevent->OSEventType    = OS_EVENT_TYPE_SEM;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x7028             STRB     R0,[R5, #+0]
    123                  pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
   \   0000003E   0x812C             STRH     R4,[R5, #+8]
    124                  pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6068             STR      R0,[R5, #+4]
    125          #if OS_EVENT_NAME_EN > 0u
    126                  pevent->OSEventName    = (INT8U *)(void *)"?";
   \   00000044   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   00000046   0x6168             STR      R0,[R5, #+20]
    127          #endif
    128                  OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_EventWaitListInit
    129              }
    130              return (pevent);
   \                     ??OSSemCreate_3:
   \   0000004E   0x0028             MOVS     R0,R5
   \                     ??OSSemCreate_1:
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    131          }
    132          
    133          /*$PAGE*/
    134          /*
    135          *********************************************************************************************************
    136          *                                         DELETE A SEMAPHORE
    137          *
    138          * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
    139          *
    140          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    141          *                            semaphore.
    142          *
    143          *              opt           determines delete options as follows:
    144          *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
    145          *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
    146          *                                                    In this case, all the tasks pending will be readied.
    147          *
    148          *              perr          is a pointer to an error code that can contain one of the following values:
    149          *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
    150          *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
    151          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    152          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
    153          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
    154          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    155          *
    156          * Returns    : pevent        upon error
    157          *              (OS_EVENT *)0 if the semaphore was successfully deleted.
    158          *
    159          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    160          *                 the semaphore MUST check the return code of OSSemPend().
    161          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
    162          *                 they check 'pevent' to see that it's a NULL pointer.
    163          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    164          *                 time is directly proportional to the number of tasks waiting on the semaphore.
    165          *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
    166          *                 applications where the semaphore is used for mutual exclusion because the resource(s)
    167          *                 will no longer be guarded by the semaphore.
    168          *              5) All tasks that were waiting for the semaphore will be readied and returned an 
    169          *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
    170          *********************************************************************************************************
    171          */
    172          
    173          #if OS_SEM_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    174          OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
    175                               INT8U      opt,
    176                               INT8U     *perr)
    177          {
   \                     OSSemDel:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    178              BOOLEAN    tasks_waiting;
    179              OS_EVENT  *pevent_return;
    180          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    181              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    182          #endif
    183          
    184          
    185          
    186          #ifdef OS_SAFETY_CRITICAL
    187              if (perr == (INT8U *)0) {
    188                  OS_SAFETY_CRITICAL_EXCEPTION();
    189                  return ((OS_EVENT *)0);
    190              }
    191          #endif
    192          
    193          #if OS_ARG_CHK_EN > 0u
    194              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    195                  *perr = OS_ERR_PEVENT_NULL;
    196                  return (pevent);
    197              }
    198          #endif
    199              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
   \   0000000E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD003             BEQ.N    ??OSSemDel_0
    200                  *perr = OS_ERR_EVENT_TYPE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    201                  return (pevent);
   \   0000001A   0x4648             MOV      R0,R9
   \   0000001C   0xE06A             B.N      ??OSSemDel_1
    202              }
    203              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
   \                     ??OSSemDel_0:
   \   0000001E   0x....             LDR.N    R0,??DataTable2_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSSemDel_2
    204                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000026   0x200F             MOVS     R0,#+15
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    205                  return (pevent);
   \   0000002A   0x4648             MOV      R0,R9
   \   0000002C   0xE062             B.N      ??OSSemDel_1
    206              }
    207              OS_ENTER_CRITICAL();
   \                     ??OSSemDel_2:
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000032   0x4680             MOV      R8,R0
    208              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
   \   00000034   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD002             BEQ.N    ??OSSemDel_3
    209                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE001             B.N      ??OSSemDel_4
    210              } else {
    211                  tasks_waiting = OS_FALSE;                          /* No                                       */
   \                     ??OSSemDel_3:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0006             MOVS     R6,R0
    212              }
    213              switch (opt) {
   \                     ??OSSemDel_4:
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD002             BEQ.N    ??OSSemDel_5
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD022             BEQ.N    ??OSSemDel_6
   \   00000050   0xE049             B.N      ??OSSemDel_7
    214                  case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
    215                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSSemDel_5:
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD117             BNE.N    ??OSSemDel_8
    216          #if OS_EVENT_NAME_EN > 0u
    217                           pevent->OSEventName    = (INT8U *)(void *)"?";
   \   00000058   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   0000005A   0xF8C9 0x0014      STR      R0,[R9, #+20]
    218          #endif
    219                           pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF889 0x0000      STRB     R0,[R9, #+0]
    220                           pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
   \   00000064   0x....             LDR.N    R0,??DataTable2_2
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF8C9 0x0004      STR      R0,[R9, #+4]
    221                           pevent->OSEventCnt     = 0u;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF8A9 0x0008      STRH     R0,[R9, #+8]
    222                           OSEventFreeList        = pevent;          /* Get next free event control block        */
   \   00000072   0x....             LDR.N    R0,??DataTable2_2
   \   00000074   0xF8C0 0x9000      STR      R9,[R0, #+0]
    223                           OS_EXIT_CRITICAL();
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Restore
    224                           *perr                  = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7028             STRB     R0,[R5, #+0]
    225                           pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0007             MOVS     R7,R0
   \   00000086   0xE005             B.N      ??OSSemDel_9
    226                       } else {
    227                           OS_EXIT_CRITICAL();
   \                     ??OSSemDel_8:
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0x.... 0x....      BL       OS_CPU_SR_Restore
    228                           *perr                  = OS_ERR_TASK_WAITING;
   \   0000008E   0x2049             MOVS     R0,#+73
   \   00000090   0x7028             STRB     R0,[R5, #+0]
    229                           pevent_return          = pevent;
   \   00000092   0x464F             MOV      R7,R9
    230                       }
    231                       break;
   \                     ??OSSemDel_9:
   \   00000094   0xE02D             B.N      ??OSSemDel_10
    232          
    233                  case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
    234                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
   \                     ??OSSemDel_6:
   \   00000096   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD006             BEQ.N    ??OSSemDel_11
    235                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
   \   0000009E   0x2302             MOVS     R3,#+2
   \   000000A0   0x2201             MOVS     R2,#+1
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       OS_EventTaskRdy
   \   000000AA   0xE7F4             B.N      ??OSSemDel_6
    236                       }
    237          #if OS_EVENT_NAME_EN > 0u
    238                       pevent->OSEventName    = (INT8U *)(void *)"?";
   \                     ??OSSemDel_11:
   \   000000AC   0x....             ADR.N    R0,??DataTable2  ;; "\?"
   \   000000AE   0xF8C9 0x0014      STR      R0,[R9, #+20]
    239          #endif
    240                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF889 0x0000      STRB     R0,[R9, #+0]
    241                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   000000B8   0x....             LDR.N    R0,??DataTable2_2
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF8C9 0x0004      STR      R0,[R9, #+4]
    242                       pevent->OSEventCnt     = 0u;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8A9 0x0008      STRH     R0,[R9, #+8]
    243                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   000000C6   0x....             LDR.N    R0,??DataTable2_2
   \   000000C8   0xF8C0 0x9000      STR      R9,[R0, #+0]
    244                       OS_EXIT_CRITICAL();
   \   000000CC   0x4640             MOV      R0,R8
   \   000000CE   0x.... 0x....      BL       OS_CPU_SR_Restore
    245                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   000000D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D4   0x2E01             CMP      R6,#+1
   \   000000D6   0xD101             BNE.N    ??OSSemDel_12
    246                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   000000D8   0x.... 0x....      BL       OS_Sched
    247                       }
    248                       *perr                  = OS_ERR_NONE;
   \                     ??OSSemDel_12:
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x7028             STRB     R0,[R5, #+0]
    249                       pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x0007             MOVS     R7,R0
    250                       break;
   \   000000E4   0xE005             B.N      ??OSSemDel_10
    251          
    252                  default:
    253                       OS_EXIT_CRITICAL();
   \                     ??OSSemDel_7:
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x.... 0x....      BL       OS_CPU_SR_Restore
    254                       *perr                  = OS_ERR_INVALID_OPT;
   \   000000EC   0x2007             MOVS     R0,#+7
   \   000000EE   0x7028             STRB     R0,[R5, #+0]
    255                       pevent_return          = pevent;
   \   000000F0   0x464F             MOV      R7,R9
    256                       break;
    257              }
    258              return (pevent_return);
   \                     ??OSSemDel_10:
   \   000000F2   0x0038             MOVS     R0,R7
   \                     ??OSSemDel_1:
   \   000000F4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    259          }
    260          #endif
    261          
    262          /*$PAGE*/
    263          /*
    264          *********************************************************************************************************
    265          *                                          PEND ON SEMAPHORE
    266          *
    267          * Description: This function waits for a semaphore.
    268          *
    269          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    270          *                            semaphore.
    271          *
    272          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    273          *                            wait for the resource up to the amount of time specified by this argument.
    274          *                            If you specify 0, however, your task will wait forever at the specified
    275          *                            semaphore or, until the resource becomes available (or the event occurs).
    276          *
    277          *              perr          is a pointer to where an error message will be deposited.  Possible error
    278          *                            messages are:
    279          *
    280          *                            OS_ERR_NONE         The call was successful and your task owns the resource
    281          *                                                or, the event you are waiting for occurred.
    282          *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
    283          *                                                'timeout'.
    284          *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
    285          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
    286          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    287          *                                                would lead to a suspension.
    288          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    289          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    290          *
    291          * Returns    : none
    292          *********************************************************************************************************
    293          */
    294          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    295          void  OSSemPend (OS_EVENT  *pevent,
    296                           INT32U     timeout,
    297                           INT8U     *perr)
    298          {
   \                     OSSemPend:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    299          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    300              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    301          #endif
    302          
    303          
    304          
    305          #ifdef OS_SAFETY_CRITICAL
    306              if (perr == (INT8U *)0) {
    307                  OS_SAFETY_CRITICAL_EXCEPTION();
    308                  return;
    309              }
    310          #endif
    311          
    312          #if OS_ARG_CHK_EN > 0u
    313              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    314                  *perr = OS_ERR_PEVENT_NULL;
    315                  return;
    316              }
    317          #endif
    318              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD002             BEQ.N    ??OSSemPend_0
    319                  *perr = OS_ERR_EVENT_TYPE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7030             STRB     R0,[R6, #+0]
    320                  return;
   \   00000014   0xE064             B.N      ??OSSemPend_1
    321              }
    322              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
   \                     ??OSSemPend_0:
   \   00000016   0x....             LDR.N    R0,??DataTable2_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??OSSemPend_2
    323                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7030             STRB     R0,[R6, #+0]
    324                  return;
   \   00000022   0xE05D             B.N      ??OSSemPend_1
    325              }
    326              if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
   \                     ??OSSemPend_2:
   \   00000024   0x....             LDR.N    R0,??DataTable2_3
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ.N    ??OSSemPend_3
    327                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   0000002C   0x200D             MOVS     R0,#+13
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
    328                  return;
   \   00000030   0xE056             B.N      ??OSSemPend_1
    329              }
    330              OS_ENTER_CRITICAL();
   \                     ??OSSemPend_3:
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000036   0x0007             MOVS     R7,R0
    331              if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
   \   00000038   0x8920             LDRH     R0,[R4, #+8]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD008             BEQ.N    ??OSSemPend_4
    332                  pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
   \   0000003E   0x8920             LDRH     R0,[R4, #+8]
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x8120             STRH     R0,[R4, #+8]
    333                  OS_EXIT_CRITICAL();
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       OS_CPU_SR_Restore
    334                  *perr = OS_ERR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
    335                  return;
   \   0000004E   0xE047             B.N      ??OSSemPend_1
    336              }
    337                                                                /* Otherwise, must wait until event occurs       */
    338              OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
   \                     ??OSSemPend_4:
   \   00000050   0x....             LDR.N    R0,??DataTable2_4
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000058   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005C   0x....             LDR.N    R1,??DataTable2_4
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF881 0x0034      STRB     R0,[R1, #+52]
    339              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000064   0x....             LDR.N    R0,??DataTable2_4
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0xF880 0x1035      STRB     R1,[R0, #+53]
    340              OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
   \   0000006E   0x....             LDR.N    R0,??DataTable2_4
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x6305             STR      R5,[R0, #+48]
    341              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_EventTaskWait
    342              OS_EXIT_CRITICAL();
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0x.... 0x....      BL       OS_CPU_SR_Restore
    343              OS_Sched();                                       /* Find next highest priority task ready         */
   \   00000080   0x.... 0x....      BL       OS_Sched
    344              OS_ENTER_CRITICAL();
   \   00000084   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000088   0x0007             MOVS     R7,R0
    345              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
   \   0000008A   0x....             LDR.N    R0,??DataTable2_4
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??OSSemPend_5
   \   00000096   0x2802             CMP      R0,#+2
   \   00000098   0xD003             BEQ.N    ??OSSemPend_6
   \   0000009A   0xE005             B.N      ??OSSemPend_7
    346                  case OS_STAT_PEND_OK:
    347                       *perr = OS_ERR_NONE;
   \                     ??OSSemPend_5:
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x7030             STRB     R0,[R6, #+0]
    348                       break;
   \   000000A0   0xE009             B.N      ??OSSemPend_8
    349          
    350                  case OS_STAT_PEND_ABORT:
    351                       *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
   \                     ??OSSemPend_6:
   \   000000A2   0x200E             MOVS     R0,#+14
   \   000000A4   0x7030             STRB     R0,[R6, #+0]
    352                       break;
   \   000000A6   0xE006             B.N      ??OSSemPend_8
    353          
    354                  case OS_STAT_PEND_TO:
    355                  default:
    356                       OS_EventTaskRemove(OSTCBCur, pevent);
   \                     ??OSSemPend_7:
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0x....             LDR.N    R0,??DataTable2_4
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       OS_EventTaskRemove
    357                       *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
   \   000000B2   0x200A             MOVS     R0,#+10
   \   000000B4   0x7030             STRB     R0,[R6, #+0]
    358                       break;
    359              }
    360              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
   \                     ??OSSemPend_8:
   \   000000B6   0x....             LDR.N    R0,??DataTable2_4
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xF880 0x1034      STRB     R1,[R0, #+52]
    361              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
   \   000000C0   0x....             LDR.N    R0,??DataTable2_4
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0xF880 0x1035      STRB     R1,[R0, #+53]
    362              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
   \   000000CA   0x....             LDR.N    R0,??DataTable2_4
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0x61C1             STR      R1,[R0, #+28]
    363          #if (OS_EVENT_MULTI_EN > 0u)
    364              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
   \   000000D2   0x....             LDR.N    R0,??DataTable2_4
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x6201             STR      R1,[R0, #+32]
    365          #endif
    366              OS_EXIT_CRITICAL();
   \   000000DA   0x0038             MOVS     R0,R7
   \   000000DC   0x.... 0x....      BL       OS_CPU_SR_Restore
    367          }
   \                     ??OSSemPend_1:
   \   000000E0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    368          
    369          /*$PAGE*/
    370          /*
    371          *********************************************************************************************************
    372          *                                    ABORT WAITING ON A SEMAPHORE
    373          *
    374          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
    375          *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
    376          *              the semaphore via OSSemPost().
    377          *
    378          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    379          *                            semaphore.
    380          *
    381          *              opt           determines the type of ABORT performed:
    382          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    383          *                                                     semaphore
    384          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    385          *                                                     semaphore
    386          *
    387          *              perr          is a pointer to where an error message will be deposited.  Possible error
    388          *                            messages are:
    389          *
    390          *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
    391          *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
    392          *                                                and informed of the aborted wait; check return value
    393          *                                                for the number of tasks whose wait on the semaphore
    394          *                                                was aborted.
    395          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
    396          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    397          *
    398          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    399          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    400          *********************************************************************************************************
    401          */
    402          
    403          #if OS_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    404          INT8U  OSSemPendAbort (OS_EVENT  *pevent,
    405                                 INT8U      opt,
    406                                 INT8U     *perr)
    407          {
   \                     OSSemPendAbort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    408              INT8U      nbr_tasks;
    409          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    410              OS_CPU_SR  cpu_sr = 0u;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    411          #endif
    412          
    413          
    414          
    415          #ifdef OS_SAFETY_CRITICAL
    416              if (perr == (INT8U *)0) {
    417                  OS_SAFETY_CRITICAL_EXCEPTION();
    418                  return (0u);
    419              }
    420          #endif
    421          
    422          #if OS_ARG_CHK_EN > 0u
    423              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    424                  *perr = OS_ERR_PEVENT_NULL;
    425                  return (0u);
    426              }
    427          #endif
    428              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD003             BEQ.N    ??OSSemPendAbort_0
    429                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7030             STRB     R0,[R6, #+0]
    430                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02D             B.N      ??OSSemPendAbort_1
    431              }
    432              OS_ENTER_CRITICAL();
   \                     ??OSSemPendAbort_0:
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000020   0x4680             MOV      R8,R0
    433              if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
   \   00000022   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD021             BEQ.N    ??OSSemPendAbort_2
    434                  nbr_tasks = 0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x0007             MOVS     R7,R0
    435                  switch (opt) {
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD10B             BNE.N    ??OSSemPendAbort_3
    436                      case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
    437                           while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
   \                     ??OSSemPendAbort_4:
   \   00000032   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??OSSemPendAbort_5
    438                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
   \   00000038   0x2302             MOVS     R3,#+2
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_EventTaskRdy
    439                               nbr_tasks++;
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \   00000046   0xE7F4             B.N      ??OSSemPendAbort_4
    440                           }
    441                           break;
   \                     ??OSSemPendAbort_5:
   \   00000048   0xE006             B.N      ??OSSemPendAbort_6
    442          
    443                      case OS_PEND_OPT_NONE:
    444                      default:                                  /* No,  ready HPT       waiting on semaphore     */
    445                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
   \                     ??OSSemPendAbort_3:
   \   0000004A   0x2302             MOVS     R3,#+2
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       OS_EventTaskRdy
    446                           nbr_tasks++;
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
    447                           break;
    448                  }
    449                  OS_EXIT_CRITICAL();
   \                     ??OSSemPendAbort_6:
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       OS_CPU_SR_Restore
    450                  OS_Sched();                                   /* Find HPT ready to run                         */
   \   0000005E   0x.... 0x....      BL       OS_Sched
    451                  *perr = OS_ERR_PEND_ABORT;
   \   00000062   0x200E             MOVS     R0,#+14
   \   00000064   0x7030             STRB     R0,[R6, #+0]
    452                  return (nbr_tasks);
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE005             B.N      ??OSSemPendAbort_1
    453              }
    454              OS_EXIT_CRITICAL();
   \                     ??OSSemPendAbort_2:
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Restore
    455              *perr = OS_ERR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    456              return (0u);                                      /* No tasks waiting on semaphore                 */
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??OSSemPendAbort_1:
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    457          }
    458          #endif
    459          
    460          /*$PAGE*/
    461          /*
    462          *********************************************************************************************************
    463          *                                         POST TO A SEMAPHORE
    464          *
    465          * Description: This function signals a semaphore
    466          *
    467          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    468          *                            semaphore.
    469          *
    470          * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
    471          *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
    472          *                                  signaled the semaphore more often than you waited on it with either
    473          *                                  OSSemAccept() or OSSemPend().
    474          *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
    475          *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    476          *********************************************************************************************************
    477          */
    478          

   \                                 In section .text, align 2, keep-with-next
    479          INT8U  OSSemPost (OS_EVENT *pevent)
    480          {
   \                     OSSemPost:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    481          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    482              OS_CPU_SR  cpu_sr = 0u;
   \   00000004   0x2500             MOVS     R5,#+0
    483          #endif
    484          
    485          
    486          
    487          #if OS_ARG_CHK_EN > 0u
    488              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    489                  return (OS_ERR_PEVENT_NULL);
    490              }
    491          #endif
    492              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD001             BEQ.N    ??OSSemPost_0
    493                  return (OS_ERR_EVENT_TYPE);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE024             B.N      ??OSSemPost_1
    494              }
    495              OS_ENTER_CRITICAL();
   \                     ??OSSemPost_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x0005             MOVS     R5,R0
    496              if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
   \   00000016   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00D             BEQ.N    ??OSSemPost_2
    497                                                                /* Ready HPT waiting on event                    */
    498                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000028   0x0006             MOVS     R6,R0
    499                  OS_EXIT_CRITICAL();
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       OS_CPU_SR_Restore
    500                  OS_Sched();                                   /* Find HPT ready to run                         */
   \   00000030   0x.... 0x....      BL       OS_Sched
    501                  return (OS_ERR_NONE);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE010             B.N      ??OSSemPost_1
    502              }
    503              if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
   \                     ??OSSemPost_2:
   \   00000038   0x8920             LDRH     R0,[R4, #+8]
   \   0000003A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD007             BEQ.N    ??OSSemPost_3
    504                  pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
   \   00000042   0x8920             LDRH     R0,[R4, #+8]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x8120             STRH     R0,[R4, #+8]
    505                  OS_EXIT_CRITICAL();
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    506                  return (OS_ERR_NONE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE003             B.N      ??OSSemPost_1
    507              }
    508              OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
   \                     ??OSSemPost_3:
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       OS_CPU_SR_Restore
    509              return (OS_ERR_SEM_OVF);
   \   00000058   0x2033             MOVS     R0,#+51
   \                     ??OSSemPost_1:
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    510          }
    511          
    512          /*$PAGE*/
    513          /*
    514          *********************************************************************************************************
    515          *                                          QUERY A SEMAPHORE
    516          *
    517          * Description: This function obtains information about a semaphore
    518          *
    519          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    520          *                            semaphore
    521          *
    522          *              p_sem_data    is a pointer to a structure that will contain information about the
    523          *                            semaphore.
    524          *
    525          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    526          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
    527          *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
    528          *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
    529          *********************************************************************************************************
    530          */
    531          
    532          #if OS_SEM_QUERY_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    533          INT8U  OSSemQuery (OS_EVENT     *pevent,
    534                             OS_SEM_DATA  *p_sem_data)
    535          {
   \                     OSSemQuery:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    536              INT8U       i;
    537              OS_PRIO    *psrc;
    538              OS_PRIO    *pdest;
    539          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    540              OS_CPU_SR   cpu_sr = 0u;
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    541          #endif
    542          
    543          
    544          
    545          #if OS_ARG_CHK_EN > 0u
    546              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    547                  return (OS_ERR_PEVENT_NULL);
    548              }
    549              if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
    550                  return (OS_ERR_PDATA_NULL);
    551              }
    552          #endif
    553              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD001             BEQ.N    ??OSSemQuery_0
    554                  return (OS_ERR_EVENT_TYPE);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE01C             B.N      ??OSSemQuery_1
    555              }
    556              OS_ENTER_CRITICAL();
   \                     ??OSSemQuery_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x4681             MOV      R9,R0
    557              p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
   \   0000001C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001E   0x72A8             STRB     R0,[R5, #+10]
    558              psrc                   = &pevent->OSEventTbl[0];
   \   00000020   0xF204 0x000B      ADDW     R0,R4,#+11
   \   00000024   0x0007             MOVS     R7,R0
    559              pdest                  = &p_sem_data->OSEventTbl[0];
   \   00000026   0x1CA8             ADDS     R0,R5,#+2
   \   00000028   0x4680             MOV      R8,R0
    560              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0006             MOVS     R6,R0
   \                     ??OSSemQuery_2:
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E08             CMP      R6,#+8
   \   00000032   0xD207             BCS.N    ??OSSemQuery_3
    561                  *pdest++ = *psrc++;
   \   00000034   0x7838             LDRB     R0,[R7, #+0]
   \   00000036   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
   \   0000003C   0xF118 0x0801      ADDS     R8,R8,#+1
    562              }
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0xE7F4             B.N      ??OSSemQuery_2
    563              p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
   \                     ??OSSemQuery_3:
   \   00000044   0x8920             LDRH     R0,[R4, #+8]
   \   00000046   0x8028             STRH     R0,[R5, #+0]
    564              OS_EXIT_CRITICAL();
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    565              return (OS_ERR_NONE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??OSSemQuery_1:
   \   00000050   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    566          }
    567          #endif                                                     /* OS_SEM_QUERY_EN                          */
    568          
    569          /*$PAGE*/
    570          /*
    571          *********************************************************************************************************
    572          *                                            SET SEMAPHORE
    573          *
    574          * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
    575          *              this value would be 0.
    576          *
    577          *              You would typically use this function when a semaphore is used as a signaling mechanism
    578          *              and, you want to reset the count value.
    579          *
    580          * Arguments  : pevent     is a pointer to the event control block
    581          *
    582          *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
    583          *                         semaphore count.
    584          *
    585          *              perr       is a pointer to an error code returned by the function as follows:
    586          *
    587          *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
    588          *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
    589          *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
    590          *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
    591          *********************************************************************************************************
    592          */
    593          
    594          #if OS_SEM_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    595          void  OSSemSet (OS_EVENT  *pevent,
    596                          INT16U     cnt,
    597                          INT8U     *perr)
    598          {
   \                     OSSemSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    599          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    600              OS_CPU_SR  cpu_sr = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
    601          #endif
    602          
    603          
    604          
    605          #ifdef OS_SAFETY_CRITICAL
    606              if (perr == (INT8U *)0) {
    607                  OS_SAFETY_CRITICAL_EXCEPTION();
    608                  return;
    609              }
    610          #endif
    611          
    612          #if OS_ARG_CHK_EN > 0u
    613              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    614                  *perr = OS_ERR_PEVENT_NULL;
    615                  return;
    616              }
    617          #endif
    618              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD002             BEQ.N    ??OSSemSet_0
    619                  *perr = OS_ERR_EVENT_TYPE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7030             STRB     R0,[R6, #+0]
    620                  return;
   \   00000014   0xE013             B.N      ??OSSemSet_1
    621              }
    622              OS_ENTER_CRITICAL();
   \                     ??OSSemSet_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x0007             MOVS     R7,R0
    623              *perr = OS_ERR_NONE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7030             STRB     R0,[R6, #+0]
    624              if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
   \   00000020   0x8920             LDRH     R0,[R4, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??OSSemSet_2
    625                  pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
   \   00000026   0x8125             STRH     R5,[R4, #+8]
   \   00000028   0xE006             B.N      ??OSSemSet_3
    626              } else {                                          /* No                                            */
    627                  if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
   \                     ??OSSemSet_2:
   \   0000002A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??OSSemSet_4
    628                      pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
   \   00000030   0x8125             STRH     R5,[R4, #+8]
   \   00000032   0xE001             B.N      ??OSSemSet_3
    629                  } else {
    630                      *perr              = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_4:
   \   00000034   0x2049             MOVS     R0,#+73
   \   00000036   0x7030             STRB     R0,[R6, #+0]
    631                  }
    632              }
    633              OS_EXIT_CRITICAL();
   \                     ??OSSemSet_3:
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    634          }
   \                     ??OSSemSet_1:
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x3F 0x00          DC8      "\?",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .rodata, align 2
   \   00000000   0x3F 0x00          DC8 "?"
    635          #endif
    636          
    637          #endif                                                /* OS_SEM_EN                                     */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSSemAccept
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OSSemCreate
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_EventWaitListInit
      32   OSSemDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_EventTaskRdy
        32   -> OS_Sched
      24   OSSemPend
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskWait
        24   -> OS_Sched
      24   OSSemPendAbort
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      16   OSSemPost
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_EventTaskRdy
        16   -> OS_Sched
      32   OSSemQuery
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      24   OSSemSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      50  OSSemAccept
      82  OSSemCreate
     248  OSSemDel
     226  OSSemPend
     124  OSSemPendAbort
      92  OSSemPost
      84  OSSemQuery
      64  OSSemSet

 
   2 bytes in section .rodata
 990 bytes in section .text
 
 990 bytes of CODE  memory
   2 bytes of CONST memory

Errors: none
Warnings: none

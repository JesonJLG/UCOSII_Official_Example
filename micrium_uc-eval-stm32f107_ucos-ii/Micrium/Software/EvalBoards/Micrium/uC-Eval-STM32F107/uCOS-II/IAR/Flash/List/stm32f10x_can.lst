###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:22 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_can.c                    #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_can.c" -D                #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_can.lst            #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_can.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_can.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_can.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the CAN firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_can.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          
     22          /* Private define ------------------------------------------------------------*/
     23          /* CAN Master Control Register bits */
     24          #define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
     25          #define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
     26          #define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
     27          #define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
     28          #define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
     29          #define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
     30          #define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
     31          #define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
     32          #define MCR_RESET    ((u32)0x00008000) /* time triggered communication */
     33          #define MCR_DBF      ((u32)0x00010000) /* software master reset */
     34          
     35          /* CAN Master Status Register bits */
     36          #define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
     37          #define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
     38          #define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
     39          
     40          /* CAN Transmit Status Register bits */
     41          #define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
     42          #define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
     43          #define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
     44          #define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
     45          #define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
     46          #define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
     47          #define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
     48          #define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
     49          #define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
     50          #define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
     51          #define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
     52          #define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
     53          
     54          /* CAN Receive FIFO 0 Register bits */
     55          #define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
     56          #define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
     57          #define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
     58          
     59          /* CAN Receive FIFO 1 Register bits */
     60          #define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
     61          #define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
     62          #define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
     63          
     64          /* CAN Error Status Register bits */
     65          #define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
     66          #define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
     67          #define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
     68          
     69          /* CAN Mailbox Transmit Request */
     70          #define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
     71          
     72          /* CAN Filter Master Register bits */
     73          #define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
     74          
     75          /* Time out for INAK bit */
     76          #define INAK_TimeOut        ((u16)0xFFFF)
     77          
     78          /* Time out for SLAK bit */
     79          #define SLAK_TimeOut        ((u16)0xFFFF)
     80          
     81          /* Private macro -------------------------------------------------------------*/
     82          /* Private variables ---------------------------------------------------------*/
     83          /* Private function prototypes -----------------------------------------------*/
     84          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
     85          
     86          /* Private functions ---------------------------------------------------------*/
     87          /*******************************************************************************
     88          * Function Name  : CAN_DeInit
     89          * Description    : Deinitializes the CAN peripheral registers to their default
     90          *                  reset values.
     91          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
     92          * Output         : None.
     93          * Return         : None.
     94          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     95          void CAN_DeInit(CAN_TypeDef* CANx)
     96          {
   \                     CAN_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     97            /* Check the parameters */
     98            assert_param(IS_CAN_ALL_PERIPH(CANx));
     99           
    100            switch (*(u32*)&CANx)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x....             LDR.N    R1,??DataTable2  ;; 0x40006400
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD003             BEQ.N    ??CAN_DeInit_0
   \   0000000C   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40006800
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD00B             BEQ.N    ??CAN_DeInit_1
   \   00000012   0xE015             B.N      ??CAN_DeInit_2
    101            {
    102              case CAN1_BASE:
    103                /* Enable CAN reset state */
    104                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \                     ??CAN_DeInit_0:
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF05F 0x7000      MOVS     R0,#+33554432
   \   0000001A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    105                /* Release CAN from reset state */
    106                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000024   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    107                break;
   \   00000028   0xE00A             B.N      ??CAN_DeInit_3
    108              
    109          	case CAN2_BASE:
    110                /* Enable CAN reset state */
    111                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_1:
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000030   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    112                /* Release CAN from reset state */
    113                RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF05F 0x6080      MOVS     R0,#+67108864
   \   0000003A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    114                break;            
   \   0000003E   0xE7FF             B.N      ??CAN_DeInit_3
    115          
    116              default:
    117                break;
    118            }
    119          }
   \                     ??CAN_DeInit_2:
   \                     ??CAN_DeInit_3:
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    120          
    121          /*******************************************************************************
    122          * Function Name  : CAN_Init
    123          * Description    : Initializes the CAN peripheral according to the specified
    124          *                  parameters in the CAN_InitStruct.
    125          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    126          *                  - CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    127          *                  contains the configuration information for the CAN peripheral.
    128          * Output         : None.
    129          * Return         : Constant indicates initialization succeed which will be 
    130          *                  CANINITFAILED or CANINITOK.
    131          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          u8 CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    133          {
   \                     CAN_Init:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    134            u8 InitStatus = CANINITFAILED;
   \   00000004   0x2000             MOVS     R0,#+0
    135            u16 waitack = 0x0000;
   \   00000006   0x2300             MOVS     R3,#+0
    136          
    137            /* Check the parameters */
    138            assert_param(IS_CAN_ALL_PERIPH(CANx));
    139            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    140            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    141            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    142            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    143            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    144            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    145            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    146            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    147            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    148            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    149            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    150          
    151            /* exit from sleep mode */
    152            CANx->MCR &= ~MCR_SLEEP;
   \   00000008   0x6814             LDR      R4,[R2, #+0]
   \   0000000A   0xF034 0x0402      BICS     R4,R4,#0x2
   \   0000000E   0x6014             STR      R4,[R2, #+0]
    153            /* Request initialisation */
    154            CANx->MCR |= MCR_INRQ ;
   \   00000010   0x6814             LDR      R4,[R2, #+0]
   \   00000012   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   00000016   0x6014             STR      R4,[R2, #+0]
    155          
    156            /* Wait the acknowledge */
    157            while ((INAK_TimeOut != waitack)&&((CANx->MSR & MSR_INAK) != MSR_INAK))
   \                     ??CAN_Init_0:
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000001E   0x42A3             CMP      R3,R4
   \   00000020   0xD004             BEQ.N    ??CAN_Init_1
   \   00000022   0x6854             LDR      R4,[R2, #+4]
   \   00000024   0x07E4             LSLS     R4,R4,#+31
   \   00000026   0xD401             BMI.N    ??CAN_Init_1
    158            {
    159          	waitack++;
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \   0000002A   0xE7F5             B.N      ??CAN_Init_0
    160            }
    161          
    162            /* ...and check acknowledged */
    163            if ((CANx->MSR & MSR_INAK) != MSR_INAK)
   \                     ??CAN_Init_1:
   \   0000002C   0x6854             LDR      R4,[R2, #+4]
   \   0000002E   0x07E4             LSLS     R4,R4,#+31
   \   00000030   0xD402             BMI.N    ??CAN_Init_2
    164            {
    165              InitStatus = CANINITFAILED;
   \   00000032   0x2400             MOVS     R4,#+0
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xE06E             B.N      ??CAN_Init_3
    166            }
    167            else 
    168            {
    169              /* Set the time triggered communication mode */
    170              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_2:
   \   00000038   0x780C             LDRB     R4,[R1, #+0]
   \   0000003A   0x2C01             CMP      R4,#+1
   \   0000003C   0xD104             BNE.N    ??CAN_Init_4
    171              {
    172                CANx->MCR |= MCR_TTCM;
   \   0000003E   0x6814             LDR      R4,[R2, #+0]
   \   00000040   0xF054 0x0480      ORRS     R4,R4,#0x80
   \   00000044   0x6014             STR      R4,[R2, #+0]
   \   00000046   0xE003             B.N      ??CAN_Init_5
    173              }
    174              else
    175              {
    176                CANx->MCR &= ~MCR_TTCM;
   \                     ??CAN_Init_4:
   \   00000048   0x6814             LDR      R4,[R2, #+0]
   \   0000004A   0xF034 0x0480      BICS     R4,R4,#0x80
   \   0000004E   0x6014             STR      R4,[R2, #+0]
    177              }
    178          
    179              /* Set the automatic bus-off management */
    180              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_5:
   \   00000050   0x784C             LDRB     R4,[R1, #+1]
   \   00000052   0x2C01             CMP      R4,#+1
   \   00000054   0xD104             BNE.N    ??CAN_Init_6
    181              {
    182                CANx->MCR |= MCR_ABOM;
   \   00000056   0x6814             LDR      R4,[R2, #+0]
   \   00000058   0xF054 0x0440      ORRS     R4,R4,#0x40
   \   0000005C   0x6014             STR      R4,[R2, #+0]
   \   0000005E   0xE003             B.N      ??CAN_Init_7
    183              }
    184              else
    185              {
    186                CANx->MCR &= ~MCR_ABOM;
   \                     ??CAN_Init_6:
   \   00000060   0x6814             LDR      R4,[R2, #+0]
   \   00000062   0xF034 0x0440      BICS     R4,R4,#0x40
   \   00000066   0x6014             STR      R4,[R2, #+0]
    187              }
    188          
    189              /* Set the automatic wake-up mode */
    190              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_7:
   \   00000068   0x788C             LDRB     R4,[R1, #+2]
   \   0000006A   0x2C01             CMP      R4,#+1
   \   0000006C   0xD104             BNE.N    ??CAN_Init_8
    191              {
    192                CANx->MCR |= MCR_AWUM;
   \   0000006E   0x6814             LDR      R4,[R2, #+0]
   \   00000070   0xF054 0x0420      ORRS     R4,R4,#0x20
   \   00000074   0x6014             STR      R4,[R2, #+0]
   \   00000076   0xE003             B.N      ??CAN_Init_9
    193              }
    194              else
    195              {
    196                CANx->MCR &= ~MCR_AWUM;
   \                     ??CAN_Init_8:
   \   00000078   0x6814             LDR      R4,[R2, #+0]
   \   0000007A   0xF034 0x0420      BICS     R4,R4,#0x20
   \   0000007E   0x6014             STR      R4,[R2, #+0]
    197              }
    198          
    199              /* Set the no automatic retransmission */
    200              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_9:
   \   00000080   0x78CC             LDRB     R4,[R1, #+3]
   \   00000082   0x2C01             CMP      R4,#+1
   \   00000084   0xD104             BNE.N    ??CAN_Init_10
    201              {
    202                CANx->MCR |= MCR_NART;
   \   00000086   0x6814             LDR      R4,[R2, #+0]
   \   00000088   0xF054 0x0410      ORRS     R4,R4,#0x10
   \   0000008C   0x6014             STR      R4,[R2, #+0]
   \   0000008E   0xE003             B.N      ??CAN_Init_11
    203              }
    204              else
    205              {
    206                CANx->MCR &= ~MCR_NART;
   \                     ??CAN_Init_10:
   \   00000090   0x6814             LDR      R4,[R2, #+0]
   \   00000092   0xF034 0x0410      BICS     R4,R4,#0x10
   \   00000096   0x6014             STR      R4,[R2, #+0]
    207              }
    208          
    209              /* Set the receive FIFO locked mode */
    210              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_11:
   \   00000098   0x790C             LDRB     R4,[R1, #+4]
   \   0000009A   0x2C01             CMP      R4,#+1
   \   0000009C   0xD104             BNE.N    ??CAN_Init_12
    211              {
    212                CANx->MCR |= MCR_RFLM;
   \   0000009E   0x6814             LDR      R4,[R2, #+0]
   \   000000A0   0xF054 0x0408      ORRS     R4,R4,#0x8
   \   000000A4   0x6014             STR      R4,[R2, #+0]
   \   000000A6   0xE003             B.N      ??CAN_Init_13
    213              }
    214              else
    215              {
    216                CANx->MCR &= ~MCR_RFLM;
   \                     ??CAN_Init_12:
   \   000000A8   0x6814             LDR      R4,[R2, #+0]
   \   000000AA   0xF034 0x0408      BICS     R4,R4,#0x8
   \   000000AE   0x6014             STR      R4,[R2, #+0]
    217              }
    218          
    219              /* Set the transmit FIFO priority */
    220              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_13:
   \   000000B0   0x794C             LDRB     R4,[R1, #+5]
   \   000000B2   0x2C01             CMP      R4,#+1
   \   000000B4   0xD104             BNE.N    ??CAN_Init_14
    221              {
    222                CANx->MCR |= MCR_TXFP;
   \   000000B6   0x6814             LDR      R4,[R2, #+0]
   \   000000B8   0xF054 0x0404      ORRS     R4,R4,#0x4
   \   000000BC   0x6014             STR      R4,[R2, #+0]
   \   000000BE   0xE003             B.N      ??CAN_Init_15
    223              }
    224              else
    225              {
    226                CANx->MCR &= ~MCR_TXFP;
   \                     ??CAN_Init_14:
   \   000000C0   0x6814             LDR      R4,[R2, #+0]
   \   000000C2   0xF034 0x0404      BICS     R4,R4,#0x4
   \   000000C6   0x6014             STR      R4,[R2, #+0]
    227              }
    228          
    229              /* Set the bit timing register */
    230              CANx->BTR = (u32)((u32)CAN_InitStruct->CAN_Mode << 30) | ((u32)CAN_InitStruct->CAN_SJW << 24) |
    231                         ((u32)CAN_InitStruct->CAN_BS1 << 16) | ((u32)CAN_InitStruct->CAN_BS2 << 20) |
    232                         ((u32)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_15:
   \   000000C8   0x798C             LDRB     R4,[R1, #+6]
   \   000000CA   0x79CD             LDRB     R5,[R1, #+7]
   \   000000CC   0x062D             LSLS     R5,R5,#+24
   \   000000CE   0xEA55 0x7484      ORRS     R4,R5,R4, LSL #+30
   \   000000D2   0x7A0D             LDRB     R5,[R1, #+8]
   \   000000D4   0xEA54 0x4405      ORRS     R4,R4,R5, LSL #+16
   \   000000D8   0x7A4D             LDRB     R5,[R1, #+9]
   \   000000DA   0xEA54 0x5405      ORRS     R4,R4,R5, LSL #+20
   \   000000DE   0x894D             LDRH     R5,[R1, #+10]
   \   000000E0   0x1E6D             SUBS     R5,R5,#+1
   \   000000E2   0x432C             ORRS     R4,R5,R4
   \   000000E4   0x61D4             STR      R4,[R2, #+28]
    233          
    234              /* Request leave initialisation */
    235              CANx->MCR &= ~MCR_INRQ;
   \   000000E6   0x6814             LDR      R4,[R2, #+0]
   \   000000E8   0x0864             LSRS     R4,R4,#+1
   \   000000EA   0x0064             LSLS     R4,R4,#+1
   \   000000EC   0x6014             STR      R4,[R2, #+0]
    236          
    237             /* Wait the acknowledge */
    238             waitack = 0x0000;
   \   000000EE   0x2400             MOVS     R4,#+0
   \   000000F0   0x0023             MOVS     R3,R4
    239             while ((INAK_TimeOut != waitack)&&((CANx->MSR & MSR_INAK) == MSR_INAK))
   \                     ??CAN_Init_16:
   \   000000F2   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000F4   0xF64F 0x74FF      MOVW     R4,#+65535
   \   000000F8   0x42A3             CMP      R3,R4
   \   000000FA   0xD004             BEQ.N    ??CAN_Init_17
   \   000000FC   0x6854             LDR      R4,[R2, #+4]
   \   000000FE   0x07E4             LSLS     R4,R4,#+31
   \   00000100   0xD501             BPL.N    ??CAN_Init_17
    240             {
    241          	 waitack++;
   \   00000102   0x1C5B             ADDS     R3,R3,#+1
   \   00000104   0xE7F5             B.N      ??CAN_Init_16
    242             }
    243              /* ...and check acknowledged */
    244              if ((CANx->MSR & MSR_INAK) == MSR_INAK)
   \                     ??CAN_Init_17:
   \   00000106   0x6854             LDR      R4,[R2, #+4]
   \   00000108   0x07E4             LSLS     R4,R4,#+31
   \   0000010A   0xD502             BPL.N    ??CAN_Init_18
    245              {
    246                InitStatus = CANINITFAILED;
   \   0000010C   0x2400             MOVS     R4,#+0
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0xE001             B.N      ??CAN_Init_3
    247              }
    248          	else
    249          	{
    250          	  InitStatus = CANINITOK ;
   \                     ??CAN_Init_18:
   \   00000112   0x2401             MOVS     R4,#+1
   \   00000114   0x0020             MOVS     R0,R4
    251          	}
    252            }
    253          
    254            /* At this step, return the status of initialization */
    255            return InitStatus;
   \                     ??CAN_Init_3:
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0xBC30             POP      {R4,R5}
   \   0000011A   0x4770             BX       LR               ;; return
    256          }
    257          
    258          /*******************************************************************************
    259          * Function Name  : CAN_FilterInit
    260          * Description    : Initializes the CAN peripheral according to the specified
    261          *                  parameters in the CAN_FilterInitStruct.
    262          * Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    263          *                  structure that contains the configuration information.
    264          * Output         : None.
    265          * Return         : None.
    266          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    267          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    268          {
   \                     CAN_FilterInit:
   \   00000000   0xB410             PUSH     {R4}
    269            u32 FilterNumber_BitPos = 0;
   \   00000002   0x2100             MOVS     R1,#+0
    270          
    271            /* Check the parameters */
    272            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    273            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    274            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    275            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    276            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    277          
    278            FilterNumber_BitPos = 
    279            (u32)(((u32)0x00000001) << ((u32)CAN_FilterInitStruct->CAN_FilterNumber));
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x7803             LDRB     R3,[R0, #+0]
   \   00000008   0x409A             LSLS     R2,R2,R3
   \   0000000A   0x0011             MOVS     R1,R2
    280          
    281            /* Initialisation mode for the filter */
    282            CAN1->FMR |= FMR_FINIT;
   \   0000000C   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000014   0x....             LDR.N    R3,??DataTable2_2  ;; 0x40006600
   \   00000016   0x601A             STR      R2,[R3, #+0]
    283          
    284            /* Filter Deactivation */
    285            CAN1->FA1R &= ~(u32)FilterNumber_BitPos;
   \   00000018   0x....             LDR.N    R2,??DataTable2_3  ;; 0x4000661c
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x438A             BICS     R2,R2,R1
   \   0000001E   0x....             LDR.N    R3,??DataTable2_3  ;; 0x4000661c
   \   00000020   0x601A             STR      R2,[R3, #+0]
    286          
    287            /* Filter Scale */
    288            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   00000022   0x7882             LDRB     R2,[R0, #+2]
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD115             BNE.N    ??CAN_FilterInit_0
    289            {
    290              /* 16-bit scale for the filter */
    291              CAN1->FS1R &= ~(u32)FilterNumber_BitPos;
   \   00000028   0x....             LDR.N    R2,??DataTable2_4  ;; 0x4000660c
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0x438A             BICS     R2,R2,R1
   \   0000002E   0x....             LDR.N    R3,??DataTable2_4  ;; 0x4000660c
   \   00000030   0x601A             STR      R2,[R3, #+0]
    292          
    293              /* First 16-bit identifier and First 16-bit mask */
    294              /* Or First 16-bit identifier and Second 16-bit identifier */
    295              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    296              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    297                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000032   0x8942             LDRH     R2,[R0, #+10]
   \   00000034   0x88C3             LDRH     R3,[R0, #+6]
   \   00000036   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000003A   0x7803             LDRB     R3,[R0, #+0]
   \   0000003C   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40006640
   \   0000003E   0xF844 0x2033      STR      R2,[R4, R3, LSL #+3]
    298          
    299              /* Second 16-bit identifier and Second 16-bit mask */
    300              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    301              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    302              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    303                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   00000042   0x8902             LDRH     R2,[R0, #+8]
   \   00000044   0x8883             LDRH     R3,[R0, #+4]
   \   00000046   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000004A   0x7803             LDRB     R3,[R0, #+0]
   \   0000004C   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40006640
   \   0000004E   0xEB14 0x03C3      ADDS     R3,R4,R3, LSL #+3
   \   00000052   0x605A             STR      R2,[R3, #+4]
    304            }
    305            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0:
   \   00000054   0x7882             LDRB     R2,[R0, #+2]
   \   00000056   0x2A01             CMP      R2,#+1
   \   00000058   0xD115             BNE.N    ??CAN_FilterInit_1
    306            {
    307              /* 32-bit scale for the filter */
    308              CAN1->FS1R |= FilterNumber_BitPos;
   \   0000005A   0x....             LDR.N    R2,??DataTable2_4  ;; 0x4000660c
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0x430A             ORRS     R2,R1,R2
   \   00000060   0x....             LDR.N    R3,??DataTable2_4  ;; 0x4000660c
   \   00000062   0x601A             STR      R2,[R3, #+0]
    309          
    310              /* 32-bit identifier or First 32-bit identifier */
    311              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    312              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    313                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000064   0x8882             LDRH     R2,[R0, #+4]
   \   00000066   0x88C3             LDRH     R3,[R0, #+6]
   \   00000068   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000006C   0x7803             LDRB     R3,[R0, #+0]
   \   0000006E   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40006640
   \   00000070   0xF844 0x2033      STR      R2,[R4, R3, LSL #+3]
    314          
    315              /* 32-bit mask or Second 32-bit identifier */
    316              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    317              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    318                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   00000074   0x8902             LDRH     R2,[R0, #+8]
   \   00000076   0x8943             LDRH     R3,[R0, #+10]
   \   00000078   0xEA53 0x4202      ORRS     R2,R3,R2, LSL #+16
   \   0000007C   0x7803             LDRB     R3,[R0, #+0]
   \   0000007E   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40006640
   \   00000080   0xEB14 0x03C3      ADDS     R3,R4,R3, LSL #+3
   \   00000084   0x605A             STR      R2,[R3, #+4]
    319          
    320            }
    321          
    322            /* Filter Mode */
    323            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1:
   \   00000086   0x7842             LDRB     R2,[R0, #+1]
   \   00000088   0x2A00             CMP      R2,#+0
   \   0000008A   0xD105             BNE.N    ??CAN_FilterInit_2
    324            {
    325              /*Id/Mask mode for the filter*/
    326              CAN1->FM1R &= ~(u32)FilterNumber_BitPos;
   \   0000008C   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40006604
   \   0000008E   0x6812             LDR      R2,[R2, #+0]
   \   00000090   0x438A             BICS     R2,R2,R1
   \   00000092   0x....             LDR.N    R3,??DataTable2_6  ;; 0x40006604
   \   00000094   0x601A             STR      R2,[R3, #+0]
   \   00000096   0xE004             B.N      ??CAN_FilterInit_3
    327            }
    328            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    329            {
    330              /*Identifier list mode for the filter*/
    331              CAN1->FM1R |= (u32)FilterNumber_BitPos;
   \                     ??CAN_FilterInit_2:
   \   00000098   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40006604
   \   0000009A   0x6812             LDR      R2,[R2, #+0]
   \   0000009C   0x430A             ORRS     R2,R1,R2
   \   0000009E   0x....             LDR.N    R3,??DataTable2_6  ;; 0x40006604
   \   000000A0   0x601A             STR      R2,[R3, #+0]
    332            }
    333          
    334            /* Filter FIFO assignment */
    335            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
   \                     ??CAN_FilterInit_3:
   \   000000A2   0x8982             LDRH     R2,[R0, #+12]
   \   000000A4   0x2A00             CMP      R2,#+0
   \   000000A6   0xD104             BNE.N    ??CAN_FilterInit_4
    336            {
    337              /* FIFO 0 assignation for the filter */
    338              CAN1->FFA1R &= ~(u32)FilterNumber_BitPos;
   \   000000A8   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40006614
   \   000000AA   0x6812             LDR      R2,[R2, #+0]
   \   000000AC   0x438A             BICS     R2,R2,R1
   \   000000AE   0x....             LDR.N    R3,??DataTable2_7  ;; 0x40006614
   \   000000B0   0x601A             STR      R2,[R3, #+0]
    339            }
    340            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
   \                     ??CAN_FilterInit_4:
   \   000000B2   0x8982             LDRH     R2,[R0, #+12]
   \   000000B4   0x2A01             CMP      R2,#+1
   \   000000B6   0xD104             BNE.N    ??CAN_FilterInit_5
    341            {
    342              /* FIFO 1 assignation for the filter */
    343              CAN1->FFA1R |= (u32)FilterNumber_BitPos;
   \   000000B8   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40006614
   \   000000BA   0x6812             LDR      R2,[R2, #+0]
   \   000000BC   0x430A             ORRS     R2,R1,R2
   \   000000BE   0x....             LDR.N    R3,??DataTable2_7  ;; 0x40006614
   \   000000C0   0x601A             STR      R2,[R3, #+0]
    344            }
    345            
    346            /* Filter activation */
    347            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5:
   \   000000C2   0x7B82             LDRB     R2,[R0, #+14]
   \   000000C4   0x2A01             CMP      R2,#+1
   \   000000C6   0xD104             BNE.N    ??CAN_FilterInit_6
    348            {
    349              CAN1->FA1R |= FilterNumber_BitPos;
   \   000000C8   0x....             LDR.N    R2,??DataTable2_3  ;; 0x4000661c
   \   000000CA   0x6812             LDR      R2,[R2, #+0]
   \   000000CC   0x430A             ORRS     R2,R1,R2
   \   000000CE   0x....             LDR.N    R3,??DataTable2_3  ;; 0x4000661c
   \   000000D0   0x601A             STR      R2,[R3, #+0]
    350            }
    351          
    352            /* Leave the initialisation mode for the filter */
    353            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6:
   \   000000D2   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   000000D4   0x6812             LDR      R2,[R2, #+0]
   \   000000D6   0x0852             LSRS     R2,R2,#+1
   \   000000D8   0x0052             LSLS     R2,R2,#+1
   \   000000DA   0x....             LDR.N    R3,??DataTable2_2  ;; 0x40006600
   \   000000DC   0x601A             STR      R2,[R3, #+0]
    354          }
   \   000000DE   0xBC10             POP      {R4}
   \   000000E0   0x4770             BX       LR               ;; return
    355          
    356          /*******************************************************************************
    357          * Function Name  : CAN_StructInit
    358          * Description    : Fills each CAN_InitStruct member with its default value.
    359          * Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    360          *                  will be initialized.
    361          * Output         : None.
    362          * Return         : None.
    363          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    364          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    365          {
    366            /* Reset CAN init structure parameters values */
    367          
    368            /* Initialize the time triggered communication mode */
    369            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    370          
    371            /* Initialize the automatic bus-off management */
    372            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    373          
    374            /* Initialize the automatic wake-up mode */
    375            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    376          
    377            /* Initialize the no automatic retransmission */
    378            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    379          
    380            /* Initialize the receive FIFO locked mode */
    381            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7101             STRB     R1,[R0, #+4]
    382          
    383            /* Initialize the transmit FIFO priority */
    384            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7141             STRB     R1,[R0, #+5]
    385          
    386            /* Initialize the CAN_Mode member */
    387            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7181             STRB     R1,[R0, #+6]
    388          
    389            /* Initialize the CAN_SJW member */
    390            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x71C1             STRB     R1,[R0, #+7]
    391          
    392            /* Initialize the CAN_BS1 member */
    393            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0x2103             MOVS     R1,#+3
   \   00000022   0x7201             STRB     R1,[R0, #+8]
    394          
    395            /* Initialize the CAN_BS2 member */
    396            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7241             STRB     R1,[R0, #+9]
    397          
    398            /* Initialize the CAN_Prescaler member */
    399            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x8141             STRH     R1,[R0, #+10]
    400          }
   \   0000002C   0x4770             BX       LR               ;; return
    401          /*******************************************************************************
    402          * Function Name  : CAN_SlaveStartBank
    403          * Description    : Select the start bank filter for slave CAN.
    404          * Input          : - CAN_BankNumber: Select the start slave bank filter from 1..27.
    405          * Output         : None.
    406          * Return         : None.
    407          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          void CAN_SlaveStartBank(u8 CAN_BankNumber) 
    409          {
    410            /* Check the parameters */
    411            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    412          
    413            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank:
   \   00000000   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    414            CAN1->FMR &= (u32)0xFFFFC0F1 ;
   \   0000000C   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x....             LDR.N    R2,??DataTable2_8  ;; 0xffffc0f1
   \   00000012   0x4011             ANDS     R1,R2,R1
   \   00000014   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   00000016   0x6011             STR      R1,[R2, #+0]
    415            CAN1->FMR |= (u32)(CAN_BankNumber)<<8;
   \   00000018   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \   00000022   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   00000024   0x6011             STR      R1,[R2, #+0]
    416            CAN1->FMR &= ~FMR_FINIT;
   \   00000026   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40006600
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x0849             LSRS     R1,R1,#+1
   \   0000002C   0x0049             LSLS     R1,R1,#+1
   \   0000002E   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40006600
   \   00000030   0x6011             STR      R1,[R2, #+0]
    417          }
   \   00000032   0x4770             BX       LR               ;; return
    418          
    419          /*******************************************************************************
    420          * Function Name  : CAN_DBGFreeze
    421          * Description    : Enables or disables the DBG Freeze for CAN.
    422          * Input          :  - CANx: where x can be 1 or 2 to select the CAN peripheral.
    423          *                   - NewState: new state of the CAN peripheral.
    424          *                    This parameter can be: ENABLE or DISABLE.
    425          * Output         : None.
    426          * Return         : None.
    427          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_CAN_ALL_PERIPH(CANx));
    432            assert_param(IS_FUNCTIONAL_STATE(NewState));
    433          
    434             if (NewState != DISABLE)
   \                     CAN_DBGFreeze:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??CAN_DBGFreeze_0
    435            {
    436              /* Enable Debug Freeze  */
    437              CANx->MCR |= MCR_DBF;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0xF452 0x3280      ORRS     R2,R2,#0x10000
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   \   0000000E   0xE003             B.N      ??CAN_DBGFreeze_1
    438            }
    439            else
    440            {
    441              /* Disable Debug Freeze */
    442              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0:
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0xF432 0x3280      BICS     R2,R2,#0x10000
   \   00000016   0x6002             STR      R2,[R0, #+0]
    443            }
    444          }
   \                     ??CAN_DBGFreeze_1:
   \   00000018   0x4770             BX       LR               ;; return
    445          
    446          /*******************************************************************************
    447          * Function Name  : CAN_ITConfig
    448          * Description    : Enables or disables the specified CAN interrupts.
    449          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    450          *                  - CAN_IT: specifies the CAN interrupt sources to be enabled or
    451          *                    disabled.
    452          *                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
    453          *                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
    454          *                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
    455          *                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
    456          *                                           CAN_IT_SLK.
    457          *                  - NewState: new state of the CAN interrupts.
    458          *                    This parameter can be: ENABLE or DISABLE.
    459          * Output         : None.
    460          * Return         : None.
    461          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    462          void CAN_ITConfig(CAN_TypeDef* CANx, u32 CAN_IT, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_CAN_ALL_PERIPH(CANx));
    466            assert_param(IS_CAN_ITConfig(CAN_IT));
    467            assert_param(IS_FUNCTIONAL_STATE(NewState));
    468          
    469            if (NewState != DISABLE)
   \                     CAN_ITConfig:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_ITConfig_0
    470            {
    471              /* Enable the selected CAN interrupt */
    472              CANx->IER |= CAN_IT;
   \   00000006   0x6943             LDR      R3,[R0, #+20]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x6143             STR      R3,[R0, #+20]
   \   0000000C   0xE002             B.N      ??CAN_ITConfig_1
    473            }
    474            else
    475            {
    476              /* Disable the selected CAN interrupt */
    477              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0:
   \   0000000E   0x6943             LDR      R3,[R0, #+20]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x6143             STR      R3,[R0, #+20]
    478            }
    479          }
   \                     ??CAN_ITConfig_1:
   \   00000014   0x4770             BX       LR               ;; return
    480          
    481          /*******************************************************************************
    482          * Function Name  : CAN_Transmit
    483          * Description    : Initiates the transmission of a message.
    484          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    485          *                  - TxMessage: pointer to a structure which contains CAN Id, CAN
    486          *                  DLC and CAN datas.
    487          * Output         : None.
    488          * Return         : The number of the mailbox that is used for transmission
    489          *                  or CAN_NO_MB if there is no empty mailbox.
    490          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    491          u8 CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    492          {
   \                     CAN_Transmit:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
    493            u8 TransmitMailbox = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    494          
    495            /* Check the parameters */
    496            assert_param(IS_CAN_ALL_PERIPH(CANx));
    497            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    498            assert_param(IS_CAN_RTR(TxMessage->RTR));
    499            assert_param(IS_CAN_DLC(TxMessage->DLC));
    500          
    501            /* Select one empty transmit mailbox */
    502            if ((CANx->TSR&TSR_TME0) == TSR_TME0)
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x015B             LSLS     R3,R3,#+5
   \   0000000A   0xD502             BPL.N    ??CAN_Transmit_0
    503            {
    504              TransmitMailbox = 0;
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE00D             B.N      ??CAN_Transmit_1
    505            }
    506            else if ((CANx->TSR&TSR_TME1) == TSR_TME1)
   \                     ??CAN_Transmit_0:
   \   00000012   0x6893             LDR      R3,[R2, #+8]
   \   00000014   0x011B             LSLS     R3,R3,#+4
   \   00000016   0xD502             BPL.N    ??CAN_Transmit_2
    507            {
    508              TransmitMailbox = 1;
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xE007             B.N      ??CAN_Transmit_1
    509            }
    510            else if ((CANx->TSR&TSR_TME2) == TSR_TME2)
   \                     ??CAN_Transmit_2:
   \   0000001E   0x6893             LDR      R3,[R2, #+8]
   \   00000020   0x00DB             LSLS     R3,R3,#+3
   \   00000022   0xD502             BPL.N    ??CAN_Transmit_3
    511            {
    512              TransmitMailbox = 2;
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0x0018             MOVS     R0,R3
   \   00000028   0xE001             B.N      ??CAN_Transmit_1
    513            }
    514            else
    515            {
    516              TransmitMailbox = CAN_NO_MB;
   \                     ??CAN_Transmit_3:
   \   0000002A   0x2304             MOVS     R3,#+4
   \   0000002C   0x0018             MOVS     R0,R3
    517            }
    518          
    519            if (TransmitMailbox != CAN_NO_MB)
   \                     ??CAN_Transmit_1:
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD075             BEQ.N    ??CAN_Transmit_4
    520            {
    521              /* Set up the Id */
    522              CANx->sTxMailBox[TransmitMailbox].TIR &= TMIDxR_TXRQ;
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   0000003A   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000003E   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000048   0xF8C4 0x3180      STR      R3,[R4, #+384]
    523              if (TxMessage->IDE == CAN_ID_STD)
   \   0000004C   0x7A0B             LDRB     R3,[R1, #+8]
   \   0000004E   0x2B00             CMP      R3,#+0
   \   00000050   0xD10F             BNE.N    ??CAN_Transmit_5
    524              {
    525                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    526                CANx->sTxMailBox[TransmitMailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   00000058   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000005C   0x680C             LDR      R4,[R1, #+0]
   \   0000005E   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000060   0xEA55 0x5444      ORRS     R4,R5,R4, LSL #+21
   \   00000064   0x4323             ORRS     R3,R4,R3
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   0000006C   0xF8C4 0x3180      STR      R3,[R4, #+384]
   \   00000070   0xE010             B.N      ??CAN_Transmit_6
    527              }
    528              else
    529              {
    530                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    531                CANx->sTxMailBox[TransmitMailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
    532                                                         TxMessage->RTR);
   \                     ??CAN_Transmit_5:
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   00000078   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   0000007C   0x684C             LDR      R4,[R1, #+4]
   \   0000007E   0x7A0D             LDRB     R5,[R1, #+8]
   \   00000080   0xEA55 0x04C4      ORRS     R4,R5,R4, LSL #+3
   \   00000084   0x7A4D             LDRB     R5,[R1, #+9]
   \   00000086   0x432C             ORRS     R4,R5,R4
   \   00000088   0x4323             ORRS     R3,R4,R3
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000090   0xF8C4 0x3180      STR      R3,[R4, #+384]
    533              }
    534              
    535              /* Set up the DLC */
    536              TxMessage->DLC &= (u8)0x0000000F;
   \                     ??CAN_Transmit_6:
   \   00000094   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000096   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   0000009A   0x728B             STRB     R3,[R1, #+10]
    537              CANx->sTxMailBox[TransmitMailbox].TDTR &= (u32)0xFFFFFFF0;
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   000000A2   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000A6   0x091B             LSRS     R3,R3,#+4
   \   000000A8   0x011B             LSLS     R3,R3,#+4
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000B0   0xF8C4 0x3184      STR      R3,[R4, #+388]
    538              CANx->sTxMailBox[TransmitMailbox].TDTR |= TxMessage->DLC;
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   000000BA   0xF8D3 0x3184      LDR      R3,[R3, #+388]
   \   000000BE   0x7A8C             LDRB     R4,[R1, #+10]
   \   000000C0   0x4323             ORRS     R3,R4,R3
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000C8   0xF8C4 0x3184      STR      R3,[R4, #+388]
    539          
    540              /* Set up the data field */
    541              CANx->sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage->Data[3] << 24) | 
    542                                                       ((u32)TxMessage->Data[2] << 16) |
    543                                                       ((u32)TxMessage->Data[1] << 8) | 
    544                                                       ((u32)TxMessage->Data[0]));
   \   000000CC   0x7B8B             LDRB     R3,[R1, #+14]
   \   000000CE   0x7B4C             LDRB     R4,[R1, #+13]
   \   000000D0   0x0424             LSLS     R4,R4,#+16
   \   000000D2   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000D6   0x7B0C             LDRB     R4,[R1, #+12]
   \   000000D8   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000DC   0x7ACC             LDRB     R4,[R1, #+11]
   \   000000DE   0x4323             ORRS     R3,R4,R3
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   000000E6   0xF8C4 0x3188      STR      R3,[R4, #+392]
    545              CANx->sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage->Data[7] << 24) | 
    546                                                       ((u32)TxMessage->Data[6] << 16) |
    547                                                       ((u32)TxMessage->Data[5] << 8) |
    548                                                       ((u32)TxMessage->Data[4]));
   \   000000EA   0x7C8B             LDRB     R3,[R1, #+18]
   \   000000EC   0x7C4C             LDRB     R4,[R1, #+17]
   \   000000EE   0x0424             LSLS     R4,R4,#+16
   \   000000F0   0xEA54 0x6303      ORRS     R3,R4,R3, LSL #+24
   \   000000F4   0x7C0C             LDRB     R4,[R1, #+16]
   \   000000F6   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   000000FA   0x7BCC             LDRB     R4,[R1, #+15]
   \   000000FC   0x4323             ORRS     R3,R4,R3
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   00000104   0xF8C4 0x318C      STR      R3,[R4, #+396]
    549          
    550              /* Request transmission */
    551              CANx->sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0xEB12 0x1300      ADDS     R3,R2,R0, LSL #+4
   \   0000010E   0xF8D3 0x3180      LDR      R3,[R3, #+384]
   \   00000112   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0xEB12 0x1400      ADDS     R4,R2,R0, LSL #+4
   \   0000011C   0xF8C4 0x3180      STR      R3,[R4, #+384]
    552            }
    553          
    554            return TransmitMailbox;
   \                     ??CAN_Transmit_4:
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0xBC30             POP      {R4,R5}
   \   00000124   0x4770             BX       LR               ;; return
    555          }
    556          
    557          /*******************************************************************************
    558          * Function Name  : CAN_TransmitStatus
    559          * Description    : Checks the transmission of a message.
    560          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    561          *                  - TransmitMailbox: the number of the mailbox that is used for
    562          *                  transmission.
    563          * Output         : None.
    564          * Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
    565          *                  in an other case.
    566          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    567          u8 CAN_TransmitStatus(CAN_TypeDef* CANx, u8 TransmitMailbox)
    568          {
   \                     CAN_TransmitStatus:
   \   00000000   0x0002             MOVS     R2,R0
    569            /* RQCP, TXOK and TME bits */
    570            u8 State = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    571          
    572            /* Check the parameters */
    573            assert_param(IS_CAN_ALL_PERIPH(CANx));
    574            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    575          
    576            switch (TransmitMailbox)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD020             BEQ.N    ??CAN_TransmitStatus_1
   \   0000000E   0xD30F             BCC.N    ??CAN_TransmitStatus_2
   \   00000010   0xE02E             B.N      ??CAN_TransmitStatus_3
    577            {
    578              case (0): State |= (u8)((CANx->TSR & TSR_RQCP0) << 2);
   \                     ??CAN_TransmitStatus_0:
   \   00000012   0x6893             LDR      R3,[R2, #+8]
   \   00000014   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000018   0xEA50 0x0083      ORRS     R0,R0,R3, LSL #+2
    579                State |= (u8)((CANx->TSR & TSR_TXOK0) >> 0);
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   \   0000001E   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000022   0x4318             ORRS     R0,R3,R0
    580                State |= (u8)((CANx->TSR & TSR_TME0) >> 26);
   \   00000024   0x6893             LDR      R3,[R2, #+8]
   \   00000026   0x0E9B             LSRS     R3,R3,#+26
   \   00000028   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   0000002C   0x4318             ORRS     R0,R3,R0
    581                break;
   \   0000002E   0xE021             B.N      ??CAN_TransmitStatus_4
    582              case (1): State |= (u8)((CANx->TSR & TSR_RQCP1) >> 6);
   \                     ??CAN_TransmitStatus_2:
   \   00000030   0x6893             LDR      R3,[R2, #+8]
   \   00000032   0x099B             LSRS     R3,R3,#+6
   \   00000034   0xF013 0x0304      ANDS     R3,R3,#0x4
   \   00000038   0x4318             ORRS     R0,R3,R0
    583                State |= (u8)((CANx->TSR & TSR_TXOK1) >> 8);
   \   0000003A   0x6893             LDR      R3,[R2, #+8]
   \   0000003C   0x0A1B             LSRS     R3,R3,#+8
   \   0000003E   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000042   0x4318             ORRS     R0,R3,R0
    584                State |= (u8)((CANx->TSR & TSR_TME1) >> 27);
   \   00000044   0x6893             LDR      R3,[R2, #+8]
   \   00000046   0x0EDB             LSRS     R3,R3,#+27
   \   00000048   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   0000004C   0x4318             ORRS     R0,R3,R0
    585                break;
   \   0000004E   0xE011             B.N      ??CAN_TransmitStatus_4
    586              case (2): State |= (u8)((CANx->TSR & TSR_RQCP2) >> 14);
   \                     ??CAN_TransmitStatus_1:
   \   00000050   0x6893             LDR      R3,[R2, #+8]
   \   00000052   0x0B9B             LSRS     R3,R3,#+14
   \   00000054   0xF013 0x0304      ANDS     R3,R3,#0x4
   \   00000058   0x4318             ORRS     R0,R3,R0
    587                State |= (u8)((CANx->TSR & TSR_TXOK2) >> 16);
   \   0000005A   0x6893             LDR      R3,[R2, #+8]
   \   0000005C   0x0C1B             LSRS     R3,R3,#+16
   \   0000005E   0xF013 0x0302      ANDS     R3,R3,#0x2
   \   00000062   0x4318             ORRS     R0,R3,R0
    588                State |= (u8)((CANx->TSR & TSR_TME2) >> 28);
   \   00000064   0x6893             LDR      R3,[R2, #+8]
   \   00000066   0x0F1B             LSRS     R3,R3,#+28
   \   00000068   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   0000006C   0x4318             ORRS     R0,R3,R0
    589                break;
   \   0000006E   0xE001             B.N      ??CAN_TransmitStatus_4
    590              default:
    591                State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_3:
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x0018             MOVS     R0,R3
    592                break;
    593            }
    594          
    595            switch (State)
   \                     ??CAN_TransmitStatus_4:
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x0003             MOVS     R3,R0
   \   00000078   0x2B00             CMP      R3,#+0
   \   0000007A   0xD004             BEQ.N    ??CAN_TransmitStatus_5
   \   0000007C   0x2B05             CMP      R3,#+5
   \   0000007E   0xD005             BEQ.N    ??CAN_TransmitStatus_6
   \   00000080   0x2B07             CMP      R3,#+7
   \   00000082   0xD006             BEQ.N    ??CAN_TransmitStatus_7
   \   00000084   0xE008             B.N      ??CAN_TransmitStatus_8
    596            {
    597                /* transmit pending  */
    598              case (0x0): State = CANTXPENDING;
   \                     ??CAN_TransmitStatus_5:
   \   00000086   0x2302             MOVS     R3,#+2
   \   00000088   0x0018             MOVS     R0,R3
    599                break;
   \   0000008A   0xE007             B.N      ??CAN_TransmitStatus_9
    600                /* transmit failed  */
    601              case (0x5): State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_6:
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0x0018             MOVS     R0,R3
    602                break;
   \   00000090   0xE004             B.N      ??CAN_TransmitStatus_9
    603                /* transmit succedeed  */
    604              case (0x7): State = CANTXOK;
   \                     ??CAN_TransmitStatus_7:
   \   00000092   0x2301             MOVS     R3,#+1
   \   00000094   0x0018             MOVS     R0,R3
    605                break;
   \   00000096   0xE001             B.N      ??CAN_TransmitStatus_9
    606              default:
    607                State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_8:
   \   00000098   0x2300             MOVS     R3,#+0
   \   0000009A   0x0018             MOVS     R0,R3
    608                break;
    609            }
    610          
    611            return State;
   \                     ??CAN_TransmitStatus_9:
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x4770             BX       LR               ;; return
    612          }
    613          
    614          /*******************************************************************************
    615          * Function Name  : CAN_CancelTransmit
    616          * Description    : Cancels a transmit request.
    617          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral. 
    618          *                  - Mailbox:  number of the mailbox.
    619          * Output         : None.
    620          * Return         : None.
    621          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          void CAN_CancelTransmit(CAN_TypeDef* CANx, u8 Mailbox)
    623          {
    624            /* Check the parameters */
    625            assert_param(IS_CAN_ALL_PERIPH(CANx));
    626            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    627          
    628            /* abort transmission */
    629            switch (Mailbox)
   \                     CAN_CancelTransmit:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   0000000A   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000C   0xE00E             B.N      ??CAN_CancelTransmit_3
    630            {
    631              case (0): CANx->TSR |= TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0:
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000014   0x6082             STR      R2,[R0, #+8]
    632                break;
   \   00000016   0xE009             B.N      ??CAN_CancelTransmit_4
    633              case (1): CANx->TSR |= TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2:
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \   0000001E   0x6082             STR      R2,[R0, #+8]
    634                break;
   \   00000020   0xE004             B.N      ??CAN_CancelTransmit_4
    635              case (2): CANx->TSR |= TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1:
   \   00000022   0x6882             LDR      R2,[R0, #+8]
   \   00000024   0xF452 0x0200      ORRS     R2,R2,#0x800000
   \   00000028   0x6082             STR      R2,[R0, #+8]
    636                break;
   \   0000002A   0xE7FF             B.N      ??CAN_CancelTransmit_4
    637              default:
    638                break;
    639            }
    640          }
   \                     ??CAN_CancelTransmit_3:
   \                     ??CAN_CancelTransmit_4:
   \   0000002C   0x4770             BX       LR               ;; return
    641          
    642          /*******************************************************************************
    643          * Function Name  : CAN_FIFORelease
    644          * Description    : Releases a FIFO.
    645          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral. 
    646          *                  - FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    647          * Output         : None.
    648          * Return         : None.
    649          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    650          void CAN_FIFORelease(CAN_TypeDef* CANx, u8 FIFONumber)
    651          {
    652            /* Check the parameters */
    653            assert_param(IS_CAN_ALL_PERIPH(CANx));
    654            assert_param(IS_CAN_FIFO(FIFONumber));
    655          
    656            /* Release FIFO0 */
    657            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD102             BNE.N    ??CAN_FIFORelease_0
    658            {
    659              CANx->RF0R = RF0R_RFOM0;
   \   00000006   0x2220             MOVS     R2,#+32
   \   00000008   0x60C2             STR      R2,[R0, #+12]
   \   0000000A   0xE001             B.N      ??CAN_FIFORelease_1
    660            }
    661            /* Release FIFO1 */
    662            else /* FIFONumber == CAN_FIFO1 */
    663            {
    664              CANx->RF1R = RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0:
   \   0000000C   0x2220             MOVS     R2,#+32
   \   0000000E   0x6102             STR      R2,[R0, #+16]
    665            }
    666          }
   \                     ??CAN_FIFORelease_1:
   \   00000010   0x4770             BX       LR               ;; return
    667          
    668          /*******************************************************************************
    669          * Function Name  : CAN_MessagePending
    670          * Description    : Returns the number of pending messages.
    671          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    672          *                  - FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    673          * Output         : None.
    674          * Return         : NbMessage which is the number of pending message.
    675          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    676          u8 CAN_MessagePending(CAN_TypeDef* CANx, u8 FIFONumber)
    677          {
   \                     CAN_MessagePending:
   \   00000000   0x0002             MOVS     R2,R0
    678            u8 MessagePending=0;
   \   00000002   0x2000             MOVS     R0,#+0
    679          
    680            /* Check the parameters */
    681            assert_param(IS_CAN_ALL_PERIPH(CANx));
    682            assert_param(IS_CAN_FIFO(FIFONumber));
    683          
    684            if (FIFONumber == CAN_FIFO0)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD104             BNE.N    ??CAN_MessagePending_0
    685            {
    686              MessagePending = (u8)(CANx->RF0R&(u32)0x03);
   \   0000000A   0x68D3             LDR      R3,[R2, #+12]
   \   0000000C   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xE009             B.N      ??CAN_MessagePending_1
    687            }
    688            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0:
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD104             BNE.N    ??CAN_MessagePending_2
    689            {
    690              MessagePending = (u8)(CANx->RF1R&(u32)0x03);
   \   0000001A   0x6913             LDR      R3,[R2, #+16]
   \   0000001C   0xF013 0x0303      ANDS     R3,R3,#0x3
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xE001             B.N      ??CAN_MessagePending_1
    691            }
    692            else
    693            {
    694              MessagePending = 0;
   \                     ??CAN_MessagePending_2:
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x0018             MOVS     R0,R3
    695            }
    696            return MessagePending;
   \                     ??CAN_MessagePending_1:
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
    697          }
    698          
    699          /*******************************************************************************
    700          * Function Name  : CAN_Receive
    701          * Description    : Receives a message.
    702          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    703          *                  - FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    704          * Output         : RxMessage: pointer to a structure which contains CAN Id,
    705          *                  CAN DLC, CAN datas and FMI number.
    706          * Return         : None.
    707          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    708          void CAN_Receive(CAN_TypeDef* CANx, u8 FIFONumber, CanRxMsg* RxMessage)
    709          {
   \                     CAN_Receive:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    710            /* Check the parameters */
    711            assert_param(IS_CAN_ALL_PERIPH(CANx));
    712            assert_param(IS_CAN_FIFO(FIFONumber));
    713          
    714            /* Get the Id */
    715            RxMessage->IDE = (u8)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   0000000E   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   00000012   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000016   0x7230             STRB     R0,[R6, #+8]
    716            if (RxMessage->IDE == CAN_ID_STD)
   \   00000018   0x7A30             LDRB     R0,[R6, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD107             BNE.N    ??CAN_Receive_0
    717            {
    718              RxMessage->StdId = (u32)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000024   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   00000028   0x0D40             LSRS     R0,R0,#+21
   \   0000002A   0x6030             STR      R0,[R6, #+0]
   \   0000002C   0xE006             B.N      ??CAN_Receive_1
    719            }
    720            else
    721            {
    722              RxMessage->ExtId = (u32)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0:
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000034   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   00000038   0x08C0             LSRS     R0,R0,#+3
   \   0000003A   0x6070             STR      R0,[R6, #+4]
    723            }
    724            
    725            RxMessage->RTR = (u8)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1:
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000042   0xF8D0 0x01B0      LDR      R0,[R0, #+432]
   \   00000046   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   0000004A   0x7270             STRB     R0,[R6, #+9]
    726          
    727            /* Get the DLC */
    728            RxMessage->DLC = (u8)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000052   0xF8D0 0x01B4      LDR      R0,[R0, #+436]
   \   00000056   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000005A   0x72B0             STRB     R0,[R6, #+10]
    729          
    730            /* Get the FMI */
    731            RxMessage->FMI = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000062   0xF8D0 0x01B4      LDR      R0,[R0, #+436]
   \   00000066   0x0A00             LSRS     R0,R0,#+8
   \   00000068   0x74F0             STRB     R0,[R6, #+19]
    732          
    733            /* Get the data field */
    734            RxMessage->Data[0] = (u8)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000070   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   00000074   0x72F0             STRB     R0,[R6, #+11]
    735            RxMessage->Data[1] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   0000007C   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   00000080   0x0A00             LSRS     R0,R0,#+8
   \   00000082   0x7330             STRB     R0,[R6, #+12]
    736            RxMessage->Data[2] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   0000008A   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   0000008E   0x0C00             LSRS     R0,R0,#+16
   \   00000090   0x7370             STRB     R0,[R6, #+13]
    737            RxMessage->Data[3] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000098   0xF8D0 0x01B8      LDR      R0,[R0, #+440]
   \   0000009C   0x0E00             LSRS     R0,R0,#+24
   \   0000009E   0x73B0             STRB     R0,[R6, #+14]
    738          
    739            RxMessage->Data[4] = (u8)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000A6   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000AA   0x73F0             STRB     R0,[R6, #+15]
    740            RxMessage->Data[5] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000B2   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000B6   0x0A00             LSRS     R0,R0,#+8
   \   000000B8   0x7430             STRB     R0,[R6, #+16]
    741            RxMessage->Data[6] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000C0   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000C4   0x0C00             LSRS     R0,R0,#+16
   \   000000C6   0x7470             STRB     R0,[R6, #+17]
    742            RxMessage->Data[7] = (u8)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   000000CE   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   000000D2   0x0E00             LSRS     R0,R0,#+24
   \   000000D4   0x74B0             STRB     R0,[R6, #+18]
    743          
    744            /* Release the FIFO */
    745            CAN_FIFORelease(CANx, FIFONumber);
   \   000000D6   0x0029             MOVS     R1,R5
   \   000000D8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       CAN_FIFORelease
    746          }
   \   000000E0   0xBD70             POP      {R4-R6,PC}       ;; return
    747          
    748          /*******************************************************************************
    749          * Function Name  : CAN_Sleep
    750          * Description    : Enters the low power mode.
    751          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    752          * Output         : None.
    753          * Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
    754          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    755          u8 CAN_Sleep(CAN_TypeDef* CANx)
    756          {
   \                     CAN_Sleep:
   \   00000000   0x0001             MOVS     R1,R0
    757            u8 sleepstatus = CANSLEEPFAILED;
   \   00000002   0x2000             MOVS     R0,#+0
    758          
    759            /* Check the parameters */
    760            assert_param(IS_CAN_ALL_PERIPH(CANx));
    761            
    762            /* Request Sleep mode */
    763             CANx->MCR = (((CANx->MCR) & (u32)(~MCR_INRQ)) | MCR_SLEEP);
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    764            /* Sleep mode status */
    765            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xD101             BNE.N    ??CAN_Sleep_0
    766            {
    767              /* Sleep mode not entered */
    768              sleepstatus =  CANSLEEPOK;
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0010             MOVS     R0,R2
    769            }
    770            /* At this step, sleep mode status */
    771             return (u8)sleepstatus;
   \                     ??CAN_Sleep_0:
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x4770             BX       LR               ;; return
    772          }
    773          
    774          
    775          /*******************************************************************************
    776          * Function Name  : CAN_WakeUp
    777          * Description    : Wakes the CAN up.
    778          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    779          * Output         : None.
    780          * Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
    781          *                  case.
    782          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    783          u8 CAN_WakeUp(CAN_TypeDef* CANx)
    784          {
   \                     CAN_WakeUp:
   \   00000000   0x0001             MOVS     R1,R0
    785            u16 waitslak = SLAK_TimeOut	;
   \   00000002   0xF64F 0x72FF      MOVW     R2,#+65535
    786            u8 wakeupstatus = CANWAKEUPFAILED;
   \   00000006   0x2000             MOVS     R0,#+0
    787            
    788            /* Check the parameter */
    789            assert_param(IS_CAN_ALL_PERIPH(CANx));
    790            
    791            /* Wake up request */
    792            CANx->MCR &= ~MCR_SLEEP;
   \   00000008   0x680B             LDR      R3,[R1, #+0]
   \   0000000A   0xF033 0x0302      BICS     R3,R3,#0x2
   \   0000000E   0x600B             STR      R3,[R1, #+0]
    793              
    794            /* Sleep mode status */
    795          
    796            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(waitslak!=0x00))
   \                     ??CAN_WakeUp_0:
   \   00000010   0x684B             LDR      R3,[R1, #+4]
   \   00000012   0x079B             LSLS     R3,R3,#+30
   \   00000014   0xD504             BPL.N    ??CAN_WakeUp_1
   \   00000016   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD001             BEQ.N    ??CAN_WakeUp_1
    797             {
    798             waitslak --;
   \   0000001C   0x1E52             SUBS     R2,R2,#+1
   \   0000001E   0xE7F7             B.N      ??CAN_WakeUp_0
    799             }
    800          
    801            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_1:
   \   00000020   0x684B             LDR      R3,[R1, #+4]
   \   00000022   0x079B             LSLS     R3,R3,#+30
   \   00000024   0xD401             BMI.N    ??CAN_WakeUp_2
    802            {
    803             /* Sleep mode exited */
    804              wakeupstatus = CANWAKEUPOK;
   \   00000026   0x2301             MOVS     R3,#+1
   \   00000028   0x0018             MOVS     R0,R3
    805            }
    806            /* At this step, sleep mode status */
    807            return (u8)wakeupstatus;
   \                     ??CAN_WakeUp_2:
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x4770             BX       LR               ;; return
    808          }
    809          
    810          /*******************************************************************************
    811          * Function Name  : CAN_GetFlagStatus
    812          * Description    : Checks whether the specified CAN flag is set or not.
    813          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    814          *                  - CAN_FLAG: specifies the flag to check.
    815          *                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
    816          *                                         CAN_FLAG_BOF.
    817          * Output         : None.
    818          * Return         : The new state of CAN_FLAG (SET or RESET).
    819          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    820          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, u32 CAN_FLAG)
    821          {
   \                     CAN_GetFlagStatus:
   \   00000000   0x0002             MOVS     R2,R0
    822            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    823          
    824            /* Check the parameters */
    825            assert_param(IS_CAN_ALL_PERIPH(CANx));
    826            assert_param(IS_CAN_FLAG(CAN_FLAG));
    827          
    828            /* Check the status of the specified CAN flag */
    829            if ((CANx->ESR & CAN_FLAG) != (u32)RESET)
   \   00000004   0x6993             LDR      R3,[R2, #+24]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD002             BEQ.N    ??CAN_GetFlagStatus_0
    830            {
    831              /* CAN_FLAG is set */
    832              bitstatus = SET;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??CAN_GetFlagStatus_1
    833            }
    834            else
    835            {
    836              /* CAN_FLAG is reset */
    837              bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_0:
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0018             MOVS     R0,R3
    838            }
    839            /* Return the CAN_FLAG status */
    840            return  bitstatus;
   \                     ??CAN_GetFlagStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    841          }
    842          
    843          /*******************************************************************************
    844          * Function Name  : CAN_ClearFlag
    845          * Description    : Clears the CAN's pending flags.
    846          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    847          *                  - CAN_FLAG: specifies the flag to clear.
    848          * Output         : None.
    849          * Return         : None.
    850          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    851          void CAN_ClearFlag(CAN_TypeDef* CANx, u32 CAN_FLAG)
    852          {
    853            /* Check the parameters */
    854            assert_param(IS_CAN_ALL_PERIPH(CANx));
    855            assert_param(IS_CAN_FLAG(CAN_FLAG));
    856          
    857            /* Clear the selected CAN flags */
    858            CANx->ESR &= ~CAN_FLAG;
   \                     CAN_ClearFlag:
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0x438A             BICS     R2,R2,R1
   \   00000004   0x6182             STR      R2,[R0, #+24]
    859          }
   \   00000006   0x4770             BX       LR               ;; return
    860          
    861          /*******************************************************************************
    862          * Function Name  : CAN_GetITStatus
    863          * Description    : Checks whether the specified CAN interrupt has occurred or 
    864          *                  not.
    865          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    866          *                  - CAN_IT: specifies the CAN interrupt source to check.
    867          *                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
    868          *                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
    869          *                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
    870          *                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
    871          * Output         : None.
    872          * Return         : The new state of CAN_IT (SET or RESET).
    873          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    874          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, u32 CAN_IT)
    875          {
   \                     CAN_GetITStatus:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    876            ITStatus pendingbitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    877          
    878            /* Check the parameters */
    879            assert_param(IS_CAN_ALL_PERIPH(CANx));
    880            assert_param(IS_CAN_ITStatus(CAN_IT));
    881          
    882            switch (CAN_IT)
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD02F             BEQ.N    ??CAN_GetITStatus_0
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD019             BEQ.N    ??CAN_GetITStatus_1
   \   00000012   0x2806             CMP      R0,#+6
   \   00000014   0xD01D             BEQ.N    ??CAN_GetITStatus_2
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD022             BEQ.N    ??CAN_GetITStatus_3
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   0000001E   0x2820             CMP      R0,#+32
   \   00000020   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   00000022   0x2840             CMP      R0,#+64
   \   00000024   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000026   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000002A   0xD038             BEQ.N    ??CAN_GetITStatus_7
   \   0000002C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000030   0xD03B             BEQ.N    ??CAN_GetITStatus_8
   \   00000032   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000036   0xD03E             BEQ.N    ??CAN_GetITStatus_9
   \   00000038   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000003C   0xD047             BEQ.N    ??CAN_GetITStatus_10
   \   0000003E   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000042   0xD03E             BEQ.N    ??CAN_GetITStatus_11
   \   00000044   0xE049             B.N      ??CAN_GetITStatus_12
    883            {
    884              case CAN_IT_RQCP0:
    885                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP0);
   \                     ??CAN_GetITStatus_1:
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x.... 0x....      BL       CheckITStatus
   \   0000004E   0x0006             MOVS     R6,R0
    886                break;
   \   00000050   0xE045             B.N      ??CAN_GetITStatus_13
    887              case CAN_IT_RQCP1:
    888                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP1);
   \                     ??CAN_GetITStatus_2:
   \   00000052   0xF44F 0x7180      MOV      R1,#+256
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x.... 0x....      BL       CheckITStatus
   \   0000005C   0x0006             MOVS     R6,R0
    889                break;
   \   0000005E   0xE03E             B.N      ??CAN_GetITStatus_13
    890              case CAN_IT_RQCP2:
    891                pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP2);
   \                     ??CAN_GetITStatus_3:
   \   00000060   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000064   0x68A0             LDR      R0,[R4, #+8]
   \   00000066   0x.... 0x....      BL       CheckITStatus
   \   0000006A   0x0006             MOVS     R6,R0
    892                break;
   \   0000006C   0xE037             B.N      ??CAN_GetITStatus_13
    893              case CAN_IT_FF0:
    894                pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FULL0);
   \                     ??CAN_GetITStatus_0:
   \   0000006E   0x2108             MOVS     R1,#+8
   \   00000070   0x68E0             LDR      R0,[R4, #+12]
   \   00000072   0x.... 0x....      BL       CheckITStatus
   \   00000076   0x0006             MOVS     R6,R0
    895                break;
   \   00000078   0xE031             B.N      ??CAN_GetITStatus_13
    896              case CAN_IT_FOV0:
    897                pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FOVR0);
   \                     ??CAN_GetITStatus_4:
   \   0000007A   0x2110             MOVS     R1,#+16
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x.... 0x....      BL       CheckITStatus
   \   00000082   0x0006             MOVS     R6,R0
    898                break;
   \   00000084   0xE02B             B.N      ??CAN_GetITStatus_13
    899              case CAN_IT_FF1:
    900                pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FULL1);
   \                     ??CAN_GetITStatus_5:
   \   00000086   0x2108             MOVS     R1,#+8
   \   00000088   0x6920             LDR      R0,[R4, #+16]
   \   0000008A   0x.... 0x....      BL       CheckITStatus
   \   0000008E   0x0006             MOVS     R6,R0
    901                break;
   \   00000090   0xE025             B.N      ??CAN_GetITStatus_13
    902              case CAN_IT_FOV1:
    903                pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FOVR1);
   \                     ??CAN_GetITStatus_6:
   \   00000092   0x2110             MOVS     R1,#+16
   \   00000094   0x6920             LDR      R0,[R4, #+16]
   \   00000096   0x.... 0x....      BL       CheckITStatus
   \   0000009A   0x0006             MOVS     R6,R0
    904                break;
   \   0000009C   0xE01F             B.N      ??CAN_GetITStatus_13
    905              case CAN_IT_EWG:
    906                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EWGF);
   \                     ??CAN_GetITStatus_7:
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x69A0             LDR      R0,[R4, #+24]
   \   000000A2   0x.... 0x....      BL       CheckITStatus
   \   000000A6   0x0006             MOVS     R6,R0
    907                break;
   \   000000A8   0xE019             B.N      ??CAN_GetITStatus_13
    908              case CAN_IT_EPV:
    909                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EPVF);
   \                     ??CAN_GetITStatus_8:
   \   000000AA   0x2102             MOVS     R1,#+2
   \   000000AC   0x69A0             LDR      R0,[R4, #+24]
   \   000000AE   0x.... 0x....      BL       CheckITStatus
   \   000000B2   0x0006             MOVS     R6,R0
    910                break;
   \   000000B4   0xE013             B.N      ??CAN_GetITStatus_13
    911              case CAN_IT_BOF:
    912                pendingbitstatus = CheckITStatus(CANx->ESR, ESR_BOFF);
   \                     ??CAN_GetITStatus_9:
   \   000000B6   0x2104             MOVS     R1,#+4
   \   000000B8   0x69A0             LDR      R0,[R4, #+24]
   \   000000BA   0x.... 0x....      BL       CheckITStatus
   \   000000BE   0x0006             MOVS     R6,R0
    913                break;
   \   000000C0   0xE00D             B.N      ??CAN_GetITStatus_13
    914              case CAN_IT_SLK:
    915                pendingbitstatus = CheckITStatus(CANx->MSR, MSR_SLAKI);
   \                     ??CAN_GetITStatus_11:
   \   000000C2   0x2110             MOVS     R1,#+16
   \   000000C4   0x6860             LDR      R0,[R4, #+4]
   \   000000C6   0x.... 0x....      BL       CheckITStatus
   \   000000CA   0x0006             MOVS     R6,R0
    916                break;
   \   000000CC   0xE007             B.N      ??CAN_GetITStatus_13
    917              case CAN_IT_WKU:
    918                pendingbitstatus = CheckITStatus(CANx->MSR, MSR_WKUI);
   \                     ??CAN_GetITStatus_10:
   \   000000CE   0x2108             MOVS     R1,#+8
   \   000000D0   0x6860             LDR      R0,[R4, #+4]
   \   000000D2   0x.... 0x....      BL       CheckITStatus
   \   000000D6   0x0006             MOVS     R6,R0
    919                break;
   \   000000D8   0xE001             B.N      ??CAN_GetITStatus_13
    920          
    921              default :
    922                pendingbitstatus = RESET;
   \                     ??CAN_GetITStatus_12:
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x0006             MOVS     R6,R0
    923                break;
    924            }
    925          
    926            /* Return the CAN_IT status */
    927            return  pendingbitstatus;
   \                     ??CAN_GetITStatus_13:
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xBD70             POP      {R4-R6,PC}       ;; return
    928          }
    929          
    930          /*******************************************************************************
    931          * Function Name  : CAN_ClearITPendingBit
    932          * Description    : Clears the CANs interrupt pending bits.
    933          * Input          : - CANx: where x can be 1 or 2 to select the CAN peripheral.
    934          *                  - CAN_IT: specifies the interrupt pending bit to clear.
    935          * Output         : None.
    936          * Return         : None.
    937          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    938          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, u32 CAN_IT)
    939          {
    940            /* Check the parameters */
    941            assert_param(IS_CAN_ALL_PERIPH(CANx));
    942            assert_param(IS_CAN_ITStatus(CAN_IT));
    943          
    944            switch (CAN_IT)
   \                     CAN_ClearITPendingBit:
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x2A04             CMP      R2,#+4
   \   00000004   0xD026             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000006   0x2A05             CMP      R2,#+5
   \   00000008   0xD019             BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000000A   0x2A06             CMP      R2,#+6
   \   0000000C   0xD01A             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000E   0x2A07             CMP      R2,#+7
   \   00000010   0xD01C             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000012   0x2A08             CMP      R2,#+8
   \   00000014   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000016   0x2A20             CMP      R2,#+32
   \   00000018   0xD022             BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   0x2A40             CMP      R2,#+64
   \   0000001C   0xD023             BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000001E   0xF5B2 0x7F80      CMP      R2,#+256
   \   00000022   0xD023             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000024   0xF5B2 0x7F00      CMP      R2,#+512
   \   00000028   0xD025             BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000002A   0xF5B2 0x6F80      CMP      R2,#+1024
   \   0000002E   0xD027             BEQ.N    ??CAN_ClearITPendingBit_9
   \   00000030   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000034   0xD029             BEQ.N    ??CAN_ClearITPendingBit_10
   \   00000036   0xF5B2 0x3F00      CMP      R2,#+131072
   \   0000003A   0xD029             BEQ.N    ??CAN_ClearITPendingBit_11
   \   0000003C   0xE02B             B.N      ??CAN_ClearITPendingBit_12
    945            {
    946              case CAN_IT_RQCP0:
    947                CANx->TSR = TSR_RQCP0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_1:
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x6082             STR      R2,[R0, #+8]
    948                break;
   \   00000042   0xE028             B.N      ??CAN_ClearITPendingBit_13
    949              case CAN_IT_RQCP1:
    950                CANx->TSR = TSR_RQCP1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_2:
   \   00000044   0xF44F 0x7280      MOV      R2,#+256
   \   00000048   0x6082             STR      R2,[R0, #+8]
    951                break;
   \   0000004A   0xE024             B.N      ??CAN_ClearITPendingBit_13
    952              case CAN_IT_RQCP2:
    953                CANx->TSR = TSR_RQCP2; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_3:
   \   0000004C   0xF45F 0x3280      MOVS     R2,#+65536
   \   00000050   0x6082             STR      R2,[R0, #+8]
    954                break;
   \   00000052   0xE020             B.N      ??CAN_ClearITPendingBit_13
    955              case CAN_IT_FF0:
    956                CANx->RF0R = RF0R_FULL0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_0:
   \   00000054   0x2208             MOVS     R2,#+8
   \   00000056   0x60C2             STR      R2,[R0, #+12]
    957                break;
   \   00000058   0xE01D             B.N      ??CAN_ClearITPendingBit_13
    958              case CAN_IT_FOV0:
    959                CANx->RF0R = RF0R_FOVR0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_4:
   \   0000005A   0x2210             MOVS     R2,#+16
   \   0000005C   0x60C2             STR      R2,[R0, #+12]
    960                break;
   \   0000005E   0xE01A             B.N      ??CAN_ClearITPendingBit_13
    961              case CAN_IT_FF1:
    962                CANx->RF1R = RF1R_FULL1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_5:
   \   00000060   0x2208             MOVS     R2,#+8
   \   00000062   0x6102             STR      R2,[R0, #+16]
    963                break;
   \   00000064   0xE017             B.N      ??CAN_ClearITPendingBit_13
    964              case CAN_IT_FOV1:
    965                CANx->RF1R = RF1R_FOVR1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_6:
   \   00000066   0x2210             MOVS     R2,#+16
   \   00000068   0x6102             STR      R2,[R0, #+16]
    966                break;
   \   0000006A   0xE014             B.N      ??CAN_ClearITPendingBit_13
    967              case CAN_IT_EWG:
    968                CANx->ESR &= ~ ESR_EWGF; /* rw */
   \                     ??CAN_ClearITPendingBit_7:
   \   0000006C   0x6982             LDR      R2,[R0, #+24]
   \   0000006E   0x0852             LSRS     R2,R2,#+1
   \   00000070   0x0052             LSLS     R2,R2,#+1
   \   00000072   0x6182             STR      R2,[R0, #+24]
    969                break;
   \   00000074   0xE00F             B.N      ??CAN_ClearITPendingBit_13
    970              case CAN_IT_EPV:
    971                CANx->ESR &= ~ ESR_EPVF; /* rw */
   \                     ??CAN_ClearITPendingBit_8:
   \   00000076   0x6982             LDR      R2,[R0, #+24]
   \   00000078   0xF032 0x0202      BICS     R2,R2,#0x2
   \   0000007C   0x6182             STR      R2,[R0, #+24]
    972                break;
   \   0000007E   0xE00A             B.N      ??CAN_ClearITPendingBit_13
    973              case CAN_IT_BOF:
    974                CANx->ESR &= ~ ESR_BOFF; /* rw */
   \                     ??CAN_ClearITPendingBit_9:
   \   00000080   0x6982             LDR      R2,[R0, #+24]
   \   00000082   0xF032 0x0204      BICS     R2,R2,#0x4
   \   00000086   0x6182             STR      R2,[R0, #+24]
    975                break;
   \   00000088   0xE005             B.N      ??CAN_ClearITPendingBit_13
    976              case CAN_IT_WKU:
    977                CANx->MSR = MSR_WKUI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_10:
   \   0000008A   0x2208             MOVS     R2,#+8
   \   0000008C   0x6042             STR      R2,[R0, #+4]
    978                break;
   \   0000008E   0xE002             B.N      ??CAN_ClearITPendingBit_13
    979              case CAN_IT_SLK:
    980                CANx->MSR = MSR_SLAKI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_11:
   \   00000090   0x2210             MOVS     R2,#+16
   \   00000092   0x6042             STR      R2,[R0, #+4]
    981                break;
   \   00000094   0xE7FF             B.N      ??CAN_ClearITPendingBit_13
    982              default :
    983                break;
    984            }
    985          }
   \                     ??CAN_ClearITPendingBit_12:
   \                     ??CAN_ClearITPendingBit_13:
   \   00000096   0x4770             BX       LR               ;; return
    986          
    987          /*******************************************************************************
    988          * Function Name  : CheckITStatus
    989          * Description    : Checks whether the CAN interrupt has occurred or not.
    990          * Input          : - CAN_Reg: specifies the CAN interrupt register to check.
    991          *                  It_Bit: specifies the interrupt source bit to check.
    992          * Output         : None.
    993          * Return         : The new state of the CAN Interrupt (SET or RESET).
    994          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    995          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
    996          {
   \                     CheckITStatus:
   \   00000000   0x0002             MOVS     R2,R0
    997            ITStatus pendingbitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    998          
    999            if ((CAN_Reg & It_Bit) != (u32)RESET)
   \   00000004   0x420A             TST      R2,R1
   \   00000006   0xD002             BEQ.N    ??CheckITStatus_0
   1000            {
   1001              /* CAN_IT is set */
   1002              pendingbitstatus = SET;
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x0018             MOVS     R0,R3
   \   0000000C   0xE001             B.N      ??CheckITStatus_1
   1003            }
   1004            else
   1005            {
   1006              /* CAN_IT is reset */
   1007              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0:
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x0018             MOVS     R0,R3
   1008            }
   1009          
   1010            return pendingbitstatus;
   \                     ??CheckITStatus_1:
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   1011          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40006800         DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1
   1012          
   1013          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
       4   CAN_FilterInit
       0   CAN_GetFlagStatus
      16   CAN_GetITStatus
        16   -> CheckITStatus
       0   CAN_ITConfig
       8   CAN_Init
       0   CAN_MessagePending
      16   CAN_Receive
        16   -> CAN_FIFORelease
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       8   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      46  CAN_CancelTransmit
       8  CAN_ClearFlag
     152  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      66  CAN_DeInit
      18  CAN_FIFORelease
     226  CAN_FilterInit
      24  CAN_GetFlagStatus
     228  CAN_GetITStatus
      22  CAN_ITConfig
     284  CAN_Init
      44  CAN_MessagePending
     226  CAN_Receive
      52  CAN_SlaveStartBank
      34  CAN_Sleep
      46  CAN_StructInit
     294  CAN_Transmit
     160  CAN_TransmitStatus
      46  CAN_WakeUp
      22  CheckITStatus

 
 2 060 bytes in section .text
 
 2 060 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.2.4510/W32 for ARM      08/Feb/2013  10:57:24 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_spi.c                    #
#    Command line =  "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\BSP\ST\STM32\src\stm32f10x_spi.c" -D                #
#                    USE_STDPERIPH_DRIVER -lCN "C:\Users\daniel01\Desktop\Fas #
#                    tFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC #
#                    -Eval-STM32F107\uCOS-II\IAR\Flash\List\" -o              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\daniel01\Desktop\FastFile Test       #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\uCOS-II\IAR\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\" -I                          #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\OS\uCOS-II\" -I               #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\ST\STM32\inc\" -I             #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\uCOS-II\" -I                  #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\BSP\IAR\" -I                      #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-LIB\Ports\ARM-Cortex- #
#                    M3\IAR\" -I "C:\Users\daniel01\Desktop\FastFile Test     #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\" -I              #
#                    "C:\Users\daniel01\Desktop\FastFile Test                 #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR #
#                    \" -I "C:\Users\daniel01\Desktop\FastFile Test           #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex #
#                    -M3\Generic\IAR\" -I "C:\Users\daniel01\Desktop\FastFile #
#                     Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval #
#                    -STM32F107\uCOS-II\IAR\..\..\..\..\..\uCOS-II\Source\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\List\stm32f10x_spi.lst            #
#    Object file  =  C:\Users\daniel01\Desktop\FastFile Test                  #
#                    Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32 #
#                    F107\uCOS-II\IAR\Flash\Obj\stm32f10x_spi.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\daniel01\Desktop\FastFile Test Folder\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\BSP\ST\STM32\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2009 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.1.0RC2
      5          * Date               : 03/13/2009
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_spi.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* SPI SPE mask */
     23          #define CR1_SPE_Set          ((u16)0x0040)
     24          #define CR1_SPE_Reset        ((u16)0xFFBF)
     25          
     26          /* I2S I2SE mask */
     27          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     28          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     29          
     30          /* SPI CRCNext mask */
     31          #define CR1_CRCNext_Set      ((u16)0x1000)
     32          
     33          /* SPI CRCEN mask */
     34          #define CR1_CRCEN_Set        ((u16)0x2000)
     35          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     36          
     37          /* SPI SSOE mask */
     38          #define CR2_SSOE_Set         ((u16)0x0004)
     39          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     40          
     41          /* SPI registers Masks */
     42          #define CR1_CLEAR_Mask       ((u16)0x3040)
     43          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     44          
     45          /* SPI or I2S mode selection masks */
     46          #define SPI_Mode_Select      ((u16)0xF7FF)
     47          #define I2S_Mode_Select      ((u16)0x0800) 
     48          
     49          /* I2S clock source selection masks */
     50          #define I2S2_CLOCK_SRC       ((u32)(0x00020000))
     51          #define I2S3_CLOCK_SRC       ((u32)(0x00040000))
     52          #define I2S_MUL_MASK         ((u32)(0x0000F000))
     53          #define I2S_DIV_MASK         ((u32)(0x000000F0))
     54          #define DIV_ID               ((*(vu32*)0xE0042000) & 0xFFF)
     55          #define STM32_CL             ((u32)0x418)
     56          
     57          /* Private macro -------------------------------------------------------------*/
     58          /* Private variables ---------------------------------------------------------*/
     59          /* Private function prototypes -----------------------------------------------*/
     60          /* Private functions ---------------------------------------------------------*/
     61          
     62          /*******************************************************************************
     63          * Function Name  : SPI_I2S_DeInit
     64          * Description    : Deinitializes the SPIx peripheral registers to their default
     65          *                  reset values (Affects also the I2Ss).
     66          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     67          * Output         : None
     68          * Return         : None
     69          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     71          {
   \                     SPI_I2S_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     72            /* Check the parameters */
     73            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     74            
     75            switch (*(u32*)&SPIx)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x....             LDR.N    R1,??DataTable1  ;; 0x40003800
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD010             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000000C   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40003c00
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD018             BEQ.N    ??SPI_I2S_DeInit_1
   \   00000012   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40013000
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD120             BNE.N    ??SPI_I2S_DeInit_2
     76            {
     77              case SPI1_BASE:
     78                /* Enable SPI1 reset state */
     79                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \                     ??SPI_I2S_DeInit_3:
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     80                /* Release SPI1 from reset state */
     81                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF44F 0x5080      MOV      R0,#+4096
   \   00000028   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     82                break;
   \   0000002C   0xE015             B.N      ??SPI_I2S_DeInit_4
     83          
     84              case SPI2_BASE:
     85                /* Enable SPI2 reset state */
     86                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_0:
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xF44F 0x4080      MOV      R0,#+16384
   \   00000034   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     87                /* Release SPI2 from reset state */
     88                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     89                break;
   \   00000042   0xE00A             B.N      ??SPI_I2S_DeInit_4
     90          
     91              case SPI3_BASE:
     92                /* Enable SPI3 reset state */
     93                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_1:
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xF44F 0x4000      MOV      R0,#+32768
   \   0000004A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     94                /* Release SPI3 from reset state */
     95                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xF44F 0x4000      MOV      R0,#+32768
   \   00000054   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     96                break;
   \   00000058   0xE7FF             B.N      ??SPI_I2S_DeInit_4
     97          
     98              default:
     99                break;
    100            }
    101          }
   \                     ??SPI_I2S_DeInit_2:
   \                     ??SPI_I2S_DeInit_4:
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    102          
    103          /*******************************************************************************
    104          * Function Name  : SPI_Init
    105          * Description    : Initializes the SPIx peripheral according to the specified 
    106          *                  parameters in the SPI_InitStruct.
    107          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    108          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    109          *                    contains the configuration information for the specified
    110          *                    SPI peripheral.
    111          * Output         : None
    112          * Return         : None
    113          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    115          {
   \                     SPI_Init:
   \   00000000   0xB410             PUSH     {R4}
    116            u16 tmpreg = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    117            
    118            /* check the parameters */
    119            assert_param(IS_SPI_ALL_PERIPH(SPIx));   
    120            
    121            /* Check the SPI parameters */
    122            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    123            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    124            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    125            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    126            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    127            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    128            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    129            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    130            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    131          
    132          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    133            /* Get the SPIx CR1 value */
    134            tmpreg = SPIx->CR1;
   \   00000004   0x8803             LDRH     R3,[R0, #+0]
   \   00000006   0x001A             MOVS     R2,R3
    135            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    136            tmpreg &= CR1_CLEAR_Mask;
   \   00000008   0xF412 0x5241      ANDS     R2,R2,#0x3040
    137            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    138               master/salve mode, CPOL and CPHA */
    139            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    140            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    141            /* Set LSBFirst bit according to SPI_FirstBit value */
    142            /* Set BR bits according to SPI_BaudRatePrescaler value */
    143            /* Set CPOL bit according to SPI_CPOL value */
    144            /* Set CPHA bit according to SPI_CPHA value */
    145            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    146                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    147                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    148                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \   0000000C   0x880B             LDRH     R3,[R1, #+0]
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x888C             LDRH     R4,[R1, #+4]
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x88CC             LDRH     R4,[R1, #+6]
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0x890C             LDRH     R4,[R1, #+8]
   \   0000001C   0x4323             ORRS     R3,R4,R3
   \   0000001E   0x894C             LDRH     R4,[R1, #+10]
   \   00000020   0x4323             ORRS     R3,R4,R3
   \   00000022   0x898C             LDRH     R4,[R1, #+12]
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x89CC             LDRH     R4,[R1, #+14]
   \   00000028   0x4323             ORRS     R3,R4,R3
   \   0000002A   0x431A             ORRS     R2,R3,R2
    149            /* Write to SPIx CR1 */
    150            SPIx->CR1 = tmpreg;
   \   0000002C   0x8002             STRH     R2,[R0, #+0]
    151            
    152            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    153            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   0000002E   0x8B83             LDRH     R3,[R0, #+28]
   \   00000030   0xF24F 0x74FF      MOVW     R4,#+63487
   \   00000034   0x4023             ANDS     R3,R4,R3
   \   00000036   0x8383             STRH     R3,[R0, #+28]
    154          
    155          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    156            /* Write to SPIx CRCPOLY */
    157            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000038   0x8A0B             LDRH     R3,[R1, #+16]
   \   0000003A   0x8203             STRH     R3,[R0, #+16]
    158          }
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    159          
    160          /*******************************************************************************
    161          * Function Name  : I2S_Init
    162          * Description    : Initializes the SPIx peripheral according to the specified 
    163          *                  parameters in the I2S_InitStruct.
    164          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    165          *                     (configured in I2S mode).
    166          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    167          *                    contains the configuration information for the specified
    168          *                    SPI peripheral configured in I2S mode.
    169          *
    170          *                 Note: The function calculates the optimal prescaler needed to 
    171          *                   obtain the most accurate audio frequency (depending on the I2S 
    172          *                   clock source, the PLL values and the product configuration). 
    173          *                   But in case the prescaler value is greater than 511, the 
    174          *                   default value (0x02) will be configured instead.
    175          *
    176          * Output         : None
    177          * Return         : None
    178          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    179          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    180          {
   \                     I2S_Init:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    181            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2702             MOVS     R7,#+2
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000012   0xF05F 0x0901      MOVS     R9,#+1
    182            u32 tmp = 0, sourceclock = 0;
   \   00000016   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000001A   0xF05F 0x0B00      MOVS     R11,#+0
    183            RCC_ClocksTypeDef RCC_Clocks;
    184             
    185            /* Check the I2S parameters */
    186            assert_param(IS_SPI_23_PERIPH(SPIx));
    187            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    188            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    189            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    190            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    191            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    192            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    193          
    194          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    195          
    196            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    197            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \   0000001E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000020   0xF24F 0x0140      MOVW     R1,#+61504
   \   00000024   0x4008             ANDS     R0,R1,R0
   \   00000026   0x83A0             STRH     R0,[R4, #+28]
    198            SPIx->I2SPR = 0x0002;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x8420             STRH     R0,[R4, #+32]
    199            
    200            /* Get the I2SCFGR register value */
    201            tmpreg = SPIx->I2SCFGR;
   \   0000002C   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000002E   0x0006             MOVS     R6,R0
    202            
    203            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    204            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000030   0x68A8             LDR      R0,[R5, #+8]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD104             BNE.N    ??I2S_Init_0
    205            {
    206              i2sodd = (u16)0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4680             MOV      R8,R0
    207              i2sdiv = (u16)2;   
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE06E             B.N      ??I2S_Init_1
    208            }
    209            /* If the requested audio frequency is not the default, compute the prescaler */
    210            else
    211            {
    212              /* Check the frame length (For the Prescaler computing) */
    213              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0:
   \   00000040   0x88A8             LDRH     R0,[R5, #+4]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD102             BNE.N    ??I2S_Init_2
    214              {
    215                /* Packet length is 16 bits */
    216                packetlength = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x4681             MOV      R9,R0
   \   0000004A   0xE001             B.N      ??I2S_Init_3
    217              }
    218              else
    219              {
    220                /* Packet length is 32 bits */
    221                packetlength = 2;
   \                     ??I2S_Init_2:
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x4681             MOV      R9,R0
    222              }
    223          
    224              /* Get the I2S clock source mask depending on the peripheral number */
    225              if((*(u32*)&(SPIx)) == SPI2_BASE)
   \                     ??I2S_Init_3:
   \   00000050   0x....             LDR.N    R0,??DataTable1  ;; 0x40003800
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD103             BNE.N    ??I2S_Init_4
    226              {
    227                /* The mask is relative to I2S2 */
    228                tmp = I2S2_CLOCK_SRC;
   \   00000056   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0xE002             B.N      ??I2S_Init_5
    229              }
    230              else 
    231              {
    232                /* The mask is relative to I2S3 */      
    233                tmp = I2S3_CLOCK_SRC;
   \                     ??I2S_Init_4:
   \   0000005E   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000062   0x4682             MOV      R10,R0
    234              }
    235              /* Check the I2S clock source configuration depending on the Device ID
    236                 Only Connectivity line devices have the PLL3 VCO clock*/
    237              if((DIV_ID == STM32_CL) && ((RCC->CFGR2 & tmp) != 0))
   \                     ??I2S_Init_5:
   \   00000064   0x....             LDR.N    R0,??DataTable1_3  ;; 0xe0042000
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \   0000006A   0x0D00             LSRS     R0,R0,#+20
   \   0000006C   0xF5B0 0x6F83      CMP      R0,#+1048
   \   00000070   0xD125             BNE.N    ??I2S_Init_6
   \   00000072   0x....             LDR.N    R0,??DataTable1_4  ;; 0x4002102c
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xEA10 0x0F0A      TST      R0,R10
   \   0000007A   0xD020             BEQ.N    ??I2S_Init_6
    238              {
    239                /* Get the configuration bits of RCC PLL3 multiplier */
    240                tmp = (u32)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);
   \   0000007C   0x....             LDR.N    R0,??DataTable1_4  ;; 0x4002102c
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF3C0 0x3003      UBFX     R0,R0,#+12,#+4
   \   00000084   0x4682             MOV      R10,R0
    241          
    242                /* Get the value of the PLL3 multiplier */      
    243                if((tmp > 5) && (tmp < 15))
   \   00000086   0xF1BA 0x0F06      CMP      R10,#+6
   \   0000008A   0xD305             BCC.N    ??I2S_Init_7
   \   0000008C   0xF1BA 0x0F0F      CMP      R10,#+15
   \   00000090   0xD202             BCS.N    ??I2S_Init_7
    244                {
    245                  /* Multplier is between 8 and 14 (value 15 is forbidden) */
    246                  tmp += 2;
   \   00000092   0xF11A 0x0A02      ADDS     R10,R10,#+2
   \   00000096   0xE004             B.N      ??I2S_Init_8
    247                }
    248                else if (tmp == 15)
   \                     ??I2S_Init_7:
   \   00000098   0xF1BA 0x0F0F      CMP      R10,#+15
   \   0000009C   0xD101             BNE.N    ??I2S_Init_8
    249                {
    250                  /* Multiplier is 20 */
    251                  tmp = 20;
   \   0000009E   0x2014             MOVS     R0,#+20
   \   000000A0   0x4682             MOV      R10,R0
    252                }      
    253                /* Get the PREDIV2 value */
    254                sourceclock = (u32)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
   \                     ??I2S_Init_8:
   \   000000A2   0x....             LDR.N    R0,??DataTable1_4  ;; 0x4002102c
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x4683             MOV      R11,R0
    255                
    256                /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
    257                sourceclock = (u32) ((HSE_Value / sourceclock) * tmp * 2); 
   \   000000AE   0x....             LDR.N    R0,??DataTable1_5  ;; 0x17d7840
   \   000000B0   0xFBB0 0xF0FB      UDIV     R0,R0,R11
   \   000000B4   0xFB0A 0xF000      MUL      R0,R10,R0
   \   000000B8   0xEA5F 0x0B40      LSLS     R11,R0,#+1
   \   000000BC   0xE004             B.N      ??I2S_Init_9
    258              }
    259              else
    260              {
    261                /* I2S Clock source is System clock: Get System Clock frequency */
    262                RCC_GetClocksFreq(&RCC_Clocks);      
   \                     ??I2S_Init_6:
   \   000000BE   0xA800             ADD      R0,SP,#+0
   \   000000C0   0x.... 0x....      BL       RCC_GetClocksFreq
    263                
    264                /* Get the source clock value: based on System Clock value */
    265                sourceclock = RCC_Clocks.SYSCLK_Frequency;
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0x4683             MOV      R11,R0
    266              }    
    267              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    268              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \                     ??I2S_Init_9:
   \   000000C8   0x88E8             LDRH     R0,[R5, #+6]
   \   000000CA   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000CE   0xD10A             BNE.N    ??I2S_Init_10
    269              {
    270                /* MCLK output is enabled */
    271                tmp = (u16)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   000000D0   0xEA5F 0x201B      LSRS     R0,R11,#+8
   \   000000D4   0x210A             MOVS     R1,#+10
   \   000000D6   0x4348             MULS     R0,R1,R0
   \   000000D8   0x68A9             LDR      R1,[R5, #+8]
   \   000000DA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000DE   0x1D40             ADDS     R0,R0,#+5
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0x4682             MOV      R10,R0
   \   000000E4   0xE00D             B.N      ??I2S_Init_11
    272              }
    273              else
    274              {
    275                /* MCLK output is disabled */
    276                tmp = (u16)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_10:
   \   000000E6   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000EA   0xEA5F 0x1049      LSLS     R0,R9,#+5
   \   000000EE   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   000000F2   0x210A             MOVS     R1,#+10
   \   000000F4   0x4348             MULS     R0,R1,R0
   \   000000F6   0x68A9             LDR      R1,[R5, #+8]
   \   000000F8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000FC   0x1D40             ADDS     R0,R0,#+5
   \   000000FE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000100   0x4682             MOV      R10,R0
    277              }
    278              
    279              /* Remove the flaoting point */
    280              tmp = tmp / 10;  
   \                     ??I2S_Init_11:
   \   00000102   0x200A             MOVS     R0,#+10
   \   00000104   0xFBBA 0xFAF0      UDIV     R10,R10,R0
    281                
    282              /* Check the parity of the divider */
    283              i2sodd = (u16)(tmp & (u16)0x0001);
   \   00000108   0xF01A 0x0001      ANDS     R0,R10,#0x1
   \   0000010C   0x4680             MOV      R8,R0
    284             
    285              /* Compute the i2sdiv prescaler */
    286              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   0000010E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000112   0xEBBA 0x0008      SUBS     R0,R10,R8
   \   00000116   0x0840             LSRS     R0,R0,#+1
   \   00000118   0x0007             MOVS     R7,R0
    287             
    288              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    289              i2sodd = (u16) (i2sodd << 8);
   \   0000011A   0xEA5F 0x2808      LSLS     R8,R8,#+8
    290            }
    291            
    292            /* Test if the divider is 1 or 0 or greater than 0xFF */
    293            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1:
   \   0000011E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000120   0x2F02             CMP      R7,#+2
   \   00000122   0xDB02             BLT.N    ??I2S_Init_12
   \   00000124   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000126   0x2FFF             CMP      R7,#+255
   \   00000128   0xDD03             BLE.N    ??I2S_Init_13
    294            {
    295              /* Set the default values */
    296              i2sdiv = 2;
   \                     ??I2S_Init_12:
   \   0000012A   0x2002             MOVS     R0,#+2
   \   0000012C   0x0007             MOVS     R7,R0
    297              i2sodd = 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x4680             MOV      R8,R0
    298            }
    299          
    300            /* Write to SPIx I2SPR register the computed value */
    301            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
   \                     ??I2S_Init_13:
   \   00000132   0xEA58 0x0007      ORRS     R0,R8,R7
   \   00000136   0x88E9             LDRH     R1,[R5, #+6]
   \   00000138   0x4308             ORRS     R0,R1,R0
   \   0000013A   0x8420             STRH     R0,[R4, #+32]
    302           
    303            /* Configure the I2S with the SPI_InitStruct values */
    304            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    305                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    306                            I2S_InitStruct->I2S_CPOL);
   \   0000013C   0x8828             LDRH     R0,[R5, #+0]
   \   0000013E   0x8869             LDRH     R1,[R5, #+2]
   \   00000140   0x4308             ORRS     R0,R1,R0
   \   00000142   0x88A9             LDRH     R1,[R5, #+4]
   \   00000144   0x4308             ORRS     R0,R1,R0
   \   00000146   0x89A9             LDRH     R1,[R5, #+12]
   \   00000148   0x4308             ORRS     R0,R1,R0
   \   0000014A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000014E   0x4306             ORRS     R6,R0,R6
    307           
    308            /* Write to SPIx I2SCFGR */  
    309            SPIx->I2SCFGR = tmpreg;                                    
   \   00000150   0x83A6             STRH     R6,[R4, #+28]
    310          }
   \   00000152   0xB005             ADD      SP,SP,#+20
   \   00000154   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    311          
    312          /*******************************************************************************
    313          * Function Name  : SPI_StructInit
    314          * Description    : Fills each SPI_InitStruct member with its default value.
    315          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    316          *                    which will be initialized.
    317          * Output         : None
    318          * Return         : None
    319          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    320          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    321          {
    322          /*--------------- Reset SPI init structure parameters values -----------------*/
    323            /* Initialize the SPI_Direction member */
    324            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    325          
    326            /* initialize the SPI_Mode member */
    327            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    328          
    329            /* initialize the SPI_DataSize member */
    330            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    331          
    332            /* Initialize the SPI_CPOL member */
    333            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    334          
    335            /* Initialize the SPI_CPHA member */
    336            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    337          
    338            /* Initialize the SPI_NSS member */
    339            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    340          
    341            /* Initialize the SPI_BaudRatePrescaler member */
    342            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    343          
    344            /* Initialize the SPI_FirstBit member */
    345            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x81C1             STRH     R1,[R0, #+14]
    346          
    347            /* Initialize the SPI_CRCPolynomial member */
    348            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x8201             STRH     R1,[R0, #+16]
    349          }
   \   00000024   0x4770             BX       LR               ;; return
    350          
    351          /*******************************************************************************
    352          * Function Name  : I2S_StructInit
    353          * Description    : Fills each I2S_InitStruct member with its default value.
    354          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    355          *                    which will be initialized.
    356          * Output         : None
    357          * Return         : None
    358          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    359          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    360          {
    361          /*--------------- Reset I2S init structure parameters values -----------------*/
    362            /* Initialize the I2S_Mode member */
    363            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    364            
    365            /* Initialize the I2S_Standard member */
    366            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    367            
    368            /* Initialize the I2S_DataFormat member */
    369            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    370            
    371            /* Initialize the I2S_MCLKOutput member */
    372            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    373            
    374            /* Initialize the I2S_AudioFreq member */
    375            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x6081             STR      R1,[R0, #+8]
    376            
    377            /* Initialize the I2S_CPOL member */
    378            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8181             STRH     R1,[R0, #+12]
    379          }
   \   00000018   0x4770             BX       LR               ;; return
    380          
    381          /*******************************************************************************
    382          * Function Name  : SPI_Cmd
    383          * Description    : Enables or disables the specified SPI peripheral.
    384          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    385          *                  - NewState: new state of the SPIx peripheral. 
    386          *                    This parameter can be: ENABLE or DISABLE.
    387          * Output         : None
    388          * Return         : None
    389          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    390          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    391          {
    392            /* Check the parameters */
    393            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    394            assert_param(IS_FUNCTIONAL_STATE(NewState));
    395          
    396            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_Cmd_0
    397            {
    398              /* Enable the selected SPI peripheral */
    399              SPIx->CR1 |= CR1_SPE_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??SPI_Cmd_1
    400            }
    401            else
    402            {
    403              /* Disable the selected SPI peripheral */
    404              SPIx->CR1 &= CR1_SPE_Reset;
   \                     ??SPI_Cmd_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF64F 0x73BF      MOVW     R3,#+65471
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
    405            }
    406          }
   \                     ??SPI_Cmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    407          
    408          /*******************************************************************************
    409          * Function Name  : I2S_Cmd
    410          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    411          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    412          *                  - NewState: new state of the SPIx peripheral. 
    413          *                    This parameter can be: ENABLE or DISABLE.
    414          * Output         : None
    415          * Return         : None
    416          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_SPI_23_PERIPH(SPIx));
    421            assert_param(IS_FUNCTIONAL_STATE(NewState));
    422          
    423            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2S_Cmd_0
    424            {
    425              /* Enable the selected SPI peripheral (in I2S mode) */
    426              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
   \   00000006   0x8B82             LDRH     R2,[R0, #+28]
   \   00000008   0xF452 0x6280      ORRS     R2,R2,#0x400
   \   0000000C   0x8382             STRH     R2,[R0, #+28]
   \   0000000E   0xE004             B.N      ??I2S_Cmd_1
    427            }
    428            else
    429            {
    430              /* Disable the selected SPI peripheral (in I2S mode) */
    431              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \                     ??I2S_Cmd_0:
   \   00000010   0x8B82             LDRH     R2,[R0, #+28]
   \   00000012   0xF64F 0x33FF      MOVW     R3,#+64511
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8382             STRH     R2,[R0, #+28]
    432            }
    433          }
   \                     ??I2S_Cmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    434          
    435          /*******************************************************************************
    436          * Function Name  : SPI_I2S_ITConfig
    437          * Description    : Enables or disables the specified SPI/I2S interrupts.
    438          * Input          : - SPIx: where x can be :
    439          *                         - 1, 2 or 3 in SPI mode 
    440          *                         - 2 or 3 in I2S mode
    441          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
    442          *                    enabled or disabled. 
    443          *                    This parameter can be one of the following values:
    444          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    445          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    446          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    447          *                  - NewState: new state of the specified SPI/I2S interrupt.
    448          *                    This parameter can be: ENABLE or DISABLE.
    449          * Output         : None
    450          * Return         : None
    451          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    452          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    453          {
   \                     SPI_I2S_ITConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
    454            u16 itpos = 0, itmask = 0 ;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
    455          
    456            /* Check the parameters */
    457            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    458            assert_param(IS_FUNCTIONAL_STATE(NewState));
    459            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    460          
    461            /* Get the SPI/I2S IT index */
    462            itpos = SPI_I2S_IT >> 4;
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x090D             LSRS     R5,R1,#+4
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x002B             MOVS     R3,R5
    463            /* Set the IT mask */
    464            itmask = (u16)((u16)1 << itpos);
   \   0000000E   0x2501             MOVS     R5,#+1
   \   00000010   0x409D             LSLS     R5,R5,R3
   \   00000012   0x002C             MOVS     R4,R5
    465          
    466            if (NewState != DISABLE)
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD003             BEQ.N    ??SPI_I2S_ITConfig_0
    467            {
    468              /* Enable the selected SPI/I2S interrupt */
    469              SPIx->CR2 |= itmask;
   \   0000001A   0x8885             LDRH     R5,[R0, #+4]
   \   0000001C   0x4325             ORRS     R5,R4,R5
   \   0000001E   0x8085             STRH     R5,[R0, #+4]
   \   00000020   0xE002             B.N      ??SPI_I2S_ITConfig_1
    470            }
    471            else
    472            {
    473              /* Disable the selected SPI/I2S interrupt */
    474              SPIx->CR2 &= (u16)~itmask;
   \                     ??SPI_I2S_ITConfig_0:
   \   00000022   0x8885             LDRH     R5,[R0, #+4]
   \   00000024   0x43A5             BICS     R5,R5,R4
   \   00000026   0x8085             STRH     R5,[R0, #+4]
    475            }
    476          }
   \                     ??SPI_I2S_ITConfig_1:
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
    477          
    478          /*******************************************************************************
    479          * Function Name  : SPI_I2S_DMACmd
    480          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    481          * Input          : - SPIx: where x can be :
    482          *                         - 1, 2 or 3 in SPI mode 
    483          *                         - 2 or 3 in I2S mode
    484          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
    485          *                    to be enabled or disabled. 
    486          *                    This parameter can be any combination of the following values:
    487          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    488          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    489          *                  - NewState: new state of the selected SPI/I2S DMA transfer 
    490          *                    request.
    491          *                    This parameter can be: ENABLE or DISABLE.
    492          * Output         : None
    493          * Return         : None
    494          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    495          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    496          {
    497            /* Check the parameters */
    498            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    499            assert_param(IS_FUNCTIONAL_STATE(NewState));
    500            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    501          
    502            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??SPI_I2S_DMACmd_0
    503            {
    504              /* Enable the selected SPI/I2S DMA requests */
    505              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000006   0x8883             LDRH     R3,[R0, #+4]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x8083             STRH     R3,[R0, #+4]
   \   0000000C   0xE002             B.N      ??SPI_I2S_DMACmd_1
    506            }
    507            else
    508            {
    509              /* Disable the selected SPI/I2S DMA requests */
    510              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0:
   \   0000000E   0x8883             LDRH     R3,[R0, #+4]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x8083             STRH     R3,[R0, #+4]
    511            }
    512          }
   \                     ??SPI_I2S_DMACmd_1:
   \   00000014   0x4770             BX       LR               ;; return
    513          
    514          /*******************************************************************************
    515          * Function Name  : SPI_I2S_SendData
    516          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    517          * Input          : - SPIx: where x can be :
    518          *                         - 1, 2 or 3 in SPI mode 
    519          *                         - 2 or 3 in I2S mode
    520          *                  - Data : Data to be transmitted..
    521          * Output         : None
    522          * Return         : None
    523          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    524          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    525          {
    526            /* Check the parameters */
    527            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    528            
    529            /* Write in the DR register the data to be sent */
    530            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   0x8181             STRH     R1,[R0, #+12]
    531          }
   \   00000002   0x4770             BX       LR               ;; return
    532          
    533          /*******************************************************************************
    534          * Function Name  : SPI_I2S_ReceiveData
    535          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
    536          * Input          : - SPIx: where x can be :
    537          *                         - 1, 2 or 3 in SPI mode 
    538          *                         - 2 or 3 in I2S mode
    539          * Output         : None
    540          * Return         : The value of the received data.
    541          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    542          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    543          {
    544            /* Check the parameters */
    545            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    546            
    547            /* Return the data in the DR register */
    548            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   0x8980             LDRH     R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    549          }
    550          
    551          /*******************************************************************************
    552          * Function Name  : SPI_NSSInternalSoftwareConfig
    553          * Description    : Configures internally by software the NSS pin for the selected 
    554          *                  SPI.
    555          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    556          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    557          *                    This parameter can be one of the following values:
    558          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    559          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    560          * Output         : None
    561          * Return         : None
    562          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    564          {
    565            /* Check the parameters */
    566            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    567            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    568          
    569            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF64F 0x62FF      MOVW     R2,#+65279
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD004             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
    570            {
    571              /* Set NSS pin internally by software */
    572              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0xF452 0x7280      ORRS     R2,R2,#0x100
   \   00000010   0x8002             STRH     R2,[R0, #+0]
   \   00000012   0xE004             B.N      ??SPI_NSSInternalSoftwareConfig_1
    573            }
    574            else
    575            {
    576              /* Reset NSS pin internally by software */
    577              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0:
   \   00000014   0x8802             LDRH     R2,[R0, #+0]
   \   00000016   0xF64F 0x63FF      MOVW     R3,#+65279
   \   0000001A   0x401A             ANDS     R2,R3,R2
   \   0000001C   0x8002             STRH     R2,[R0, #+0]
    578            }
    579          }
   \                     ??SPI_NSSInternalSoftwareConfig_1:
   \   0000001E   0x4770             BX       LR               ;; return
    580          
    581          /*******************************************************************************
    582          * Function Name  : SPI_SSOutputCmd
    583          * Description    : Enables or disables the SS output for the selected SPI.
    584          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    585          *                  - NewState: new state of the SPIx SS output. 
    586          *                    This parameter can be: ENABLE or DISABLE.
    587          * Output         : None
    588          * Return         : None
    589          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    590          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    591          {
    592            /* Check the parameters */
    593            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    594            assert_param(IS_FUNCTIONAL_STATE(NewState));
    595          
    596            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_SSOutputCmd_0
    597            {
    598              /* Enable the selected SPI SS output */
    599              SPIx->CR2 |= CR2_SSOE_Set;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000C   0x8082             STRH     R2,[R0, #+4]
   \   0000000E   0xE004             B.N      ??SPI_SSOutputCmd_1
    600            }
    601            else
    602            {
    603              /* Disable the selected SPI SS output */
    604              SPIx->CR2 &= CR2_SSOE_Reset;
   \                     ??SPI_SSOutputCmd_0:
   \   00000010   0x8882             LDRH     R2,[R0, #+4]
   \   00000012   0xF64F 0x73FB      MOVW     R3,#+65531
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8082             STRH     R2,[R0, #+4]
    605            }
    606          }
   \                     ??SPI_SSOutputCmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    607          
    608          /*******************************************************************************
    609          * Function Name  : SPI_DataSizeConfig
    610          * Description    : Configures the data size for the selected SPI.
    611          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    612          *                  - SPI_DataSize: specifies the SPI data size.
    613          *                    This parameter can be one of the following values:
    614          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    615          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    616          * Output         : None
    617          * Return         : None
    618          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    619          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    620          {
    621            /* Check the parameters */
    622            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    623            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    624          
    625            /* Clear DFF bit */
    626            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    627            /* Set new DFF bit value */
    628            SPIx->CR1 |= SPI_DataSize;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
    629          }
   \   00000010   0x4770             BX       LR               ;; return
    630          
    631          /*******************************************************************************
    632          * Function Name  : SPI_TransmitCRC
    633          * Description    : Transmit the SPIx CRC value.
    634          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    635          * Output         : None
    636          * Return         : None
    637          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    638          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    639          {
    640            /* Check the parameters */
    641            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    642            
    643            /* Enable the selected SPI CRC transmission */
    644            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    645          }
   \   00000008   0x4770             BX       LR               ;; return
    646          
    647          /*******************************************************************************
    648          * Function Name  : SPI_CalculateCRC
    649          * Description    : Enables or disables the CRC value calculation of the
    650          *                  transfered bytes.
    651          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    652          *                  - NewState: new state of the SPIx CRC value calculation.
    653          *                    This parameter can be: ENABLE or DISABLE.
    654          * Output         : None
    655          * Return         : None
    656          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    657          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    658          {
    659            /* Check the parameters */
    660            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    661            assert_param(IS_FUNCTIONAL_STATE(NewState));
    662          
    663            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_CalculateCRC_0
    664            {
    665              /* Enable the selected SPI CRC calculation */
    666              SPIx->CR1 |= CR1_CRCEN_Set;
   \   00000006   0x8802             LDRH     R2,[R0, #+0]
   \   00000008   0xF452 0x5200      ORRS     R2,R2,#0x2000
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   \   0000000E   0xE004             B.N      ??SPI_CalculateCRC_1
    667            }
    668            else
    669            {
    670              /* Disable the selected SPI CRC calculation */
    671              SPIx->CR1 &= CR1_CRCEN_Reset;
   \                     ??SPI_CalculateCRC_0:
   \   00000010   0x8802             LDRH     R2,[R0, #+0]
   \   00000012   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8002             STRH     R2,[R0, #+0]
    672            }
    673          }
   \                     ??SPI_CalculateCRC_1:
   \   0000001A   0x4770             BX       LR               ;; return
    674          
    675          /*******************************************************************************
    676          * Function Name  : SPI_GetCRC
    677          * Description    : Returns the transmit or the receive CRC register value for
    678          *                  the specified SPI.
    679          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    680          *                  - SPI_CRC: specifies the CRC register to be read.
    681          *                    This parameter can be one of the following values:
    682          *                       - SPI_CRC_Tx: Selects Tx CRC register
    683          *                       - SPI_CRC_Rx: Selects Rx CRC register
    684          * Output         : None
    685          * Return         : The selected CRC register value..
    686          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    687          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    688          {
   \                     SPI_GetCRC:
   \   00000000   0x0002             MOVS     R2,R0
    689            u16 crcreg = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    690          
    691            /* Check the parameters */
    692            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    693            assert_param(IS_SPI_CRC(SPI_CRC));
    694          
    695            if (SPI_CRC != SPI_CRC_Rx)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD002             BEQ.N    ??SPI_GetCRC_0
    696            {
    697              /* Get the Tx CRC register */
    698              crcreg = SPIx->TXCRCR;
   \   0000000A   0x8B13             LDRH     R3,[R2, #+24]
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??SPI_GetCRC_1
    699            }
    700            else
    701            {
    702              /* Get the Rx CRC register */
    703              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0:
   \   00000010   0x8A93             LDRH     R3,[R2, #+20]
   \   00000012   0x0018             MOVS     R0,R3
    704            }
    705          
    706            /* Return the selected CRC register */
    707            return crcreg;
   \                     ??SPI_GetCRC_1:
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x4770             BX       LR               ;; return
    708          }
    709          
    710          /*******************************************************************************
    711          * Function Name  : SPI_GetCRCPolynomial
    712          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    713          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    714          * Output         : None
    715          * Return         : The CRC Polynomial register value.
    716          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    717          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    718          {
    719            /* Check the parameters */
    720            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    721            
    722            /* Return the CRC polynomial register */
    723            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    724          }
    725          
    726          /*******************************************************************************
    727          * Function Name  : SPI_BiDirectionalLineConfig
    728          * Description    : Selects the data transfer direction in bi-directional mode
    729          *                  for the specified SPI.
    730          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    731          *                  - SPI_Direction: specifies the data transfer direction in
    732          *                    bi-directional mode. 
    733          *                    This parameter can be one of the following values:
    734          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    735          *                       - SPI_Direction_Rx: Selects Rx receive direction
    736          * Output         : None
    737          * Return         : None
    738          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    739          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    740          {
    741            /* Check the parameters */
    742            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    743            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    744          
    745            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000006   0xD104             BNE.N    ??SPI_BiDirectionalLineConfig_0
    746            {
    747              /* Set the Tx only mode */
    748              SPIx->CR1 |= SPI_Direction_Tx;
   \   00000008   0x8802             LDRH     R2,[R0, #+0]
   \   0000000A   0xF452 0x4280      ORRS     R2,R2,#0x4000
   \   0000000E   0x8002             STRH     R2,[R0, #+0]
   \   00000010   0xE004             B.N      ??SPI_BiDirectionalLineConfig_1
    749            }
    750            else
    751            {
    752              /* Set the Rx only mode */
    753              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000012   0x8802             LDRH     R2,[R0, #+0]
   \   00000014   0xF64B 0x73FF      MOVW     R3,#+49151
   \   00000018   0x401A             ANDS     R2,R3,R2
   \   0000001A   0x8002             STRH     R2,[R0, #+0]
    754            }
    755          }
   \                     ??SPI_BiDirectionalLineConfig_1:
   \   0000001C   0x4770             BX       LR               ;; return
    756          
    757          /*******************************************************************************
    758          * Function Name  : SPI_I2S_GetFlagStatus
    759          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    760          * Input          : - SPIx: where x can be :
    761          *                         - 1, 2 or 3 in SPI mode 
    762          *                         - 2 or 3 in I2S mode
    763          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
    764          *                    This parameter can be one of the following values:
    765          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    766          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    767          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    768          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    769          *                       - SPI_FLAG_MODF: Mode Fault flag.
    770          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    771          *                       - I2S_FLAG_UDR: Underrun Error flag.
    772          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    773          * Output         : None
    774          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    775          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    776          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    777          {
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0x0002             MOVS     R2,R0
    778            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
    779          
    780            /* Check the parameters */
    781            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    782            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    783          
    784            /* Check the status of the specified SPI/I2S flag */
    785            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \   00000004   0x8913             LDRH     R3,[R2, #+8]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD002             BEQ.N    ??SPI_I2S_GetFlagStatus_0
    786            {
    787              /* SPI_I2S_FLAG is set */
    788              bitstatus = SET;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xE001             B.N      ??SPI_I2S_GetFlagStatus_1
    789            }
    790            else
    791            {
    792              /* SPI_I2S_FLAG is reset */
    793              bitstatus = RESET;
   \                     ??SPI_I2S_GetFlagStatus_0:
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0018             MOVS     R0,R3
    794            }
    795            /* Return the SPI_I2S_FLAG status */
    796            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    797          }
    798          
    799          /*******************************************************************************
    800          * Function Name  : SPI_I2S_ClearFlag
    801          * Description    : Clears the SPIx CRC Error (CRCERR) flag.
    802          * Input          : - SPIx: where x can be :
    803          *                         - 1, 2 or 3 in SPI mode 
    804          *                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
    805          *                    This function clears only CRCERR flag.                                           
    806          *                  Notes:
    807          *                       - OVR (OverRun error) flag is cleared by software 
    808          *                         sequence: a read operation to SPI_DR register 
    809          *                         (SPI_I2S_ReceiveData()) followed by a read operation 
    810          *                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
    811          *                       - UDR (UnderRun error) flag is cleared by a read 
    812          *                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
    813          *                       - MODF (Mode Fault) flag is cleared by software sequence: 
    814          *                         a read/write operation to SPI_SR register 
    815          *                         (SPI_I2S_GetFlagStatus()) followed by a write 
    816          *                         operation to SPI_CR1 register (SPI_Cmd() to enable 
    817          *                         the SPI).   
    818          * Output         : None
    819          * Return         : None
    820          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    821          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    822          {
    823            /* Check the parameters */
    824            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    825            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    826              
    827              /* Clear the selected SPI CRC Error (CRCERR) flag */
    828              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x43CA             MVNS     R2,R1
   \   00000004   0x8102             STRH     R2,[R0, #+8]
    829          }
   \   00000006   0x4770             BX       LR               ;; return
    830          
    831          /*******************************************************************************
    832          * Function Name  : SPI_I2S_GetITStatus
    833          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    834          * Input          : - SPIx: where x can be :
    835          *                         - 1, 2 or 3 in SPI mode 
    836          *                         - 2 or 3 in I2S mode
    837          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
    838          *                    This parameter can be one of the following values:
    839          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    840          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    841          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    842          *                       - SPI_IT_MODF: Mode Fault interrupt.
    843          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    844          *                       - I2S_IT_UDR: Underrun Error interrupt.
    845          * Output         : None
    846          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    847          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    848          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    849          {
   \                     SPI_I2S_GetITStatus:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
    850            ITStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
    851            u16 itpos = 0, itmask = 0, enablestatus = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x2400             MOVS     R4,#+0
    852          
    853            /* Check the parameters */
    854            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    855            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    856          
    857            /* Get the SPI/I2S IT index */
    858            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \   0000000C   0x2601             MOVS     R6,#+1
   \   0000000E   0xF011 0x070F      ANDS     R7,R1,#0xF
   \   00000012   0x40BE             LSLS     R6,R6,R7
   \   00000014   0x0033             MOVS     R3,R6
    859          
    860            /* Get the SPI/I2S IT mask */
    861            itmask = SPI_I2S_IT >> 4;
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x090E             LSRS     R6,R1,#+4
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x0035             MOVS     R5,R6
    862            /* Set the IT mask */
    863            itmask = (u16)((u16)0x01 << itmask);
   \   0000001E   0x2601             MOVS     R6,#+1
   \   00000020   0xFA16 0xF505      LSLS     R5,R6,R5
    864            /* Get the SPI_I2S_IT enable bit status */
    865            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000024   0x8896             LDRH     R6,[R2, #+4]
   \   00000026   0x402E             ANDS     R6,R5,R6
   \   00000028   0x0034             MOVS     R4,R6
    866          
    867            /* Check the status of the specified SPI/I2S interrupt */
    868            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   0000002A   0x8916             LDRH     R6,[R2, #+8]
   \   0000002C   0x421E             TST      R6,R3
   \   0000002E   0xD005             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000030   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD002             BEQ.N    ??SPI_I2S_GetITStatus_0
    869            {
    870              /* SPI_I2S_IT is set */
    871              bitstatus = SET;
   \   00000036   0x2601             MOVS     R6,#+1
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xE001             B.N      ??SPI_I2S_GetITStatus_1
    872            }
    873            else
    874            {
    875              /* SPI_I2S_IT is reset */
    876              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_0:
   \   0000003C   0x2600             MOVS     R6,#+0
   \   0000003E   0x0030             MOVS     R0,R6
    877            }
    878            /* Return the SPI_I2S_IT status */
    879            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_1:
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xBCF0             POP      {R4-R7}
   \   00000044   0x4770             BX       LR               ;; return
    880          }
    881          
    882          /*******************************************************************************
    883          * Function Name  : SPI_I2S_ClearITPendingBit
    884          * Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
    885          * Input          : - SPIx: where x can be :
    886          *                         - 1, 2 or 3 in SPI mode 
    887          *                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
    888          *                    This function clears only CRCERR intetrrupt pending bit.   
    889          *                  Notes:
    890          *                       - OVR (OverRun Error) interrupt pending bit is cleared 
    891          *                         by software sequence: a read operation to SPI_DR 
    892          *                         register (SPI_I2S_ReceiveData()) followed by a read 
    893          *                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
    894          *                       - UDR (UnderRun Error) interrupt pending bit is cleared 
    895          *                         by a read operation to SPI_SR register 
    896          *                         (SPI_I2S_GetITStatus()).                           
    897          *                       - MODF (Mode Fault) interrupt pending bit is cleared by 
    898          *                         software sequence: a read/write operation to SPI_SR 
    899          *                         register (SPI_I2S_GetITStatus()) followed by a write 
    900          *                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
    901          *                         SPI).   
    902          * Output         : None
    903          * Return         : None
    904          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    905          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    906          {
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0xB410             PUSH     {R4}
    907            u16 itpos = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    908          
    909            /* Check the parameters */
    910            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    911            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    912          
    913            /* Get the SPI IT index */
    914            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF011 0x040F      ANDS     R4,R1,#0xF
   \   0000000A   0x40A3             LSLS     R3,R3,R4
   \   0000000C   0x001A             MOVS     R2,R3
    915            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
    916            SPIx->SR = (u16)~itpos;
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000010   0x43D3             MVNS     R3,R2
   \   00000012   0x8103             STRH     R3,[R0, #+8]
    917          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0xE0042000         DC32     0xe0042000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x4002102C         DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x017D7840         DC32     0x17d7840
    918          
    919          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
      56   I2S_Init
        56   -> RCC_GetClocksFreq
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_I2S_ClearFlag
       4   SPI_I2S_ClearITPendingBit
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
      16   SPI_I2S_GetITStatus
       8   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData
       0   SPI_I2S_SendData
       4   SPI_Init
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_SSOutputCmd
       0   SPI_StructInit
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
      28  I2S_Cmd
     344  I2S_Init
      26  I2S_StructInit
      30  SPI_BiDirectionalLineConfig
      28  SPI_CalculateCRC
      28  SPI_Cmd
      18  SPI_DataSizeConfig
      24  SPI_GetCRC
       4  SPI_GetCRCPolynomial
       8  SPI_I2S_ClearFlag
      24  SPI_I2S_ClearITPendingBit
      22  SPI_I2S_DMACmd
      92  SPI_I2S_DeInit
      24  SPI_I2S_GetFlagStatus
      70  SPI_I2S_GetITStatus
      44  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      64  SPI_Init
      32  SPI_NSSInternalSoftwareConfig
      28  SPI_SSOutputCmd
      38  SPI_StructInit
      10  SPI_TransmitCRC

 
 1 018 bytes in section .text
 
 1 018 bytes of CODE memory

Errors: none
Warnings: none
